[{:lociπH:projects[I"activemodel_proj:ETI"activerecord_proj;TI"backup_proj;TI"cancan_proj;TI"compass_proj;TI"devise_proj;TI"diaspora_proj;TI"haml_proj;TI"homebrew_proj;TI"jekyll_proj;TI"nokogiri_proj;TI"omni_proj;TI"paperclip_proj;TI"rescue_proj;TI"sinatra_proj;TI"state_machine_proj;TI"twitter_proj;TI"whenever_proj;T[5[	I"#   end;FI"#;FiÓ[Ó[	I"Aprojects//activemodel_proj/active_model/attribute_methods.rb;Ti0I"l      #       send("#{attr}=", nil)
      #     end
      #   end
      #
      #   person = Person.new;Fi[	@ iTI"l      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new;Fi[	@ ixI"Z      #       ...
      #     end
      #   end
      #
      #   person = Person.new;Fi[	@ iêI"l      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new;Fi[	@ i‘I"l      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new;Fi[	@ i˜I"l      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new;Fi[	I"9projects//activemodel_proj/active_model/callbacks.rb;Ti&I"\    #
    #     before_create AnotherClass
    #   end
    #
    #   class AnotherClass;Fi[	I":projects//activemodel_proj/active_model/conversion.rb;TiI"q    #   class Person
    #     include ActiveModel::Conversion
    #   end
    #
    #   person = Person.new;Fi[	@0iI"e    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.create;Fi[	@0i,I"e    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.create;Fi[	@0i9I"q    #   class Person
    #     include ActiveModel::Conversion
    #   end
    #
    #   person = Person.new;Fi[	I"6projects//activemodel_proj/active_model/errors.rb;TiiI"™    #   person.errors.each do |attribute, error|
    #     # Will yield :name and "can't be blank"
    #   end
    #
    #   person.errors.add(:name, "must be specified");Fi[	@9i!I"±    #     validates_presence_of :name, :address, :email
    #     validates_length_of :name, in: 5..30
    #   end
    #
    #   person = Person.create(address: '123 First St.');Fi[	I"5projects//activemodel_proj/active_model/model.rb;TiI"é    #     include ActiveModel::Model
    #     attr_accessor :name, :age
    #   end
    #
    #   person = Person.new(name: 'bob', age: '18');Fi[	I"6projects//activemodel_proj/active_model/naming.rb;TiI"Ç    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name == 'BlogPost'  # => true;Fi[	@Ai*I"É    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name === 'BlogPost'  # => true;Fi[	@Ai8I"Ä    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name <=> 'BlogPost'  # => 0;Fi[	@AiII"    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name =~ /Post/ # => 4;Fi[	@AiXI"~    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name !~ /Post/ # => false;Fi[	@AigI"Ö    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name.eql?('BlogPost')  # => true;Fi[	@AiuI"~    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name.to_s # => "BlogPost";Fi[	@AiÅI"e    #     class Bar
    #     end
    #   end
    #
    #   ActiveModel::Name.new(Foo::Bar).to_s;Fi[	@AiõI"Ä    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name.human # => "Blog post";Fi[	@Ai∏I"u    #
    #   class Person < ActiveModel::Model
    #   end
    #
    #   Person.model_name          # => Person;Fi[	I"?projects//activemodel_proj/active_model/secure_password.rb;Ti%I"∏      #   class User < ActiveRecord::Base
      #     has_secure_password
      #   end
      #
      #   user = User.new(name: 'david', password: '', password_confirmation: 'nomatch');Fi[	@ViHI"∂      #   class User < ActiveRecord::Base
      #     has_secure_password validations: false
      #   end
      #
      #   user = User.new(name: 'david', password: 'mUc3m00RsqyRe');Fi[	@ViWI"å      #   class User < ActiveRecord::Base
      #     has_secure_password validations: false
      #   end
      #
      #   user = User.new;Fi[	I"=projects//activemodel_proj/active_model/serialization.rb;TiI"\    #       name.capitalize
    #     end
    #   end
    #
    #   person = Person.new;Fi[	I"@projects//activemodel_proj/active_model/serializers/json.rb;TitI"É      #       instance_values
      #     end
      #   end
      #
      #   json = { name: 'bob', age: 22, awesome:true }.to_json;Fi[	I"?projects//activemodel_proj/active_model/serializers/xml.rb;Ti–I"Å      #       instance_values
      #     end
      #   end
      #
      #   xml = { name: 'bob', age: 22, awesome:true }.to_xml;Fi[	I"Cprojects//activemodel_proj/active_model/validations/absence.rb;TiI"ª      #   class Person < ActiveRecord::Base
      #     validates_absence_of :first_name
      #   end
      #
      # The first_name attribute must be in the object and it must be blank.;Fi[	I"Fprojects//activemodel_proj/active_model/validations/acceptance.rb;Ti!I"‡      #     validates_acceptance_of :terms_of_service
      #     validates_acceptance_of :eula, message: 'must be abided'
      #   end
      #
      # If the database column does not exist, the +terms_of_service+ attribute;Fi[	I"Eprojects//activemodel_proj/active_model/validations/callbacks.rb;Ti"I"l        #       name.strip!
        #     end
        #   end
        #
        #   person = Person.new;Fi[	@liDI"|        #       self.status = errors.empty?
        #     end
        #   end
        #
        #   person = Person.new;Fi[	I"Eprojects//activemodel_proj/active_model/validations/exclusion.rb;TiI"ÿ      #                            message: 'should not be the same as your username or first name'
      #     validates_exclusion_of :karma, in: :reserved_karmas
      #   end
      #
      # Configuration options:;Fi[	I"Bprojects//activemodel_proj/active_model/validations/format.rb;Ti>I"˘      #   class Person < ActiveRecord::Base
      #     validates_format_of :email, with: /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\z/i, on: :create
      #   end
      #
      # Alternatively, you can require that the specified attribute does _not_;Fi[	@tiEI"       #   class Person < ActiveRecord::Base
      #     validates_format_of :email, without: /NOSPAM/
      #   end
      #
      # You can also provide a proc or lambda which will determine the regular;Fi[	@tiNI"      #     validates_format_of :screen_name,
      #                         with: ->(person) { person.admin? ? /\A[a-z0-9][a-z0-9_\-]*\z/i : /\A[a-z][a-z0-9_\-]*\z/i }
      #   end
      #
      # Note: use <tt>\A</tt> and <tt>\Z</tt> to match the start and end of the;Fi[	I"Eprojects//activemodel_proj/active_model/validations/inclusion.rb;TiI"À      #     validates_inclusion_of :states, in: ->(person) { STATES[person.country] }
      #     validates_inclusion_of :karma, in: :available_karmas
      #   end
      #
      # Configuration options:;Fi[	I"Bprojects//activemodel_proj/active_model/validations/length.rb;TiMI"Ê      #     validates_length_of :essay, minimum: 100, too_short: 'Your essay must be at least 100 words.',
      #                         tokenizer: ->(str) { str.scan(/\w+/) }
      #   end
      #
      # Configuration options:;Fi[	I"Hprojects//activemodel_proj/active_model/validations/numericality.rb;TiSI"ö      #   class Person < ActiveRecord::Base
      #     validates_numericality_of :value, on: :create
      #   end
      #
      # Configuration options:;Fi[	I"Dprojects//activemodel_proj/active_model/validations/presence.rb;TiI"æ      #   class Person < ActiveRecord::Base
      #     validates_presence_of :first_name
      #   end
      #
      # The first_name attribute must be in the object and it cannot be blank.;Fi[	I"Eprojects//activemodel_proj/active_model/validations/validates.rb;Ti"I"É      #         value =~ /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\z/i
      #     end
      #   end
      #
      #   class Person;Fi[	@Çi*I"Ò      #     validates :name, presence: true, uniqueness: true, length: { maximum: 100 }
      #     validates :email, presence: true, email: true
      #   end
      #
      # Validator classes may also exist within the class being validated;Fi[	@Çi9I"ì      #
      #     validates :name, title: true
      #   end
      #
      # Additionally validator classes may be in another namespace and still;Fi[	@ÇiÄI"Ä      #     attr_accessor :name
      #     validates! :name, presence: true
      #   end
      #
      #   person = Person.new;Fi[	I"@projects//activemodel_proj/active_model/validations/with.rb;Ti$I"û      #     include ActiveModel::Validations
      #     validates_with MyValidator
      #   end
      #
      #   class MyValidator < ActiveModel::Validator;Fi[	@ãi1I"z      #         # ...
      #       end
      #   end
      #
      # You may also pass it multiple classes, like so:;Fi[	@ãi8I"ß      #     include ActiveModel::Validations
      #     validates_with MyValidator, MyOtherValidator, on: :create
      #   end
      #
      # Configuration options:;Fi[	@ãiQI"¿      #     include ActiveModel::Validations
      #     validates_with MyValidator, my_custom_key: 'my custom value'
      #   end
      #
      #   class MyValidator < ActiveModel::Validator;Fi[	@ãirI"í    #       validates_with MyValidator
    #     end
    #   end
    #
    # Please consult the class method documentation for more information on;Fi[	@ãi|I"ù    #       validates_with MyValidator, MyOtherValidator
    #     end
    #   end
    #
    # Standard configuration options (<tt>:on</tt>, <tt>:if</tt> and;Fi[	I";projects//activemodel_proj/active_model/validations.rb;Ti"I"Ñ      #       record.errors.add attr, 'starts with z.' if value.to_s[0] == ?z
      #     end
      #   end
      #
      # Options:;Fi[	@òiDI"‡      #       errors.add(:base, 'Must be friends to leave a comment') unless commenter.friend_of?(commentee)
      #     end
      #   end
      #
      # With a block which is passed with the current record to be validated:;Fi[	@òiRI"„      #       errors.add(:base, 'Must be friends to leave a comment') unless commenter.friend_of?(commentee)
      #     end
      #   end
      #
      # Or with a block where self points to the current record to be validated:;Fi[	@òi\I"£      #       errors.add(:base, 'Must be friends to leave a comment') unless commenter.friend_of?(commentee)
      #     end
      #   end
      #
      # Options:;Fi[	@òi{I"°      #     validates_with OtherValidator, on: :create
      #     validates_with StrictValidator, strict: true
      #   end
      #
      #   Person.validators;Fi[	@òiêI"ñ      #     validates_presence_of :name
      #     validates_inclusion_of :age, in: 0..99
      #   end
      #
      #   Person.validators_on(:name);Fi[	@òiøI"v    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new;Fi[	@òi–I"v    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new;Fi[	@òi‡I"{    #     attr_accessor :name
    #     validates_presence_of :name, on: :new
    #   end
    #
    #   person = Person.new;Fi[	@òi˜I"v    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new;Fi[	@òiI"{    #     attr_accessor :name
    #     validates_presence_of :name, on: :new
    #   end
    #
    #   person = Person.new;Fi[	I"Uprojects//activerecord_proj/active_record/associations/collection_association.rb;TiaI"â      #   class Author < ActiveRecord::Base
      #     has_many :books
      #   end
      #
      #   Author.first.books.transaction do;Fi[	I"Oprojects//activerecord_proj/active_record/associations/collection_proxy.rb;Ti'I"w      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets;Ti[	@≤i`I"w      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets;Ti[	@≤i~I"w      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets;Ti[	@≤ióI"w      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets;Ti[	@≤i∂I"h      #   class Person
      #     has_many :pets
      #   end
      #
      #   person.pets.build;Ti[	@≤i—I"~      #   class Person
      #     has_many :pets
      #   end
      #
      #   person.pets.create(name: 'Fancy-Fancy');Ti[	@≤iÌI"`      #   class Person
      #     has_many :pets
      #   end
      #
      #   class Pet;Ti[	@≤iÒI"~      #   class Pet
      #     validates :name, presence: true
      #   end
      #
      #   person.pets.create!(name: nil);Ti[	@≤i I"~      #   class Person < ActiveRecord::Base
      #     pets :has_many
      #   end
      #
      #   person.pets.size # => 0;Ti[	@≤iI"w      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets;Ti[	@≤i:I"¶      #   class Person < ActiveRecord::Base
      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3;Ti[	@≤i[I"ì      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3;Ti[	@≤itI"ñ      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3;Ti[	@≤iëI"~      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3;Ti[	@≤i±I"¶      #   class Person < ActiveRecord::Base
      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3;Ti[	@≤iÕI"ì      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3;Ti[	@≤iÈI"ñ      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3;Ti[	@≤iI"~      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3;Ti[	@≤i!I"~      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3;Ti[	@≤igI"Ä      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.select(:name);Ti[	@≤iyI"      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.count # => 3;Ti[	@≤ièI"~      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3;Ti[	@≤i©I"Ä      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.length # => 3;Ti[	@≤i√I"Ä      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.count  # => 1;Ti[	@≤i‘I"      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.count # => 0;Ti[	@≤iˆI"~      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.count #=> 1;Ti[	@≤iI"ñ      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets # => [#<Pet id: 20, name: "Snoop">];Ti[	@≤iAI"w      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets;Ti[	@≤i[I"w      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets;Ti[	@≤iÉI"~      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 0;Ti[	@≤i§I"ì      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets # fetches pets from the database;Ti[	I">projects//activerecord_proj/active_record/associations.rb;TiMI"ú      #       end
      #     end
      #   end
      #
      # It's also a good idea to add indexes to each of those columns to speed up the joins process.;Fi[	I"Tprojects//activerecord_proj/active_record/attribute_methods/before_type_cast.rb;TiI"Ü      #
      #   class Task < ActiveRecord::Base
      #   end
      #
      #   task = Task.new(id: '1', completed_on: '2012-10-21');Fi[	I"Oprojects//activerecord_proj/active_record/attribute_methods/primary_key.rb;TieI"≤        #   class Project < ActiveRecord::Base
        #     self.primary_key = 'sysid'
        #   end
        #
        # You can also define the +primary_key+ method yourself:;Fi[	@˜imI"}        #       'foo_' + super
        #     end
        #   end
        #
        #   Project.primary_key # => "foo_id";Fi[	I"Cprojects//activerecord_proj/active_record/attribute_methods.rb;Ti7I"ì      #       'already defined by Active Record'
      #     end
      #   end
      #
      #   Person.instance_method_already_implemented?(:save);Fi[	@¸i`I"Ä      #
      #   class Person < ActiveRecord::Base
      #   end
      #
      #   Person.attribute_method?('name')   # => true;Fi[	@¸imI"o      #
      #   class Person < ActiveRecord::Base
      #   end
      #
      #   Person.attribute_names;Fi[	@¸iâI"b    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new;Fi[	@¸iùI"b    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new;Fi[	@¸i™I"b    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new;Fi[	@¸i∂I"|    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.create(name: 'Francesco', age: 22);Fi[	@¸i›I"y    #
    #   class Task < ActiveRecord::Base
    #   end
    #
    #   person = Task.new(title: '', is_done: false);Fi[	@¸iÔI"b    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new;Fi[	@¸iI"ò    #   class Person < ActiveRecord::Base
    #     belongs_to :organization
    #   end
    #
    #   person = Person.new(name: 'Francesco', age: '22');Fi[	@¸iI"b    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new;Fi[	I"bprojects//activerecord_proj/active_record/connection_adapters/abstract/database_statements.rb;TiüI"¬      #       # active_record_1 now automatically released
      #     end  # RELEASE SAVEPOINT active_record_1  <--- BOOM! database error!
      #   end
      #
      # == Transaction isolation;Fi[	@i®I"É      #   Post.transaction(isolation: :serializable) do
      #     # ...
      #   end
      #
      # Valid isolation levels are:;Fi[	I"aprojects//activerecord_proj/active_record/connection_adapters/abstract/schema_definitions.rb;Ti©I"™      #     t.column :created_at, :datetime
      #     t.column :updated_at, :datetime
      #   end
      #
      # can also be written as follows using the short-hand:;Fi[	@i±I"Õ      #     t.string  :name, :value, default: "Untitled"
      #     t.timestamps
      #   end
      #
      # There's a short-hand method for each of the type values declared at the top. And then there's;Fi[	I"6projects//activerecord_proj/active_record/core.rb;Ti{I"a    #
    #   class Post < ActiveRecord::Base
    #   end
    #
    #   post = Post.allocate;Fi[	I"=projects//activerecord_proj/active_record/inheritance.rb;TiRI"}      #   class Child < SuperClass
      #     self.table_name = 'the_table_i_really_want'
      #   end
      #
      #;Fi[	I"=projects//activerecord_proj/active_record/integration.rb;Ti$I"a    #       name
    #     end
    #   end
    #
    #   user = User.find_by_name('Phusion');Fi[	I">projects//activerecord_proj/active_record/model_schema.rb;Ti"I"â      #
      #   class Invoice < ActiveRecord::Base
      #   end
      #
      #   file                  class               table_name;Fi[	@&i*I"î      #     class Lineitem < ActiveRecord::Base
      #     end
      #   end
      #
      #   file                  class               table_name;Fi[	@&i2I"î      #     class Lineitem < ActiveRecord::Base
      #     end
      #   end
      #
      #   file                  class               table_name;Fi[	@&i@I"≤      #   class Mouse < ActiveRecord::Base
      #     self.table_name = "mice"
      #   end
      #
      # Alternatively, you can override the table_name method to define your;Fi[	@&iUI"π      #   class Project < ActiveRecord::Base
      #     self.table_name = "project"
      #   end
      #
      # You can also just define your own <tt>self.table_name</tt> method; see;Fi[	I"=projects//activerecord_proj/active_record/persistence.rb;TiI"œ      #   User.create(first_name: 'Jamie') do |u|
      #     u.is_admin = false
      #   end
      #
      #   # Creating an Array of new objects using a block, where the block is executed for each object:;Fi[	@1iTI"à    #   class Brake < ActiveRecord::Base
    #     belongs_to :car, touch: true
    #   end
    #
    #   class Car < ActiveRecord::Base;Fi[	@1iXI"¨    #   class Car < ActiveRecord::Base
    #     belongs_to :corporation, touch: true
    #   end
    #
    #   # triggers @brake.car.touch and @brake.car.corporation.touch;Fi[	I"<projects//activerecord_proj/active_record/reflection.rb;TimI"{      #     has_many :taggings
      #     has_many :tags, through: :taggings
      #   end
      #
      def function;Fi[	@8i{I"¢      #     has_many :taggings
      #     has_many :tags, through: :taggings
      #   end
      #
      #   tags_reflection = Post.reflect_on_association(:tags);Fi[	@8iïI"É      #     has_many :articles
      #     has_many :comment_tags, through: :articles
      #   end
      #
      #   class Article;Fi[	@8iöI"í      #     has_many :comments
      #     has_many :comment_tags, through: :comments, source: :tags
      #   end
      #
      #   class Comment;Fi[	@8iûI"¶      #   class Comment
      #     has_many :tags
      #   end
      #
      # There may be scopes on Person.comment_tags, Article.comment_tags and/or Comment.tags,;Fi[	I"Bprojects//activerecord_proj/active_record/relation/batches.rb;TiI"ì    #   Person.all.find_each do |person|
    #     person.do_awesome_stuff
    #   end
    #
    #   Person.where("age > 21").find_each do |person|;Fi[	@CiI"¢    #   Person.where("age > 21").find_each do |person|
    #     person.party_all_night!
    #   end
    #
    #  You can also pass the +:start+ option to specify;Fi[	@Ci3I"æ    #     sleep(50) # Make sure it doesn't get too crowded in there!
    #     group.each { |person| person.party_all_night! }
    #   end
    #
    #   # Let's process the next 2000 records;Fi[	I"Hprojects//activerecord_proj/active_record/relation/query_methods.rb;TiNI"ô    #   users.each do |user|
    #     user.address.city
    #   end
    #
    # allows you to access the +address+ attribute of the +User+ model without;Fi[	@Ji I"~    #       Post.none # => returning [] instead breaks the previous code
    #     end
    #   end
    #
    def function;Fi[	@JieI"|    #       # pagination code goes here
    #     end
    #   end
    #
    #   scope = Model.all.extending(Pagination);Fi[	I":projects//activerecord_proj/active_record/relation.rb;Ti‘I"“    #   Comment.where(post_id: 1).scoping do
    #     Comment.first # SELECT * FROM comments WHERE post_id = 1
    #   end
    #
    # Please check unscoped if you want to remove all previous scopes (including;Ti[	I"Aprojects//activerecord_proj/active_record/scoping/default.rb;TiI"§        #       where published: true
        #     end
        #   end
        #
        #   Post.all          # Fires "SELECT * FROM posts WHERE published = true";Fi[	@Ti9I"         #   class Article < ActiveRecord::Base
        #     default_scope { where(published: true) }
        #   end
        #
        #   Article.all # => SELECT * FROM articles WHERE published = true;Fi[	@TiMI"ﬂ        #     default_scope { where(published: true) }
        #     default_scope { where(rating: 'G') }
        #   end
        #
        #   Article.all # => SELECT * FROM articles WHERE published = true AND rating = 'G';Fi[	I"?projects//activerecord_proj/active_record/scoping/named.rb;Ti=I"        #     scope :red, -> { where(color: 'red') }
        #     scope :dry_clean_only, -> { joins(:washing_instructions).where('washing_instructions.dry_clean_only = ?', true) }
        #   end
        #
        # The above calls to +scope+ define class methods <tt>Shirt.red</tt> and;Fi[	@[iNI"ö        #       where(color: 'red')
        #     end
        #   end
        #
        # Unlike <tt>Shirt.find(...)</tt>, however, the object returned by;Fi[	@[igI"±        #   class Person < ActiveRecord::Base
        #     has_many :shirts
        #   end
        #
        # then <tt>elton.shirts.red.dry_clean_only</tt> will return all of;Fi[	@[iuI"É        #       end
        #     end
        #   end
        #
        # Scopes can also be used while creating/building a record.;Fi[	@[i{I"ø        #   class Article < ActiveRecord::Base
        #     scope :published, -> { where(published: true) }
        #   end
        #
        #   Article.published.new.published    # => true;Fi[	@[iâI"~        #       pluck(:title)
        #     end
        #   end
        #
        # We are able to call the methods like this:;Fi[	I"Lprojects//activerecord_proj/active_record/serializers/xml_serializer.rb;TiìI"b    #       xml.last_name "Heinemeier Hansson"
    #     end
    #   end
    #
    #   <firm>;Fi[	I"Hprojects//activerecord_proj/active_record/validations/associated.rb;TiI"°      #
      #     validates_associated :pages, :library
      #   end
      #
      # WARNING: This validation must not be used on both ends of an association.;Fi[	I"Fprojects//activerecord_proj/active_record/validations/presence.rb;TiI"©      #     has_one :face
      #     validates_presence_of :face
      #   end
      #
      # The face attribute must be in the object and it cannot be blank or marked;Fi[	I"Hprojects//activerecord_proj/active_record/validations/uniqueness.rb;Ti[I"ø      #   class Person < ActiveRecord::Base
      #     validates_uniqueness_of :user_name
      #   end
      #
      # It can also validate whether the value of the specified attributes are;Fi[	@qibI"œ      #   class Person < ActiveRecord::Base
      #     validates_uniqueness_of :user_name, scope: :account_id
      #   end
      #
      # Or even multiple scope parameters. For example, making sure that a;Fi[	@qijI"Á      #   class TeacherSchedule < ActiveRecord::Base
      #     validates_uniqueness_of :teacher_id, scope: [:semester_id, :class_id]
      #   end
      #
      # It is also possible to limit the uniqueness constraint to a set of;Fi[	@qisI"È      #   class Article < ActiveRecord::Base
      #     validates_uniqueness_of :title, conditions: where('status != ?', 'archived')
      #   end
      #
      # When the record is created, a check is performed to make sure that no;Fi[	I"2projects//backup_proj/backup/encryptor/gpg.rb;Ti^I"i      #       s2k-digest-algo SHA512
      #     EOF
      #   end
      #
      # @see #gpg_homedir;Fi[	@ziíI"~      #
      #     EOS
      #   end
      #
      # All leading spaces/tabs will be stripped from the key, so the above;Fi[	@ziÊI"Z      #       ]
      #     end
      #   end
      #
      # @return [String, Array];Fi[	@ziI"≠      #   Backup::Encryptor::GPG.defaults do |enc|
      #     enc.passphrase = 'secret phrase'
      #   end
      #
      #   Backup::Model.new(:my_backup, 'My Backup') do;Fi[	@ziI"}      #       enc.passphrase_file = '/path/to/passphrase.file'
      #     end
      #   end
      #
      # @return [String];Fi[	@zi%I"~      #
      #     encryptor.recipients = 'joe@example.com'
      #   end
      #
      #   # Encryptor set in the model;Fi[	@zi+I"}      #     # archives, storage options, etc...
      #     encrypt_with GPG
      #   end
      #
      # @!scope class;Fi[	@ziGI"R      #
      #     notify_by Mail
      #   end
      #
      # @api private;Fi[	I",projects//cancan_proj/cancan/ability.rb;TiI"∂    #   can :create Project do |project, remote_ip|
    #     # ...
    #   end
    #
    # Not only can you use the can? method in the controller and view (see ControllerAdditions),;Fi[	@ãi)I"¬    #     assert ability.can?(:destroy, Project.new(:user => user))
    #     assert ability.cannot?(:destroy, Project.new)
    #   end
    #
    # Also see the RSpec Matchers to aid in testing.;Fi[	@ãiWI"œ    #   can :update, Project do |project|
    #     project.groups.include?(user.group)
    #   end
    #
    # If the block returns true then the user has that :update ability for that project, otherwise he;Fi[	@ãinI"ô    #   can do |action, object_class, object|
    #     # check the database and return true/false
    #   end
    #
    def function(var, var, var, var);Fi[	@ãi~I"~    #   cannot :read, Product do |product|
    #     product.invisible?
    #   end
    #
    def function(var, var, var, var);Fi[	I"9projects//cancan_proj/cancan/controller_additions.rb;TiI"ç      #   class BooksController < ApplicationController
      #     load_and_authorize_resource
      #   end
      #
      def function(var);Fi[	@ñi!I"–      #   class BooksController < ApplicationController
      #     load_resource
      #   end
      #
      # A resource is not loaded if the instance variable is already set. This makes it easy to override;Fi[	@ñi/I"À      #       @book = Book.find_by_permalink!(params[:id)
      #     end
      #   end
      #
      # If a name is provided which does not match the controller it assumes it is a parent resource. Child;Fi[	@ñi7I"€      #     load_resource :author
      #     load_resource :book, :through => :author
      #   end
      #
      # Here the author resource will be loaded before each action using params[:author_id]. The book resource;Fi[	@ñi~I"Õ      #   class BooksController < ApplicationController
      #     authorize_resource
      #   end
      #
      # If you pass in the name of a resource which does not match the controller it will assume;Fi[	@ñiÜI"¿      #     authorize_resource :author
      #     authorize_resource :book
      #   end
      #
      # Here it will authorize :+show+, @+author+ on every action before authorizing the book.;Fi[	@ñi¥I"‰      #   class ProjectsController < SomeOtherController
      #     skip_load_and_authorize_resource :only => :index
      #   end
      #
      # You can also pass the resource name as the first argument to skip that resource.;Fi[	@ñi√I"≈      #     load_and_authorize_resource
      #     skip_load_resource :only => :index
      #   end
      #
      # You can also pass the resource name as the first argument to skip that resource.;Fi[	@ñi”I"       #     load_and_authorize_resource
      #     skip_authorize_resource :only => :index
      #   end
      #
      # You can also pass the resource name as the first argument to skip that resource.;Fi[	@ñi‚I"Œ      #   class ApplicationController < ActionController::Base
      #     check_authorization
      #   end
      #
      # See skip_authorization_check to bypass this check on specific controller actions.;Fi[	@ñiI"∆      #   class HomeController < ApplicationController
      #     skip_authorization_check :only => :index
      #   end
      #
      # Any arguments are passed to the +before_filter+ it triggers.;Fi[	@ñi(I"´    #     @article = Article.find(params[:id])
    #     authorize! :read, @article
    #   end
    #
    # A :message option can be passed to specify a different message.;Fi[	@ñi?I"∫    #       redirect_to root_url, :alert => exception.message
    #     end
    #   end
    #
    # See the CanCan::AccessDenied exception for more details on working with the exception.;Fi[	@ñiUI"»    #     # instead of Ability.new(current_user)
    #     @current_ability ||= UserAbility.new(current_account)
    #   end
    #
    # Notice it is important to cache the ability object so it is not;Fi[	I"8projects//devise_proj/devise/controllers/helpers.rb;TiòI"—      #   map.namespace :user do |user|
      #     user.root :controller => 'users' # creates user_root_path
      #   end
      #
      # If the resource root path is not defined, root_path is used. However,;Fi[	@≥i§I"Z      #         super
      #       end
      #   end
      #
      def function(var);Fi[	I";projects//devise_proj/devise/models/authenticatable.rb;TiôI"¶        #     conditions[:active] = true
        #     super
        #   end
        #
        # Finally, notice that Devise also queries for users in other scenarios;Fi[	I"Dprojects//devise_proj/devise/models/database_authenticatable.rb;TiGI"s      #     params.delete(:email)
      #     super(params)
      #   end
      #
      def function(var, var);Fi[	I"1projects//devise_proj/devise/rails/routes.rb;TiäI"î    #   scope "/my" do
    #     devise_for :users
    #   end
    #
    # However, since Devise uses the request path to retrieve the current user,;Fi[	@æiëI"à    #   scope ":locale" do
    #     devise_for :users
    #   end
    #
    # you are required to configure default_url_options in your;Fi[	@æiöI"    #       { :locale => I18n.locale }
    #     end
    #   end
    #
    # ==== Adding custom actions to override controllers;Fi[	@æi·I"h    #   authenticate do
    #     resources :post
    #   end
    #
    #   authenticate(:admin) do;Fi[	@æiÂI"ä    #   authenticate(:admin) do
    #     resources :users
    #   end
    #
    #   authenticate :user, lambda {|u| u.role == "admin"} do;Fi[	@æiÈI"ó    #   authenticate :user, lambda {|u| u.role == "admin"} do
    #     root :to => "admin/dashboard#show"
    #   end
    #
    def function(var, var);Fi[	@æi¯I"|    #   authenticated :admin do
    #     root :to => 'admin/dashboard#show'
    #   end
    #
    #   authenticated do;Fi[	@æi¸I"ê    #   authenticated do
    #     root :to => 'dashboard#show'
    #   end
    #
    #   authenticated :user, lambda {|u| u.role == "admin"} do;Fi[	@æi I"†    #   authenticated :user, lambda {|u| u.role == "admin"} do
    #     root :to => "admin/dashboard#show"
    #   end
    #
    #   root :to => 'landing#show';Fi[	@æiI"|    #       root :to => 'devise/registrations#new'
    #     end
    #   end
    #
    #   root :to => 'dashboard#show';Fi[	@æi!I"≠    #   as :user do
    #     get "sign_in", :to => "devise/sessions#new"
    #   end
    #
    # Notice you cannot have two scopes mapping to the same URL. And remember, if;Fi[	I"6projects//nokogiri_proj/nokogiri/html/document.rb;Ti=I"â      #   node.serialize(:encoding => 'UTF-8') do |config|
      #     config.format.as_xml
      #   end
      #
      def function(var);Fi[	I"1projects//nokogiri_proj/nokogiri/xml/node.rb;Ti§I"é      #   node.serialize(:encoding => 'UTF-8') do |config|
      #     config.format.as_xml
      #   end
      #
      def function(var, var);Fi[	I"-projects//omni_proj/omniauth/strategy.rb;Ti-I"Å      #       c.foo = 'bar'
      #     end
      #   end
      #
      # @example Using a hash to configure the default options.;Fi[	I",projects//rescue_proj/resque/helpers.rb;Ti)I"æ    #     C               # => 'inside'
    #     'C'.constantize # => 'outside', same as ::C
    #   end
    #
    # NameError is raised when the name is not in CamelCase or the constant is;Fi[	I"?projects//state_machine_proj/state_machine/eval_helpers.rb;TiI"V    #       @name
    #     end
    #   end
    #   
    #   class PersonCallback;Fi[	@·i I"g    #       person.name
    #     end
    #   end
    # 
    #   person = Person.new('John Smith');Fi[	I"Cprojects//state_machine_proj/state_machine/event_collection.rb;Ti#I"m    #       end
    #     end
    #   end
    #   
    #   events = Vehicle.state_machine(:state).events;Fi[	@ÊiHI"e    #       end
    #     end
    #   end
    #   
    #   events = Vehicle.state_machine.events;Fi[	@ÊihI"è    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                       # => #<Vehicle id: nil, state: "parked">;Fi[	I"=projects//state_machine_proj/state_machine/extensions.rb;TiTI"™    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                         # => #<Vehicle:0xb7c02850 @state="parked", @alarm_state="active">;Fi[	@ÌiÅI"™    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                         # => #<Vehicle:0xb7c02850 @state="parked", @alarm_state="active">;Fi[	I"Dprojects//state_machine_proj/state_machine/integrations/base.rb;TiDI"ë        #       end
        #     end
        #   end
        # 
        # In the above example, a version override is defined for the ORMLibrary;Fi[	I"Tprojects//state_machine_proj/state_machine/integrations/data_mapper/observer.rb;Ti I"i        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver;Fi[	@ıi9I"ò        #       # log message
        #     end
        #   end
        # 
        # *Note* that in each of the above +before_transition+ callbacks, the;Fi[	@ıi]I"i        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver;Fi[	@ıiiI"†        #       # track end time
        #     end
        #   end
        # 
        # See +before_transition+ for a description of the possible configurations;Fi[	@ıi|I"i        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver;Fi[	@ıiÜI"ù        #       # log failure
        #     end
        #   end
        # 
        # See +before_transition+ for a description of the possible configurations;Fi[	I"Eprojects//state_machine_proj/state_machine/machine_collection.rb;TiI"›    #   machines.initialize_states(object) do
    #     # After static state initialization, before dynamic state initialization
    #   end
    # 
    # If no block is provided, then all states will still be initialized.;Fi[	I"@projects//state_machine_proj/state_machine/macro_methods.rb;Ti@I"|    #       end
    #     end
    #   end
    # 
    # The above example will define a state machine named "state" that will;Fi[	@iLI"X    #       ...
    #     end
    #   end
    # 
    # With a static initial state:;Fi[	@iTI"Y    #       ...
    #     end
    #   end
    # 
    # With a dynamic initial state:;Fi[	@i\I"L    #       ...
    #     end
    #   end
    # 
    # == Class Methods;Fi[	@ivI"w    #       end
    #     end
    #   end
    #   
    #   Vehicle.human_state_name(:parked)         # => "parked";Fi[	@ißI"U    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new;Fi[	@i‹I"}    #       ...
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">;Fi[	@iÌI"{    #     def initialize
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c77678>;Fi[	@i I"Å    #       super()
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">;Fi[	@iI"ì    #       initialize_state_machines
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">;Fi[	@i,I"}    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">;Fi[	@iII"|    #       end
    #     end
    #   end
    # 
    # ...will generate the following instance methods (assuming they're not;Fi[	@iaI"ã    #       start :idling, :value => 1
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new # => #<Vehicle:0xb712da60 @state=0>;Fi[	@iòI"^    #       end
    #     end
    #   end
    #   
    #   # Fire +ignite+ event directly;Fi[	@i”I"Ñ    #       end
    #     end
    #   end
    # 
    # The above class defines two state machines: +heater_state+ and +alarm_state+.;Fi[	I"Bprojects//state_machine_proj/state_machine/matcher_helpers.rb;TiI"}    #       end
    #     end
    #   end
    # 
    # In the above example, +all+ will match the following states since they;Fi[	@$i0I"    #       end
    #     end
    #   end
    # 
    # In the above example, +same+ will match whichever the from state is.  In;Fi[	I"Cprojects//state_machine_proj/state_machine/state_collection.rb;TiI"v    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states;Fi[	@)i-I"v    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states;Fi[	@)iHI"v    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states;Fi[	I"@projects//state_machine_proj/state_machine/state_context.rb;Ti(I"ı    #       transition :from => [:idling, :parked], :on => :park, :unless => :seatbelt_on?  # Transitions to :parked if seatbelt is off
    #     end
    #   end
    # 
    # See StateMachine::Machine#transition for a description of the possible;Fi[	I"=projects//state_machine_proj/state_machine/transition.rb;TiµI"U    #       ...
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new;Fi[	@3iÈI"U    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new;Fi[	@3iI"    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new     # => #<Vehicle:0xb7b7f568 @state="parked">;Fi[	I"def function;FI""STRING";Fi}[}[	I"Xprojects//activerecord_proj/active_record/associations/join_dependency/join_base.rb;TiI"M        end
        
        def function
          "STRING"
        end;Fi[	I"Xprojects//activerecord_proj/active_record/associations/join_dependency/join_part.rb;Ti+I"Å        
        # The alias for the primary key of the active_record's table
        def function
          "STRING"
        end;Fi[	I"`projects//activerecord_proj/active_record/associations/preloader/has_and_belongs_to_many.rb;TiI"M        end
        
        def function
          "STRING"
        end;Fi[	@i/I"C      end
      
      def function
        "STRING"
      end;Fi[	@i3I"C      end
      
      def function
        "STRING"
      end;Fi[	I"Vprojects//activerecord_proj/active_record/connection_adapters/abstract/quoting.rb;TikI"C      end
      
      def function
        "STRING"
      end;Fi[	@KioI"C      end
      
      def function
        "STRING"
      end;Fi[	I"Vprojects//activerecord_proj/active_record/connection_adapters/abstract_adapter.rb;TifI"•      # Returns the human-readable name of the adapter. Use mixed case - one
      # can always use downcase if needed.
      def function
        "STRING"
      end;Fi[	@PiI"C      end
      
      def function
        "STRING"
      end;Fi[	I"\projects//activerecord_proj/active_record/connection_adapters/abstract_mysql_adapter.rb;Ti:I"C      end
      
      def function
        "STRING"
      end;Fi[	I"Uprojects//activerecord_proj/active_record/connection_adapters/sqlite3_adapter.rb;TioI"H      
      #:nodoc:
      def function
        "STRING"
      end;Fi[	I":projects//activerecord_proj/active_record/fixtures.rb;TiËI"9    end
    
    def function
      "STRING"
    end;Fi[	@CiRI"=    private
    
    def function
      "STRING"
    end;Fi[	I"Lprojects//activerecord_proj/active_record/tasks/mysql_database_tasks.rb;TilI"C      end
      
      def function
        "STRING"
      end;Fi[	I"5projects//backup_proj/backup/database/mongodb.rb;Ti®I"›      # Returns the MongoDB syntax for determining where to output all the database dumps,
      # e.g. ~/Backup/.tmp/databases/MongoDB/<databases here>/<database collections>
      def function
        "STRING"
      end;Fi[	I"3projects//backup_proj/backup/database/redis.rb;TiWI"h      ##
      # Returns the Redis database file name
      def function
        "STRING"
      end;Fi[	I"2projects//backup_proj/backup/database/riak.rb;Ti6I"}      ##
      # Builds the full riak-admin string based on all attributes
      def function
        "STRING"
      end;Fi[	I",projects//backup_proj/backup/package.rb;Ti+I"9    end
    
    def function
      "STRING"
    end;Fi[	I"7projects//backup_proj/backup/storage/cloudfiles.rb;Ti#I"}      ##
      # This is the provider that Fog uses for the Cloud Files Storage
      def function
        "STRING"
      end;Fi[	I"5projects//backup_proj/backup/storage/ninefold.rb;TiI"      ##
      # This is the provider that Fog uses for the Ninefold storage
      def function
        "STRING"
      end;Fi[	I"2projects//backup_proj/backup/storage/rsync.rb;TiyI"z      ##
      # Returns Rsync syntax for defining a port to connect to
      def function
        "STRING"
      end;Fi[	@ui{I"ò      # RSync options
      # -z = Compresses the bytes that will be transferred to reduce bandwidth usage
      def function
        "STRING"
      end;Fi[	I"/projects//backup_proj/backup/storage/s3.rb;Ti!I"y      ##
      # This is the provider that Fog uses for the S3 Storage
      def function
        "STRING"
      end;Fi[	I"=projects//backup_proj/backup/syncer/cloud/cloud_files.rb;Ti@I"        ##
        # This is the provider that Fog uses for the Cloud Files
        def function
          "STRING"
        end;Fi[	I"4projects//backup_proj/backup/syncer/cloud/s3.rb;Ti7I"        ##
        # This is the provider that Fog uses for the Cloud Files
        def function
          "STRING"
        end;Fi[	I"6projects//backup_proj/backup/syncer/rsync/base.rb;Ti)I"~        ##
        # Returns Rsync syntax for invoking "archive" mode
        def function
          "STRING"
        end;Fi[	I"6projects//backup_proj/backup/syncer/rsync/push.rb;TiOI"        ##
        # Returns Rsync syntax for defining a port to connect to
        def function
          "STRING"
        end;Fi[	I"Yprojects//compass_proj/compass/app_integration/stand_alone/configuration_defaults.rb;TiI"M        end
        
        def function
          "STRING"
        end;Fi[	@âiI"M        end
        
        def function
          "STRING"
        end;Fi[	@âiI"M        end
        
        def function
          "STRING"
        end;Fi[	@âiI"M        end
        
        def function
          "STRING"
        end;Fi[	@âiI"M        end
        
        def function
          "STRING"
        end;Fi[	I"=projects//compass_proj/compass/configuration/defaults.rb;TiI"]  module Configuration
    module Defaults
      def function
        "STRING"
      end;Fi[	@îiI"C      end
      
      def function
        "STRING"
      end;Fi[	@îiI"C      end
      
      def function
        "STRING"
      end;Fi[	I"6projects//compass_proj/compass/installers/base.rb;Ti†I"Ü      
      # Emits an HTML fragment that can be used to link to the compiled css files
      def function
        "STRING"
      end;Fi[	I"Mprojects//compass_proj/compass/sass_extensions/sprites/sprite_methods.rb;Ti,I"M        end
        
        def function
          "STRING"
        end;Fi[	I"+projects//devise_proj/devise/models.rb;TiI"C      end
      
      def function
        "STRING"
      end;Fi[	I"Gprojects//devise_proj/generators/active_record/devise_generator.rb;Ti&I"C      end
      
      def function
        "STRING"
      end;Fi[	I";projects//devise_proj/generators/devise/orm_helpers.rb;TiI"\  module Generators
    module OrmHelpers
      def function
        "STRING"
      end;Fi[	I"?projects//devise_proj/generators/devise/views_generator.rb;TihI"C      end
      
      def function
        "STRING"
      end;Fi[	I"Aprojects//devise_proj/generators/mongoid/devise_generator.rb;TiI"C      end
      
      def function
        "STRING"
      end;Fi[	I"Cprojects//diaspora_proj/models/notifications/also_commented.rb;Ti
I"/  end
  
  def function
    "STRING"
  end;Fi[	@∞iI"/  end
  
  def function
    "STRING"
  end;Fi[	I"Dprojects//diaspora_proj/models/notifications/comment_on_post.rb;Ti
I"/  end
  
  def function
    "STRING"
  end;Fi[	@µiI"/  end
  
  def function
    "STRING"
  end;Fi[	I":projects//diaspora_proj/models/notifications/liked.rb;Ti
I"/  end
  
  def function
    "STRING"
  end;Fi[	@∫iI"/  end
  
  def function
    "STRING"
  end;Fi[	I">projects//diaspora_proj/models/notifications/mentioned.rb;Ti
I"/  end
  
  def function
    "STRING"
  end;Fi[	@øiI"/  end
  
  def function
    "STRING"
  end;Fi[	I"Dprojects//diaspora_proj/models/notifications/private_message.rb;Ti
I"/  end
  
  def function
    "STRING"
  end;Fi[	I"Eprojects//diaspora_proj/models/notifications/request_accepted.rb;Ti
I"/  end
  
  def function
    "STRING"
  end;Fi[	I"=projects//diaspora_proj/models/notifications/reshared.rb;Ti
I"/  end
  
  def function
    "STRING"
  end;Fi[	@ iI"/  end
  
  def function
    "STRING"
  end;Fi[	I"Dprojects//diaspora_proj/models/notifications/started_sharing.rb;Ti
I"/  end
  
  def function
    "STRING"
  end;Fi[	I"-projects//diaspora_proj/models/person.rb;Ti∆I"/  end
  
  def function
    "STRING"
  end;Fi[	I"+projects//diaspora_proj/models/post.rb;Ti>I"/  end
  
  def function
    "STRING"
  end;Fi[	I"8projects//diaspora_proj/models/services/facebook.rb;TiI"F  MAX_CHARACTERS = "LITERAL"
  
  def function
    "STRING"
  end;Fi[	@ÿi'I"/  end
  
  def function
    "STRING"
  end;Fi[	I"6projects//diaspora_proj/models/services/tumblr.rb;TiI"F  MAX_CHARACTERS = "LITERAL"
  
  def function
    "STRING"
  end;Fi[	I"7projects//diaspora_proj/models/services/twitter.rb;TiI"L  SHORTENED_URL_LENGTH = "LITERAL"
  
  def function
    "STRING"
  end;Fi[	I"9projects//diaspora_proj/uploaders/processed_image.rb;TiI"L  include(CarrierWave::MiniMagick)
  
  def function
    "STRING"
  end;Fi[	I";projects//diaspora_proj/uploaders/unprocessed_image.rb;TiI"L  include(CarrierWave::MiniMagick)
  
  def function
    "STRING"
  end;Fi[	I"'projects//haml_proj/haml/buffer.rb;Ti£I"]    
    if (RUBY_VERSION < "STRING") then
      def function
        "STRING"
      end;Fi[	I")projects//haml_proj/haml/compiler.rb;Ti>I"√    # Returns the string used as the return value of the precompiled method.
    # This method exists so it can be monkeypatched to return modified values.
    def function
      "STRING"
    end;Fi[	I"(projects//haml_proj/haml/helpers.rb;TiI"y      
      # @return [String] A human-readable string representation
      def function
        "STRING"
      end;Fi[	I")projects//haml_proj/haml/template.rb;TiI"Imodule Haml
  class Compiler
    def function
      "STRING"
    end;Fi[	I"'projects//homebrew_proj/bottles.rb;Ti=I"F  Pathname::OLD_BOTTLE_EXTNAME_RX
end
def function
  "STRING"
end;Fi[	I",projects//homebrew_proj/cmd/--config.rb;TiXI"/  end
  
  def function
    "STRING"
  end;Fi[	I"4projects//homebrew_proj/compat/compatibility.rb;TiLI"/  end
  
  def function
    "STRING"
  end;Ti[	I"*projects//homebrew_proj/exceptions.rb;Ti;I"wend
class FormulaInstallationAlreadyAttemptedError < Homebrew::InstallationError
  def function
    "STRING"
  end;Fi[	I"-projects//homebrew_proj/macos/xquartz.rb;Ti'I"/  end
  
  def function
    "STRING"
  end;Fi[	I"2projects//homebrew_proj/test/test_patching.rb;TiI"arequire("test/testball")
class DefaultPatchBall < TestBall
  def function
    "STRING"
  end;Fi[	I")projects//jekyll_proj/jekyll/page.rb;TiáI"]    
    # Returns the object as a debug String.
    def function
      "STRING"
    end;Fi[	I")projects//jekyll_proj/jekyll/post.rb;TiﬂI"m    
    # Returns the shorthand String identifier of this Post.
    def function
      "STRING"
    end;Fi[	I"Aprojects//nokogiri_proj/nokogiri/html/element_description.rb;TiI"i      ###
      # Convert this description to a string
      def function
        "STRING"
      end;Fi[	@iI"[      ###
      # Inspection information
      def function
        "STRING"
      end;Fi[	I";projects//nokogiri_proj/nokogiri/xml/attribute_decl.rb;TiI"u      undef_method("LITERAL") if method_defined?("LITERAL")
      
      def function
        "STRING"
      end;Fi[	I"2projects//nokogiri_proj/nokogiri/xml/cdata.rb;Ti
I"d      ###
      # Get the name of this CDATA node
      def function
        "STRING"
      end;Fi[	I"5projects//nokogiri_proj/nokogiri/xml/document.rb;TiRI"w      
      # The name of this document.  Always returns "document"
      def function
        "STRING"
      end;Fi[	@iﬂI"G      private
      
      def function
        "STRING"
      end;Fi[	I">projects//nokogiri_proj/nokogiri/xml/document_fragment.rb;TiI"i      ###
      # return the name for DocumentFragment
      def function
        "STRING"
      end;Fi[	I"9projects//nokogiri_proj/nokogiri/xml/element_decl.rb;TiI"u      undef_method("LITERAL") if method_defined?("LITERAL")
      
      def function
        "STRING"
      end;Fi[	I"8projects//nokogiri_proj/nokogiri/xml/entity_decl.rb;TiI"C      end
      
      def function
        "STRING"
      end;Fi[	@ÿikI"C      end
      
      def function
        "STRING"
      end;Fi[	I"5projects//nokogiri_proj/nokogiri/xml/node_set.rb;Ti<I"s      ###
      # Return a nicely formated string representation
      def function
        "STRING"
      end;Fi[	I">projects//nokogiri_proj/nokogiri/xml/pp/character_data.rb;TiI"S        
        # :nodoc:
        def function
          "STRING"
        end;Fi[	I")projects//omni_proj/omniauth/form.rb;TiZI"?    protected
    
    def function
      "STRING"
    end;Fi[	@€i|I"9    end
    
    def function
      "STRING"
    end;Fi[	I"$projects//omni_proj/omniauth.rb;TicI"E    module_function
    
    def function
      "STRING"
    end;Fi[	I"Iprojects//paperclip_proj/generators/paperclip/paperclip_generator.rb;TiI"5  protected
  
  def function
    "STRING"
  end;Fi[	@6iI"/  end
  
  def function
    "STRING"
  end;Fi[	I"Gprojects//paperclip_proj/paperclip/io_adapters/abstract_adapter.rb;TiI"9    end
    
    def function
      "STRING"
    end;Fi[	I"Bprojects//paperclip_proj/paperclip/io_adapters/nil_adapter.rb;TiI"9    end
    
    def function
      "STRING"
    end;Fi[	@>iI"9    end
    
    def function
      "STRING"
    end;Fi[	I"Nprojects//paperclip_proj/paperclip/matchers/have_attached_file_matcher.rb;TiI"M        end
        
        def function
          "STRING"
        end;Fi[	@Ci"I"M        end
        
        def function
          "STRING"
        end;Fi[	@Ci&I"M        end
        
        def function
          "STRING"
        end;Fi[	I"\projects//paperclip_proj/paperclip/matchers/validate_attachment_content_type_matcher.rb;Ti4I"M        end
        
        def function
          "STRING"
        end;Fi[	@JiJI"M        end
        
        def function
          "STRING"
        end;Fi[	I"Xprojects//paperclip_proj/paperclip/matchers/validate_attachment_presence_matcher.rb;TiI"M        end
        
        def function
          "STRING"
        end;Fi[	@Oi!I"M        end
        
        def function
          "STRING"
        end;Fi[	@Oi%I"M        end
        
        def function
          "STRING"
        end;Fi[	I"Tprojects//paperclip_proj/paperclip/matchers/validate_attachment_size_matcher.rb;Ti0I"M        end
        
        def function
          "STRING"
        end;Fi[	@Vi4I"M        end
        
        def function
          "STRING"
        end;Fi[	@Vi8I"M        end
        
        def function
          "STRING"
        end;Fi[	I"+projects//rescue_proj/resque/worker.rb;TiÁI"9    end
    
    def function
      "STRING"
    end;Fi[	I"$projects//rescue_proj/resque.rb;Ti∂I"/  end
  
  def function
    "STRING"
  end;Fi[	I"Oprojects//state_machine_proj/state_machine/integrations/sequel/versions.rb;Ti4I"—          (defined? ::Sequel::MAJOR.! or ((::Sequel::MAJOR == "LITERAL") or ((::Sequel::MAJOR == "LITERAL") and (::Sequel::MINOR <= "LITERAL"))))
        end
        def function
          "STRING"
        end;Fi[	@ci7I"W          "STRING"
        end
        def function
          "STRING"
        end;Fi[	@ci@I"œ          defined? ::Sequel::MAJOR and ((::Sequel::MAJOR == "LITERAL") and ((::Sequel::MINOR >= "LITERAL") and (::Sequel::MINOR <= "LITERAL")))
        end
        def function
          "STRING"
        end;Fi[	@ciCI"W          "STRING"
        end
        def function
          "STRING"
        end;Fi[	I":projects//state_machine_proj/state_machine/matcher.rb;Ti0I"t    
    # A human-readable description of this matcher.  Always "all".
    def function
      "STRING"
    end;Fi[	@li\I"d    
    # A human-readable description of this matcher
    def function
      "STRING"
    end;Fi[	@liqI"u    
    # A human-readable description of this matcher.  Always "same".
    def function
      "STRING"
    end;Fi[	@3i'I"    #   transition = StateMachine::Transition.new(object, machine, :ignite, :parked, :idling)
    #   transition   # => #<StateMachine::Transition attribute=:state event=:ignite from="parked" from_name=:parked to="idling" to_name=:idling>
    def function
      "STRING"
    end;Fi[	I"5projects//whenever_proj/whenever/command_line.rb;TimI"9    end
    
    def function
      "STRING"
    end;Fi[	@uiqI"9    end
    
    def function
      "STRING"
    end;Fi[	@uiuI"9    end
    
    def function
      "STRING"
    end;Fi[	I";projects//whenever_proj/whenever/output_redirection.rb;Ti;I"C      end
      
      def function
        "STRING"
      end;Fi[	I"when "LITERAL" then;F@;ir[r[	@KiI"ç          return "STRING" unless var
          case var.type
          when "LITERAL" then
            "STRING"
          when "LITERAL" then;Fi[	@Ui—I"}        when "STRING" then
          case var
          when "LITERAL" then
            "STRING"
          when nil then;Fi[	@Ui’I"s          when nil then
            "STRING"
          when "LITERAL" then
            "STRING"
          else;Fi[	@Ui‹I"~        when "STRING" then
          case var
          when "LITERAL" then
            "STRING"
          when "LITERAL" then;Fi[	@UiﬁI"É          when "LITERAL" then
            "STRING"
          when "LITERAL" then
            "STRING"
          when "LITERAL" then;Fi[	@Ui‡I"ì          when "LITERAL" then
            "STRING"
          when "LITERAL" then
            "STRING"
          when nil, "LITERAL", "LITERAL" then;Fi[	@Ui‰I"Ñ          when nil, "LITERAL", "LITERAL" then
            "STRING"
          when "LITERAL" then
            "STRING"
          else;Fi[	@UiÎI"É        when "STRING" then
          case var
          when "LITERAL" then
            "STRING"
          when nil, "LITERAL" then;Fi[	@UiÔI"à          when nil, "LITERAL" then
            "STRING"
          when "LITERAL" then
            "STRING"
          when "LITERAL" then;Fi[	@UiÒI"y          when "LITERAL" then
            "STRING"
          when "LITERAL" then
            "STRING"
          else;Fi[	I"Xprojects//activerecord_proj/active_record/connection_adapters/postgresql/quoting.rb;TiCI"ì            when "LITERAL" then
              case var
              when "LITERAL" then
                "STRING"
              when "LITERAL" then;Fi[	@ñiEI"à              when "LITERAL" then
                "STRING"
              when "LITERAL" then
                "STRING"
              else;Fi[	I"bprojects//activerecord_proj/active_record/connection_adapters/postgresql/schema_statements.rb;TiI"†          var = var.symbolize_keys.sum do |var, var|
            case var
            when "LITERAL" then
              "STRING"
            when "LITERAL" then;Fi[	@õiI"ç            when "LITERAL" then
              "STRING"
            when "LITERAL" then
              "STRING"
            when "LITERAL" then;Fi[	@õi I"ç            when "LITERAL" then
              "STRING"
            when "LITERAL" then
              "STRING"
            when "LITERAL" then;Fi[	@õi"I"ç            when "LITERAL" then
              "STRING"
            when "LITERAL" then
              "STRING"
            when "LITERAL" then;Fi[	@õi$I"ç            when "LITERAL" then
              "STRING"
            when "LITERAL" then
              "STRING"
            when "LITERAL" then;Fi[	@õi&I"ç            when "LITERAL" then
              "STRING"
            when "LITERAL" then
              "STRING"
            when "LITERAL" then;Fi[	@õi(I"~            when "LITERAL" then
              "STRING"
            when "LITERAL" then
              "STRING"
            else;Fi[	@õi1I"â            when "LITERAL", "LITERAL" then
              "STRING"
            when "LITERAL" then
              "STRING"
            else;Fi[	@õi9I"Ä            return super unless var
            case var
            when "LITERAL" then
              "STRING"
            else;Fi[	@õiAI"í            return "STRING" unless var
            case var
            when "LITERAL" then
              "STRING"
            when "LITERAL" then;Fi[	@õiCI"~            when "LITERAL" then
              "STRING"
            when "LITERAL" then
              "STRING"
            else;Fi[	I"6projects//backup_proj/backup/notifier/campfire.rb;Ti1I"~      def function(var)
        var = case var
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@≤i3I"~        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@≤i5I"o        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        else;Fi[	I"3projects//backup_proj/backup/notifier/prowl.rb;Ti/I"~      def function(var)
        var = case var
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@πi1I"~        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@πi3I"o        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        else;Fi[	I"6projects//backup_proj/backup/notifier/pushover.rb;Ti9I"~      def function(var)
        var = case var
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@¿i;I"~        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@¿i=I"o        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        else;Fi[	I"5projects//backup_proj/backup/notifier/twitter.rb;Ti-I"~      def function(var)
        var = case var
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@«i/I"~        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@«i1I"o        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        else;Fi[	I"Mprojects//compass_proj/compass/sass_extensions/functions/inline_image.rb;Ti'I"f    return var if var
    case var
    when "LITERAL" then
      "STRING"
    when "LITERAL" then;Fi[	@Œi)I"j    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then;Fi[	@Œi+I"j    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then;Fi[	@Œi-I"j    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then;Fi[	@Œi/I"j    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then;Fi[	@Œi1I"j    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then;Fi[	@Œi3I"j    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then;Fi[	@Œi5I"j    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then;Fi[	@Œi7I"j    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then;Fi[	@Œi9I"[    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING"
    else;Fi[	I")projects//homebrew_proj/blacklist.rb;TiI"e  when "STRING" then
    "STRING".undent
  when "LITERAL" then
    "STRING"
  when "STRING" then;Fi[	I"*projects//homebrew_proj/cmd/update.rb;TièI"y      when "LITERAL" then
        File.basename(var, "STRING")
      when "LITERAL" then
        "STRING"
      else;Fi[	I"1projects//homebrew_proj/download_strategy.rb;Ti"I"π        safe_system(@@git, "STRING", "STRING", @url)
        safe_system(@@git, "STRING", "STRING", case @spec
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@Èi$I"o        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        else;Fi[	I"(projects//homebrew_proj/hardware.rb;Ti.I"  def self.cores_as_words
    case Hardware.processor_count
    when "LITERAL" then
      "STRING"
    when "LITERAL" then;Fi[	@Ói0I"j    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then;Fi[	@Ói2I"[    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING"
    else;Fi[	I"+projects//homebrew_proj/macos/xcode.rb;TiI"i  def function
    case MacOS.version
    when "LITERAL" then
      "STRING"
    when "LITERAL" then;Fi[	@ıi I"[    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING"
    else;Fi[	@ıiPI"û    raise if ($1.nil? or $?.success?.!)
    $1) rescue case MacOS.llvm_build_version.to_i
      when "LITERAL" then
        "STRING"
      when "LITERAL" then;Fi[	@ıiRI"t      when "LITERAL" then
        "STRING"
      when "LITERAL" then
        "STRING"
      when "LITERAL" then;Fi[	@ıiTI"t      when "LITERAL" then
        "STRING"
      when "LITERAL" then
        "STRING"
      when "LITERAL" then;Fi[	@ıiVI"t      when "LITERAL" then
        "STRING"
      when "LITERAL" then
        "STRING"
      when "LITERAL" then;Fi[	@ıiXI"t      when "LITERAL" then
        "STRING"
      when "LITERAL" then
        "STRING"
      when "LITERAL" then;Fi[	@ıiZI"e      when "LITERAL" then
        "STRING"
      when "LITERAL" then
        "STRING"
      else;Fi[	@ıi^I"é      else
        case (MacOS.clang_version.to_f * "LITERAL").to_i
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@ıi`I"~        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@ıibI"~        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@ıidI"~        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@ıifI"~        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@ıihI"~        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@ıijI"~        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@ıilI"~        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@ıinI"~        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@ıipI"o        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        else;Fi[	@iI"ç      if (prefix.to_s == "STRING") then
        case MacOS.version
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@iI"~        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@iI"o        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        else;Fi[	I",projects//homebrew_proj/requirements.rb;Ti/I"e  def function
    case @language
    when "LITERAL" then
      "STRING"
    when "LITERAL" then;Fi[	@ i1I"j    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then;Fi[	@ i3I"j    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then;Fi[	@ i5I"j    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then;Fi[	@ i7I"j    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then;Fi[	@ i9I"j    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then;Fi[	@ i;I"j    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then;Fi[	@ i=I"j    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then;Fi[	@ i?I"[    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING"
    else;Fi[	I"1projects//homebrew_proj/test/test_formula.rb;TiZI"ò    assert_equal("LITERAL", var.devel.checksum.hash_type)
    assert_equal(case MacOS.cat
    when "LITERAL" then
      "STRING"
    when "LITERAL" then;Fi[	@3i\I"j    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then;Fi[	@3i^I"[    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING"
    else;Fi[	@3iÒI"è    assert_equal("LITERAL", var.bottle.revision)
    assert_equal(case MacOS.cat
    when "LITERAL" then
      "STRING"
    when "LITERAL" then;Fi[	@3iÛI"j    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then;Fi[	@3iıI"[    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING"
    else;Fi[	I",projects//jekyll_proj/jekyll/filters.rb;TiwI"t      var = "STRING"
      case var.length
      when "LITERAL" then
        "STRING"
      when "LITERAL" then;Fi[	@@i{I"p      when "LITERAL" then
        var["LITERAL"].to_s
      when "LITERAL" then
        "STRING"
      else;Fi[	@
izI"    def function
      case self.site.permalink_style
      when "LITERAL" then
        "STRING"
      when "LITERAL" then;Fi[	@
i|I"t      when "LITERAL" then
        "STRING"
      when "LITERAL" then
        "STRING"
      when "LITERAL" then;Fi[	@
i~I"e      when "LITERAL" then
        "STRING"
      when "LITERAL" then
        "STRING"
      else;Fi[	I":projects//nokogiri_proj/nokogiri/css/xpath_visitor.rb;TiI"£        return self.send(var, var) if self.respond_to?(var)
        case var.value.first
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@KiI"~        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@KiI"~        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@KiI"ë            (var == "LITERAL") ? ("STRING") : ("STRING")
          end
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@Ki!I"~        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@Ki#I"~        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@Ki%I"~        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@Ki'I"~        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@Ki)I"~        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@KiMI"é        when "LITERAL" then
          ((var + "STRING") + "STRING")
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@KiOI"~        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@KiQI"~        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@KiSI"~        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	I"Bprojects//twitter_proj/twitter/request/multipart_with_file.rb;TiI"x      def function(var)
        case var
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@fiI"~        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then;Fi[	@fiI"o        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING"
        else;Fi[	I",# @authentication Requires user context;FI"g# @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fii[i[	I":projects//twitter_proj/twitter/api/direct_messages.rb;TiI"∏      # @note This method requires an access token with RWD (read, write & direct message) permissions. Consult The Application Permission Model for more information.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::DirectMessage>] Direct messages sent to the authenticating user.;Fi[	@qi&I"∏      # @note This method requires an access token with RWD (read, write & direct message) permissions. Consult The Application Permission Model for more information.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::DirectMessage>] Direct messages sent by the authenticating user.;Fi[	@qi9I"ò      # @note This method requires an access token with RWD (read, write & direct message) permissions. Consult The Application Permission Model for more information.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::DirectMessage] The requested messages.;Fi[	@qiGI"ü      # @note This method requires an access token with RWD (read, write & direct message) permissions. Consult The Application Permission Model for more information.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::DirectMessage>] The requested messages.;Fi[	@qipI"û      # @note This method requires an access token with RWD (read, write & direct message) permissions. Consult The Application Permission Model for more information.
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::DirectMessage>] Deleted direct message.;Fi[	@qi}I"5      # @see https://dev.twitter.com/docs/api/1.1/post/direct_messages/new
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::DirectMessage] The sent message.;Fi[	I"4projects//twitter_proj/twitter/api/favorites.rb;TiI".      # @see https://dev.twitter.com/docs/api/1.1/get/favorites/list
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>] favorite Tweets.;Fi[	@~i4I"9      # @see https://dev.twitter.com/docs/api/1.1/post/favorites/destroy
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>] The un-favorited Tweets.;Fi[	@~iLI"5      # @see https://dev.twitter.com/docs/api/1.1/post/favorites/create
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>] The favorited Tweets.;Fi[	I"@projects//twitter_proj/twitter/api/friends_and_followers.rb;TiI"      # @see https://dev.twitter.com/docs/api/1.1/get/friends/ids
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor];Fi[	@Öi+I"      # @see https://dev.twitter.com/docs/api/1.1/get/followers/ids
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor];Fi[	@ÖiFI"5      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/lookup
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::User>] The requested users.;Fi[	@Öi\I"      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/incoming
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor];Fi[	@ÖikI"      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/outgoing
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor];Fi[	@ÖizI"4      # @see https://dev.twitter.com/docs/api/1.1/post/friendships/create
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::User>] The followed users.;Fi[	@ÖiéI"4      # @see https://dev.twitter.com/docs/api/1.1/post/friendships/create
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::User>] The followed users.;Fi[	@Öi´I"7      # @see https://dev.twitter.com/docs/api/1.1/post/friendships/destroy
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::User>] The unfollowed users.;Fi[	@ÖiøI"!      # @see https://dev.twitter.com/docs/api/1.1/post/friendships/update
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Relationship];Fi[	@Öi—I"      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Relationship];Fi[	@ÖiÎI"A      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Boolean] true if user_a follows user_b, otherwise false.;Fi[	@Öi˝I"      # @see https://dev.twitter.com/docs/api/1.1/get/followers/list
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor];Fi[	@ÖiI"      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor];Fi[	@Öi=I"#      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/no_retweets/ids
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Integer>];Fi[	I"/projects//twitter_proj/twitter/api/help.rb;TiI";      # @see https://dev.twitter.com/docs/api/1.1/get/help/configuration
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Configuration] Twitter's configuration.;Fi[	@¢iI"       # @see https://dev.twitter.com/docs/api/1.1/get/help/languages
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Language>];Fi[	@¢i+I"      # @see https://dev.twitter.com/docs/api/1.1/get/help/privacy
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [String];Fi[	@¢i8I"      # @see https://dev.twitter.com/docs/api/1.1/get/help/tos
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [String];Fi[	I"0projects//twitter_proj/twitter/api/lists.rb;TiI"      # @see https://dev.twitter.com/docs/api/1.1/get/lists/list
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::List>];Fi[	@´i0I"      # @see https://dev.twitter.com/docs/api/1.1/get/lists/statuses
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>];Fi[	@´iUI"&      # @see https://dev.twitter.com/docs/api/1.1/post/lists/members/destroy
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::List] The list.;Fi[	@´irI"      # @see https://dev.twitter.com/docs/api/1.1/get/lists/memberships
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor];Fi[	@´iÜI"A      # @see https://dev.twitter.com/docs/api/1.1/get/lists/subscribers
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor] The subscribers of the specified list.;Fi[	@´i°I"3      # @see https://dev.twitter.com/docs/api/1.1/post/lists/subscribers/create
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::List] The specified list.;Fi[	@´i∫I"\      # @see https://dev.twitter.com/docs/api/1.1/get/lists/subscribers/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Boolean] true if user is a subscriber of the specified list, otherwise false.;Fi[	@´iÿI"4      # @see https://dev.twitter.com/docs/api/1.1/post/lists/subscribers/destroy
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::List] The specified list.;Fi[	@´iÚI"f      # @note Lists are limited to having 500 members, and you are limited to adding up to 100 members to a list at a time with this method.
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::List] The list.;Fi[	@´i-I"      # @see https://dev.twitter.com/docs/api/1.1/get/lists/members
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor];Fi[	@´iJI"      # @note Lists are limited to having 500 members.
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::List] The list.;Fi[	@´igI"      # @note Must be owned by the authenticated user.
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::List] The deleted list.;Fi[	@´iÅI"%      # @see https://dev.twitter.com/docs/api/1.1/post/lists/update
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::List] The created list.;Fi[	@´i†I"      # @note Accounts are limited to 20 lists.
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::List] The created list.;Fi[	@´i≤I"F      # @note Private lists will only be shown if the authenticated user owns the specified list.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::List] The specified list.;Fi[	@´iÃI"      # @see https://dev.twitter.com/docs/api/1.1/get/lists/subscriptions
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor];Fi[	@´i„I"*      # @see https://dev.twitter.com/docs/api/1.1/post/lists/members/destroy_all
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::List] The list.;Fi[	I"9projects//twitter_proj/twitter/api/places_and_geo.rb;TiI"|      # @see https://dev.twitter.com/docs/api/1.1/get/geo/id/:place_id
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param place_id [String] A place in the world. These IDs can be retrieved from {Twitter::API::PlacesAndGeo#reverse_geocode}.;Fi[	@Œi I"U      # @note This request is an informative call and will deliver generalized results about geography.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.;Fi[	@Œi3I".      # @see https://dev.twitter.com/docs/api/1.1/get/geo/search
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.;Fi[	@ŒiMI"      # @note Conceptually, you would use this method to get a list of known places to choose from first. Then, if the desired place doesn't exist, make a request to {Twitter::API::PlacesAndGeo#place} to create a new one. The token contained in the response is the token necessary to create a new place.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.;Fi[	@ŒibI".      # @see https://dev.twitter.com/docs/api/1.1/post/geo/place
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.;Fi[	I"9projects//twitter_proj/twitter/api/saved_searches.rb;TiI"˘      
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::SavedSearch>] The saved searches.;Fi[	@Ÿi2I"9      # @see https://dev.twitter.com/docs/api/1.1/get/saved_searches/show/:id
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::SavedSearch] The saved searches.;Fi[	@ŸiAI"=      # @see https://dev.twitter.com/docs/api/1.1/post/saved_searches/create
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::SavedSearch] The created saved search.;Fi[	@ŸiQI"L      # @note The search specified by ID must be owned by the authenticating user.
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::SavedSearch>] The deleted saved searches.;Fi[	I"1projects//twitter_proj/twitter/api/search.rb;TiI"±      # @note Please note that Twitter's search service and, by extension, the Search API is not meant to be an exhaustive source of Tweets. Not all Tweets will be indexed or made available via the search interface.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param q [String] A search term.;Fi[	I"9projects//twitter_proj/twitter/api/spam_reporting.rb;TiI"4      # @see https://dev.twitter.com/docs/api/1.1/post/users/report_spam
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::User>] The reported users.;Fi[	I":projects//twitter_proj/twitter/api/suggested_users.rb;TiI"      # @return [Array<Twitter::Suggestion>]
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @overload suggestions(options={});Fi[	I"4projects//twitter_proj/twitter/api/timelines.rb;TiI"      # @note This method can only return up to 800 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>];Fi[	@Îi+I"      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>];Fi[	@ÎiCI"      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>];Fi[	@Îi[I"      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>];Fi[	@ÎipI"(      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>];Fi[	@ÎiÇI"(      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>];Fi[	@ÎióI"&      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/retweets_of_me
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>];Fi[	I"1projects//twitter_proj/twitter/api/trends.rb;TiI"      # @see https://dev.twitter.com/docs/api/1.1/get/trends/place
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param id [Integer] The {https://developer.yahoo.com/geo/geoplanet Yahoo! Where On Earth ID} of the location to return trending information for. WOEIDs can be retrieved by calling {Twitter::API::Trends#trend_locations}. Global information is available by using 1 as the WOEID.;Fi[	@˙i'I"4      # @see https://dev.twitter.com/docs/api/1.1/get/trends/available
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.;Fi[	@˙i7I"2      # @see https://dev.twitter.com/docs/api/1.1/get/trends/closest
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.;Fi[	I"1projects//twitter_proj/twitter/api/tweets.rb;TiI"$      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/retweets/:id
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>];Fi[	@i%I"      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/retweets/:id
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array];Fi[	@i9I".      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/show/:id
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Tweet] The requested Tweet.;Fi[	@iII"6      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/show/:id
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>] The requested Tweets.;Fi[	@i]I"=      # @note The authenticating user must be the author of the specified Tweets.
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>] The deleted Tweets.;Fi[	@isI"h      # @note A status update with text identical to the authenticating user's current status will be ignored to prevent duplicates.
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Tweet] The created Tweet.;Fi[	@iÉI"W      # @see https://dev.twitter.com/docs/api/1.1/post/statuses/retweet/:id
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>] The original tweets with retweet details embedded.;Fi[	@iπI"[      # @note A status update with text/media identical to the authenticating user's current status will NOT be ignored
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Tweet] The created Tweet.;Fi[	@iœI"8      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/oembed
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::OEmbed] OEmbed for the requested Tweet.;Fi[	@iÂI"A      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/oembed
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::OEmbed>] OEmbeds for the requested Tweets.;Fi[	I"7projects//twitter_proj/twitter/api/undocumented.rb;TiI"˜      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array] An array of actions;Fi[	@i2I"”      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      #;Fi[	@iPI"      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Tweet] The requested Tweet.;Fi[	@icI"	      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>] The requested Tweets.;Fi[	I"0projects//twitter_proj/twitter/api/users.rb;TiI"      # @see https://dev.twitter.com/docs/api/1.1/get/account/settings
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Settings];Fi[	@i.I"9      # @see https://dev.twitter.com/docs/api/1.1/get/account/verify_credentials
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::User] The authenticated user.;Fi[	@i?I"=      # @see https://dev.twitter.com/docs/api/1.1/post/account/update_delivery_device
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::User] The authenticated user.;Fi[	@iOI"!      # @note Only the options specified will be updated.
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::User] The authenticated user.;Fi[	@iaI"F      # @see https://dev.twitter.com/docs/api/1.1/post/account/update_profile_background_image
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::User] The authenticated user.;Fi[	@iqI"<      # @see https://dev.twitter.com/docs/api/1.1/post/account/update_profile_colors
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::User] The authenticated user.;Fi[	@iÅI"      # @note This method asynchronously processes the uploaded file before updating the user's profile image URL. You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::User] The authenticated user.;Fi[	@iêI"P      # @see https://dev.twitter.com/docs/api/1.1/get/blocks/list
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::User>] User objects that the authenticating user is blocking.;Fi[	@iüI"?      # @see https://dev.twitter.com/docs/api/1.1/get/blocks/ids
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array] Numeric user ids the authenticating user is blocking.;Fi[	@i∞I"Y      # @see https://dev.twitter.com/docs/api/1.1/get/blocks/ids
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Boolean] true if the authenticating user is blocking the target user, otherwise false.;Fi[	@iÃI"0      # @note Destroys a friendship to the blocked user if it exists.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::User>] The blocked users.;Fi[	@iﬂI"2      # @see https://dev.twitter.com/docs/api/1.1/post/blocks/destroy
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::User>] The un-blocked users.;Fi[	@iÚI"/      # @see https://dev.twitter.com/docs/api/1.1/get/users/lookup
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::User>] The requested users.;Fi[	@iI"%      # @see https://dev.twitter.com/docs/api/1.1/get/users/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::User] The requested user.;Fi[	@i+I"¸      #
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Boolean] true if the user exists, otherwise false.;Fi[	@i@I"      # @see https://dev.twitter.com/docs/api/1.1/get/users/search
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::User>];Fi[	@iQI"       # @see https://dev.twitter.com/docs/api/1.1/get/users/contributees
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::User>];Fi[	@ihI"       # @see https://dev.twitter.com/docs/api/1.1/get/users/contributors
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::User>];Fi[	@iI"      # @see https://dev.twitter.com/docs/api/1.1/post/account/remove_profile_banner
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [nil];Fi[	@i•I"9      # @note If the user has not uploaded a profile banner, a HTTP 404 will be served instead.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::ProfileBanner];Fi[	I"@var = var;F@Hie[e[	I"Lprojects//activerecord_proj/active_record/associations/alias_tracker.rb;TiI"ï      def function(var, var)
        @var = Hash.new { |var, var| var[var] = initial_count_for(var) }
        @var = var
        @var = var
      end;Fi[	I"Rprojects//activerecord_proj/active_record/associations/builder/association.rb;TiI"•    def function(var, var, var, var)
      raise(ArgumentError, "STRING") unless var.kind_of?(Symbol)
      @var = var
      @var = var
      if var.is_a?(Hash) then;Fi[	@NiI"R        @var = var
      else
        @var = var
        @var = var
      end;Fi[	I"_projects//activerecord_proj/active_record/associations/join_dependency/join_association.rb;Ti+I"ß          raise(EagerLoadPolymorphicError.new(var)) if var.options["LITERAL"]
          super(var.klass)
          @var = var
          @var = var
          @var = var;Fi[	@Si,I"          super(var.klass)
          @var = var
          @var = var
          @var = var
          @var = Arel::InnerJoin;Fi[	I"Nprojects//activerecord_proj/active_record/associations/join_dependency.rb;TiI"v      
      def function(var, var, var)
        @var = var
        @var = var
        @var = [JoinBase.new(var)];Fi[	I"Tprojects//activerecord_proj/active_record/associations/preloader/association.rb;TiI"u        
        def function(var, var, var, var)
          @var = var
          @var = var
          @var = var;Fi[	@[iI"|        def function(var, var, var, var)
          @var = var
          @var = var
          @var = var
          @var = var;Fi[	@[iI"Ñ          @var = var
          @var = var
          @var = var
          @var = var
          @var = (var.first and var.first.class);Fi[	I"Fprojects//activerecord_proj/active_record/attribute_assignment.rb;TieI"f      
      def function(var, var, var)
        @var = var
        @var = var
        @var = var;Fi[	@bifI"i      def function(var, var, var)
        @var = var
        @var = var
        @var = var
      end;Fi[	I"^projects//activerecord_proj/active_record/connection_adapters/abstract/connection_pool.rb;TiI"b        
        def function(var, var)
          @var = var
          @var = var
        end;Fi[	@iI"a    class Table
      def function(var, var)
        @var = var
        @var = var
      end;Fi[	@PiJI"®        @var = ActiveSupport::Notifications.instrumenter
        @var = false
        @var = var
        @var = var
        @var = Hash.new { |var, var| var[var] = {} };Fi[	@UiI"â        
        def function(var, var, var, var, var, var)
          @var = var
          @var = var
          super(var, var, var, var);Fi[	I"^projects//activerecord_proj/active_record/connection_adapters/connection_specification.rb;TiI"b        
        def function(var, var)
          @var = var
          @var = var
        end;Fi[	I"Tprojects//activerecord_proj/active_record/connection_adapters/postgresql/oid.rb;Ti6I"}          # pg_types table.
          def function(var, var)
            @var = var
            @var = var
          end;Fi[	I"Tprojects//activerecord_proj/active_record/connection_adapters/statement_pool.rb;TiI"X      
      def function(var, var)
        @var = var
        @var = var
      end;Fi[	I"8projects//activerecord_proj/active_record/errors.rb;TiAI"_    def function(var, var)
      super("STRING")
      @var = var
      @var = var
    end;Fi[	@yiZI"_    def function(var, var, var)
      super(var)
      @var = var
      @var = var
    end;Fi[	@[izI"¢    def function(var, var, var, var)
      @var = {}
      @var = var
      @var = var
      var.is_a?(Class) ? (@var = var) : (@var = var.constantize rescue nil);Fi[	@[i˚I"N    
    def function(var, var)
      @var = var
      @var = var
    end;Fi[	@8ieI"y      # :nodoc:
      def function(var, var, var, var, var)
        @var = var
        @var = var
        @var = var;Fi[	@8ifI"|      def function(var, var, var, var, var)
        @var = var
        @var = var
        @var = var
        @var = var;Fi[	@8igI"c        @var = var
        @var = var
        @var = var
        @var = var
        @var = var;Fi[	@8ihI"ò        @var = var
        @var = var
        @var = var
        @var = var
        @var = var.pluralize_table_names ? (var.to_s.pluralize) : (var.to_s);Fi[	I"Aprojects//activerecord_proj/active_record/relation/merger.rb;TiI"Ñ      def function(var, var)
        var.assert_valid_keys(*Relation::VALUE_METHODS)
        @var = var
        @var = var
      end;Fi[	@QiI"\    
    def function(var, var, var)
      @var = var
      @var = var
      @var = var;Ti[	@QiI"h    def function(var, var, var)
      @var = var
      @var = var
      @var = var
      @var = nil;Ti[	I"8projects//activerecord_proj/active_record/result.rb;TiI"\    
    def function(var, var, var)
      @var = var
      @var = var
      @var = nil;Fi[	@≤ibI"£        # necessary arguments (@room_id, @subdomain, @api_token)
        def function(var, var, var)
          @var = var
          @var = var
          @var = var;Fi[	@≤icI"s        def function(var, var, var)
          @var = var
          @var = var
          @var = var
        end;Fi[	I"-projects//backup_proj/backup/splitter.rb;Ti
I"N    
    def function(var, var)
      @var = var
      @var = var
    end;Fi[	I"1projects//backup_proj/backup/storage/base.rb;TiI"h      def function(var, var)
        load_defaults!
        @var = var
        @var = var
      end;Fi[	I"/projects//cancan_proj/cancan/exceptions.rb;TiI"\    
    def function(var, var, var)
      @var = var
      @var = var
      @var = var;Fi[	@ûiI"à    def function(var, var, var)
      @var = var
      @var = var
      @var = var
      @var = I18n.t("LITERAL", "LITERAL" => "STRING");Fi[	I"Dprojects//cancan_proj/cancan/model_adapters/abstract_adapter.rb;Ti*I"X      
      def function(var, var)
        @var = var
        @var = var
      end;Fi[	@õiI"l      
      def function(var, var, var)
        @var = var
        @var = var
        @var = Dir.getwd;Fi[	I":projects//compass_proj/compass/installers/manifest.rb;TiRI"l      def function(var, var)
        if var then
          @var = var
          @var = var
        else;Fi[	I"Bprojects//compass_proj/compass/installers/template_context.rb;TiI"X      
      def function(var, var)
        @var = var
        @var = var
      end;Fi[	I"Iprojects//compass_proj/compass/sass_extensions/sprites/sprite_map.rb;Ti$I"z        
        def function(var, var, var, var, var)
          @var = var
          @var = var
          @var = var;Fi[	@Æi%I"Å        def function(var, var, var, var, var)
          @var = var
          @var = var
          @var = var
          @var = var;Fi[	@Æi&I"ê          @var = var
          @var = var
          @var = var
          @var = var
          @kwargs["STRING"] ||= Sass::Script::Bool.new(true);Fi[	I"4projects//devise_proj/devise/omniauth/config.rb;TiI"Ö      
      def function(var, var)
        @var = var
        @var = var
        @var = @args.last.is_a?(Hash) ? (@args.last) : ({});Fi[	I"0projects//diaspora_proj/mailers/notifier.rb;Ti&I"\  
  def function(var, var, var, var, var)
    @var = var
    @var = var
    @var = var;Fi[	@∏i'I"h  def function(var, var, var, var, var)
    @var = var
    @var = var
    @var = var
    @var = var;Fi[	@∏i(I"    @var = var
    @var = var
    @var = var
    @var = var
    var = { "LITERAL" => (var), "LITERAL" => (AppConfig.mail.sender_address), "LITERAL" => (I18n.t("STRING", "LITERAL" => (@inviter.name))), "LITERAL" => (AppConfig.pod_uri.host) };Fi[	I"Aprojects//diaspora_proj/presenters/extreme_post_presenter.rb;TiI"\class ExtremePostPresenter
  def function(var, var)
    @var = var
    @var = var
  end;Fi[	I"<projects//diaspora_proj/presenters/o_embed_presenter.rb;TiI"D  
  def function(var, var)
    @var = var
    @var = var
  end;Fi[	I";projects//diaspora_proj/presenters/person_presenter.rb;TiI"Wclass PersonPresenter
  def function(var, var)
    @var = var
    @var = var
  end;Fi[	I"9projects//diaspora_proj/presenters/post_presenter.rb;Ti
I"D  
  def function(var, var)
    @var = var
    @var = var
  end;Fi[	@»iEI"`class PostInteractionPresenter
  def function(var, var)
    @var = var
    @var = var
  end;Fi[	@ÈiVI"s    def function(var, var)
      @var = true
      @var = var
      @var = var
      @var = new_encoded_string;Fi[	@˛iÉI"c  
  def function(var, var)
    @var = var
    @var = var
    @var = var.hash_type.to_s.upcase;Fi[	I"1projects//homebrew_proj/formula_installer.rb;TiI"O  
  def function(var, var)
    @var = var
    @var = var
    @var = false;Fi[	I"/projects//homebrew_proj/formula_support.rb;TiI"L  
  def function(var, var)
    @var = var
    @var = var
    @var = [];Fi[	@‘iiI"V  
  def function(var, var)
    @var = var
    @var = var
    @var = case @reason;Fi[	I"'projects//homebrew_proj/patches.rb;TiBI"a  # Used by audit
  def function(var, var, var)
    @var = var
    @var = var
    @var = nil;Fi[	@ i	I"[  
  def function(var, var, var)
    @var = var
    @var = var
    @var = (var or var);Fi[	@ iôI"ñ  # The user can chose to force installation even in the face of conflicts.
  def function(var, var, var)
    @var = var
    @var = var
    @var = var;Fi[	@ iöI"U  def function(var, var, var)
    @var = var
    @var = var
    @var = var
  end;Fi[	I"+projects//jekyll_proj/jekyll/layout.rb;TiI"Ö    # name - The String filename of the post file.
    def function(var, var, var)
      @var = var
      @var = var
      @var = var;Fi[	@‚iI"l    def function(var, var, var)
      @var = var
      @var = var
      @var = var
      self.data = {};Fi[	@iI"Ö    # name - The String filename of the file.
    def function(var, var, var, var)
      @var = var
      @var = var
      @var = var;Fi[	@iI"m    def function(var, var, var, var)
      @var = var
      @var = var
      @var = var
      @var = var;Fi[	@iI"`      @var = var
      @var = var
      @var = var
      @var = var
      self.process(var);Fi[	I"0projects//jekyll_proj/jekyll/static_file.rb;TiI"Ö    # name - The String filename of the file.
    def function(var, var, var, var)
      @var = var
      @var = var
      @var = var;Fi[	@ÌiI"m    def function(var, var, var, var)
      @var = var
      @var = var
      @var = var
      @var = var;Fi[	@ÌiI"P      @var = var
      @var = var
      @var = var
      @var = var
    end;Fi[	I"1projects//nokogiri_proj/nokogiri/css/node.rb;TiI"~      # Create a new Node with +type+ and +value+
      def function(var, var)
        @var = var
        @var = var
      end;Fi[	I"=projects//nokogiri_proj/nokogiri/html/sax/push_parser.rb;Ti
I"õ      class PushParser
        def function(var, var, var)
          @var = var
          @var = var
          @var = HTML::SAX::Parser.new(var, @encoding);Fi[	I"4projects//nokogiri_proj/nokogiri/xml/builder.rb;TiÇI"q      class NodeBuilder
        def function(var, var)
          @var = var
          @var = var
        end;Fi[	I"7projects//nokogiri_proj/nokogiri/xml/sax/parser.rb;Ti/I"}        def function(var, var)
          check_encoding(var)
          @var = var
          @var = var
          @var = false;Fi[	I"<projects//nokogiri_proj/nokogiri/xml/sax/push_parser.rb;TiI"©        # an optional +file_name+ and +encoding+
        def function(var, var, var)
          @var = var
          @var = var
          @var = XML::SAX::Parser.new(var);Fi[	I"5projects//paperclip_proj/paperclip/attachment.rb;Ti,I"∑    # +escape_url+ - Perform URI escaping to URLs. Defaults to true
    def function(var, var, var)
      @var = var
      @var = var
      var = self.class.default_options.merge(var);Fi[	I"4projects//paperclip_proj/paperclip/processor.rb;Ti
I"\    
    def function(var, var, var)
      @var = var
      @var = var
      @var = var;Fi[	@iI"_    def function(var, var, var)
      @var = var
      @var = var
      @var = var
    end;Fi[	I"0projects//paperclip_proj/paperclip/style.rb;TiI"Ç    # can be string, array or hash
    def function(var, var, var)
      @var = var
      @var = var
      if var.is_a?(Hash) then;Fi[	I"8projects//paperclip_proj/paperclip/url_generator.rb;Ti	I"^  class UrlGenerator
    def function(var, var)
      @var = var
      @var = var
    end;Fi[	I"1projects//rescue_proj/resque/failure/base.rb;TiI"ô      # The payload object associated with the failed job
      def function(var, var, var, var)
        @var = var
        @var = var
        @var = var;Fi[	@iI"w      def function(var, var, var, var)
        @var = var
        @var = var
        @var = var
        @var = var;Fi[	@iI"Z        @var = var
        @var = var
        @var = var
        @var = var
      end;Fi[	I"(projects//rescue_proj/resque/job.rb;TiI"{    # This job's associated payload object.
    def function(var, var)
      @var = var
      @var = var
      @var = false;Fi[	I"*projects//rescue_proj/resque/queue.rb;TiI"`      @var = var
      @var = "STRING"
      @var = var
      @var = var
      @var = false;Fi[	I"8projects//state_machine_proj/state_machine/event.rb;Ti4I"∞    def function(var, var, var)
      assert_valid_keys(var, "LITERAL")
      @var = var
      @var = var
      @var = var.namespace ? (:"#{var}STRING#{var.namespace}") : (var);Fi[	I"@projects//state_machine_proj/state_machine/helper_module.rb;TiI"g  class HelperModule < Module
    def function(var, var)
      @var = var
      @var = var
    end;Fi[	I"7projects//state_machine_proj/state_machine/path.rb;TiI"ê    def function(var, var, var)
      assert_valid_keys(var, "LITERAL", "LITERAL")
      @var = var
      @var = var
      @var = var["LITERAL"];Fi[	I"Bprojects//state_machine_proj/state_machine/path_collection.rb;Ti!I"˘      var = { "LITERAL" => (false), "LITERAL" => (var.states.match!(var).name) }.merge(var)
      assert_valid_keys(var, "LITERAL", "LITERAL", "LITERAL", "LITERAL")
      @var = var
      @var = var
      @var = var.states.fetch(var["LITERAL"]).name;Fi[	I"8projects//state_machine_proj/state_machine/state.rb;Ti=I"‰    def function(var, var, var)
      assert_valid_keys(var, "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL")
      @var = var
      @var = var
      @var = var and var.namespace ? (:"#{var.namespace}STRING#{var}") : (var);Fi[	@3iRI"â    # Creates a new, specific transition
    def function(var, var, var, var, var, var)
      @var = var
      @var = var
      @var = [];Fi[	I"-projects//twitter_proj/twitter/cursor.rb;TiI"Å    # @return [Twitter::Cursor]
    def function(var, var, var, var, var, var)
      @var = var
      @var = var
      @var = var;Fi[	@/iI"w    def function(var, var, var, var, var, var)
      @var = var
      @var = var
      @var = var
      @var = var;Fi[	@/iI"õ      @var = var
      @var = var
      @var = var
      @var = var
      @var = Array(var[var.to_sym]).map { |var| var ? (var.fetch_or_new(var)) : (var) };Fi[	I"-projects//whenever_proj/whenever/cron.rb;TiI"f      
      def function(var, var, var)
        @var = var
        @var = var
        @var = var;Fi[	@6iI"É      def function(var, var, var)
        @var = var
        @var = var
        @var = var
        @var = if var.is_a?(String) then;Fi[	I"1projects//whenever_proj/whenever/job_list.rb;Ti&I"R    
    def function(var, var)
      @var = var
      @var = var
      yield;Fi[	I"#     end;F@i][][	@ i/I"t      #     def clear_attribute(attr)
      #       send("#{attr}=", nil)
      #     end
      #   end
      #;Fi[	@ iSI"u      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #;Fi[	@ iwI"n      #     def reset_attribute_to_default!(attr)
      #       ...
      #     end
      #   end
      #;Fi[	@ ièI"u      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #;Fi[	@ i∑I"r      #     def clear_attribute(attr)
      #       ...
      #     end
      #   end
      def function(var);Fi[	@ i”I"u      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #;Fi[	@ iˆI"u      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #;Fi[	@-i+I"¶    #     def self.before_create( obj )
    #       # obj is the MyModel instance that the callback is being called on
    #     end
    #   end
    def function(var);Fi[	@9iI"|    #     def initialize
    #       @errors = ActiveModel::Errors.new(self)
    #     end
    #   end
    def function(var);Fi[	@AiÄI"K    #   module Foo
    #     class Bar
    #     end
    #   end
    #;Fi[	@]iI"_    #     def capitalized_name
    #       name.capitalize
    #     end
    #   end
    #;Fi[	@]iLI"ß    #     def read_attribute_for_serialization(key)
    #       @data[key]
    #     end
    #   end
    # Add associations specified via the <tt>:include</tt> option.;Fi[	@`isI"c      #     def attributes
      #       instance_values
      #     end
      #   end
      #;Fi[	@ciœI"c      #     def attributes
      #       instance_values
      #     end
      #   end
      #;Fi[	@li!I"q        #     def remove_whitespaces
        #       name.strip!
        #     end
        #   end
        #;Fi[	@liCI"y        #     def set_status
        #       self.status = errors.empty?
        #     end
        #   end
        #;Fi[	@Çi!I"«      #       record.errors.add attribute, (options[:message] || "is not an email") unless
      #         value =~ /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\z/i
      #     end
      #   end
      #;Fi[	@ãiVI"ò      #     def validate(record)
      #       options[:my_custom_key] # => "my custom value"
      #     end
      #   end
      def function(var, var);Fi[	@ãiqI"n    #     def instance_validations
    #       validates_with MyValidator
    #     end
    #   end
    #;Fi[	@ãi{I"{    #     def instance_validations
    #       validates_with MyValidator, MyOtherValidator
    #     end
    #   end
    #;Fi[	@òi!I"“      #     validates_each :first_name, :last_name, allow_blank: true do |record, attr, value|
      #       record.errors.add attr, 'starts with z.' if value.to_s[0] == ?z
      #     end
      #   end
      #;Fi[	@òiCI"≤      #     def must_be_friends
      #       errors.add(:base, 'Must be friends to leave a comment') unless commenter.friend_of?(commentee)
      #     end
      #   end
      #;Fi[	@òiQI"≤      #     def must_be_friends
      #       errors.add(:base, 'Must be friends to leave a comment') unless commenter.friend_of?(commentee)
      #     end
      #   end
      #;Fi[	@òi[I"™      #     validate do
      #       errors.add(:base, 'Must be friends to leave a comment') unless commenter.friend_of?(commentee)
      #     end
      #   end
      #;Fi[	@òi"I"w    #     def read_attribute_for_validation(key)
    #       @data[key]
    #     end
    #   end
    def function;Fi[	@ÒiLI"b      #         t.integer :project_id
      #       end
      #     end
      #   end
      #;Fi[	@˜ilI"r        #     def self.primary_key
        #       'foo_' + super
        #     end
        #   end
        #;Fi[	@¸i6I"p      #     def save
      #       'already defined by Active Record'
      #     end
      #   end
      #;Fi[	@#i#I"Z    #     def to_param  # overridden
    #       name
    #     end
    #   end
    #;Fi[	@&i)I"Ç      #   class Invoice < ActiveRecord::Base
      #     class Lineitem < ActiveRecord::Base
      #     end
      #   end
      #;Fi[	@&i1I"s      #   module Invoice
      #     class Lineitem < ActiveRecord::Base
      #     end
      #   end
      #;Fi[	@&iII"ç      #     def self.table_name
      #       "special_" + super
      #     end
      #   end
      #   Post.table_name # => "special_posts";Fi[	@JiˇI"Ç    #     when 'Bad User'
    #       Post.none # => returning [] instead breaks the previous code
    #     end
    #   end
    #;Fi[	@JidI"g    #     def page(number)
    #       # pagination code goes here
    #     end
    #   end
    #;Fi[	@JisI"~    #     def page(number)
    #       # pagination code goes here
    #     end
    #   end
    #   scope.page(params[:page]);Fi[	@Ji|I"{    #     def per_page(number)
    #       # pagination code goes here
    #     end
    #   end
    def function(var, var);Fi[	@TiI"{        #     def self.default_scope
        #       where published: true
        #     end
        #   end
        #;Fi[	@Ti[I"®        #     def self.default_scope
        #       # Should return a scope, you can call 'super' here etc.
        #     end
        #   end
        def function(var);Fi[	@[iMI"o        #     def self.red
        #       where(color: 'red')
        #     end
        #   end
        #;Fi[	@[itI"c        #         'red_shirts'
        #       end
        #     end
        #   end
        #;Fi[	@[iàI"l        #     def self.titles
        #       pluck(:title)
        #     end
        #   end
        #;Fi[	@hiíI"v    #       xml.first_name "David"
    #       xml.last_name "Heinemeier Hansson"
    #     end
    #   end
    #;Fi[	@hi™I"z    #         xml.tag!(:second_level, 'content')
    #       end
    #     end
    #   end
    def function(var, var);Fi[	@ziÂI"c      #         'mary.smith@example.com'
      #       ]
      #     end
      #   end
      #;Fi[	@zi
I"á      #       enc.passphrase = nil
      #       enc.passphrase_file = '/path/to/passphrase.file'
      #     end
      #   end
      #;Fi[	@ñi.I"Ü      #     def find_book_by_permalink
      #       @book = Book.find_by_permalink!(params[:id)
      #     end
      #   end
      #;Fi[	@ñi>I"ó    #     rescue_from CanCan::AccessDenied do |exception|
    #       redirect_to root_url, :alert => exception.message
    #     end
    #   end
    #;Fi[	@æiôI"r    #     def self.default_url_options
    #       { :locale => I18n.locale }
    #     end
    #   end
    #;Fi[	@æiI"m    #     as :user do
    #       root :to => 'devise/registrations#new'
    #     end
    #   end
    #;Fi[	@€i,I"c      #     configure do |c|
      #       c.foo = 'bar'
      #     end
      #   end
      #;Fi[	@·iI"L    #     def name
    #       @name
    #     end
    #   end
    #   ;Fi[	@·iI"\    #     def self.run(person)
    #       person.name
    #     end
    #   end
    # ;Fi[	@Êi"I"c    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   ;Fi[	@ÊiGI"c    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   ;Fi[	@ÊigI"c    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   ;Fi[	@ÌiSI"\    #         transition all => :off
    #       end
    #     end
    #   end
    #   ;Fi[	@ÌiÄI"\    #         transition all => :off
    #       end
    #     end
    #   end
    #   ;Fi[	@ÚiCI"[        #         end
        #       end
        #     end
        #   end
        # ;Fi[	@ıiI"w        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   ;Fi[	@ıi8I"        #     before_transition do |transition|
        #       # log message
        #     end
        #   end
        # ;Fi[	@ıi\I"w        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   ;Fi[	@ıihI"m        #       block.call
        #       # track end time
        #     end
        #   end
        # ;Fi[	@ıi{I"w        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   ;Fi[	@ıiÖI"É        #     after_transition_failure :on => :ignite do
        #       # log failure
        #     end
        #   end
        # ;Fi[	@i?I"G    #         ...
    #       end
    #     end
    #   end
    # ;Fi[	@iKI"u    #     state_machine :status, :attribute => :status_value do
    #       ...
    #     end
    #   end
    # ;Fi[	@iSI"m    #     state_machine :status, :initial => :parked do
    #       ...
    #     end
    #   end
    # ;Fi[	@i[I"ö    #     state_machine :status, :initial => lambda {|vehicle| vehicle.speed == 0 ? :parked : :idling} do
    #       ...
    #     end
    #   end
    # ;Fi[	@iuI"g    #         transition :idling => :first_gear
    #       end
    #     end
    #   end
    #   ;Fi[	@i¶I"c    #         transition :idling => :parked
    #       end
    #     end
    #   end
    #   ;Fi[	@i€I"n    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #   end
    #   ;Fi[	@iÏI"K    #     
    #     def initialize
    #     end
    #   end
    #   ;Fi[	@iˇI"K    #       ...
    #       super()
    #     end
    #   end
    #   ;Fi[	@iI"]    #       ...
    #       initialize_state_machines
    #     end
    #   end
    #   ;Fi[	@i+I"I    #         ...
    #       end
    #     end
    #   end
    #   ;Fi[	@iHI"]    #         transition all => :idling
    #       end
    #     end
    #   end
    # ;Fi[	@i`I"u    #       state :parked, :value => 0
    #       start :idling, :value => 1
    #     end
    #   end
    #   ;Fi[	@ióI"\    #         transition all => :off
    #       end
    #     end
    #   end
    #   ;Fi[	@i“I"Z    #         transition all => :off
    #       end
    #     end
    #   end
    # ;Fi[	@$iI"h    #         transition all - :parked => :stalled
    #       end
    #     end
    #   end
    # ;Fi[	@$i/I"m    #         transition [:idling, :first_gear] => same
    #       end
    #     end
    #   end
    # ;Fi[	@)iI"w    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   ;Fi[	@)i,I"w    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   ;Fi[	@)iGI"w    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   ;Fi[	@0i'I"    #       transition :to => :idling, :on => [:ignite, :shift_up]                          # Transitions to :idling
    #       transition :from => [:idling, :parked], :on => :park, :unless => :seatbelt_on?  # Transitions to :parked if seatbelt is off
    #     end
    #   end
    # ;Fi[	@3i¥I"c    #     state_machine :action => :save do
    #       ...
    #     end
    #   end
    #   ;Fi[	@3iËI"c    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   ;Fi[	@3iI"c    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   ;Fi[	@;@i\[\[	@KiI"Ç          case var.type
          when "LITERAL" then
            "STRING"
          when "LITERAL" then
            var.to_i.to_s;Fi[	@Ui‘I"y            "STRING"
          when nil then
            "STRING"
          when "LITERAL" then
            "STRING";Fi[	@Ui›I"}          case var
          when "LITERAL" then
            "STRING"
          when "LITERAL" then
            "STRING";Fi[	@UiﬂI"            "STRING"
          when "LITERAL" then
            "STRING"
          when "LITERAL" then
            "STRING";Fi[	@Ui„I"ä            "STRING"
          when nil, "LITERAL", "LITERAL" then
            "STRING"
          when "LITERAL" then
            "STRING";Fi[	@UiÓI"            "STRING"
          when nil, "LITERAL" then
            "STRING"
          when "LITERAL" then
            "STRING";Fi[	@UiI"            "STRING"
          when "LITERAL" then
            "STRING"
          when "LITERAL" then
            "STRING";Fi[	@ñi@I"É              "STRING"
            when "STRING" then
              "STRING"
            when "LITERAL" then
              case var;Fi[	@ñiDI"å              case var
              when "LITERAL" then
                "STRING"
              when "LITERAL" then
                "STRING";Fi[	@õiI"Ç            case var
            when "LITERAL" then
              "STRING"
            when "LITERAL" then
              "STRING";Fi[	@õiI"Ñ              "STRING"
            when "LITERAL" then
              "STRING"
            when "LITERAL" then
              "STRING";Fi[	@õi!I"Ñ              "STRING"
            when "LITERAL" then
              "STRING"
            when "LITERAL" then
              "STRING";Fi[	@õi#I"Ñ              "STRING"
            when "LITERAL" then
              "STRING"
            when "LITERAL" then
              "STRING";Fi[	@õi%I"Ñ              "STRING"
            when "LITERAL" then
              "STRING"
            when "LITERAL" then
              "STRING";Fi[	@õi'I"Ñ              "STRING"
            when "LITERAL" then
              "STRING"
            when "LITERAL" then
              "STRING";Fi[	@õi0I"è              "STRING"
            when "LITERAL", "LITERAL" then
              "STRING"
            when "LITERAL" then
              "STRING";Fi[	@õiBI"Ç            case var
            when "LITERAL" then
              "STRING"
            when "LITERAL" then
              "STRING";Fi[	@≤i2I"y        var = case var
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@≤i4I"u          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@πi0I"y        var = case var
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@πi2I"u          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@¿i:I"y        var = case var
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@¿i<I"u          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@«i.I"y        var = case var
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@«i0I"u          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@Œi(I"_    case var
    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING";Fi[	@Œi*I"a      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING";Fi[	@Œi,I"a      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING";Fi[	@Œi.I"a      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING";Fi[	@Œi0I"a      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING";Fi[	@Œi2I"a      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING";Fi[	@Œi4I"a      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING";Fi[	@Œi6I"a      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING";Fi[	@Œi8I"a      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING";Fi[	I"*projects//homebrew_proj/cmd/search.rb;TiI"y        var = case var
        when nil then
          "STRING"
        when "LITERAL" then
          Regexp.new($1);Fi[	@Èi#I"ó        safe_system(@@git, "STRING", "STRING", case @spec
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@Ói/I"t    case Hardware.processor_count
    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING";Fi[	@Ói1I"a      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING";Fi[	@ıiI"i    case MacOS.version
    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING";Fi[	@ıiQI"á    $1) rescue case MacOS.llvm_build_version.to_i
      when "LITERAL" then
        "STRING"
      when "LITERAL" then
        "STRING";Fi[	@ıiSI"k        "STRING"
      when "LITERAL" then
        "STRING"
      when "LITERAL" then
        "STRING";Fi[	@ıiUI"k        "STRING"
      when "LITERAL" then
        "STRING"
      when "LITERAL" then
        "STRING";Fi[	@ıiWI"k        "STRING"
      when "LITERAL" then
        "STRING"
      when "LITERAL" then
        "STRING";Fi[	@ıiYI"k        "STRING"
      when "LITERAL" then
        "STRING"
      when "LITERAL" then
        "STRING";Fi[	@ıi_I"ñ        case (MacOS.clang_version.to_f * "LITERAL").to_i
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@ıiaI"u          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@ıicI"u          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@ıieI"u          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@ıigI"u          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@ıiiI"u          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@ıikI"u          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@ıimI"u          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@ıioI"u          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@iI"}        case MacOS.version
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@iI"u          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@ i0I"e    case @language
    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING";Fi[	@ i2I"a      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING";Fi[	@ i4I"a      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING";Fi[	@ i6I"a      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING";Fi[	@ i8I"a      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING";Fi[	@ i:I"a      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING";Fi[	@ i<I"a      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING";Fi[	@ i>I"a      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING";Fi[	@3i[I"r    assert_equal(case MacOS.cat
    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING";Fi[	@3i]I"a      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING";Fi[	@3iÚI"r    assert_equal(case MacOS.cat
    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING";Fi[	@3iÙI"a      "STRING"
    when "LITERAL" then
      "STRING"
    when "LITERAL" then
      "STRING";Fi[	I"'projects//homebrew_proj/version.rb;TiI"j      "STRING"
    when "STRING", "STRING" then
      "STRING"
    when "LITERAL" then
      var.to_i;Fi[	@@ixI"{      case var.length
      when "LITERAL" then
        "STRING"
      when "LITERAL" then
        var["LITERAL"].to_s;Fi[	@
i{I"      case self.site.permalink_style
      when "LITERAL" then
        "STRING"
      when "LITERAL" then
        "STRING";Fi[	@
i}I"k        "STRING"
      when "LITERAL" then
        "STRING"
      when "LITERAL" then
        "STRING";Fi[	@KiI"        case var.value.first
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@KiI"u          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@KiI"Ã          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          if var.value["LITERAL"].is_a?(Nokogiri::CSS::Node) and (var.value["LITERAL"].type == "LITERAL") then;Fi[	@Ki I"p          end
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@Ki"I"u          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@Ki$I"u          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@Ki&I"u          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@Ki(I"u          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@Ki*I"â          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          var.value["LITERAL"].accept(self);Fi[	@KiNI"Ö          ((var + "STRING") + "STRING")
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@KiPI"u          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@KiRI"u          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@KiTI"}          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          ("STRING" + "STRING");Fi[	@fiI"s        case var
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@fiI"u          "STRING"
        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          "STRING";Fi[	@6iGI"~        var = case @time
        when *KEYWORDS then
          "STRING"
        when "LITERAL" then
          "LITERAL".months;Fi[	I"def function(var);F@HiX[X[	@9iI"U    #     end
    #   end
    def function(var)
      @var = var
      @var = {};Fi[	I"Jprojects//activerecord_proj/active_record/associations/association.rb;Ti>I"¢      
      # Sets the target of this association to <tt>\target</tt>, and the \loaded flag to +true+.
      def function(var)
        @var = var
        loaded!;Fi[	I"Pprojects//activerecord_proj/active_record/associations/association_scope.rb;TiI"¡      delegate("LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL" => "LITERAL")
      
      def function(var)
        @var = var
        @var = AliasTracker.new(klass.connection);Fi[	@AiI"´        delegate("LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL" => "LITERAL")
        
        def function(var)
          @var = var
          @var = {};Fi[	I"Qprojects//activerecord_proj/active_record/attribute_methods/serialization.rb;Ti8I"W      
      class Type
        def function(var)
          @var = var
        end;Fi[	I"Xprojects//activerecord_proj/active_record/attribute_methods/time_zone_conversion.rb;Ti	I"n    module TimeZoneConversion
      class Type
        def function(var)
          @var = var
        end;Fi[	@giI"~    class ConnectionPool
      class Queue
        def function(var)
          @var = var
          @var = @lock.new_cond;Fi[	@gi‡I"]    
    class ConnectionManagement
      def function(var)
        @var = var
      end;Fi[	I"Zprojects//activerecord_proj/active_record/connection_adapters/abstract/transaction.rb;Ti
I"]      attr_reader("LITERAL")
      
      def function(var)
        @var = var
      end;Fi[	@siEI"q          attr_reader("LITERAL")
          
          def function(var)
            @var = var
          end;Fi[	I"Rprojects//activerecord_proj/active_record/connection_adapters/schema_cache.rb;TiI"g      attr_accessor("LITERAL")
      
      def function(var)
        @var = var
        @var = {};Fi[	@yibI"S    attr_reader("LITERAL")
    
    def function(var)
      @var = var
    end;Fi[	I"=projects//activerecord_proj/active_record/query_cache.rb;TiI"@    end
    
    def function(var)
      @var = var
    end;Fi[	@JiI"S    
    class WhereChain
      def function(var)
        @var = var
      end;Fi[	I"?projects//activerecord_proj/active_record/schema_dumper.rb;TiI"k    private
    
    def function(var)
      @var = var
      @var = @connection.native_database_types;Fi[	@`iI"É      delegate("LITERAL", "LITERAL", "LITERAL" => (ActiveRecord::Base))
      
      def function(var)
        @var = var
      end;Fi[	I"Qprojects//activerecord_proj/active_record/tasks/postgresql_database_tasks.rb;TiI"é      delegate("LITERAL", "LITERAL", "LITERAL", "LITERAL" => (ActiveRecord::Base))
      
      def function(var)
        @var = var
      end;Fi[	@qiI"É      
      # Unfortunately, we have to tie Uniqueness validators to a class.
      def function(var)
        @var = var
      end;Fi[	I"=projects//activerecord_proj/active_record/validations.rb;Ti
I"v    
    # :nodoc:
    def function(var)
      @var = var
      var = @record.errors.full_messages.join("STRING");Fi[	I",projects//backup_proj/backup/archive.rb;Ti8I"Ü    # Adds the given String of +options+ to the `tar` command.
    # e.g. '-h --xattrs'
    def function(var)
      @var = var
    end;Fi[	I"2projects//backup_proj/backup/database/base.rb;TiI"µ      # Creates a new instance of the MongoDB database object
      # * Called using super(model) from subclasses *
      def function(var)
        @var = var
        load_defaults!;Fi[	I"2projects//backup_proj/backup/notifier/base.rb;Ti!I"{      ##
      # Called with super(model) from subclasses
      def function(var)
        @var = var
        load_defaults!;Fi[	I"=projects//devise_proj/devise/controllers/rememberable.rb;TiI"Ç        delegate("LITERAL", "LITERAL", "LITERAL" => "LITERAL")
        
        def function(var)
          @var = var
        end;Fi[	I"=projects//devise_proj/devise/controllers/scoped_views.rb;TiI"T        end
        
        def function(var)
          @var = var
        end;Fi[	@ªiI"ƒ      
      # Generates password encryption based on the given value.
      def function(var)
        @var = var
        self.encrypted_password = password_digest(@password) if @password.present?;Fi[	@°iI"t  module Models
    class MissingAttribute < StandardError
      def function(var)
        @var = var
      end;Fi[	@µiI"{  module OmniAuth
    class StrategyNotFound < NameError
      def function(var)
        @var = var
        super("STRING");Fi[	I"$projects//devise_proj/devise.rb;Ti˛I"E  
  class Getter
    def function(var)
      @var = var
    end;Fi[	I"8projects//diaspora_proj/models/signed_retraction.rb;TiBI"J  end
  
  def function(var)
    @var = var
    @var = var.class.to_s;Fi[	I";projects//diaspora_proj/presenters/aspect_presenter.rb;TiI"Sclass AspectPresenter < BasePresenter
  def function(var)
    @var = var
  end;Fi[	I"<projects//diaspora_proj/presenters/comment_presenter.rb;TiI"Tclass CommentPresenter < BasePresenter
  def function(var)
    @var = var
  end;Fi[	I"Hprojects//diaspora_proj/presenters/last_three_comments_decorator.rb;TiI"Nclass LastThreeCommentsDecorator
  def function(var)
    @var = var
  end;Fi[	I"<projects//diaspora_proj/presenters/service_presenter.rb;TiI"Tclass ServicePresenter < BasePresenter
  def function(var)
    @var = var
  end;Fi[	@ÏiI"d    attr_accessor("LITERAL")
    
    def function(var)
      @var = var
      @var = "LITERAL";Fi[	I"%projects//haml_proj/haml/exec.rb;TiI"†    class Generic
      # @param args [Array<String>] The command-line arguments
      def function(var)
        @var = var
        @var = { "LITERAL" => ({}) };Fi[	I"%projects//haml_proj/haml/util.rb;Ti∞I"Æ    class StaticConditionalContext
      # @param set [#include?] The set of variables that are defined for this context.
      def function(var)
        @var = var
      end;Fi[	I"'projects//homebrew_proj/caveats.rb;TiI"I  attr_reader("LITERAL")
  
  def function(var)
    @var = var
  end;Fi[	I")projects//homebrew_proj/cmd/audit.rb;TiJI"∂  BUILD_TIME_DEPS = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"]
  
  def function(var)
    @var = var
    @var = [];Fi[	I"*projects//homebrew_proj/cmd/create.rb;TiEI"^  attr("LITERAL", true)
  
  def function(var)
    @var = var
    var = Pathname.new(var);Fi[	I")projects//homebrew_proj/compilers.rb;Ti2I"b  attr_reader("LITERAL", "LITERAL")
  
  def function(var)
    @var = var
    @var = case var;Fi[	@iWI"è  NAMES = { "LITERAL" => "STRING", "LITERAL" => "STRING", "LITERAL" => "STRING" }
  
  def function(var)
    @var = var
    @var = ENV.compiler;Fi[	@˛iI"P  attr("LITERAL")
  
  def function(var)
    @var = var
    super("STRING");Fi[	@˛iI"P  attr("LITERAL")
  
  def function(var)
    @var = var
    super("STRING");Fi[	@˛i*I"6  end
  
  def function(var)
    @var = var
  end;Fi[	@ imI"I  env("LITERAL")
  
  def function(var)
    @var = var
    @var = [];Fi[	@ziñI"Mend
class VersionSchemeDetector
  def function(var)
    @var = var
  end;Fi[	I".projects//jekyll_proj/jekyll/converter.rb;TiI"a    #
    # Returns an initialized Converter.
    def function(var)
      @var = var
    end;Fi[	I"6projects//nokogiri_proj/nokogiri/css/tokenizer.rb;Ti$I"å      alias "LITERAL" "LITERAL"
      
      def function(var)
        @var = var
        open(var, "STRING") { |var| scan_setup(var.read) };Fi[	@’inI"}        attr_reader("LITERAL")
        
        def function(var)
          @var = var
          super(("STRING" % var));Fi[	@’iÅI"~        
        class JumpSAXHandler < SAXHandler
          def function(var)
            @var = var
            super();Fi[	@’i±I"]        end
        
        def function(var)
          @var = var
          @var = nil;Fi[	I">projects//nokogiri_proj/nokogiri/xml/node/save_options.rb;Ti4I"ß        # Integer representation of the SaveOptions
        # Create a new SaveOptions object with +options+
        def function(var)
          @var = var
        end;Fi[	I":projects//nokogiri_proj/nokogiri/xml/parse_options.rb;TiOI"´      # the default options used for parsing XML documents
      # the default options used for parsing HTML documents
      def function(var)
        @var = var
      end;Fi[	I"5projects//omni_proj/omniauth/failure_endpoint.rb;TiI"@    end
    
    def function(var)
      @var = var
    end;Fi[	I"7projects//omni_proj/omniauth/test/phony_session.rb;TiI"Pclass OmniAuth::Test::PhonySession
  def function(var)
    @var = var
  end;Fi[	I"@projects//paperclip_proj/paperclip/content_type_detector.rb;TiI"X    SENSIBLE_DEFAULT = "STRING"
    
    def function(var)
      @var = var
    end;Fi[	I"Mprojects//paperclip_proj/paperclip/file_command_content_type_detector.rb;Ti	I"X    SENSIBLE_DEFAULT = "STRING"
    
    def function(var)
      @var = var
    end;Fi[	I"Dprojects//paperclip_proj/paperclip/geometry_detector_factory.rb;TiI"omodule Paperclip
  class GeometryDetector
    def function(var)
      @var = var
      raise_if_blank_file;Fi[	I"Bprojects//paperclip_proj/paperclip/geometry_parser_factory.rb;Ti	I"O    FORMAT = "LITERAL"
    
    def function(var)
      @var = var
    end;Fi[	I"Cprojects//paperclip_proj/paperclip/io_adapters/file_adapter.rb;TiI"}module Paperclip
  class FileAdapter < AbstractAdapter
    def function(var)
      @var = var
      cache_current_values;Fi[	I"Gprojects//paperclip_proj/paperclip/io_adapters/stringio_adapter.rb;TiI"|module Paperclip
  class StringioAdapter < AbstractAdapter
    def function(var)
      @var = var
      cache_current_values;Fi[	I"Lprojects//paperclip_proj/paperclip/io_adapters/uploaded_file_adapter.rb;TiI"Ämodule Paperclip
  class UploadedFileAdapter < AbstractAdapter
    def function(var)
      @var = var
      cache_current_values;Fi[	I"Bprojects//paperclip_proj/paperclip/io_adapters/uri_adapter.rb;TiI"module Paperclip
  class UriAdapter < AbstractAdapter
    def function(var)
      @var = var
      @var = download_content;Fi[	I"1projects//paperclip_proj/paperclip/logger.rb;TiI"@    end
    
    def function(var)
      @var = var
    end;Fi[	@CiI"j      
      class HaveAttachedFileMatcher
        def function(var)
          @var = var
        end;Fi[	@CiI"~        end
        
        def function(var)
          @var = var
          @var = @subject.class unless Class.===(@subject);Fi[	@JiI"      
      class ValidateAttachmentContentTypeMatcher
        def function(var)
          @var = var
          @var = [];Fi[	@Ji&I"~        end
        
        def function(var)
          @var = var
          @var = @subject.new if (@subject.class == Class);Fi[	@OiI"t      
      class ValidateAttachmentPresenceMatcher
        def function(var)
          @var = var
        end;Fi[	@OiI"y        end
        
        def function(var)
          @var = var
          @var = var.new if (var.class == Class);Fi[	@ViI"p      
      class ValidateAttachmentSizeMatcher
        def function(var)
          @var = var
        end;Fi[	@ViI"W        end
        
        def function(var)
          @var = var
          self;Fi[	@Vi I"W        end
        
        def function(var)
          @var = var
          self;Fi[	@Vi*I"~        end
        
        def function(var)
          @var = var
          @var = @subject.new if (@subject.class == Class);Fi[	I";projects//paperclip_proj/paperclip/tempfile_factory.rb;Ti	I"á    ILLEGAL_FILENAME_CHARACTERS = "LITERAL"
    
    def function(var)
      @var = var
      var = Tempfile.new([basename, extension]);Fi[	I"5projects//sinatra_proj/sinatra/showexceptions.rb;TiI"W    end
    
    def function(var)
      @var = var
      @var = ERB.new(TEMPLATE);Fi[	I"Bprojects//state_machine_proj/state_machine/node_collection.rb;Ti8I"Ô    # Changes the current machine associated with the collection.  In turn, this
    # will change the state machine associated with each node in the collection.
    def function(var)
      @var = var
      each { |var| var.machine = var };Fi[	@0iI"ø    # The state that must be present in an object for this context to be active
    # Creates a new context for the given state
    def function(var)
      @var = var
      @var = var.machine;Fi[	I"+projects//twitter_proj/twitter/base.rb;Ti:I"k    # @param attrs [Hash]
    # @return [Twitter::Base]
    def function(var)
      @var = var
    end;Fi[	I"1projects//twitter_proj/twitter/rate_limit.rb;TiI"[    
    # @return [Twitter::RateLimit]
    def function(var)
      @var = var
    end;Fi[	@uiI"_    end
    
    def function(var)
      @var = var
      @options["LITERAL"] ||= "STRING";Fi[	I",projects//whenever_proj/whenever/job.rb;Ti
I"y    attr_reader("LITERAL", "LITERAL")
    
    def function(var)
      @var = var
      @var = var.delete("LITERAL");Fi[	@|iI"_  module Output
    class Redirection
      def function(var)
        @var = var
      end;Fi[	@;I"	else;FiR[R[	@Ki,I"b          "STRING"
        when Class then
          "STRING"
        else
          "STRING";Fi[	I"\projects//activerecord_proj/active_record/connection_adapters/abstract/schema_dumper.rb;TiI"∏        var["LITERAL"] = var.name.inspect
        var["LITERAL"] = if (var.type == "LITERAL") and "LITERAL" =~ var.sql_type then
          "STRING"
        else
          var.type.to_s;Fi[	@Åi1I"t          var.to_s
        when Date, DateTime, Time then
          "STRING"
        else
          var.inspect;Fi[	I"`projects//activerecord_proj/active_record/connection_adapters/abstract/schema_statements.rb;TiºI"≥        if Hash.===(var) then
          if var["LITERAL"] then
            "STRING"
          else
            var["LITERAL"] ? (var["LITERAL"]) : (raise(ArgumentError, "STRING"));Fi[	@Ui¿I"!        if var.kind_of?(String) and (var and ((var.type == "LITERAL") and var.class.respond_to?("LITERAL"))) then
          var = var.class.string_to_binary(var).unpack("STRING")["LITERAL"]
          "STRING"
        else
          var.kind_of?(BigDecimal) ? (var.to_s("STRING")) : (super);Fi[	@Ui÷I"Ö            "STRING"
          when "LITERAL" then
            "STRING"
          else
            raise(ActiveRecordError, "STRING");Fi[	@UiÂI"Ö            "STRING"
          when "LITERAL" then
            "STRING"
          else
            raise(ActiveRecordError, "STRING");Fi[	@UiÚI"Ö            "STRING"
          when "LITERAL" then
            "STRING"
          else
            raise(ActiveRecordError, "STRING");Fi[	@Ui™I"¶        var = var.map do |var, var|
          if ((var == "STRING") or (var == "LITERAL")) then
            "STRING"
          else
            "STRING" if var.nil?.!;Fi[	I"Uprojects//activerecord_proj/active_record/connection_adapters/postgresql/cast.rb;Ti7I"∑            if String.===(var) then
              if (var == "STRING") then
                "STRING"
              else
                quote_and_escape(var.type_cast(var, var, true));Fi[	@ìirI"ˆ            if Range.===(var) then
              if [var.first, var.last].all? { |var| Integer.===(var) } then
                "STRING"
              else
                [var.first, var.last].all? { |var| NilClass.===(var) } ? ("STRING") : (nil);Fi[	@ìiI"~        def function(var)
          if var.nil? then
            "STRING"
          else
            if (var == "STRING") then;Fi[	@ìiÇI"ö          else
            if (var == "STRING") then
              "STRING"
            else
              ("STRING" % var.to_s.gsub("LITERAL", "STRING"));Fi[	@ñi4I"¿          when Float then
            if var.infinite? and (var.type == "LITERAL") then
              "STRING"
            else
              (var.infinite? or var.nan?) ? ("STRING") : (super);Fi[	@ñiFI"É                "STRING"
              when "LITERAL" then
                "STRING"
              else
                # do nothing;Fi[	@ñiÅI"ò          if var then
            var, var = extract_pg_identifier_from_name(var)
            "STRING"
          else
            quote_column_name(var);Fi[	@õi)I"z              "STRING"
            when "LITERAL" then
              "STRING"
            else
              "STRING";Fi[	@õi2I"è              "STRING"
            when "LITERAL" then
              "STRING"
            else
              raise(ActiveRecordError, "STRING");Fi[	@õi:I"ç            case var
            when "LITERAL" then
              "STRING"
            else
              raise(ActiveRecordError, "STRING");Fi[	@õiDI"è              "STRING"
            when "LITERAL" then
              "STRING"
            else
              raise(ActiveRecordError, "STRING");Fi[	@Xi√I"Ì        if var.kind_of?(String) and (var and ((var.type == "LITERAL") and var.class.respond_to?("LITERAL"))) then
          var = var.class.string_to_binary(var).unpack("STRING")["LITERAL"]
          "STRING"
        else
          super;Fi[	@i6I"y        else
          if abstract_class? then
            "STRING"
          else
            if table_exists? then;Fi[	@i:I"†            if table_exists? then
              var = (columns.map { |var| "STRING" } * "STRING")
              "STRING"
            else
              "STRING";Fi[	@#i7I"Ö      when var = self["LITERAL"] then
        var = var.utc.to_s(cache_timestamp_format)
        "STRING"
      else
        "STRING";Fi[	@&i9I"n            var = (var + "STRING")
          end
          "STRING"
        else
          var.table_name;Fi[	@8i«I"ó      def function
        if (options["LITERAL"] == true) then
          "STRING"
        else
          options["LITERAL"].to_s if options["LITERAL"];Fi[	@8iUI"õ      def function
        if belongs_to? then
          "STRING"
        else
          options["LITERAL"] ? ("STRING") : (active_record.name.foreign_key);Fi[	I"Gprojects//activerecord_proj/active_record/relation/calculations.rb;TiêI"ê      var.map! do |var|
        if var.is_a?(Symbol) and self.column_names.include?(var.to_s) then
          "STRING"
        else
          var;Fi[	@zi‰I"y        end
        if var and File.exist?(var) then
          "STRING"
        else
          Logger.warn("STRING");Fi[	@≤i6I"j          "STRING"
        when "LITERAL" then
          "STRING"
        else
          # do nothing;Fi[	@πi4I"j          "STRING"
        when "LITERAL" then
          "STRING"
        else
          # do nothing;Fi[	@¿i>I"j          "STRING"
        when "LITERAL" then
          "STRING"
        else
          # do nothing;Fi[	@«i2I"j          "STRING"
        when "LITERAL" then
          "STRING"
        else
          # do nothing;Fi[	I"=projects//compass_proj/compass/configuration/comments.rb;TiI"ñ      def function
        if (top_level.preferred_syntax == "LITERAL") and top_level.sass_dir then
          "STRING"
        else
          "STRING";Fi[	I"@projects//compass_proj/compass/configuration/inheritance.rb;Ti<I"â          def function(var)
            if var = @data.raw(var) then
              "STRING"
            else
              var = "STRING";Fi[	I"Jprojects//compass_proj/compass/sass_extensions/functions/constants.rb;Ti!I"á            "STRING"
          when "STRING" then
            "STRING"
          else
            (Compass::Util.compass_warn("STRING");Fi[	@ÀiMI"`          "STRING"
        when "STRING" then
          "STRING"
        else
          var;Fi[	@Œi:I"i      "STRING"
    when "LITERAL" then
      "STRING"
    else
      raise(Compass::Error, "STRING");Fi[	I"=projects//diaspora_proj/controllers/photos_controller.rb;TiÅI"î      var = var["LITERAL"]
      var = if (request.content_type.to_s == "STRING") then
        "STRING"
      else
        request.content_type.to_s;Fi[	I">projects//diaspora_proj/models/acts_as_taggable_on/tag.rb;TiI"ö  def self.normalize(var)
    if var =~ "LITERAL" then
      "STRING"
    else
      var.gsub(/[^#{self.tag_text_regexp}STRING/, "STRING").downcase if var;Fi[	@Ïi®I"è            (block_given?.! or (var["LITERAL"] or var["LITERAL"]))
          end) then
            "STRING"
          else
            "STRING";Fi[	@ÏiÎI"h      end
      if @options.html5? then
        "STRING"
      else
        if @options.xhtml? then;Fi[	@ÏiÔI"≥        if @options.xhtml? then
          if (@node.value["LITERAL"] == "STRING") then
            "STRING"
          else
            if (@node.value["LITERAL"] == "STRING") then;Fi[	@ÏiÚI"ô          else
            if (@node.value["LITERAL"] == "STRING") then
              "STRING"
            else
              case @node.value["LITERAL"];Fi[	@Ïi˛I"~                "STRING"
              when "STRING" then
                "STRING"
              else
                "STRING";Fi[	@Ïi
I"y              "STRING"
            when "STRING" then
              "STRING"
            else
              "STRING";Fi[	@Ôi≤I"ü    def function(var, var, var)
      var = if var.empty? then
        "STRING"
      else
        ("STRING" << var.map { |var, var| "STRING" }.join("STRING"));Fi[	I"'projects//homebrew_proj/cmd/tap.rb;TicI"`      "STRING"
    when /^#{HOMEBREW_LIBRARY}STRING/ then
      "STRING"
    else
      nil;Fi[	@ÊiêI"t        File.basename(var, "STRING")
      when "LITERAL" then
        "STRING"
      else
        # do nothing;Fi[	@Èi%I"f          "STRING"
        when "LITERAL" then
          "STRING"
        else
          "STRING";Fi[	@Ói3I"b      "STRING"
    when "LITERAL" then
      "STRING"
    else
      Hardware.processor_count;Fi[	@ıi!I"Ç      "STRING"
    when "LITERAL" then
      "STRING"
    else
      (MacOS.version >= "LITERAL") ? ("STRING") : (raise("STRING"));Fi[	@ıi[I"        "STRING"
      when "LITERAL" then
        "STRING"
      else
        case (MacOS.clang_version.to_f * "LITERAL").to_i;Fi[	@ıiqI"f          "STRING"
        when "LITERAL" then
          "STRING"
        else
          "STRING";Fi[	@iI"g          "STRING"
        when "LITERAL" then
          "STRING"
        else
          "LITERAL";Fi[	@ i@I"V      "STRING"
    when "LITERAL" then
      "STRING"
    else
      # do nothing;Fi[	@3i_I"V      "STRING"
    when "LITERAL" then
      "STRING"
    else
      # do nothing;Fi[	@3iˆI"V      "STRING"
    when "LITERAL" then
      "STRING"
    else
      # do nothing;Fi[	I"?projects//homebrew_proj/vendor/multi_json/vendor/okjson.rb;TisI"é        "STRING"
      when nil then
        "STRING"
      else
        var.respond_to?("LITERAL") ? (var.to_json) : (raise(Error, "STRING"));Fi[	@@i|I"g        var["LITERAL"].to_s
      when "LITERAL" then
        "STRING"
      else
        "STRING";Fi[	I"1projects//jekyll_proj/jekyll/migrators/mt.rb;Ti&I"é    def self.suffix(var)
      if (var.nil? or var.include?("STRING")) then
        "STRING"
      else
        if var.include?("STRING") then;Fi[	@	i)I"û      else
        if var.include?("STRING") then
          "STRING"
        else
          ((var == "STRING") or var.include?("STRING")) ? ("STRING") : (var);Fi[	@iBI"ç    def function
      if (self.site.permalink_style == "LITERAL") and (index?.! and html?) then
        "STRING"
      else
        "STRING";Fi[	@
iI"r        "STRING"
      when "LITERAL" then
        "STRING"
      else
        self.site.permalink_style.to_s;Fi[	@Ki?I"≤      def function(var)
        var = if ((var.value.first.type == "LITERAL") or var.value.first.value.first =~ "LITERAL") then
          "STRING"
        else
          "STRING";Fi[	@KirI"~            "STRING"
          when "STRING" then
            "STRING"
          else
            (var.value.first + "STRING");Fi[	I"6projects//paperclip_proj/paperclip/storage/fog.rb;TiVI"ñ      def function(var)
        if @options["LITERAL"] then
          "STRING"
        else
          if (fog_credentials["LITERAL"] == "STRING") then;Fi[	@	iYI"∞        else
          if (fog_credentials["LITERAL"] == "STRING") then
            "STRING"
          else
            directory.files.new("LITERAL" => (path(var))).public_url;Fi[	@	iäI"ù      def function
        if @options["LITERAL"].to_s.=~(Fog::AWS_BUCKET_SUBDOMAIN_RESTRICTON_REGEX) then
          "STRING"
        else
          "STRING";Fi[	@i+I"ô      if var["LITERAL"] and timestamp_possible? then
        var = var.match("LITERAL") ? ("STRING") : ("STRING")
        "STRING"
      else
        var;Fi[	@gi0I"∫    def function(var)
      if var.filename =~ "LITERAL" then
        "STRING"
      else
        if ((defined? Gem and var.filename.include?(Gem.dir)) or var.filename =~ "LITERAL") then;Fi[	@gi3I"û      else
        if ((defined? Gem and var.filename.include?(Gem.dir)) or var.filename =~ "LITERAL") then
          "STRING"
        else
          "STRING";Fi[	I"Kprojects//state_machine_proj/state_machine/integrations/data_mapper.rb;Ti"I"q      def function(var)
        if var.errors.empty? then
          "STRING"
        else
          var = [];Fi[	I"9projects//twitter_proj/twitter/error/client_error.rb;TiI"~      def self.parse_error(var)
        if var.nil? then
          "STRING"
        else
          if var["LITERAL"] then;Fi[	@fiI"f          "STRING"
        when "LITERAL" then
          "STRING"
        else
          "STRING";Fi[	@|iI"o          redirect_from_hash
        when NilClass then
          "STRING"
        else
          "STRING";Fi[	@|i5I"c          "STRING"
        when stdout then
          "STRING"
        else
          "STRING";Fi[	I"# @rate_limited Yes;F@miO[O[	@qiI"ù      # @see https://dev.twitter.com/docs/api/1.1/get/direct_messages
      # @note This method requires an access token with RWD (read, write & direct message) permissions. Consult The Application Permission Model for more information.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@qi%I"¢      # @see https://dev.twitter.com/docs/api/1.1/get/direct_messages/sent
      # @note This method requires an access token with RWD (read, write & direct message) permissions. Consult The Application Permission Model for more information.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@qi8I"¢      # @see https://dev.twitter.com/docs/api/1.1/get/direct_messages/show
      # @note This method requires an access token with RWD (read, write & direct message) permissions. Consult The Application Permission Model for more information.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@qiFI"^      
      # @note This method requires an access token with RWD (read, write & direct message) permissions. Consult The Application Permission Model for more information.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@~iI"¸      
      # @see https://dev.twitter.com/docs/api/1.1/get/favorites/list
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@ÖiI"˘      
      # @see https://dev.twitter.com/docs/api/1.1/get/friends/ids
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@Öi*I"˚      
      # @see https://dev.twitter.com/docs/api/1.1/get/followers/ids
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@ÖiEI"      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/lookup
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@Öi[I"      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/incoming
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@ÖijI"      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/outgoing
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@Öi–I"ˇ      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@ÖiÍI"ˇ      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@Öi¸I"˝      #
      # @see https://dev.twitter.com/docs/api/1.1/get/followers/list
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@ÖiI"ˇ      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@Öi<I"      # =>
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/no_retweets/ids
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@¢iI"      #
      # @see https://dev.twitter.com/docs/api/1.1/get/help/configuration
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@¢iI"˝      #
      # @see https://dev.twitter.com/docs/api/1.1/get/help/languages
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@¢i*I"˚      #
      # @see https://dev.twitter.com/docs/api/1.1/get/help/privacy
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@¢i7I"˜      #
      # @see https://dev.twitter.com/docs/api/1.1/get/help/tos
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@´iI"˘      #
      # @see https://dev.twitter.com/docs/api/1.1/get/lists/list
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@´i/I"˝      #
      # @see https://dev.twitter.com/docs/api/1.1/get/lists/statuses
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@´iqI"       #
      # @see https://dev.twitter.com/docs/api/1.1/get/lists/memberships
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@´iÖI"       #
      # @see https://dev.twitter.com/docs/api/1.1/get/lists/subscribers
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@´iπI"      #
      # @see https://dev.twitter.com/docs/api/1.1/get/lists/subscribers/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@´i,I"¸      #
      # @see https://dev.twitter.com/docs/api/1.1/get/lists/members
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@´i±I"S      # @see https://dev.twitter.com/docs/api/1.1/get/lists/show
      # @note Private lists will only be shown if the authenticated user owns the specified list.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@´iÀI"      #
      # @see https://dev.twitter.com/docs/api/1.1/get/lists/subscriptions
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@ŒiI"ˇ      #
      # @see https://dev.twitter.com/docs/api/1.1/get/geo/id/:place_id
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@ŒiI"b      # @see https://dev.twitter.com/docs/api/1.1/get/geo/reverse_geocode
      # @note This request is an informative call and will deliver generalized results about geography.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@Œi2I"˘      #
      # @see https://dev.twitter.com/docs/api/1.1/get/geo/search
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@ŒiLI")      # @see https://dev.twitter.com/docs/api/1.1/get/geo/similar_places
      # @note Conceptually, you would use this method to get a list of known places to choose from first. Then, if the desired place doesn't exist, make a request to {Twitter::API::PlacesAndGeo#place} to create a new one. The token contained in the response is the token necessary to create a new place.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@ŒiaI"˘      #
      # @see https://dev.twitter.com/docs/api/1.1/post/geo/place
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@ŸiI"⁄      include(Twitter::API::Utils)
      
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@Ÿi1I"      #
      # @see https://dev.twitter.com/docs/api/1.1/get/saved_searches/show/:id
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@‚iI"ø      # @see https://dev.twitter.com/docs/using-search
      # @note Please note that Twitter's search service and, by extension, the Search API is not meant to be an exhaustive source of Tweets. Not all Tweets will be indexed or made available via the search interface.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@ÂiI"      #
      # @see https://dev.twitter.com/docs/api/1.1/post/users/report_spam
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@ËiI"‰      
      # @return [Array<Twitter::Suggestion>]
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@Ëi-I"Ë      #
      # @see https://dev.twitter.com/docs/api/1.1/get/users/suggestions/:slug/members
      # @rate_limited Yes
      # @authentication Requires user context
      # @param slug [String] The short name of list or a category.;Fi[	@ÎiI"=      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/mentions_timeline
      # @note This method can only return up to 800 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@Îi*I";      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@ÎiBI";      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@ÎiZI";      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@ÎioI"M      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/home_timeline
      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@ÎiÅI"M      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/home_timeline
      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@ÎiñI"      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/retweets_of_me
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@˙iI"˚      #
      # @see https://dev.twitter.com/docs/api/1.1/get/trends/place
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@˙i&I"ˇ      #
      # @see https://dev.twitter.com/docs/api/1.1/get/trends/available
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@˙i6I"˝      #
      # @see https://dev.twitter.com/docs/api/1.1/get/trends/closest
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@iI"      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/retweets/:id
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@i$I"      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/retweets/:id
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@i8I"       #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/show/:id
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@iHI"       #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/show/:id
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@iÇI"      #
      # @see https://dev.twitter.com/docs/api/1.1/post/statuses/retweet/:id
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@iúI"      #
      # @see https://dev.twitter.com/docs/api/1.1/post/statuses/retweet/:id
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::AlreadyRetweeted] Error raised when tweet has already been retweeted.;Fi[	@iŒI"˛      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/oembed
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@i‰I"˛      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/oembed
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@iI"”      #
      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@i#I"‘      #
      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid./;Fi[	@i1I"“      
      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@iOI"”      #
      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@ibI"”      #
      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@iI"?      # @see https://dev.twitter.com/docs/api/1.1/post/account/settings
      # @see https://dev.twitter.com/docs/api/1.1/get/account/settings
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@i-I"	      #
      # @see https://dev.twitter.com/docs/api/1.1/get/account/verify_credentials
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@ièI"˙      #
      # @see https://dev.twitter.com/docs/api/1.1/get/blocks/list
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@iûI"˘      #
      # @see https://dev.twitter.com/docs/api/1.1/get/blocks/ids
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@iØI"˘      #
      # @see https://dev.twitter.com/docs/api/1.1/get/blocks/ids
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@iÀI";      # @see https://dev.twitter.com/docs/api/1.1/post/blocks/create
      # @note Destroys a friendship to the blocked user if it exists.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@iÒI"˚      #
      # @see https://dev.twitter.com/docs/api/1.1/get/users/lookup
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@iI"¯      
      # @see https://dev.twitter.com/docs/api/1.1/get/users/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@i*I"Í      # Returns true if the specified user exists
      #
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@i?I"˚      #
      # @see https://dev.twitter.com/docs/api/1.1/get/users/search
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@iPI"      #
      # @see https://dev.twitter.com/docs/api/1.1/get/users/contributees
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@igI"      #
      # @see https://dev.twitter.com/docs/api/1.1/get/users/contributors
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@i§I"[      # @see https://dev.twitter.com/docs/api/1.1/get/users/profile_banner
      # @note If the user has not uploaded a profile banner, a HTTP 404 will be served instead.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@:I"
begin;FiK[K[	@®ixI"
      # ActiveRecord::RecordNotFound is rescued within the method, and it is
      # not reraised. The proxy is \reset and +nil+ is the return value.
      def function
        begin
          (@var = find_target if ((@stale_state and stale_target?) or find_target?);Fi[	@gi»I"∂      # exists checkout a connection, yield it to the block, and checkin the
      # connection when finished.
      def function
        begin
          (var = current_connection_id;Fi[	@UiˇI"R      end
      
      def function
        begin
          execute("STRING");Fi[	@UiI"W      
      #:nodoc:
      def function
        begin
          execute("STRING");Fi[	@UiI"W      
      #:nodoc:
      def function
        begin
          execute("STRING");Fi[	I"Sprojects//activerecord_proj/active_record/connection_adapters/mysql_adapter.rb;Ti†I"†      
      # CONNECTION MANAGEMENT ====================================
      def function
        begin
          (if @connection.respond_to?("LITERAL") then;Fi[	@Ã	iéI"Z      
      #:nodoc:
      def function
        begin
          exec_query("STRING");Fi[	I"fprojects//activerecord_proj/active_record/connection_adapters/postgresql/referential_integrity.rb;TiI"{        
        #:nodoc:
        def function
          begin
            (if supports_disable_referential_integrity? then;Fi[	I"9projects//activerecord_proj/active_record/explain.rb;Ti-I"ê    # whether auto explain is enabled. This method serves that purpose.
    # :nodoc:
    def function
      begin
        (var = Thread.current;Fi[	@‘	iQI"œ    # As the name of the method suggests this only applies to automatic
    # EXPLAINs, manual calls to <tt>ActiveRecord::Relation#explain</tt> run.
    def function
      begin
        (var = Thread.current;Fi[	I"Lprojects//activerecord_proj/active_record/migration/command_recorder.rb;TiI"—      #   recorder.revert{ recorder.record(:rename_table, [:old, :new]) }
      #   # same effect as recorder.record(:rename_table, [:new, :old])
      def function
        begin
          (@var = @reverting.!;Fi[	I"Iprojects//activerecord_proj/active_record/relation/finder_methods.rb;TiØI"r    protected
    
    def function
      begin
        (var = construct_join_dependency_for_association_find;Fi[	@QiÿI"Â    # Please check unscoped if you want to remove all previous scopes (including
    # the default_scope) during the execution of a block.
    def function
      begin
        (var, klass.current_scope = klass.current_scope, self;Ti[	@`iI"v      end
      
      def function
        begin
          (establish_connection(configuration_without_database);Fi[	I">projects//activerecord_proj/active_record/transactions.rb;TiXI"ä    
    # Reset id and @new_record if the transaction rolls back.
    def function
      begin
        (remember_transaction_record_state;Fi[	@„	ieI"m    
    # Call the after_commit callbacks
    def function
      begin
        run_callbacks("LITERAL");Fi[	I"0projects//backup_proj/backup/cli/utility.rb;Ti%I"ﬁ      # as well as the base path for any option specified as a relative path.
      # Any option given as an absolute path will be used "as-is".
      def function
        begin
          (Logger.quiet = options["LITERAL"];Fi[	@ciAI"π      # collections to dump, it'll loop through the array of collections and invoke the
      # 'mongodump' command once per collection
      def function
        begin
          (super;Fi[	@ziZI"R      #
      # @api private
      def function
        begin
          (log!;Fi[	@ziíI"â      # secret key listing which we don't care about.
      #
      def function
        begin
          (return false unless gpg_homedir;Fi[	@zi≤I"ü      # We'll cleanup to remove the tempdir (if created) and raise an error.
      #
      def function
        begin
          (return false unless gpg_config;Fi[	@ziI"ú      # Return false if no :passphrase is set or an error occurs.
      #
      def function
        begin
          (return false if passphrase.to_s.empty?;Fi[	I"-projects//backup_proj/backup/pipeline.rb;Ti'I"ˆ    # Use `#success?` to determine if all commands in the pipeline succeeded.
    # If `#success?` returns `false`, use `#error_messages` to get an error report.
    def function
      begin
        (Open4.popen4(pipeline) do |var, var, var, var|;Fi[	I"4projects//backup_proj/backup/storage/dropbox.rb;Ti3I"Ë      # connection with Dropbox at a later time. This allows the user to avoid
      # having to go to a new Dropbox URL to authorize over and over again.
      def function
        begin
          (return @connection if @connection;Fi[	@¯	i|I"º      # Create a new session, write a serialized version of it to the
      # .cache directory, and return the session object
      def function
        begin
          (require("timeout");Fi[	@ui:I"ô      ##
      # Transfers the archived file to the specified remote server
      def function
        begin
          (write_password_file! unless local;Fi[	I"6projects//backup_proj/backup/syncer/rsync/pull.rb;TiI"ë        # Performs the RSync::Pull operation
        # debug options: -vhP
        def function
          begin
            (write_password_file!;Fi[	@Üi.I"ê        # Performs the RSync:Push operation
        # debug options: -vhP
        def function
          begin
            (write_password_file!;Fi[	I"8projects//cancan_proj/cancan/controller_resource.rb;Ti˘I"|    end
    
    def function
      begin
        [namespace, name.camelize].join("STRING").singularize.camelize.constantize;Fi[	I"Lprojects//compass_proj/compass/app_integration/stand_alone/installer.rb;TiI"ò        end
        
        def function
          begin
            (var, Compass.configuration.project_path = Compass.configuration.project_path, nil;Fi[	I":projects//compass_proj/compass/exec/sub_command_ui.rb;TiI"F    end
    
    def function
      begin
        return perform!;Fi[	@

iI"S    protected
    
    def function
      begin
        ($command = args.shift;Fi[	I"5projects//compass_proj/compass/exec/switch_ui.rb;TiI"?    end
    
    def function
      begin
        perform!;Fi[	I"1projects//compass_proj/compass/frameworks.rb;Ti2I"B    end
    
    def function
      begin
        (@var = nil;Fi[	I"@projects//compass_proj/compass/installers/bare_installer.rb;TiI"é      end
      
      def function
        begin
          (var, Compass.configuration.project_path = Compass.configuration.project_path, nil;Fi[	I"-projects//compass_proj/compass/logger.rb;TiI"W    end
    
    def function
      begin
        ($stderr.write(color("LITERAL"));Fi[	@
i*I"W    end
    
    def function
      begin
        ($stderr.write(color("LITERAL"));Fi[	@“iµI"2  end
  
  def function
    begin
      yield;Fi[	I"6projects//diaspora_proj/models/invitation_code.rb;TiI"U  end
  
  def function
    begin
      self.token = SecureRandom.hex("LITERAL");Fi[	I"4projects//diaspora_proj/models/o_embed_cache.rb;TiI"≠  end
  
  def function
    begin
      var = OEmbed::Providers.get(self.url, "LITERAL" => "LITERAL", "LITERAL" => "LITERAL", "LITERAL" => "LITERAL", "LITERAL" => "LITERAL");Fi[	@“i∫I"T  end
  
  def function
    begin
      (var = URI.parse(@attributes["STRING"]);Fi[	I"+projects//diaspora_proj/models/user.rb;TigI"i  
  #@deprecated
  def function
    begin
      self.invitations_to_me.first.sender.invitation_code;Fi[	@ˇiI"Q      #
      # @see #parse
      def function
        begin
          parse;Fi[	I"?projects//haml_proj/haml/helpers/action_view_extensions.rb;Ti/I"Æ      # @yield A block in which all input to `#haml_concat` is treated as raw.
      # @see Haml::Util#rails_xss_safe?
      def function
        begin
          (@var = true;Fi[	@ÔiI"      #
      # @raise [Haml::Error] The error
      def function
        begin
          raise(Haml::Error.new(@message));Fi[	@ÔiHI"}    #
    # @yield A block which won't register as Haml
    def function
      begin
        (var = @haml_buffer.active?;Fi[	I"'projects//haml_proj/haml/parser.rb;Ti\I"^    end
    
    def function
      begin
        (@var = @var = ParseNode.new("LITERAL");Fi[	@i/I"í    #
    # @yield A block in which no output will be printed to STDERR
    def function
      begin
        (var, $stderr = $stderr, StringIO.new;Fi[	I"%projects//homebrew_proj/build.rb;TiI"∏# the whole of everything must be run in at_exit because the formula has to
# be the run script as __END__ must work for *that* formula.
def function
  begin
    (if ENV["STRING"] then;Fi[	I"-projects//homebrew_proj/cmd/uninstall.rb;Ti
I"f  extend(self)
  
  def function
    begin
      (raise(KegUnspecifiedError) if ARGV.named.empty?;Fi[	@Êi0I"M  private
  
  def function
    begin
      if Dir["STRING"].empty? then;Fi[	@Èi8I"H  end
  
  def function
    begin
      (if @local_bottle_path then;Fi[	I"+projects//homebrew_proj/extend/ARGV.rb;TiI"7  end
  
  def function
    begin
      (var = nil;Fi[	@B
i°I"9  end
  
  def function
    begin
      (var = clone;Fi[	I"0projects//homebrew_proj/extend/fileutils.rb;TiI"æ  # Create a temporary directory then yield. When the block returns,
  # recursively delete the temporary directory.
  def function
    begin
      (var = (ENV["STRING"].chuzzle or "STRING");Fi[	I"/projects//homebrew_proj/extend/pathname.rb;Ti|I"¶  # it is slow to enumerate the whole directory just to see if it is empty,
  # instead rely on good ol' libc and the filesystem
  def function
    begin
      (rmdir;Fi[	@J
iI"7  end
  
  def function
    begin
      (var = nil;Fi[	@—i"I"M  end
  
  def function
    begin
      (if @@attempted.include?(f) then;Fi[	@—i°I"I  end
  
  def function
    begin
      (FileUtils.rm(Dir["STRING"]);Fi[	@—i‚I"P  end
  
  def function
    begin
      Keg.new(f.prefix).fix_install_names;Fi[	@—iÓI"M  end
  
  def function
    begin
      (ohai("STRING") if ARGV.verbose?;Fi[	I"7projects//jekyll_proj/jekyll/converters/textile.rb;TiI"^    pygments_suffix("STRING")
    
    def function
      begin
        (return if @setup;Fi[	I")projects//jekyll_proj/jekyll/site.rb;Ti©I"Z    #
    # Returns nothing.
    def function
      begin
        (var = site_payload;Fi[	I"0projects//nokogiri_proj/nokogiri/version.rb;Ti;I"G    end
    
    def function
      begin
        require("psych");Fi[	@;iI"T    private
    
    def function
      begin
        silence_stream(STDERR) do;Fi[	I"4projects//paperclip_proj/paperclip/thumbnail.rb;TiiI"À    
    # Return true if ImageMagick's +identify+ returns an animated format
    def function
      begin
        ANIMATED_FORMATS.include?(identify("STRING", "LITERAL" => "STRING").to_s.downcase.strip);Fi[	@imI"    
    # returns true if payload_class does not raise NameError
    def function
      begin
        payload_class.!=(Object);Fi[	@]i5I"º    # is processing will not be completed. Send the child a TERM signal,
    # wait 5 seconds, and then a KILL signal if it has not quit
    def function
      begin
        if @child then;Fi[	@3i3I"°    # This will return true if the given block halts for a reason other than
    # getting paused.
    def function
      begin
        var = catch("LITERAL") do;Fi[	I"Hprojects//state_machine_proj/state_machine/transition_collection.rb;TiöI"®    # occur will automatically result in the transition rolling back any changes
    # that were made to the object involved.
    def function
      begin
        yield;Fi[	@|I"# do nothing;FiF[F[	I"Rprojects//activerecord_proj/active_record/associations/has_one_association.rb;Ti6I"ñ          when "LITERAL" then
            target.update_columns(reflection.foreign_key => (nil))
          else
            # do nothing
          end;Fi[	@XiQI"è            remove_duplicate_results!(var.klass, var, var[var]) unless var.empty?
          end
        else
          # do nothing
        end;Fi[	I"Hprojects//activerecord_proj/active_record/associations/preloader.rb;TiÜI"d        when "LITERAL" then
          BelongsTo
        else
          # do nothing
        end;Fi[	@Üi[I"Ñ          when String then
            var.each { |var| var[var] += "STRING" }
          else
            # do nothing
          end;Fi[	@UiAI"Ñ          when Fixnum then
            var.each { |var| var[var] += "STRING" }
          else
            # do nothing
          end;Fi[	@pi$I"          when Hash then
            resolve_hash_connection(config)
          else
            # do nothing
          end;Fi[	I"]projects//activerecord_proj/active_record/connection_adapters/postgresql/array_parser.rb;Ti!I"x            when "STRING" then
              return var
            else
              # do nothing
            end;Fi[	I"dprojects//activerecord_proj/active_record/connection_adapters/postgresql/database_statements.rb;TiOI"¨              when "LITERAL" then
                var.gsub!("LITERAL", "STRING").sub!("LITERAL", "STRING")
              else
                # do nothing
              end;Fi[	@si(I"¢            when "LITERAL" then
              var.gsub!("LITERAL", "STRING").sub!("LITERAL", "STRING")
            else
              # do nothing
            end;Fi[	@ñiGI"|              when "LITERAL" then
                "STRING"
              else
                # do nothing
              end;Fi[	@Xi\I"ã          when "LITERAL" then
            var["STRING"] = $1.gsub("STRING", "STRING")
          else
            # do nothing
          end;Fi[	@[iΩI"g                end)
              end
            else
              # do nothing
            end;Fi[	I"Cprojects//activerecord_proj/active_record/nested_attributes.rb;TiÔI"Y      when Proc then
        var.call(var)
      else
        # do nothing
      end;Fi[	@8iI"å        when "LITERAL" then
          var = AggregateReflection.new(var, var, var, var, var)
        else
          # do nothing
        end;Fi[	@8iBI"n            Associations::HasOneAssociation
          end
        else
          # do nothing
        end;Fi[	@JiªI"k        when String then
          var = Arel.sql(var)
        else
          # do nothing
        end;Fi[	@QiŸI"Z      when Array then
        (to_a == var)
      else
        # do nothing
      end;Ti[	@„	i I"Å      when "LITERAL" then
        (transaction_record_state("LITERAL") or destroyed?).!
      else
        # do nothing
      end;Fi[	I"`projects//activerecord_proj/rails/generators/active_record/migration/migration_generator.rb;Ti I"^            set_index_names
          end
        else
          # do nothing
        end;Fi[	@≤i7I"c        when "LITERAL" then
          "STRING"
        else
          # do nothing
        end;Fi[	I"5projects//backup_proj/backup/notifier/hipchat.rb;TiOI"t        when "LITERAL" then
          ["STRING", failure_color]
        else
          # do nothing
        end;Fi[	I"2projects//backup_proj/backup/notifier/mail.rb;TiâI"k        when "LITERAL" then
          ["STRING", true]
        else
          # do nothing
        end;Fi[	@¢
i±I"\        when "STRING" then
          {}
        else
          # do nothing
        end;Fi[	@πi5I"c        when "LITERAL" then
          "STRING"
        else
          # do nothing
        end;Fi[	@¿i?I"c        when "LITERAL" then
          "STRING"
        else
          # do nothing
        end;Fi[	@«i3I"c        when "LITERAL" then
          "STRING"
        else
          # do nothing
        end;Fi[	I"?projects//devise_proj/devise/strategies/authenticatable.rb;Ti$I"`          fail!(var)
          return false
        else
          # do nothing
        end;Fi[	I"6projects//diaspora_proj/helpers/o_embed_helper.rb;TiI"d        var = link_to_oembed_image(var, "STRING")
      end
    else
      # do nothing
    end;Fi[	I"1projects//diaspora_proj/models/invitation.rb;Ti_I"V    when "STRING" then
      I18n.t("STRING")
    else
      # do nothing
    end;Fi[	@≥
ikI"K    when "STRING" then
      false
    else
      # do nothing
    end;Fi[	@3
iŸI"m        when "STRING" then
          var["STRING"] = var
        else
          # do nothing
        end;Fi[	@„iI"K  when "STRING" then
    "STRING".undent
  else
    # do nothing
  end;Fi[	I")projects//homebrew_proj/cmd/--env.rb;Ti*I"j          print("STRING") if File.symlink?(var)
        end
      else
        # do nothing
      end;Fi[	@igI"r      when "STRING", "STRING" then
        problem("STRING".undent)
      else
        # do nothing
      end;Fi[	@iïI"Z      when "LITERAL" then
        "LITERAL"
      else
        # do nothing
      end;Fi[	@i´I"b      when "LITERAL" then
        problem("STRING")
      else
        # do nothing
      end;Fi[	I"(projects//homebrew_proj/cmd/edit.rb;Ti+I"^      when "STRING", "STRING" then
        true
      else
        # do nothing
      end;Fi[	I"+projects//homebrew_proj/cmd/install.rb;Ti I"h    when "LITERAL", "LITERAL" then
      abort("STRING".undent)
    else
      # do nothing
    end;Fi[	@Êi|I"a      when "LITERAL" then
        Pathname.new($1)
      else
        # do nothing
      end;Fi[	@ÊiëI"Y      when "LITERAL" then
        "STRING"
      else
        # do nothing
      end;Fi[	@i;I"f    when "LITERAL" then
      MacOS.gcc_42_build_version.to_i
    else
      # do nothing
    end;Fi[	@i}I"?        end
      end
    else
      # do nothing
    end);Fi[	@ÈiI"h      @var = @specs.keys.first
      @var = @specs.values.first
    else
      # do nothing
    end;Fi[	@ÈizI"f    when "LITERAL" then
      Dir.chdir(var.first) rescue nil
    else
      # do nothing
    end;Fi[	@Èi2I"w      when "LITERAL", "LITERAL" then
        ((var << "STRING") << @ref)
      else
        # do nothing
      end;Fi[	@ÈiHI"ó            quiet_safe_system(@@git, "STRING", { "LITERAL" => "STRING" }, @ref, "STRING")
          end
        else
          # do nothing
        end;Fi[	@J
i∫I"Y      when "STRING" then
        "LITERAL"
      else
        # do nothing
      end;Fi[	I"#projects//homebrew_proj/keg.rb;TiOI"X    when "LITERAL" then
      (self / "STRING")
    else
      # do nothing
    end;Fi[	@ŸiYI"á      @var = (@patch_filename + "STRING")
      FileUtils.mv(@patch_filename, @compressed_filename)
    else
      # do nothing
    end;Fi[	@ i(I"y    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING", "STRING"]
    else
      # do nothing
    end;Fi[	@ iAI"O    when "LITERAL" then
      "STRING"
    else
      # do nothing
    end;Fi[	@3i`I"o    when "LITERAL" then
      "STRING"
    else
      # do nothing
    end, var.bottle.checksum.hexdigest);Fi[	@3i˜I"o    when "LITERAL" then
      "STRING"
    else
      # do nothing
    end, var.bottle.checksum.hexdigest);Fi[	I"8projects//jekyll_proj/jekyll/converters/markdown.rb;TiwI"g      when "STRING" then
        Maruku.new(var).to_html
      else
        # do nothing
      end;Fi[	I"-projects//jekyll_proj/jekyll/core_ext.rb;Ti*I"m        when Array then
          var = var[var].compact
        else
          # do nothing
        end;Fi[	I"5projects//jekyll_proj/jekyll/migrators/tumblr.rb;TiZI"ã        var = var["STRING"]
        (var << ("STRING" + var["STRING"])) unless var["STRING"].nil?
      else
        # do nothing
      end;Fi[	I"Iprojects//paperclip_proj/paperclip/io_adapters/attachment_adapter.rb;TiI"r      when Paperclip::Style then
        [var.attachment, var.name]
      else
        # do nothing
      end;Fi[	I"+projects//rescue_proj/resque/server.rb;TiAI"p        when "STRING" then
          Resque.redis.hlen(var)
        else
          # do nothing
        end;Fi[	@ˆ
iSI"s        when "STRING" then
          Resque.redis.hgetall(var)
        else
          # do nothing
        end;Fi[	I"Kprojects//state_machine_proj/state_machine/yard/handlers/transition.rb;Ti+I"l              AllMatcher.instance
            end
          else
            # do nothing
          end;Fi[	@´iJI"|          var["LITERAL"] = var.id
          merge_owner!(var, var.user)
        else
          # do nothing
        end;Fi[	@i¡I"e        when Twitter::User then
          var.id
        else
          # do nothing
        end;Fi[	I"0projects//twitter_proj/twitter/api/utils.rb;TiëI"ï        when Twitter::User then
          var[[var, "STRING"].compact.join("STRING").to_sym] = var.id
        else
          # do nothing
        end;Fi[	@iØI"x          when Twitter::User then
            (var << var.id)
          else
            # do nothing
          end;Fi[	@6iRI"i        when "LITERAL" then
          "LITERAL".hour
        else
          # do nothing
        end;Fi[	I"puts("STRING");F@	i@[@[	@Ë	i©I"u        unless options.any? then
          puts
          puts("STRING")
          puts("STRING")
          puts;Fi[	@Ë	i¨I"m          puts("STRING")
          puts
          puts("STRING")
          puts("STRING")
          puts;Fi[	@Ë	iØI"m          puts("STRING")
          puts
          puts("STRING")
          puts("STRING")
          exit;Fi[	@Ë	i∑I"|            puts
            puts(var)
            puts("STRING")
            puts("STRING")
            puts("STRING");Fi[	@Ë	i∏I"Å            puts(var)
            puts("STRING")
            puts("STRING")
            puts("STRING")
            puts("STRING");Fi[	@Ë	iπI"~            puts("STRING")
            puts("STRING")
            puts("STRING")
            puts("STRING")
          end;Fi[	@Ë	iøI"|        if options["LITERAL"] then
          puts
          puts("STRING")
          puts("STRING")
          puts("STRING");Fi[	@Ë	i¿I"w          puts
          puts("STRING")
          puts("STRING")
          puts("STRING")
          puts("STRING");Fi[	@Ë	i¡I"€          puts("STRING")
          puts("STRING")
          puts("STRING")
          puts("STRING")
          puts(`gem install #{options["LITERAL"]}STRING#{Backup::Dependency.all[options["LITERAL"]]["LITERAL"]}STRING`);Fi[	I"3projects//compass_proj/compass/dependencies.rb;TiI"[    require("sass")
  rescue LoadError
    puts("STRING")
    puts("STRING")
    raise;Fi[	@8
i^I"Ç    if ARGV.flag?("STRING") then
      ohai("STRING")
      puts("STRING")
      puts("STRING")
      if ARGV.flag?("STRING") then;Fi[	@8
iaI"|      puts("STRING")
      if ARGV.flag?("STRING") then
        puts("STRING")
        puts("STRING")
        puts("STRING");Fi[	@8
ibI"v      if ARGV.flag?("STRING") then
        puts("STRING")
        puts("STRING")
        puts("STRING")
      end;Fi[	@¯igI"é  # we try to keep output minimal
  def function
    puts("STRING")
    puts("STRING")
    puts("STRING") if HOMEBREW_PREFIX.to_s.!=("STRING");Fi[	@¯isI"t      puts("STRING") if gcc_40
      puts("STRING") if gcc_42
      puts("STRING")
      puts("STRING")
    end;Fi[	@¯iÄI"O  
  def function
    puts("STRING")
    puts("STRING")
    puts("STRING");Fi[	@¯iÅI"_  def function
    puts("STRING")
    puts("STRING")
    puts("STRING")
    puts("STRING");Fi[	@¯iÇI"c    puts("STRING")
    puts("STRING")
    puts("STRING")
    puts("STRING")
    puts("STRING");Fi[	@¯iÉI"c    puts("STRING")
    puts("STRING")
    puts("STRING")
    puts("STRING")
    puts(hardware);Fi[	@¯iãI"Ü    puts("STRING") if gcc_40
    puts("STRING") if gcc_42
    puts("STRING")
    puts("STRING")
    puts("STRING") if macports_or_fink;Fi[	@¯iéI"w    puts("STRING")
    puts("STRING") if macports_or_fink
    puts("STRING")
    puts("STRING")
    puts("STRING");Fi[	@¯ièI"w    puts("STRING") if macports_or_fink
    puts("STRING")
    puts("STRING")
    puts("STRING")
    puts("STRING");Fi[	@¯iêI"c    puts("STRING")
    puts("STRING")
    puts("STRING")
    puts("STRING")
    puts("STRING");Fi[	@¯iëI"V    puts("STRING")
    puts("STRING")
    puts("STRING")
    puts("STRING")
  end;Fi[	I"*projects//homebrew_proj/cmd/bottle.rb;TiI"•      ohai("STRING")
      safe_system("STRING", "STRING", (var / var), "STRING")
      puts("STRING")
      puts("STRING")
      puts("STRING") if (var > "LITERAL");Fi[	@=iI"u      puts("STRING")
      puts("STRING") if (var > "LITERAL")
      puts("STRING")
      puts("STRING")
    end;Fi[	I")projects//homebrew_proj/cmd/fetch.rb;TiI"á      next unless var.kind_of?(Pathname)
      puts("STRING") unless var
      puts("STRING")
      puts("STRING")
      puts("STRING");Fi[	@BiI"o      puts("STRING") unless var
      puts("STRING")
      puts("STRING")
      puts("STRING")
      begin;Fi[	@»
i:I"y    unless MacOS.macports_or_fink.empty? then
      opoo("STRING")
      puts("STRING")
      puts("STRING")
    end;Fi[	I"'projects//homebrew_proj/cmd/irb.rb;TiI"v  def function
    if ARGV.include?("STRING") then
      puts("STRING")
      puts("STRING")
      puts("STRING");Fi[	@IiI"|    if ARGV.include?("STRING") then
      puts("STRING")
      puts("STRING")
      puts("STRING")
      puts("STRING");Fi[	@IiI"a      puts("STRING")
      puts("STRING")
      puts("STRING")
      puts("STRING")
    else;Fi[	@Êi#I"Ñ    puts("STRING")
    curl("STRING", "STRING", "STRING") rescue puts
      puts("STRING")
      puts("STRING")
      puts("STRING");Fi[	@Êi$I"Ü    curl("STRING", "STRING", "STRING") rescue puts
      puts("STRING")
      puts("STRING")
      puts("STRING")
      puts("STRING");Fi[	@Êi%I"c      puts("STRING")
      puts("STRING")
      puts("STRING")
      puts("STRING")
      puts;Fi[	@Êi(I"Y      puts("STRING")
      puts
      puts("STRING")
      puts("STRING")
      puts;Fi[	I"&projects//homebrew_proj/debrew.rb;Ti]I"Iend
def function(var, var)
  puts("STRING")
  puts("STRING")
  begin;Fi[	@ÈiÓI"ü    if (var["LITERAL"] == "LITERAL") and (var["LITERAL"] <= "LITERAL") then
      onoe("STRING")
      puts("STRING")
      puts("STRING")
      puts("STRING");Fi[	@ÈiÔI"`      onoe("STRING")
      puts("STRING")
      puts("STRING")
      puts("STRING")
    end;Fi[	@—i“I"à    rescue Exception => var
      onoe("STRING")
      puts("STRING")
      puts("STRING")
      ohai(var, var.backtrace) if ARGV.debug?;Fi[	@—iÁI"à    rescue Exception => var
      onoe("STRING")
      puts("STRING")
      puts("STRING")
      ohai(var, var.backtrace) if ARGV.debug?;Fi[	@—iÛI"Å      if f.class.skip_clean_all? then
        opoo("STRING")
        puts("STRING")
        puts("STRING")
        puts("STRING");Fi[	@—iÙI"w        opoo("STRING")
        puts("STRING")
        puts("STRING")
        puts("STRING")
        puts("STRING");Fi[	@—iıI"o        puts("STRING")
        puts("STRING")
        puts("STRING")
        puts("STRING")
        return;Fi[	@—iI"}    if (f.prefix + "STRING").directory? then
      opoo("STRING")
      puts("STRING")
      puts("STRING")
      @var = true;Fi[	@—i#I"}    if (f.prefix + "STRING").directory? then
      opoo("STRING")
      puts("STRING")
      puts("STRING")
      @var = true;Fi[	@—i.I"s    unless var.empty? then
      opoo("STRING")
      puts("STRING")
      puts("STRING")
      puts("STRING");Fi[	@—i/I"m      opoo("STRING")
      puts("STRING")
      puts("STRING")
      puts("STRING")
      puts("STRING");Fi[	@—i0I"m      puts("STRING")
      puts("STRING")
      puts("STRING")
      puts("STRING")
      puts("STRING");Fi[	@—i1I"h      puts("STRING")
      puts("STRING")
      puts("STRING")
      puts("STRING")
      puts(var);Fi[	@—iAI"n    unless var.empty? then
      opoo("STRING")
      puts("STRING")
      puts("STRING")
      puts(var);Fi[	@—iMI"n    unless var.empty? then
      opoo("STRING")
      puts("STRING")
      puts("STRING")
      puts(var);Fi[	@—iYI"n    unless var.empty? then
      opoo("STRING")
      puts("STRING")
      puts("STRING")
      puts(var);Fi[	@‘iI"Ü    rescue ChecksumMissingError
      opoo("STRING")
      puts("STRING")
      puts("STRING")
    rescue ChecksumMismatchError => var;Fi[	I"3projects//jekyll_proj/jekyll/commands/build.rb;TiI"      rescue Jekyll::FatalException => var
        puts
        puts("STRING")
        puts("STRING")
        puts(var.message);Fi[	I">projects//jekyll_proj/jekyll/migrators/wordpressdotcom.rb;Ti*I"t          end)
        rescue => var
          puts("STRING")
          puts("STRING")
          puts("STRING");Fi[	@Äi+I"~        rescue => var
          puts("STRING")
          puts("STRING")
          puts("STRING")
          puts("STRING");Fi[	@Äi,I"w          puts("STRING")
          puts("STRING")
          puts("STRING")
          puts("STRING")
          next;Fi[	@ui)I"Ä        else
          puts(Whenever.cron(@options))
          puts("STRING")
          puts("STRING")
          exit("LITERAL");Fi[	@I"*#   class Person < ActiveRecord::Base;Fi;[;[	@0iI"€    # Returns an Enumerable of all key attributes if any is set, regardless if
    # the object is persisted or not. If there no key attributes, returns +nil+.
    #
    #   class Person < ActiveRecord::Base
    #   end;Fi[	@0i*I"æ    # Returns a +string+ representing the object's key suitable for use in URLs,
    # or +nil+ if <tt>persisted?</tt> is +false+.
    #
    #   class Person < ActiveRecord::Base
    #   end;Fi[	@fiI"›      # Validates that the specified attributes are blank (as defined by
      # Object#blank?). Happens by default on save.
      #
      #   class Person < ActiveRecord::Base
      #     validates_absence_of :first_name;Fi[	@iiI"      # Encapsulates the pattern of wanting to validate the acceptance of a
      # terms of service check box (or similar agreement).
      #
      #   class Person < ActiveRecord::Base
      #     validates_acceptance_of :terms_of_service;Fi[	@qiI"      # Validates that the value of the specified attribute is not in a
      # particular enumerable object.
      #
      #   class Person < ActiveRecord::Base
      #     validates_exclusion_of :username, in: %w( admin superuser ), message: "You don't belong here";Fi[	@ti;I"      # form, going by the regular expression provided.You can require that the
      # attribute matches the regular expression:
      #
      #   class Person < ActiveRecord::Base
      #     validates_format_of :email, with: /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\z/i, on: :create;Fi[	@tiBI"‚      # Alternatively, you can require that the specified attribute does _not_
      # match the regular expression:
      #
      #   class Person < ActiveRecord::Base
      #     validates_format_of :email, without: /NOSPAM/;Fi[	@tiII"      # You can also provide a proc or lambda which will determine the regular
      # expression that will be used to validate the attribute.
      #
      #   class Person < ActiveRecord::Base
      #     # Admin can have number as a first letter in their screen name;Fi[	@{iI"‰      # Validates whether the value of the specified attribute is available in a
      # particular enumerable object.
      #
      #   class Person < ActiveRecord::Base
      #     validates_inclusion_of :gender, in: %w( m f );Fi[	@~iBI"Ù      # Validates that the specified attribute matches the length restrictions
      # supplied. Only one option can be used at a time:
      #
      #   class Person < ActiveRecord::Base
      #     validates_length_of :first_name, maximum: 30;Fi[	@|iPI"˘      # is +false+) or applying it to the regular expression <tt>/\A[\+\-]?\d+\Z/</tt>
      # (if <tt>only_integer</tt> is set to +true+).
      #
      #   class Person < ActiveRecord::Base
      #     validates_numericality_of :value, on: :create;Fi[	@|iyI"¶      #
      # For example:
      #
      #   class Person < ActiveRecord::Base
      #     validates_numericality_of :width, less_than: ->(person) { person.height };Fi[	@iI"‚      # Validates that the specified attributes are not blank (as defined by
      # Object#blank?). Happens by default on save.
      #
      #   class Person < ActiveRecord::Base
      #     validates_presence_of :first_name;Fi[	@≤i$I"¶      #
      # *First:* Specify a subset of fields to be selected from the result set.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets;Ti[	@≤i]I"›      # rules as <tt>ActiveRecord::Base.find</tt>. Returns <tt>ActiveRecord::RecordNotFound</tt>
      # error if the object can not be found.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets;Ti[	@≤i{I"ƒ      # If the collection is empty, the first form returns +nil+, and the second
      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets;Ti[	@≤iîI"ƒ      # If the collection is empty, the first form returns +nil+, and the second
      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets;Ti[	@≤i˝I"       # inserts each record, +push+ and +concat+ behave identically. Returns +self+
      # so method calls may be chained.
      #
      #   class Person < ActiveRecord::Base
      #     pets :has_many;Ti[	@≤iI"“      # Replace this collection with +other_array+. This will perform a diff
      # and delete/add only records that have changed.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets;Ti[	@≤i7I"˜      # sets the foreign keys to <tt>NULL</tt>. For, +has_many+ <tt>:through</tt>,
      # the default strategy is +delete_all+.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets # dependent: :nullify option by default;Ti[	@≤iXI"∆      # are removed by calling their +destroy+ method. See +destroy+ for more
      # information.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :destroy;Ti[	@≤iqI"‚      # If it is set to <tt>:delete_all</tt>, all the objects are deleted
      # *without* calling their +destroy+ method.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :delete_all;Ti[	@≤iéI"¶      # This will _always_ remove the records ignoring the +:dependent+
      # option.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets;Ti[	@≤iÆI"Ê      # keys to <tt>NULL</tt>. For, +has_many+ <tt>:through</tt>, the default
      # strategy is +delete_all+.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets # dependent: :nullify option by default;Ti[	@≤i I"˙      # If it is set to <tt>:destroy</tt> all the +records+ are removed by calling
      # their +destroy+ method. See +destroy+ for more information.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :destroy;Ti[	@≤iÊI"‰      # If it is set to <tt>:delete_all</tt>, all the +records+ are deleted
      # *without* calling their +destroy+ method.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :delete_all;Ti[	@≤iI"—      # You can pass +Fixnum+ or +String+ values, it finds the records
      # responding to the +id+ and executes delete on them.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets;Ti[	@≤iI"Â      # This method will _always_ remove record from the database ignoring
      # the +:dependent+ option. Returns an array with the removed records.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets;Ti[	@≤idI"î      
      # Specifies whether the records should be unique or not.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets;Ti[	@≤ivI"      
      # Count all records using SQL.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets;Ti[	@≤iåI"Â      # equivalent. If not and you are going to need the records anyway
      # +length+ will take one less query. Otherwise +size+ is more efficient.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets;Ti[	@≤i¶I"Ë      # equivalent. If not and you are going to need the records anyway this
      # method will take one less query. Otherwise +size+ is more efficient.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets;Ti[	@≤i¿I"‹      # not already been loaded and you are going to fetch the records anyway it
      # is better to check <tt>collection.length.zero?</tt>.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets;Ti[	@≤i—I"å      
      # Returns +true+ if the collection is not empty.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets;Ti[	@≤iÛI"√      # Returns true if the collection has more than one record.
      # Equivalent to <tt>collection.size > 1</tt>.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets;Ti[	@≤iI"û      
      # Returns +true+ if the given object is present in the collection.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets;Ti[	@≤i>I"™      # to the corresponding element in the other array, otherwise returns
      # +false+.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets;Ti[	@≤iXI"‚      # Returns a new array of objects from the collection. If the collection
      # hasn't been loaded, it fetches the records from the database.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets;Ti[	@≤iÄI"¡      # to the association√¢¬Ä¬òs primary key. Returns +self+, so several appends may be
      # chained together.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets;Ti[	@≤i°I"¡      # Reloads the collection from the database. Returns +self+.
      # Equivalent to <tt>collection(true)</tt>.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets;Ti[	@¸i2I"Â      # Raises a <tt>ActiveRecord::DangerousAttributeError</tt> exception when an
      # \Active \Record method is defined in the model, otherwise +false+.
      #
      #   class Person < ActiveRecord::Base
      #     def save;Fi[	@¸i^I"´      # Returns +true+ if +attribute+ is an attribute method and table exists,
      # +false+ otherwise.
      #
      #   class Person < ActiveRecord::Base
      #   end;Fi[	@¸ikI"“      # Returns an array of column names as strings if it's not an abstract class and
      # table exists. Otherwise it returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #   end;Fi[	@¸iáI"´    # which will all return +true+. It also define the attribute methods if they have
    # not been generated.
    #
    #   class Person < ActiveRecord::Base
    #   end;Fi[	@¸iõI"ö    
    # Returns +true+ if the given attribute is in the attributes hash, otherwise +false+.
    #
    #   class Person < ActiveRecord::Base
    #   end;Fi[	@¸i®I"ç    
    # Returns an array of names for the attributes available on this object.
    #
    #   class Person < ActiveRecord::Base
    #   end;Fi[	@¸i¥I"∞    
    # Returns a hash of all the attributes with their names as keys and the values of the attributes as values.
    #
    #   class Person < ActiveRecord::Base
    #   end;Fi[	@¸iÌI"´    # Returns the column object for the named attribute. Returns +nil+ if the
    # named attribute not exists.
    #
    #   class Person < ActiveRecord::Base
    #   end;Fi[	@¸i I"å    #
    # Alias for the <tt>read_attribute</tt> method.
    #
    #   class Person < ActiveRecord::Base
    #     belongs_to :organization;Fi[	@¸iI"’    # Updates the attribute identified by <tt>attr_name</tt> with the specified +value+.
    # (Alias for the protected <tt>write_attribute</tt> method).
    #
    #   class Person < ActiveRecord::Base
    #   end;Fi[	@[idI"÷        # descendant upon which the \scopes were defined. But they are also
        # available to +has_many+ associations. If,
        #
        #   class Person < ActiveRecord::Base
        #     has_many :shirts;Fi[	@niI"™      # associated object is not marked for destruction. Happens by default
      # on save.
      #
      #   class Person < ActiveRecord::Base
      #     has_one :face;Fi[	@qiXI"«      # across the system. Useful for making sure that only one user
      # can be named "davidhh".
      #
      #   class Person < ActiveRecord::Base
      #     validates_uniqueness_of :user_name;Fi[	@qi_I"˙      # It can also validate whether the value of the specified attributes are
      # unique based on a <tt>:scope</tt> parameter:
      #
      #   class Person < ActiveRecord::Base
      #     validates_uniqueness_of :user_name, scope: :account_id;Fi[	I"#:nodoc:;F@:i7[7[	@ iI"™      
      # Returns true if the attribute methods defined have been generated.
      #:nodoc:
      def function
        @var ||= Module.new.tap { |var| include(var) };Fi[	@ iI"¿      # significantly (in our case our test suite finishes 10% faster with
      # this cache).
      #:nodoc:
      def function
        @var ||= ThreadSafe::Cache.new("LITERAL" => "LITERAL");Fi[	@0iBI"•    
    module ClassMethods
      #:nodoc:
      def function
        @var ||= (var = ActiveSupport::Inflector.underscore(ActiveSupport::Inflector.demodulize(self));Fi[	I">projects//activerecord_proj/active_record/aggregations.rb;Ti	I"w    extend(ActiveSupport::Concern)
    
    #:nodoc:
    def function
      @aggregation_cache.clear if persisted?;Fi[	@ÒiöI"|    
    # Clears out the association cache.
    #:nodoc:
    def function
      @association_cache.clear if persisted?;Fi[	@˜iHI"f        end
        
        #:nodoc:
        def function
          if (self == base_class) then;Fi[	I";projects//activerecord_proj/active_record/callbacks.rb;TiI"X    end
    
    #:nodoc:
    def function
      run_callbacks("LITERAL") { super };Fi[	@i I"\    private
    
    #:nodoc:
    def function
      run_callbacks("LITERAL") { super };Fi[	@i%I"X    end
    
    #:nodoc:
    def function
      run_callbacks("LITERAL") { super };Fi[	@giTI"o      end
      
      #:nodoc:
      def function
        Base.connection_id ||= Thread.current.object_id;Fi[	@iÍI"Z      end
      
      #:nodoc:
      def function
        @var = @transaction.commit;Fi[	@iÔI"\      end
      
      #:nodoc:
      def function
        @var = @transaction.rollback;Fi[	@iÙI"b      end
      
      #:nodoc:
      def function
        @var = ClosedTransaction.new(self);Fi[	@ÜiˇI"y      end
      
      #:nodoc:
      def function
        var = ActiveRecord::Migrator.schema_migrations_table_name;Fi[	@UiÅI"X      end
      
      #:nodoc:
      def function
        self.class::ADAPTER_NAME;Fi[	@UiI"E      end
      
      #:nodoc:
      def function
        begin;Fi[	@UiI"E      end
      
      #:nodoc:
      def function
        begin;Fi[	@Ui?I"©      
      # SCHEMA STATEMENTS ========================================
      #:nodoc:
      def function
        supports_views? ? (var = "STRING") : (var = "STRING");Fi[	@Ã	içI"[      alias "LITERAL" "LITERAL"
      
      #:nodoc:
      def function
        begin;Fi[	@—	iI"O        end
        
        #:nodoc:
        def function
          begin;Fi[	@XinI"H      end
      
      #:nodoc:
      def function
        "STRING";Fi[	@Xi∞I"L      end
      
      #:nodoc:
      def function
        { "LITERAL" => (default_primary_key_type), "LITERAL" => ({ "LITERAL" => "STRING", "LITERAL" => "LITERAL" }), "LITERAL" => ({ "LITERAL" => "STRING" }), "LITERAL" => ({ "LITERAL" => "STRING" }), "LITERAL" => ({ "LITERAL" => "STRING" }), "LITERAL" => ({ "LITERAL" => "STRING" }), "LITERAL" => ({ "LITERAL" => "STRING" }), "LITERAL" => ({ "LITERAL" => "STRING" }), "LITERAL" => ({ "LITERAL" => "STRING" }), "LITERAL" => ({ "LITERAL" => "STRING" }), "LITERAL" => ({ "LITERAL" => "STRING" }), "LITERAL" => ({ "LITERAL" => "STRING" }) };Fi[	@Xi8I"n      end
      
      #:nodoc:
      def function
        log("STRING", nil) { @connection.transaction };Fi[	@Xi=I"i      end
      
      #:nodoc:
      def function
        log("STRING", nil) { @connection.commit };Fi[	@XiBI"k      end
      
      #:nodoc:
      def function
        log("STRING", nil) { @connection.rollback };Fi[	@i[I"h      private
      
      #:nodoc:
      def function
        var = Relation.new(self, arel_table);Fi[	@&inI"£      
      # Computes the table name, (re)sets it internally, and returns it.
      #:nodoc:
      def function
        self.table_name = if abstract_class? then;Fi[	@&i{I"ä      end
      
      #:nodoc:
      def function
        (parents.detect { |var| var.respond_to?("LITERAL") } or self).table_name_prefix;Fi[	@&iñI"L      end
      
      #:nodoc:
      def function
        @var = false;Fi[	@&iÍI"      # and true as the value. This makes it possible to do O(1) lookups in respond_to? to check if a given method for attribute
      # is available.
      #:nodoc:
      def function
        @var ||= column_names.each_with_object(Hash.new(false)) do |var, var|;Fi[	I"Hprojects//activerecord_proj/active_record/relation/spawn_methods.rb;TiI"~  module SpawnMethods
    # This is overridden by Associations::CollectionProxy
    #:nodoc:
    def function
      clone;Fi[	@Qi‚I"m    end
    
    #:nodoc:
    def function
      if default_scoped? and var = klass.send("LITERAL") then;Ti[	@Ti-I"b        end
        
        #:nodoc:
        def function
          self.current_scope = nil;Fi[	I"9projects//activerecord_proj/active_record/scoping.rb;TiI"d    
    module ClassMethods
      #:nodoc:
      def function
        Thread.current["STRING"];Fi[	@„	iJI"a    end
    
    #:nodoc:
    def function
      with_transaction_returning_status { super };Fi[	@„	iíI"æ    
    # Save the new record state and id of a record so it can be restored later if a transaction fails.
    #:nodoc:
    def function
      if has_attribute?(self.class.primary_key) then;Fi[	@„	iûI"∆    
    # Clear the new record state and id of a record.
    #:nodoc:
    def function
      @_start_transaction_state["LITERAL"] = ((@_start_transaction_state["LITERAL"] or "LITERAL") - "LITERAL");Fi[	I"=projects//activerecord_proj/active_record/translation.rb;Ti
I"h    
    # Set the lookup ancestors for ActiveModel.
    #:nodoc:
    def function
      var = self;Fi[	@IiI"j    
    # Set the i18n scope to overwrite ActiveModel.
    #:nodoc:
    def function
      "LITERAL";Fi[	I"8projects//devise_proj/devise/models/rememberable.rb;Ti[I"•        
        # Generate a token checking if one does not already exist in the database.
        #:nodoc:
        def function
          generate_token("LITERAL");Fi[	I"1projects//devise_proj/devise/test_helpers.rb;TiI"¢    
    # We need to setup the environment variables and the response in the controller.
    #:nodoc:
    def function
      @request.env["STRING"] = @controller;Fi[	@QiI"°    
    # Quick access to Warden::Proxy.
    #:nodoc:
    def function
      @var ||= (var = Warden::Manager.new(nil) { |var| var.merge!(Devise.warden_config) };Fi[	@iOI"f    end
    
    #:nodoc:
    def function
      var = @options["LITERAL"].to_s.downcase.camelize;Fi[	@iïI"`    end
    
    #:nodoc:
    def function
      return if (@options["LITERAL"] or file?.!);Fi[	@i°I"P    end
    
    #:nodoc:
    def function
      @errors.each do |var, var|;Fi[	@MiI"k    end
    
    #:nodoc:
    def function
      @var ||= (options["LITERAL"] or ::Logger.new(STDOUT));Fi[	I"=projects//paperclip_proj/paperclip/storage/filesystem.rb;TiI"d      end
      
      #:nodoc:
      def function
        @queued_for_write.each do |var, var|;Fi[	@^i#I"`      end
      
      #:nodoc:
      def function
        @queued_for_delete.each do |var|;Fi[	I"5projects//paperclip_proj/paperclip/storage/s3.rb;TiºI"d      end
      
      #:nodoc:
      def function
        @queued_for_write.each do |var, var|;Fi[	@ci⁄I"`      end
      
      #:nodoc:
      def function
        @queued_for_delete.each do |var|;Fi[	@:I"	true;Fi2[2[	I"]projects//activerecord_proj/active_record/associations/builder/collection_association.rb;TiI"5    end
    
    def function
      true
    end;Fi[	I"[projects//activerecord_proj/active_record/associations/builder/singular_association.rb;TiI"5    end
    
    def function
      true
    end;Fi[	@∫iI"?      end
      
      def function
        true
      end;Fi[	@∫iqI"?      end
      
      def function
        true
      end;Fi[	@PiyI"ü      # Does this adapter support using DISTINCT within COUNT? This is +true+
      # for all adapters except sqlite.
      def function
        true
      end;Fi[	@UiáI"~      
      # Returns true, since this connection adapter supports migrations.
      def function
        true
      end;Fi[	@UiãI"?      end
      
      def function
        true
      end;Fi[	@UiêI"~      
      # Returns true, since this connection adapter supports savepoints.
      def function
        true
      end;Fi[	@UiîI"?      end
      
      def function
        true
      end;Fi[	@UiöI"µ      # Technically MySQL allows to create indexes with the sort order syntax
      # but at the moment (5.5) it doesn't yet implement them
      def function
        true
      end;Fi[	I"Tprojects//activerecord_proj/active_record/connection_adapters/mysql2_adapter.rb;Ti&I"?      end
      
      def function
        true
      end;Fi[	@Ã	i}I"ä      # Returns true, since this connection adapter supports prepared statement
      # caching.
      def function
        true
      end;Fi[	@—	i	I"    class PostgreSQLAdapter < AbstractAdapter
      module ReferentialIntegrity
        def function
          true
        end;Fi[	@XitI"J      
      # Returns true
      def function
        true
      end;Fi[	@XiI"ä      # Returns true, since this connection adapter supports prepared statement
      # caching.
      def function
        true
      end;Fi[	@XiI"~      
      # Returns true, since this connection adapter supports migrations.
      def function
        true
      end;Fi[	@XiÑI"K      
      # Returns true.
      def function
        true
      end;Fi[	@XiàI"?      end
      
      def function
        true
      end;Fi[	@XiçI"J      
      # Returns true
      def function
        true
      end;Fi[	@Xi£I"J      
      # Returns true
      def function
        true
      end;Fi[	@Xi®I"J      
      # Returns true
      def function
        true
      end;Fi[	@Xi¨I"?      end
      
      def function
        true
      end;Fi[	@XiªI"K      
      # Returns true.
      def function
        true
      end;Fi[	I"?projects//activerecord_proj/active_record/null_relation.rb;TiI"5    end
    
    def function
      true
    end;Fi[	@îi(I"?      end
      
      def function
        true
      end;Fi[	@îiçI"?      end
      
      def function
        true
      end;Fi[	I"Vprojects//compass_proj/compass/sass_extensions/functions/cross_browser_support.rb;TiI"5    end
    
    def function
      true
    end;Fi[	I"Qprojects//compass_proj/compass/sass_extensions/functions/gradient_support.rb;TiBI"5    end
    
    def function
      true
    end;Fi[	@∏i&I"?      end
      
      def function
        true
      end;Fi[	I"7projects//devise_proj/devise/models/validatable.rb;Ti)I"?      end
      
      def function
        true
      end;Fi[	I"<projects//devise_proj/devise/strategies/rememberable.rb;Ti$I"?      end
      
      def function
        true
      end;Fi[	I"Eprojects//devise_proj/devise/strategies/token_authenticatable.rb;TiI"è      
      # Token Authenticatable can be authenticated with params in any controller and any verb.
      def function
        true
      end;Fi[	I"7projects//diaspora_proj/models/account_deletion.rb;Ti-I"+  end
  
  def function
    true
  end;Fi[	I"=projects//diaspora_proj/models/activity_streams/photo.rb;TiI"^  # A better solution is needed.
  # @return [Boolean] true
  def function
    true
  end;Fi[	I",projects//diaspora_proj/models/photo.rb;TiÄI"+  end
  
  def function
    true
  end;Fi[	I";projects//diaspora_proj/models/relayable_retraction.rb;Ti!I"+  end
  
  def function
    true
  end;Fi[	I"0projects//haml_proj/haml/template/plugin.rb;TiI"~    # the ERB handler does.
    # In Rails 3.1+, we don't need to include Compilable.
    def function
      true
    end;Fi[	@ÚiI"]    undef "LITERAL" if defined? rails_xss_safe?
    
    def function
      true
    end;Fi[	I"1projects//homebrew_proj/test/test_bottles.rb;TiI"U  def function
    alias "LITERAL" "LITERAL"
    def function
      true
    end;Fi[	@>iI"5    end
    
    def function
      true
    end;Fi[	@>iI"5    end
    
    def function
      true
    end;Fi[	I"Vprojects//state_machine_proj/state_machine/integrations/active_record/versions.rb;Ti/I"ë          defined? I18n ? (super) : (var ? (var.to_s.humanize.downcase) : ("STRING"))
        end
        def function
          true
        end;Fi[	@Ãi2I"O          true
        end
        def function
          true
        end;Fi[	@Ãi5I"O          true
        end
        def function
          true
        end;Fi[	I"Uprojects//state_machine_proj/state_machine/integrations/mongo_mapper/versions.rb;Ti7I"P          false
        end
        def function
          true
        end;Fi[	@:@n
i2[2[	@cieI"U        private
        
        def function
          # do nothing
        end;Fi[	I"9projects//activemodel_proj/active_model/validator.rb;TiGI"∞    # that the arguments supplied are valid. You could for example raise an
    # +ArgumentError+ when invalid options are supplied.
    def function
      # do nothing
    end;Fi[	@®iÀI"ò      #
      # This is only relevant to certain associations, which is why it returns nil by default.
      def function
        # do nothing
      end;Fi[	@Ni)I"U    
    include(Module.new do
      def function
        # do nothing
      end;Fi[	I"^projects//activerecord_proj/active_record/connection_adapters/abstract/database_limits.rb;Ti-I"ï      # Returns the maximum number of elements in an IN (x,y,z) clause.
      # nil means no limit.
      def function
        # do nothing
      end;Fi[	@i I"}      
      # Begins the transaction (and turns off auto-committing).
      def function
        # do nothing
      end;Fi[	@iI"}      
      # Commits the transaction (and turns on auto-committing).
      def function
        # do nothing
      end;Fi[	@iI"»      # Rolls back the transaction (and turns on auto-committing). Must be
      # done if the transaction block raises an exception or returns false.
      def function
        # do nothing
      end;Fi[	@Üi˚I"±      # Returns a string of <tt>CREATE TABLE</tt> SQL statement(s) for recreating the
      # entire structure of the database.
      def function
        # do nothing
      end;Fi[	@Pi∑I"´      # checking whether the database is actually capable of responding, i.e. whether
      # the connection isn't stale.
      def function
        # do nothing
      end;Fi[	@Pi–I"®      # The default implementation does nothing; the implementation should be
      # overridden by concrete adapters.
      def function
        # do nothing
      end;Fi[	@Pi◊I"ƒ      # Clear any caching the database adapter may be doing, for example
      # clearing the prepared statement cache. This is database specific.
      def function
        # do nothing
      end;Fi[	@Pi¸I"G      end
      
      def function
        # do nothing
      end;Fi[	@Pi I"G      end
      
      def function
        # do nothing
      end;Fi[	@PiI"G      end
      
      def function
        # do nothing
      end;Fi[	@Ã	iÍI"i      module Fields
        class Type
          def function
            # do nothing
          end;Fi[	@siI"f      module OID
        class Type
          def function
            # do nothing
          end;Fi[	@iI"ô    # See also http://tenderlovemaking.com/2011/06/28/til-its-ok-to-return-nil-from-to_ary.html
    # :nodoc:
    def function
      # do nothing
    end;Fi[	@1ipI"k    
    # A hook to be overridden by association modules.
    def function
      # do nothing
    end;Fi[	@8i‰I"G      end
      
      def function
        # do nothing
      end;Fi[	@8iËI"G      end
      
      def function
        # do nothing
      end;Fi[	@õi2I"á      ##
      # Each subclass must define a +path+ where remote files will be stored
      def function
        # do nothing
      end;Fi[	@uiOI"j      ##
      # Note: Storage::RSync doesn't cycle
      def function
        # do nothing
      end;Fi[	@
i.I"Q        end
        
        def function
          # do nothing
        end;Fi[	@
iI"i  module Installers
    class BareInstaller < Base
      def function
        # do nothing
      end;Fi[	@
iI"G      end
      
      def function
        # do nothing
      end;Fi[	@õi&I"§      # The default prepare method -- it is a no-op.
      # Generally you would create required directories, etc.
      def function
        # do nothing
      end;Fi[	@∏i.I"G      end
      
      def function
        # do nothing
      end;Fi[	@ªiQI"G      end
      
      def function
        # do nothing
      end;Fi[	I"7projects//devise_proj/devise/models/recoverable.rb;TiQI"G      end
      
      def function
        # do nothing
      end;Fi[	I"Aprojects//devise_proj/devise/models/token_authenticatable.rb;Ti%I"m      
      # Hook called after token authentication.
      def function
        # do nothing
      end;Fi[	@’i:I"3  end
  
  def function
    # do nothing
  end;Fi[	I".projects//diaspora_proj/models/service.rb;Ti'I"3  end
  
  def function
    # do nothing
  end;Fi[	@ÏizI"=    end
    
    def function
      # do nothing
    end;Fi[	I"=projects//haml_proj/haml/helpers/safe_erubis_template.rb;TiI"nmodule Haml
  class SafeErubisTemplate < Tilt::ErubisTemplate
    def function
      # do nothing
    end;Fi[	I"-projects//homebrew_proj/extend/string.rb;Ti%I"=end
class NilClass
  def function
    # do nothing
  end;Fi[	I"9projects//nokogiri_proj/nokogiri/xml/sax/document.rb;TiI"v        ###
        # Called when document starts parsing
        def function
          # do nothing
        end;Fi[	@'iI"t        ###
        # Called when document ends parsing
        def function
          # do nothing
        end;Fi[	I"<projects//omni_proj/omniauth/test/strategy_test_case.rb;TiI"G      end
      
      def function
        # do nothing
      end;Fi[	@iI"=    end
    
    def function
      # do nothing
    end;Fi[	@iI"Ñ      #
      # This is where you POST or PUT or whatever to your Failure service.
      def function
        # do nothing
      end;Fi[	@”i1I"{          (action == "LITERAL") ? ("LITERAL") : (super)
        end
        def function
          # do nothing
        end;Fi[	@”i:I"W          true
        end
        def function
          # do nothing
        end;Fi[	@ci"I"±          (defined? ::Sequel::MAJOR.! or ((::Sequel::MAJOR == "LITERAL") and (::Sequel::MINOR <= "LITERAL")))
        end
        def function
          # do nothing
        end;Fi[	@ci%I"_          # do nothing
        end
        def function
          # do nothing
        end;Fi[	@:I"0assert_version_detected("STRING", "STRING");Fi1[1[	I"2projects//homebrew_proj/test/test_versions.rb;TiPI"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>iTI"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>iXI"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>i\I"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>i`I"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>idI"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>ihI"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>ilI"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>ipI"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>itI"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>ixI"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>i|I"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>i{I"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>iI"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>iÉI"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>iáI"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>iãI"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>ièI"|  end
  
  def function
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING");Fi[	@>iîI"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>iòI"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>iúI"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>i†I"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>i§I"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>i®I"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>i¨I"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>i∞I"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>i¥I"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>i∏I"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>iºI"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>i¿I"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>iƒI"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>i»I"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>iÃI"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>i–I"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>i‘I"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>iÿI"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>i‹I"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>i‡I"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>i‰I"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>iËI"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>iÏI"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>iI"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>iÙI"R  end
  
  def function
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>i¸I"È  #   assert_version_detected '7.0.4', 'http://www.haskell.org/ghc/dist/7.0.4/ghc-7.0.4-i386-apple-darwin.tar.bz2'
  # end
  def function
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING");Fi[	@I""LITERAL";Fi0[0[	@Ui9I"ê          when "LITERAL", "LITERAL" then
            "LITERAL"
          when "LITERAL" then
            "LITERAL"
          when "LITERAL" then;Fi[	@Ui;I"{          when "LITERAL" then
            "LITERAL"
          when "LITERAL" then
            "LITERAL"
          else;Fi[	@UiFI"ä          when "LITERAL" then
            case var
            when "LITERAL" then
              "LITERAL"
            when "LITERAL" then;Fi[	@UiHI"è            when "LITERAL" then
              "LITERAL"
            when "LITERAL" then
              "LITERAL"
            when "LITERAL" then;Fi[	@UiJI"Ä            when "LITERAL" then
              "LITERAL"
            when "LITERAL" then
              "LITERAL"
            else;Fi[	@UiOI"z              super
            end
          when "LITERAL" then
            "LITERAL"
          when "LITERAL" then;Fi[	@UiQI"Ö          when "LITERAL" then
            "LITERAL"
          when "LITERAL" then
            "LITERAL"
          when "LITERAL" then;Fi[	@UiSI"Ö          when "LITERAL" then
            "LITERAL"
          when "LITERAL" then
            "LITERAL"
          when "LITERAL" then;Fi[	@UiUI"Ö          when "LITERAL" then
            "LITERAL"
          when "LITERAL" then
            "LITERAL"
          when "LITERAL" then;Fi[	@UiWI"Ö          when "LITERAL" then
            "LITERAL"
          when "LITERAL" then
            "LITERAL"
          when "LITERAL" then;Fi[	@ièI"{      next if var.nil?
      var = case var.hash_type
      when "LITERAL" then
        "LITERAL"
      when "LITERAL" then;Fi[	@iëI"v      when "LITERAL" then
        "LITERAL"
      when "LITERAL" then
        "LITERAL"
      when "LITERAL" then;Fi[	@iìI"g      when "LITERAL" then
        "LITERAL"
      when "LITERAL" then
        "LITERAL"
      else;Fi[	@J
i§I"Ñ    File.open(self) { |var| var = var.read("LITERAL") }
    case var
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then;Fi[	@J
i¶I"l    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then;Fi[	@J
i®I"l    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then;Fi[	@J
i™I"l    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then;Fi[	@J
i¨I"l    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then;Fi[	@J
iÆI"l    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then;Fi[	@J
i∞I"]    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    else;Fi[	@Ói	I"å    @@cpu_type ||= `/usr/sbin/sysctl -n hw.cputype`.to_i
    case @@cpu_type
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then;Fi[	@ÓiI"]    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    else;Fi[	@ÓiI"ñ    @@intel_family ||= `/usr/sbin/sysctl -n hw.cpufamily`.to_i
    case @@intel_family
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then;Fi[	@ÓiI"l    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then;Fi[	@ÓiI"l    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then;Fi[	@ÓiI"l    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then;Fi[	@ÓiI"l    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then;Fi[	@ÓiI"l    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then;Fi[	@Ói!I"]    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    else;Fi[	@›
izI"l        when *var then
          "LITERAL"
        when "LITERAL" then
          "LITERAL"
        else;Fi[	@›
iÅI"~        when "STRING" then
          "LITERAL"
        when "LITERAL" then
          "LITERAL"
        when "STRING" then;Fi[	@›
iâI"        when "STRING" then
          "LITERAL"
        when "LITERAL" then
          "LITERAL"
        when "LITERAL" then;Fi[	@›
iãI"        when "LITERAL" then
          "LITERAL"
        when "LITERAL" then
          "LITERAL"
        when "STRING" then;Fi[	@›
ièI"~        when "STRING" then
          "LITERAL"
        when "LITERAL" then
          "LITERAL"
        when "STRING" then;Fi[	I"$projects//homebrew_proj/mach.rb;TiGI"i  def function
    case archs.length
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then;Fi[	I"%projects//homebrew_proj/macos.rb;TiQI"g  def function
    case default_cc
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then;Fi[	@·iSI"k    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    when "STRING" then;Fi[	I"3projects//homebrew_proj/test/test_compilers.rb;TiI"}    var.select_compiler
    assert_equal(case MacOS.clang_build_version
    when "LITERAL" then
      "LITERAL"
    else;Fi[	@ÊiYI"}    var.select_compiler
    assert_equal(case MacOS.clang_build_version
    when "LITERAL" then
      "LITERAL"
    else;Fi[	@zi´I"v  compare do |var|
    super(Version.new(case var
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then;Fi[	@zi≠I"l    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then;Fi[	@ziØI"l    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then;Fi[	@zi±I"]    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    else;Fi[	@@£i.[.[	@iÉI"ì      #  t.references(:user)
      #  t.belongs_to(:supplier, polymorphic: true)
      #
      def function(var)
        var = var.extract_options!;Fi[	@iêI"°      #  t.remove_references(:user)
      #  t.remove_belongs_to(:supplier, polymorphic: true)
      #
      def function(var)
        var = var.extract_options!;Fi[	@XiÔI"¯        #   0|0|0|SEARCH TABLE users USING INTEGER PRIMARY KEY (rowid=?) (~1 rows)
        #   0|1|1|SCAN TABLE posts (~100000 rows)
        #
        def function(var)
          (var.rows.map { |var| var.join("STRING") }.join("STRING") + "STRING");Fi[	@8i%I"û      #
      #   Account.reflect_on_aggregation(:balance) # => the balance AggregateReflection
      #
      def function(var)
        var = reflections[var];Fi[	@8i4I"'      #   Account.reflect_on_all_associations             # returns an array of all associations
      #   Account.reflect_on_all_associations(:has_many)  # returns an array of all has_many associations
      #
      def function(var)
        var = reflections.values.grep(AssociationReflection);Fi[	@8i>I"ˆ      #   Account.reflect_on_association(:owner)             # returns the owner AssociationReflection
      #   Invoice.reflect_on_association(:line_items).macro  # returns :has_many
      #
      def function(var)
        var = reflections[var];Fi[	@∏iåI"î    #   # SELECT DATEDIFF(updated_at, created_at) FROM people
    #   # => ['0', '27761', '173']
    #
    def function(var)
      var.map! do |var|;Fi[	@zi'I"ü      # @raise [Backup::Errors::Encryptor::GPG::InvalidModeError]
      #   if mode given is invalid.
      #
      def function(var)
        @var = var.to_sym;Fi[	@zi«I"≥      # If so, raise the returned error message.
      # Note that Cli::Helpers#run may also raise an error here.
      #
      def function(var)
        var = run("STRING").chomp;Fi[	@zi9I"Œ      # Strip out all spaces, upcase non-email identifiers,
      # and wrap email addresses in <> to perform exact matching.
      #
      def function(var)
        var = var.to_s.gsub("LITERAL", "STRING");Fi[	@≤i.I"À      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(var)
        var = case var;Fi[	@ü
iFI"–      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(var)
        var, var = case var;Fi[	@¢
iÄI"–      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(var)
        var, var = case var;Fi[	@πi,I"À      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(var)
        var = case var;Fi[	@¿i6I"À      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(var)
        var = case var;Fi[	@«i*I"À      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(var)
        var = case var;Fi[	@ãi6I"\    #
    #   cannot? :destroy, @project
    #
    def function(var)
      can?(*var).!;Fi[	@ñiI"ú      #     load_and_authorize_resource
      #   end
      #
      def function(var)
        cancan_resource_class.add_before_filter(self, "LITERAL", *var);Fi[	@ñisI"÷      # [:+prepend+]
      #   Passing +true+ will use prepend_before_filter instead of a normal before_filter.
      #
      def function(var)
        cancan_resource_class.add_before_filter(self, "LITERAL", *var);Fi[	@ñi©I"÷      # [:+prepend+]
      #   Passing +true+ will use prepend_before_filter instead of a normal before_filter.
      #
      def function(var)
        cancan_resource_class.add_before_filter(self, "LITERAL", *var);Fi[	@ñiˆI"™      #
      #     check_authorization :unless => :devise_controller?
      #
      def function(var)
        self.after_filter(var.slice("LITERAL", "LITERAL")) do |var|;Fi[	@ñiwI"m    #
    #   cannot? :destroy, @project
    #
    def function(var)
      current_ability.cannot?(*var);Fi[	@≥i]I"Æ      #   sign_out :user     # sign_out(scope)
      #   sign_out @user     # sign_out(resource)
      #
      def function(var)
        return sign_out_all_scopes unless var;Fi[	@≥i~I"î      #
      #   redirect_to stored_location_for(:user) || root_path
      #
      def function(var)
        var = Devise::Mapping.find_scope!(var);Fi[	@≥i•I"~      #       end
      #   end
      #
      def function(var)
        (stored_location_for(var) or signed_in_root_path(var));Fi[	I"4projects//devise_proj/devise/mailers/helpers.rb;TiTI"ˆ      #         confirmation_instructions:
      #           subject: '...'
      #
      def function(var)
        I18n.t(:"#{devise_mapping.name}STRING", "LITERAL" => (["LITERAL", "LITERAL", var]), "LITERAL" => (["LITERAL", var.to_s.humanize]));Fi[	@°i2I"¬    # with specific values for this model. Please check your Devise initializer
    # for a complete description on those values.
    #
    def function(var)
      var = var.extract_options!.dup;Fi[	@æi≥I"ü    #       post "deactivate", :to => "registrations#deactivate", :as => "deactivate_registration"
    #     end
    #
    def function(var)
      @var = false;Fi[	@æiI"ô    #
    #   root :to => 'dashboard#show'
    #
    def function(var)
      var = lambda { |var| var.env["STRING"].authenticate?("LITERAL" => (var)).! };Fi[	@Qi3I"•    #   sign_out :user     # sign_out(scope)
    #   sign_out @user     # sign_out(resource)
    #
    def function(var)
      var = Devise::Mapping.find_scope!(var);Fi[	@3
i≤I"    #   (however, "x?," is a method call and not a literal)
    # - and not "?\," which is a character literal
    #
    def function(var)
      var and ((var.length > "LITERAL") and ((var["LITERAL"] == "STRING") and (var["LITERAL"] =~ "LITERAL" or (var["LITERAL"] == "STRING")).!));Fi[	@’i>I"é      #     config.format.as_xml
      #   end
      #
      def function(var)
        var["LITERAL"] ||= XML::Node::SaveOptions::DEFAULT_HTML;Fi[	@ÿiÜI"z      #     end
      #   }.new)
      #
      def function(var)
        return NodeSet.new(document) unless document;Fi[	@ÿi∑I"¬      # found in an XML document, where tags names are case-sensitive
      # (e.g., "H1" is distinct from "h1").
      #
      def function(var)
        var, var, var, var = extract_params(var);Fi[	@ÿi‘I"ò      # Equivalent to <tt>xpath(paths).first</tt>
      # See Node#xpath for more information.
      #
      def function(var)
        xpath(*var).first;Fi[	@ÿi›I"í      # Equivalent to <tt>css(rules).first</tt>
      # See Node#css for more information.
      #
      def function(var)
        css(*var).first;Fi[	@(iÑI"õ      # Equivalent to <tt>xpath(paths).first</tt>
      # See NodeSet#xpath for more information.
      #
      def function(var)
        xpath(*var).first;Fi[	@(içI"ï      # Equivalent to <tt>css(rules).first</tt>
      # See NodeSet#css for more information.
      #
      def function(var)
        css(*var).first;Fi[	I"5projects//paperclip_proj/paperclip/validators.rb;TiI"∑      #      :content_type => { :content_type => "image/jpg" },
      #      :size => { :in => 0..10.kilobytes }
      #
      def function(var)
        var = var.extract_options!.dup;Fi[	@;iDI"“    # and breaks it into variable/value pairs. Used for setting variables at runtime from the command line.
    # Only works for setting values as strings.
    #
    def function(var)
      return if var.blank?;Fi[	@;i`I"Î    # at 3:02am and 4:02am, instead of creating two jobs this method combines
    # them into one that runs on the 2nd minute at the 3rd and 4th hour.
    #
    def function(var)
      var.map! { |var| var.split("LITERAL", "LITERAL") };Fi[	I"#   #    ];F@i,[,[	@≤i.I"π      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.select(:name);Ti[	@≤i5I"¶      #   #      #<Pet id: nil, name: "Spook">,
      #   #      #<Pet id: nil, name: "Choo-Choo">
      #   #    ]
      #
      #   person.pets.select([:id, :name]);Ti[	@≤i<I"√      #   #      #<Pet id: 2, name: "Spook">,
      #   #      #<Pet id: 3, name: "Choo-Choo">
      #   #    ]
      #
      # Be careful because this also means you√¢¬Ä¬ôre initializing a model;Ti[	@≤iOI"“      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.select(:name) { |pet| pet.name =~ /oo/ };Ti[	@≤igI"Ë      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.find(1) # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>;Ti[	@≤iÄI"Ê      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.first # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>;Ti[	@≤iàI"Ã      #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>
      #   #    ]
      #
      #   another_person_without.pets          # => [];Ti[	@≤iûI"„      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.last # => #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤i¶I"…      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   another_person_without.pets         # => [];Ti[	@≤i√I"”      #   #      #<Pet id: nil, name: "Choo-Choo", person_id: 1>,
      #   #      #<Pet id: nil, name: "Brain", person_id: 1>
      #   #    ]
      #
      #   person.pets.size  # => 5 # size of the collection;Ti[	@≤i⁄I"∂      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size  # => 3;Ti[	@≤iI"‰      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.concat([Pet.new(name: 'Brain'), Pet.new(name: 'Benny')]);Ti[	@≤iBI"∂      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all;Ti[	@≤iII"∑      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size # => 0;Ti[	@≤iSI"Á      #   #       #<Pet id: 2, name: "Spook", person_id: nil>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: nil>
      #   #    ]
      #
      # If it is set to <tt>:destroy</tt> all the objects from the collection;Ti[	@≤icI"∂      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all;Ti[	@≤ijI"±      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1, 2, 3);Ti[	@≤i|I"∂      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all;Ti[	@≤iÉI"±      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1, 2, 3);Ti[	@≤iôI"∑      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy_all;Ti[	@≤iπI"ø      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1));Ti[	@≤i√I"´      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1);Ti[	@≤i’I"Ã      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1), Pet.find(3));Ti[	@≤i€I"Ω      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size # => 1;Ti[	@≤iÒI"ø      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1));Ti[	@≤i˚I"´      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1);Ti[	@≤iI"∑      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete("1");Ti[	@≤i)I"¿      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy(Pet.find(1));Ti[	@≤i3I"Õ      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy(Pet.find(2), Pet.find(3));Ti[	@≤i9I"∏      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size  # => 0;Ti[	@≤iII"¥      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy("4");Ti[	@≤iSI"µ      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy(5, 6);Ti[	@≤iYI"¥      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   person.pets.size  # => 0;Ti[	@≤imI"ö      #   #      #<Pet name: "Fancy-Fancy">,
      #   #      #<Pet name: "Fancy-Fancy">
      #   #    ]
      #
      #   person.pets.select(:name).uniq;Ti[	@≤iôI"∑      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size # => 3;Ti[	@≤iI"ß      #   #      #<Pet name: "Puff", group: "cats">,
      #   #      #<Pet name: "Snoop", group: "dogs">
      #   #    ]
      #
      #   person.pets.many? do |pet|;Ti[	@≤iGI"∫      #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>
      #   #    ]
      #
      #   other = person.pets.to_ary;Ti[	@≤ibI"ª      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   other_pets = person.pets.to_ary;Ti[	@≤iiI"…      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   other_pets.replace([Pet.new(name: 'BooGoo')]);Ti[	I"var;F@|i,[,[	@9iÃI"          var[var] = var.map { |var| full_message(var, var) }
        end
        var
      else
        self.messages.dup;Fi[	@KiI"ê        if aliases[var].zero? then
          aliases[var] = "LITERAL"
          var
        else
          var = connection.table_alias_for(var);Fi[	@ØiYI"e              var[var] = var[var]
            end
            var
          else
            var;Fi[	@∞i%I"µ          include(Behavior)
          var = if ["LITERAL", "LITERAL"].all? { |var| var.respond_to?(var) } then
            var
          else
            Coders::YAMLColumn.new(var);Fi[	@gi=I"Å      def function
        if var = @available.poll then
          var
        else
          if (@connections.size < @size) then;Fi[	@iFI"•      def function(var)
        if (var.is_a?(Integer) or var.is_a?(Arel::Nodes::SqlLiteral)) then
          var
        else
          if var.to_s =~ "LITERAL" then;Fi[	@Üi/I"K            end
          end
          var
        else
          var;Fi[	@ìiåI"h          case var
          when "STRING" then
            var
          else
            "STRING";Fi[	@8i	I"∆        if has_inverse? then
          if var = var.reflect_on_association(options["LITERAL"]) then
            var
          else
            raise(InverseOfAssociationNotFoundError.new(self, var));Fi[	@‹	iI"b      end
      if (var.size == var) then
        var
      else
        var = arel.where_sql;Fi[	@äinI"e            end.reverse
          end
          var
        else
          relation.where_values;Fi[	I"Lprojects//activerecord_proj/active_record/relation/predicate_builder.rb;Ti0I"t      var.map do |var, var|
        if var.is_a?(Hash) then
          var
        else
          var = var.to_s;Fi[	@QiÁI"i        var = var.merge(self)
        var.default_scoped = false
        var
      else
        self;Ti[	I">projects//activerecord_proj/active_record/sanitization.rb;TiI"û          else
            if var.blank? then
              var
            else
              (var % var.collect { |var| connection.quote_string(var.to_s) });Fi[	I"7projects//activerecord_proj/active_record/store.rb;Ti=I"√      def function(var)
        @var = if var.respond_to?("LITERAL") and var.respond_to?("LITERAL") then
          var
        else
          ActiveRecord::Coders::YAMLColumn.new((var or Object));Fi[	@ziI"ò          var = clean_identifier(var)
          if system_identifiers.include?(var) then
            var
          else
            var = user_keys[var];Fi[	@îi{I"      def function
        if var = top_level.fonts_dir_without_default then
          var
        else
          "STRING";Fi[	@îi®I"é      def function(var)
        if (File::SEPARATOR == "STRING") then
          var
        else
          var.gsub(File::SEPARATOR, "STRING");Fi[	I"<projects//compass_proj/compass/configuration/helpers.rb;Ti!I"î        else
          if var.is_a?(Compass::Configuration::Data) then
            var
          else
            if var.respond_to?("LITERAL") then;Fi[	@
ikI"      else
        if var = var.manifest(var).help then
          var
        else
          "STRING".gsub("LITERAL", "STRING");Fi[	@¶i›I"ö      Sass::Script::List.new(var.map do |var|
        if ColorStop.===(var) then
          var
        else
          if Sass::Script::Color.===(var) then;Fi[	@Ni5I"è        else
          if respond_to?("LITERAL") and var = authenticatable_salt then
            var
          else
            raise("STRING");Fi[	I":projects//diaspora_proj/helpers/markdownify_helper.rb;Ti#I"n    var.gsub("LITERAL") do |var|
      if var =~ "LITERAL" then
        var
      else
        var.strip!;Fi[	I"7projects//diaspora_proj/helpers/notifier_helper.rb;TiI"≈      var = truncate(var.formatted_message("LITERAL" => (true)), "LITERAL" => (var["LITERAL"]))
      var = process_newlines(var) if var["LITERAL"]
      var
    else
      I18n.translate("STRING");Fi[	I"3projects//diaspora_proj/models/notification.rb;Ti"I"h        if var then
          var.email_the_user(var, var)
          var
        else
          nil;Fi[	@”iNI"Y        nil
      end
      var
    else
      make_notification(var, var, var, var);Fi[	@Ïi!I"ñ    def function(var, var, var)
      var = if (var.! or (@dont_indent_next_line or @options["LITERAL"])) then
        var
      else
        "STRING";Fi[	I"9projects//haml_proj/haml/helpers/action_view_mods.rb;TiwI"º          var = (form_tag_without_haml(var, var, *var, &var) + "STRING")
          (var << "STRING") if var
          var
        else
          form_tag_without_haml(var, var, *var, &var);Fi[	@ÈiÌI"Õ  def self.detect(var, var)
    if var.is_a?(Class) and var.ancestors.include?(AbstractDownloadStrategy) then
      var
    else
      var.is_a?(Symbol) ? (detect_from_symbol(var)) : (detect_from_url(var));Fi[	@ıi*I"ü    @var ||= (var = Pathname.new(folder)
    if var.absolute? and (var / "STRING").executable? then
      var
    else
      if File.executable?("STRING") then;Fi[	I"Nprojects//homebrew_proj/vendor/multi_json/adapters/nsjsonserialization.rb;TiI"É        if var then
          var = symbolize_keys(var) if var["LITERAL"]
          var
        else
          super(var, var = {});Fi[	@Z
i I"å      var = self.converters.select { |var| (var.class == var) }
      if var = var.first then
        var
      else
        raise("STRING");Fi[	@ÿieI"°          var = var.to_s
          if var =~ "LITERAL" then
            var
          else
            CSS.xpath_for(var, "LITERAL" => (var), "LITERAL" => (var));Fi[	@€iYI"|        var = options[var].call(env)
        return nil unless var.is_a?(String)
        var
      else
        options[var];Fi[	I"9projects//paperclip_proj/paperclip/interpolations.rb;TioI"ù      else
        if var.include?(var) then
          var
        else
          var.empty?.! ? (var.first) : ("LITERAL".match(var.content_type)["LITERAL"]);Fi[	@	ióI"í          YAML.load(ERB.new(File.read(var)).result)
        when Hash then
          var
        else
          if var.respond_to?("LITERAL") then;Fi[	@ci˝I"é          YAML.load(ERB.new(File.read(var)).result)
        when Hash then
          var
        else
          raise(ArgumentError, "STRING");Fi[	@]i-I"V        var = new(*var)
        var.to_s = var
        var
      else
        nil;Fi[	I"Lprojects//state_machine_proj/state_machine/integrations/active_model.rb;Ti∞I"           @callbacks[((var == "LITERAL") ? ("LITERAL") : (var))].insert("LITERAL", (var = Callback.new(var, var, &var)))
          add_states(var.known_states)
          var
        else
          super;Fi[	@:I"
super;Fi,[,[	I"/projects//activemodel_proj/active_model.rb;Ti:I"N  end
  
  def function
    super
    ActiveModel::Serializer.eager_load!;Fi[	I"Uprojects//activerecord_proj/active_record/associations/belongs_to_association.rb;TiI"K      end
      
      def function
        super
        @var = false;Fi[	@ki>I"r    end
    
    def function
      super
      mixin.class_eval("STRING", "STRING", ("LITERAL" + "LITERAL"));Fi[	@kiCI"r    end
    
    def function
      super
      mixin.class_eval("STRING", "STRING", ("LITERAL" + "LITERAL"));Fi[	I"^projects//activerecord_proj/active_record/associations/builder/has_and_belongs_to_many.rb;TiI"Y    end
    
    def function
      super
      ["LITERAL", "LITERAL"].each do |var|;Fi[	@niI"Z    end
    
    def function
      super
      define_constructors if constructable?;Fi[	@Øi$I"H      end
      
      def function
        super
        @var = [];Fi[	@iI"y  module ConnectionAdapters
    module DatabaseStatements
      def function
        super
        reset_transaction;Fi[	@ÅiFI"J      end
      
      def function
        super
        disconnect!;Fi[	@ÅiPI"Æ      # Disconnects from the database if already connected.
      # Otherwise, this method does nothing.
      def function
        super
        unless @connection.nil? then;Fi[	@Ã	i≠I"J      end
      
      def function
        super
        disconnect!;Fi[	@Ã	iµI"Æ      # Disconnects from the database if already connected. Otherwise, this
      # method does nothing.
      def function
        super
        @connection.close rescue nil;Fi[	@Ã	iÕI"›      # Many Rails applications monkey-patch a replacement of the configure_connection method
      # and don't call 'super', so leave this here even though it looks superfluous.
      def function
        super
      end;Fi[	@XióI"û      # Disconnects from the database if already connected. Otherwise, this
      # method does nothing.
      def function
        super
        @var = false;Fi[	I"@projects//activerecord_proj/active_record/log_subscriber.rb;TiI"A    end
    
    def function
      super
      @var = false;Fi[	I"3projects//backup_proj/backup/database/mysql.rb;Ti6I"¨      # Performs the mysqldump command and outputs the
      # data to the specified path based on the 'trigger'
      def function
        super
        var = Pipeline.new;Fi[	I"8projects//backup_proj/backup/database/postgresql.rb;Ti6I"©      # Performs the pgdump command and outputs the
      # data to the specified path based on the 'trigger'
      def function
        super
        var = Pipeline.new;Fi[	@fi4I"€      # the Redis server to persist the current state to the dump file
      # before copying the dump to get the most recent updates in to the backup
      def function
        super
        invoke_save! if invoke_save;Fi[	@ii%I"Ã      # Performs the riak-admin command and outputs the
      # data to the specified path based on the 'trigger'
      def function
        super
        FileUtils.chown_R("STRING", "STRING", @dump_path);Fi[	I"6projects//backup_proj/backup/syncer/cloud/base.rb;Ti'I"¡        # the Cloud specific defaults are set here before evaluating
        # any block provided in the user's configuration file.
        def function
          super
          @var ||= false;Fi[	@ÉiI"ü        # Instantiates a new RSync Syncer object
        # and sets the default configuration
        def function
          super
          @var ||= Array.new;Fi[	I"<projects//compass_proj/compass/commands/project_base.rb;TiI"@      end
      
      def function
        super
      end;Fi[	I"0projects//compass_proj/compass/test_case.rb;TiI"Q    Test::Unit::TestCase
  end
    def function
      super
      @var = nil;Fi[	I"7projects//devise_proj/devise/models/confirmable.rb;TißI"Y      end
      
      def function
        super
        confirm! unless confirmed?;Fi[	I"Dprojects//diaspora_proj/controllers/registrations_controller.rb;TiI",  end
  
  def function
    super
  end;Fi[	@ˇi—I"–      # Processes the options set by the command-line arguments,
      # and runs the Haml compiler appropriately.
      def function
        super
        @options["LITERAL"]["LITERAL"] = @options["LITERAL"];Fi[	@J
i\I"fend
module ObserverPathnameExtension
  def function
    super
    puts("STRING") if ARGV.verbose?;Fi[	@J
ibI"J  end
  
  def function
    super
    puts("STRING") if ARGV.verbose?;Fi[	@J
imI"J  end
  
  def function
    super
    puts("STRING") if ARGV.verbose?;Fi[	@J
irI"J  end
  
  def function
    super
    puts("STRING") if ARGV.verbose?;Fi[	@ÛirI"Ñ      
      # Initializes class-level extensions and defaults for this machine
      def function
        super
        load_locale;Fi[	@ÛiñI"®      
      # Adds hooks into validation for automatically firing events
      def function
        super
        define_validation_hook if runs_validations_on_action?;Fi[	@Ãi>I"Õ          (action == "LITERAL") ? ("LITERAL") : (super)
        end
        def function
          super
          unless (::ActiveRecord::Observer < StateMachine::Integrations::ActiveModel::Observer) then;Fi[	@	i2I"ë      
      # Initializes class-level extensions and defaults for this machine
      def function
        super
        load_observer_extensions;Fi[	@	ijI"™      
      # Adds hooks into validation for automatically firing events
      def function
        super
        if (action == "LITERAL") and supports_validations? then;Fi[	I"Fprojects//state_machine_proj/state_machine/integrations/sequel.rb;TiWI"≠      
      # Defines validation hooks if the machine's action is to save the model
      def function
        super
        define_validation_hook if (action == "LITERAL");Fi[	@k
i’I"X    
    # Resets callback tracking
    def function
      super
      @var = false;Fi[	@k
i€I"É    
    # Resets the event attribute so it can be re-evaluated if attempted again
    def function
      super
      each do |var|;Fi[	I"Zprojects//state_machine_proj/state_machine/yard/templates/default/class/html/setup.rb;TiI"ërequire("tempfile")
# Define where state machine descriptions will be rendered
def function
  super
  sections.place("LITERAL").before("LITERAL");Fi[	@£@ø	i+[+[	@òiÂI"Æ    #   person.valid?       # => true
    #   person.valid?(:new) # => false
    def function(var)
      begin
        (var, self.validation_context = validation_context, var;Fi[	I"[projects//activerecord_proj/active_record/associations/has_many_through_association.rb;TiSI"e      end
      
      def function(var)
        begin
          build_through_record(var).save!;Fi[	@gigI"»        # Waits on the queue up to +timeout+ seconds, then removes and
        # returns the head of the queue.
        def function(var)
          begin
            (@var = (@num_waiting + "LITERAL");Fi[	@i¡I"
      # because they are affected by a bug[http://bugs.mysql.com/bug.php?id=39170]
      # which means the isolation level gets persisted outside the transaction.
      def function(var)
        begin
          (var.assert_valid_keys("LITERAL", "LITERAL", "LITERAL");Fi[	@iœI"c      end
      
      def function(var)
        begin
          (var = begin_transaction(var);Fi[	@UiI"X      end
      
      def function(var)
        begin
          (execute("STRING");Fi[	@[iLI"]      end
      
      def function(var)
        begin
          require_dependency(var);Fi[	@ iÉI"b      end
      
      def function(var)
        begin
          if store_full_sti_class then;Fi[	@1iaI"è    # +save+ returns +false+. See ActiveRecord::Callbacks for further
    # details.
    def function(var)
      begin
        create_or_update;Fi[	@ƒiI"t    end
    
    def function(var)
      begin
        (var = ActiveRecord::Base.connection.query_cache_enabled;Fi[	@‹	iöI"}    #   Person.exists?(false)
    #   Person.exists?
    def function(var)
      begin
        (var = var.id if Base.===(var);Fi[	I"Fprojects//activerecord_proj/active_record/tasks/database_tasks.rb;Ti)I"V      end
      
      def function(var)
        begin
          (var = var.first;Fi[	@miBI"V      end
      
      def function(var)
        begin
          (var = var.first;Fi[	@ŒiI"m      end
      
      def function(var)
        begin
          (establish_master_connection unless var;Fi[	@„	ioI"    # Call the after rollback callbacks. The restore_state argument indicates if the record
    # state should be rolled back to the beginning or just to the last savepoint.
    def function(var)
      begin
        run_callbacks("LITERAL");Fi[	@®itI"Q      end
      
      def function(var)
        begin
          (@var = var;Fi[	@ÏiI"y    end
    
    def function(var)
      begin
        (var = instance_variable_defined?("STRING") ? (@node) : (nil);Fi[	@ÔiI"∫    # @param i [Fixnum] The number of tabs to use
    # @yield A block in which the indentation will be `i` spaces
    def function(var)
      begin
        (var = haml_buffer.tabulation;Fi[	@Ôi5I"Ã    # @param buffer [Haml::Buffer] The Haml buffer to use temporarily
    # @yield A block in which the given buffer should be used
    def function(var)
      begin
        (@var, var = var, @haml_buffer;Fi[	@iWI"J    end
    
    def function(var)
      begin
        (var = var.pos;Fi[	@8
iqI"q  end
end
def function(var)
  begin
    (var = if var.linked_keg.directory? and var.linked_keg.symlink? then;Fi[	@¯izI"@  end
  
  def function(var)
    begin
      (var = $stdout;Fi[	I"(projects//homebrew_proj/cmd/info.rb;TiBI"k  end
  
  def function(var)
    begin
      (exec("STRING", github_info(var)) if ARGV.flag?("STRING");Fi[	@»
iSI"R  end
  
  def function(var)
    begin
      (var = FormulaInstaller.new(var);Fi[	I"+projects//homebrew_proj/cmd/upgrade.rb;Ti0I"V  end
  
  def function(var)
    begin
      (var = if var.opt_prefix.exist? then;Fi[	@—ijI"M  end
  
  def function(var)
    begin
      (var = Tab.for_formula(var);Fi[	@‘iI"P  end
  
  def function(var)
    begin
      var.verify_checksum(@checksum);Fi[	@›
icI"b  end
  
  def function(var)
    begin
      (raise("STRING") if linked_keg_record.directory?;Fi[	@›
iØI"_  protected
  
  def function(var)
    begin
      if var.symlink? and var.directory? then;Fi[	@
i[I"z    #
    # Returns nothing.
    def function(var)
      begin
        (var, var, var, var, var = *var.match(MATCHER);Fi[	@ViFI"m        end
        
        def function(var)
          begin
            (var = StringIO.new("STRING");Fi[	@ci§I"|      end
      
      def function(var)
        begin
          original_filename ? (s3_object(var).exists?) : (false);Fi[	@iùI"O    end
    
    def function(var)
      begin
        (var = (args or []);Fi[	I"/projects//rescue_proj/resque/json_coder.rb;Ti	I"emodule Resque
  class JsonCoder < Coder
    def function(var)
      begin
        JSON.dump(var);Fi[	@]iùI"Ä    
    # Processes a given job in the child.
    def function(var)
      begin
        (run_hook("LITERAL", var) if will_fork?;Fi[	@`i⁄I"\  #
  # Returns a Ruby object.
  def function(var)
    begin
      queue(var).pop(true);Fi[	@giI"J    end
    
    def function(var)
      begin
        @app.call(var);Fi[	@oiAI"É    #
    # @param method [String, Symbol] Message to send to the object
    def function(var)
      begin
        send(var.to_sym);Fi[	@I"#   class Person;Fi*[*[	@ i#I"√      # An instance method <tt>#{prefix}attribute</tt> must exist and accept
      # at least the +attr+ argument.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods;Fi[	@ iGI"√      # An <tt>attribute#{suffix}</tt> instance method must exist and accept at
      # least the +attr+ argument.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods;Fi[	@ ikI"Ã      # An <tt>#{prefix}attribute#{suffix}</tt> instance method must exist and
      # accept at least the +attr+ argument.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods;Fi[	@ iÅI"ä      
      # Allows you to make aliases for attributes.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods;Fi[	@ ißI"À      # +define_attribute_methods+ after you define any prefix, suffix or affix
      # methods, or they will not hook in.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods;Fi[	@ i√I"…      # +define_attribute_method+ after you define any prefix, suffix or affix
      # method, or they will not hook in.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods;Fi[	@ iÍI"¶      
      # Removes all the previously dynamically defined methods from the class.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods;Fi[	@0iI"®    # you can use the default <tt>:to_model</tt> implementation, which simply
    # returns +self+.
    #
    #   class Person
    #     include ActiveModel::Conversion;Fi[	@0i6I"›    # Returns a +string+ identifying the path associated with the object.
    # ActionPack uses this to find a suitable partial to represent the object.
    #
    #   class Person
    #     include ActiveModel::Conversion;Fi[	@9iI"Ç    
    # Pass in the instance of the object that is using the errors object.
    #
    #   class Person
    #     def initialize;Fi[	@9iI"é    
    # Returns all the full error messages in an array.
    #
    #   class Person
    #     validates_presence_of :name, :address, :email;Fi[	@>iI"{    
    # Initializes a new model with the given +params+.
    #
    #   class Person
    #     include ActiveModel::Model;Fi[	@]i
I"é  module Serialization
    # Returns a serialized hash of your object.
    #
    #   class Person
    #     include ActiveModel::Serialization;Fi[	@`ieI"†      
      # Sets the model +attributes+ from a JSON string. Returns +self+.
      #
      #   class Person
      #     include ActiveModel::Serializers::JSON;Fi[	@ci¡I"ü      
      # Sets the model +attributes+ from a JSON string. Returns +self+.
      #
      #   class Person
      #     include ActiveModel::Serializers::Xml;Fi[	@liI"Æ        # Defines a callback that will get called right before validation
        # happens.
        #
        #   class Person
        #     include ActiveModel::Validations;Fi[	@li4I"≠        # Defines a callback that will get called right after validation
        # happens.
        #
        #   class Person
        #     include ActiveModel::Validations;Fi[	@Çi#I"n      #     end
      #   end
      #
      #   class Person
      #     include ActiveModel::Validations;Fi[	@ÇiI"ª      # when validation fails. See <tt>validates</tt> for more information about
      # the validation itself.
      #
      #   class Person
      #     include ActiveModel::Validations;Fi[	@ãi I"”      # Passes the record off to the class or classes specified and allows them
      # to add errors based on more complex conditions.
      #
      #   class Person
      #     include ActiveModel::Validations;Fi[	@ãi4I"ã      #
      # You may also pass it multiple classes, like so:
      #
      #   class Person
      #     include ActiveModel::Validations;Fi[	@ãiMI"       # If you pass any additional configuration options, they will be passed
      # to the class and available as +options+:
      #
      #   class Person
      #     include ActiveModel::Validations;Fi[	@ãiiI"…    # Passes the record off to the class or classes specified and allows them
    # to add errors based on more complex conditions.
    #
    #   class Person
    #     include ActiveModel::Validations;Fi[	@ãixI"Å    #
    # You may also pass it multiple classes, like so:
    #
    #   class Person
    #     include ActiveModel::Validations;Fi[	@òiI"ï    module ClassMethods
      # Validates each attribute against a block.
      #
      #   class Person
      #     include ActiveModel::Validations;Fi[	@òiyI"∏      # List all validators that are being used to validate the model using
      # +validates_with+ method.
      #
      #   class Person
      #     include ActiveModel::Validations;Fi[	@òiàI"§      
      # List all validators that are being used to validate a specific attribute.
      #
      #   class Person
      #     include ActiveModel::Validations;Fi[	@òiπI"®    # Returns the +Errors+ object that holds all information about attribute
    # error messages.
    #
    #   class Person
    #     include ActiveModel::Validations;Fi[	@òi I"≤    # Runs all the specified validations and returns +true+ if no errors were
    # added otherwise +false+.
    #
    #   class Person
    #     include ActiveModel::Validations;Fi[	@òi⁄I"ﬁ    # Context can optionally be supplied to define which callbacks to test
    # against (the context is defined on the validations using <tt>:on</tt>).
    #
    #   class Person
    #     include ActiveModel::Validations;Fi[	@òiÒI"≥    # Performs the opposite of <tt>valid?</tt>. Returns +true+ if errors were
    # added, +false+ otherwise.
    #
    #   class Person
    #     include ActiveModel::Validations;Fi[	@òiI"ﬁ    # Context can optionally be supplied to define which callbacks to test
    # against (the context is defined on the validations using <tt>:on</tt>).
    #
    #   class Person
    #     include ActiveModel::Validations;Fi[	@≤i≥I"•      # You can pass an array of attributes hashes, this will return an array
      # with the new objects.
      #
      #   class Person
      #     has_many :pets;Ti[	@≤iŒI"´      # attributes, linked to this object and that has already been saved (if it
      # passes the validations).
      #
      #   class Person
      #     has_many :pets;Ti[	@≤iÍI"í      
      # Like +create+, except that if the record is invalid, raises an exception.
      #
      #   class Person
      #     has_many :pets;Ti[	@8iëI"q      
      # Consider the following example:
      #
      #   class Person
      #     has_many :articles;Fi[	@·iI"ö    # Below are examples of the various ways that a method can be evaluated
    # on an object:
    # 
    #   class Person
    #     def initialize(name);Fi[	@|@öi*[*[	@9ilI"K      when Proc then
        var.call
      else
        var
      end;Fi[	I"Oprojects//activemodel_proj/active_model/forbidden_attributes_protection.rb;TiI"ì      if var.respond_to?("LITERAL") and var.permitted?.! then
        raise(ActiveModel::ForbiddenAttributesError)
      else
        var
      end;Fi[	@ØiZI"Q            end
            var
          else
            var
          end;Fi[	I"Rprojects//activerecord_proj/active_record/associations/through_association.rb;Ti0I"á        if (var.count == "LITERAL") then
          Hash[var.map { |var, var| [var, var.first] }]
        else
          var
        end;Fi[	@iI"~          var = var.dup
          visitor.accept(var.ast) { quote(*var.shift.reverse) }
        else
          var
        end;Fi[	@KiBI"d          when "LITERAL" then
            var.to_f
          else
            var
          end;Fi[	@Üi0I"G          end
          var
        else
          var
        end;Fi[	@ìi)I"e                [var, var]
              end]
            else
              var
            end;Fi[	@ìieI"l                end
                (var..var)
              else
                var
              end;Fi[	@ìivI"†                [var.first, var.last].all? { |var| NilClass.===(var) } ? ("STRING") : (nil)
              end
            else
              var
            end;Fi[	@Ç
ièI"h            end
            last_insert_id_result(var)
          else
            var
          end;Fi[	@siLI"®            if String.===(var) then
              ConnectionAdapters::PostgreSQLColumn.string_to_array(var, @subtype)
            else
              var
            end;Fi[	@i`I"¨        if finder_needs_type_condition? then
          var.where(type_condition).create_with(inheritance_column.to_sym => (sti_name))
        else
          var
        end;Fi[	@[iaI"¶              var = if var.model_class.respond_to?("LITERAL") then
                var.model_class.connection
              else
                var
              end;Fi[	@ç
i´I"U        when Proc then
          var.call
        else
          var
        end;Fi[	@∏iëI"Ñ        if var.is_a?(Symbol) and self.column_names.include?(var.to_s) then
          "STRING"
        else
          var
        end;Fi[	@Ji›I"\        var ||= "STRING"
        var.arel.as(var.to_s)
      else
        var
      end;Fi[	@JiI"            var[var] = (var == "LITERAL") ? ("LITERAL") : ("LITERAL")
          end
        else
          var
        end;Fi[	@Ji+I"x        when Hash then
          var.map { |var, var| table[var].send(var) }
        else
          var
        end;Fi[	@∏i!I"w        when Hash then
          sanitize_sql_hash_for_conditions(var, var)
        else
          var
        end;Fi[	@∏i1I"r        when Hash then
          sanitize_sql_hash_for_assignment(var)
        else
          var
        end;Fi[	@ãiıI"Ç        if aliased_actions[var] then
          [var, *expand_actions(aliased_actions[var])]
        else
          var
        end;Fi[	@*iZI"d            File.join(var, var["LITERAL"])
          end
        else
          var
        end;Fi[	I"=projects//compass_proj/compass/configuration/adapters.rb;Ti*I"¶          if var.is_a?(String) and (project_path and absolute_path?(var).!) then
            File.join(project_path, var)
          else
            var
          end;Fi[	@ƒiÅI"õ        if (var[("LITERAL"..(var.size - "LITERAL"))] == var) then
          var[((var.size + "LITERAL").."LITERAL")]
        else
          var
        end;Fi[	@ÀiNI"Y        when "STRING" then
          "STRING"
        else
          var
        end;Fi[	@£i?I"l          var.options = options
          var.send(:"to_#{var}")
        else
          var
        end;Fi[	@¶i”I"|        when "LITERAL" then
          Sass::Script::Number.new("LITERAL", ["STRING"])
        else
          var
        end;Fi[	I"Fprojects//compass_proj/compass/sass_extensions/functions/lists.rb;Ti^I"Ñ      if defined? Sass::Script::List and var.is_a?(Sass::Script::List) then
        var.value.first
      else
        var
      end;Fi[	I"Hprojects//compass_proj/compass/sass_extensions/functions/sprites.rb;Ti»I"i    when Sass::Script::Bool then
      Sass::Script::String.new(var.to_s)
    else
      var
    end;Fi[	@QiGI"è        if (var.first == "LITERAL") and intercept_401?(var) then
          _process_unauthenticated(var)
        else
          var
        end;Fi[	@QiLI"e      when Hash then
        _process_unauthenticated(var, var)
      else
        var
      end;Fi[	I"1projects//haml_proj/haml/helpers/xss_mods.rb;TirI"h        when String then
          Haml::Util.html_safe(var)
        else
          var
        end;Fi[	I"Bprojects//homebrew_proj/vendor/multi_json/adapters/ok_json.rb;Ti'I"^            var.merge!(var => (var))
          end
        else
          var
        end;Fi[	@ziI"F    when "LITERAL" then
      var.to_i
    else
      var
    end;Fi[	@i,I"s        var = var.match("LITERAL") ? ("STRING") : ("STRING")
        "STRING"
      else
        var
      end;Fi[	I"Oprojects//paperclip_proj/paperclip/validators/attachment_size_validator.rb;Ti6I"é        if var.is_a?(Range) then
          ["LITERAL", "LITERAL"].include?(var) ? (var.max) : (var.min)
        else
          var
        end;Fi[	I"def function(var, var);F@Hi*[*[	@ci8I"É        attr_reader("LITERAL")
        
        def function(var, var)
          @var = var
          @var = var ? (var.dup) : ({});Fi[	@⁄iMI"f  
  class BlockValidator < EachValidator
    def function(var, var)
      @var = var
      super;Fi[	@≤i
I"≈      delegate(*(ActiveRecord::Calculations.public_instance_methods - ["LITERAL"]), "LITERAL" => "LITERAL")
      
      def function(var, var)
        @var = var
        super(var, var.arel_table);Ti[	@gi~I"{        attr_reader("LITERAL", "LITERAL")
        
        def function(var, var)
          @var = var
          @var = var;Fi[	@iI"\    
    class Table
      def function(var, var)
        @var = var
        @var = var;Fi[	@piI"Ü        attr_reader("LITERAL", "LITERAL", "LITERAL")
        
        def function(var, var)
          @var = var
          @var = var;Fi[	@si5I"¥          # table.  +subtype+ is derived from the `typelem` column in the
          # pg_types table.
          def function(var, var)
            @var = var
            @var = var;Fi[	@vi
I"h      include(Enumerable)
      
      def function(var, var)
        @var = var
        @var = var;Fi[	@[i˙I"l    attr_reader("LITERAL", "LITERAL")
    
    def function(var, var)
      @var = var
      @var = var;Fi[	@òi	I"h    include(Backup::CLI::Helpers)
    
    def function(var, var)
      @var = var
      @var = var;Fi[	@
iI"U    end
    
    def function(var, var)
      @var = var
      @var = var.params;Fi[	@£i)I"X      end
      
      def function(var, var)
        @var = var
        @var = var;Fi[	@´iI"X      end
      
      def function(var, var)
        @var = var
        @var = var;Fi[	@µiI"á      attr_reader("LITERAL", "LITERAL", "LITERAL", "LITERAL")
      
      def function(var, var)
        @var = var
        @var = var;Fi[	@øiI"Vclass ExtremePostPresenter
  def function(var, var)
    @var = var
    @var = var;Fi[	@¬iI"i  include(ActionView::Helpers::TextHelper)
  
  def function(var, var)
    @var = var
    @var = var;Fi[	@≈iI"Qclass PersonPresenter
  def function(var, var)
    @var = var
    @var = var;Fi[	@»i	I"d  attr_accessor("LITERAL", "LITERAL")
  
  def function(var, var)
    @var = var
    @var = var;Fi[	@»iDI"^end
class PostInteractionPresenter
  def function(var, var)
    @var = var
    @var = var;Fi[	I")projects//homebrew_proj/checksums.rb;Ti
I"o  TYPES = ["LITERAL", "LITERAL", "LITERAL"]
  
  def function(var, var)
    @var = var
    @var = var.to_s;Fi[	@iGI"p  attr_reader("LITERAL")
  
  def function(var, var)
    @var = var
    instance_eval(&var) if block_given?;Fi[	@˛iBI"  attr("LITERAL")
  
  def function(var, var)
    @var = var
    var = (var.length == "LITERAL") ? ("STRING") : ("STRING");Fi[	@˛iÇI"P  attr("LITERAL")
  
  def function(var, var)
    @var = var
    @var = var;Fi[	@—iI"V  attr("LITERAL", true)
  
  def function(var, var)
    @var = var
    @var = var;Fi[	@‘iI"m  attr_reader("LITERAL", "LITERAL", "LITERAL")
  
  def function(var, var)
    @var = var
    @var = var;Fi[	@‘ihI"b  attr_reader("LITERAL", "LITERAL")
  
  def function(var, var)
    @var = var
    @var = var;Fi[	@ÙiI"ó      # Get the value of this node
      # Create a new Node with +type+ and +value+
      def function(var, var)
        @var = var
        @var = var;Fi[	@˙iÅI"l      
      class NodeBuilder
        def function(var, var)
          @var = var
          @var = var;Fi[	@(iI"Ω      # The Document this NodeSet is associated with
      # Create a NodeSet with +document+ defaulting to +list+
      def function(var, var)
        @var = var
        var.decorate(self);Fi[	@iI"gmodule Paperclip
  class UrlGenerator
    def function(var, var)
      @var = var
      @var = var;Fi[	@iI"{    # placed)
    # This job's associated payload object.
    def function(var, var)
      @var = var
      @var = var;Fi[	I"8projects//state_machine_proj/state_machine/error.rb;Ti
I"c    
    # The object that failed
    def function(var, var)
      @var = var
      super(var);Fi[	@iI"}    
    # The event that was attempted to be run
    def function(var, var)
      @var = var
      super(var, "STRING");Fi[	@!iI"smodule StateMachine
  class HelperModule < Module
    def function(var, var)
      @var = var
      @var = var;Fi[	@3i3I"Å    
    # The set of events that failed the transition(s)
    def function(var, var)
      @var = var
      super(var, "STRING");Fi[	I";projects//twitter_proj/twitter/response/raise_error.rb;TiI"X      end
      
      def function(var, var)
        @var = var
        super(var);Fi[	@;i%I"N    end
    
    def function(var, var)
      @var = var
      @var = var;Fi[	@|@;i)[)[	@˜i[I"∏            if ActiveRecord::Base.!=(self) and table_exists? then
              connection.schema_cache.primary_keys[table_name]
            else
              "STRING"
            end;Fi[	@KiI"n          when "LITERAL" then
            var.to_f.to_s
          else
            "STRING"
          end;Fi[	@Ki-I"[        when Class then
          "STRING"
        else
          "STRING"
        end;Fi[	@ìiçI"c          when "STRING" then
            var
          else
            "STRING"
          end;Fi[	@õi*I"s            when "LITERAL" then
              "STRING"
            else
              "STRING"
            end;Fi[	@i;I"é              var = (columns.map { |var| "STRING" } * "STRING")
              "STRING"
            else
              "STRING"
            end;Fi[	@iˇI"Æ      var = if @attributes then
        self.class.column_names.collect { |var| "STRING" if has_attribute?(var) }.compact.join("STRING")
      else
        "STRING"
      end;Fi[	@#i8I"n        var = var.utc.to_s(cache_timestamp_format)
        "STRING"
      else
        "STRING"
      end;Fi[	@¢
iúI"±        var = if ["STRING", "STRING", "STRING", "STRING", "STRING"].index(@delivery_method.to_s) then
          @delivery_method.to_s
        else
          "STRING"
        end;Fi[	@≈iI"è        if (top_level.preferred_syntax == "LITERAL") and top_level.sass_dir then
          "STRING"
        else
          "STRING"
        end;Fi[	@îi|I"x        if var = top_level.fonts_dir_without_default then
          var
        else
          "STRING"
        end;Fi[	I"Bprojects//compass_proj/compass/configuration/serialization.rb;TiCI"ä        if var.respond_to?("LITERAL") then
          (var.serialize_to_config(var) + "STRING")
        else
          "STRING"
        end;Fi[	@
i8I"ø      if Compass.configuration.color_output and (var and COLORS.has_key?(var.to_sym)) then
        defined? $boring and $boring ? ("STRING") : ("STRING")
      else
        "STRING"
      end;Fi[	I"?projects//diaspora_proj/controllers/profiles_controller.rb;TiJI"ä    @profile_attrs["LITERAL"] = if params["LITERAL"] then
      params["LITERAL"].gsub("STRING", "STRING")
    else
      "STRING"
    end;Fi[	I":projects//diaspora_proj/helpers/application_helper.rb;Ti	I"w    if AppConfig.settings.pod_name.present? then
      AppConfig.settings.pod_name
    else
      "STRING"
    end;Fi[	I"9projects//diaspora_proj/helpers/open_graph_helper.rb;Ti'I"¢    var = if AppConfig.services.facebook.open_graph_namespace.present? then
      AppConfig.services.facebook.open_graph_namespace
    else
      "STRING"
    end;Fi[	@ªi;I"s    if image_path("STRING").include?("STRING") then
      image_path("STRING")
    else
      "STRING"
    end;Fi[	@Ïi©I"a          end) then
            "STRING"
          else
            "STRING"
          end));Fi[	@ÏiˇI"|              when "STRING" then
                "STRING"
              else
                "STRING"
              end;Fi[	@ÏiI"r            when "STRING" then
              "STRING"
            else
              "STRING"
            end;Fi[	@Ïi"I"Ä      var = if (var.! or (@dont_indent_next_line or @options["LITERAL"])) then
        var
      else
        "STRING"
      end;Fi[	@Èi&I"`        when "LITERAL" then
          "STRING"
        else
          "STRING"
        end);Fi[	@ıirI"_        when "LITERAL" then
          "STRING"
        else
          "STRING"
        end;Fi[	@@i}I"U      when "LITERAL" then
        "STRING"
      else
        "STRING"
      end;Fi[	@iCI"Ü      if (self.site.permalink_style == "LITERAL") and (index?.! and html?) then
        "STRING"
      else
        "STRING"
      end;Fi[	I"1projects//jekyll_proj/jekyll/tags/include.rb;TiI"          var = Liquid::Template.parse(var)
          var.stack { var.render(var) }
        else
          "STRING"
        end;Fi[	@KiI"Ã          if var.value["LITERAL"].is_a?(Nokogiri::CSS::Node) and (var.value["LITERAL"].type == "LITERAL") then
            an_plus_b(var.value["LITERAL"])
          else
            "STRING"
          end;Fi[	@Ki@I"¶        var = if ((var.value.first.type == "LITERAL") or var.value.first.value.first =~ "LITERAL") then
          "STRING"
        else
          "STRING"
        end;Fi[	@	iãI"ñ        if @options["LITERAL"].to_s.=~(Fog::AWS_BUCKET_SUBDOMAIN_RESTRICTON_REGEX) then
          "STRING"
        else
          "STRING"
        end;Fi[	@`iDI"~    self.redis = if Redis.respond_to?("LITERAL") then
      Redis.connect("LITERAL" => (true))
    else
      "STRING"
    end;Fi[	@gi4I"ü        if ((defined? Gem and var.filename.include?(Gem.dir)) or var.filename =~ "LITERAL") then
          "STRING"
        else
          "STRING"
        end;Fi[	I"Hprojects//state_machine_proj/state_machine/yard/handlers/machine.rb;TirI"´          @var ||= if machine.states.any? then
            machine.states.map { |var| var.name }.compact.first.class.to_s
          else
            "STRING"
          end;Fi[	@fi I"_        when "LITERAL" then
          "STRING"
        else
          "STRING"
        end;Fi[	@wiI"†      @options["LITERAL"] = if var.has_key?("LITERAL") then
        Whenever::Output::Redirection.new(var["LITERAL"]).to_s
      else
        "STRING"
      end;Fi[	@|iI"^        when NilClass then
          "STRING"
        else
          "STRING"
        end;Fi[	@|i6I"\        when stdout then
          "STRING"
        else
          "STRING"
        end;Fi[	@|@ˆi([([	@∞ijI"®          if var and var = self.class.serialized_attributes[var.name] then
            Attribute.new(var, var, "LITERAL")
          else
            super
          end;Fi[	@∞ivI"î          if self.class.serialized_attributes.include?(var) then
            super.unserialized_value
          else
            super
          end;Fi[	@∞iÅI"ù          if self.class.serialized_attributes.include?(var) then
            @attributes[var].serialized_value
          else
            super
          end;Fi[	@≥i)I"Ø            var, var = "STRING", ("LITERAL" + "LITERAL")
            generated_attribute_methods.module_eval(var, "STRING", var)
          else
            super
          end;Fi[	@Ui=I"g          when "LITERAL" then
            "LITERAL"
          else
            super
          end;Fi[	@UiLI"q            when "LITERAL" then
              "LITERAL"
            else
              super
            end;Fi[	@Ui[I"ú          when "LITERAL" then
            $1.split("STRING").map { |var| (var.strip.length - "LITERAL") }.max
          else
            super
          end;Fi[	@UiˆI"j            raise(ActiveRecordError, "STRING")
          end
        else
          super
        end;Fi[	@UiUI"s        when "LITERAL" then
          InvalidForeignKey.new(var, var)
        else
          super
        end;Fi[	@ìiI"â          when "LITERAL" then
            super(("STRING" + var.sub("LITERAL", "STRING")))
          else
            super
          end;Fi[	@Ç
i0I"ï              super
              last_insert_id_value((var or default_sequence_name(var, var)))
            else
              super
            end;Fi[	@ñi!I"í            when "STRING" then
              super(PostgreSQLColumn.json_to_string(var), var)
            else
              super
            end;Fi[	@ñi(I"†            when "STRING", "STRING" then
              super(PostgreSQLColumn.intrange_to_string(var), var)
            else
              super
            end;Fi[	@ñi/I"ú            when "STRING", "STRING" then
              super(PostgreSQLColumn.cidr_to_string(var), var)
            else
              super
            end;Fi[	@ñiJI"h                # do nothing
              end
            else
              super
            end;Fi[	@ñiMI"W              super
            end
          else
            super
          end;Fi[	@õiHI"t              raise(ActiveRecordError, "STRING")
            end
          else
            super
          end;Fi[	@XiƒI"á          var = var.class.string_to_binary(var).unpack("STRING")["LITERAL"]
          "STRING"
        else
          super
        end;Fi[	@Xi	I"q        when "LITERAL" then
          RecordNotUnique.new(var, var)
        else
          super
        end;Fi[	@ iI"è        if using_single_table_inheritance?(var) then
          find_sti_class(var[inheritance_column])
        else
          super
        end;Fi[	I"Mprojects//activerecord_proj/active_record/railties/controller_runtime.rb;TiI"k          self.db_runtime = (var + var)
          (var - var)
        else
          super
        end;Fi[	I"Eprojects//activerecord_proj/active_record/relation/delegation.rb;Ti:I"ú              self.class.delegate(var, "LITERAL" => "LITERAL")
              arel.send(var, *var, &var)
            else
              super
            end;Fi[	I":projects//backup_proj/backup/configuration/helpers.rb;TijI"•          self.class.log_deprecation_warning(var, var)
          var["LITERAL"].call(self, var["LITERAL"]) if var["LITERAL"]
        else
          super
        end;Fi[	@¶iòI"Œ      if ["STRING", "STRING"].include?(var) and (position_or_angle.is_a?(Sass::Script::Number) and position_or_angle.numerator_units.include?("STRING")) then
        false
      else
        super
      end;Fi[	@ÆiEI"õ          if @evaluation_context.respond_to?(var) then
            @evaluation_context.send(var, *var, &var)
          else
            super
          end;Fi[	I"4projects//devise_proj/devise/models/lockable.rb;Ti]I"è          if lock_strategy_enabled?("LITERAL") and attempts_exceeded? then
            "LITERAL"
          else
            super
          end;Fi[	@i…I"|          raise("STRING") if (var.size > "LITERAL")
          super(var.first)
        else
          super
        end;Fi[	I"3projects//paperclip_proj/paperclip/tempfile.rb;TiI"h        var = Time.now.strftime("STRING")
        var = "STRING"
      else
        super
      end;Fi[	@Ûi±I"b          add_states(var.known_states)
          var
        else
          super
        end;Fi[	I"Mprojects//state_machine_proj/state_machine/integrations/active_record.rb;Ti>I"ß        if (action_hook == "LITERAL") then
          owner_class.set_callback("LITERAL", "LITERAL", self, "LITERAL" => (true))
        else
          super
        end;Fi[	I"Lprojects//state_machine_proj/state_machine/integrations/mongo_mapper.rb;Ti7I"ß        if (action_hook == "LITERAL") then
          owner_class.set_callback("LITERAL", "LITERAL", self, "LITERAL" => (true))
        else
          super
        end;Fi[	I"Gprojects//state_machine_proj/state_machine/integrations/mongoid.rb;Ti;I"ß        if (action_hook == "LITERAL") then
          owner_class.set_callback("LITERAL", "LITERAL", self, "LITERAL" => (true))
        else
          super
        end;Fi[	@ciI"®          if (action == "LITERAL") then
            define_helper("LITERAL", "STRING", "STRING", ("LITERAL" + "LITERAL"))
          else
            super
          end;Fi[	@k
i…I"v          each { |var| var.machine.write(object, "LITERAL", var) }
        end
      else
        super
      end;Fi[	I",projects//twitter_proj/twitter/error.rb;TiI"      if @wrapped_exception.respond_to?("LITERAL") then
        @wrapped_exception.backtrace
      else
        super
      end;Fi[	@ó@i'['[	@Ui8I"Ö          case var
          when "LITERAL", "LITERAL" then
            "LITERAL"
          when "LITERAL" then
            "LITERAL";Fi[	@Ui:I"}            "LITERAL"
          when "LITERAL" then
            "LITERAL"
          when "LITERAL" then
            "LITERAL";Fi[	@UiGI"Ñ            case var
            when "LITERAL" then
              "LITERAL"
            when "LITERAL" then
              "LITERAL";Fi[	@UiII"á              "LITERAL"
            when "LITERAL" then
              "LITERAL"
            when "LITERAL" then
              "LITERAL";Fi[	@UiPI"|            end
          when "LITERAL" then
            "LITERAL"
          when "LITERAL" then
            "LITERAL";Fi[	@UiRI"}            "LITERAL"
          when "LITERAL" then
            "LITERAL"
          when "LITERAL" then
            "LITERAL";Fi[	@UiTI"}            "LITERAL"
          when "LITERAL" then
            "LITERAL"
          when "LITERAL" then
            "LITERAL";Fi[	@UiVI"}            "LITERAL"
          when "LITERAL" then
            "LITERAL"
          when "LITERAL" then
            "LITERAL";Fi[	@UiXI"∑            "LITERAL"
          when "LITERAL" then
            "LITERAL"
          when "LITERAL" then
            $1.split("STRING").map { |var| (var.strip.length - "LITERAL") }.max;Fi[	@iêI"{      var = case var.hash_type
      when "LITERAL" then
        "LITERAL"
      when "LITERAL" then
        "LITERAL";Fi[	@iíI"n        "LITERAL"
      when "LITERAL" then
        "LITERAL"
      when "LITERAL" then
        "LITERAL";Fi[	@J
i•I"a    case var
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL";Fi[	@J
ißI"d      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL";Fi[	@J
i©I"d      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL";Fi[	@J
i´I"d      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL";Fi[	@J
i≠I"d      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL";Fi[	@J
iØI"d      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL";Fi[	@Ói
I"h    case @@cpu_type
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL";Fi[	@ÓiI"l    case @@intel_family
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL";Fi[	@ÓiI"d      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL";Fi[	@ÓiI"d      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL";Fi[	@ÓiI"d      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL";Fi[	@ÓiI"d      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL";Fi[	@Ói I"d      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL";Fi[	@›
iyI"s          "LITERAL"
        when *var then
          "LITERAL"
        when "LITERAL" then
          "LITERAL";Fi[	@›
iÄI"w          "LITERAL"
        when "STRING" then
          "LITERAL"
        when "LITERAL" then
          "LITERAL";Fi[	@›
iàI"w          "LITERAL"
        when "STRING" then
          "LITERAL"
        when "LITERAL" then
          "LITERAL";Fi[	@›
iäI"x          "LITERAL"
        when "LITERAL" then
          "LITERAL"
        when "LITERAL" then
          "LITERAL";Fi[	@›
iéI"w          "LITERAL"
        when "STRING" then
          "LITERAL"
        when "LITERAL" then
          "LITERAL";Fi[	@ﬁiHI"l    case archs.length
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      archs.first;Fi[	@·iRI"h    case default_cc
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL";Fi[	@zi¨I"s    super(Version.new(case var
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL";Fi[	@ziÆI"d      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL";Fi[	@zi∞I"d      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    when "LITERAL" then
      "LITERAL";Fi[	@:@ói&[&[	I";projects//activemodel_proj/active_model/translation.rb;Ti
I"Ä    
    # Returns the +i18n_scope+ for the class. Overwrite if you want custom lookup.
    def function
      "LITERAL"
    end;Fi[	I"Qprojects//activerecord_proj/active_record/associations/builder/belongs_to.rb;TiI"{module ActiveRecord::Associations::Builder
  class BelongsTo < SingularAssociation
    def function
      "LITERAL"
    end;Fi[	@iI"ámodule ActiveRecord::Associations::Builder
  class HasAndBelongsToMany < CollectionAssociation
    def function
      "LITERAL"
    end;Fi[	I"Oprojects//activerecord_proj/active_record/associations/builder/has_many.rb;TiI"{module ActiveRecord::Associations::Builder
  class HasMany < CollectionAssociation
    def function
      "LITERAL"
    end;Fi[	I"Nprojects//activerecord_proj/active_record/associations/builder/has_one.rb;TiI"}module ActiveRecord::Associations::Builder
  class HasOne < SingularAssociation
    def function
      "LITERAL"
    end;Fi[	@·i	I"}    module DatabaseLimits
      # Returns the maximum length of a table alias.
      def function
        "LITERAL"
      end;Fi[	@·iI"o      
      # Returns the maximum length of a column name.
      def function
        "LITERAL"
      end;Fi[	@·iI"n      
      # Returns the maximum length of a table name.
      def function
        "LITERAL"
      end;Fi[	@·iI"o      
      # Returns the maximum length of an index name.
      def function
        "LITERAL"
      end;Fi[	@·iI"s      
      # Returns the maximum number of columns per table.
      def function
        "LITERAL"
      end;Fi[	@·i"I"s      
      # Returns the maximum number of indexes per table.
      def function
        "LITERAL"
      end;Fi[	@·i'I"{      
      # Returns the maximum number of columns in a multicolumn index.
      def function
        "LITERAL"
      end;Fi[	@·i2I"n      
      # Returns the maximum length of an SQL query.
      def function
        "LITERAL"
      end;Fi[	@·i7I"u      
      # Returns maximum number of joins in a single query.
      def function
        "LITERAL"
      end;Fi[	@∫iI"b    
    class ClosedTransaction < Transaction
      def function
        "LITERAL"
      end;Fi[	@Ã	iI"b        
        class Date < Type
          def function
            "LITERAL"
          end;Fi[	@Ã	iI"f        
        class DateTime < Type
          def function
            "LITERAL"
          end;Fi[	@Ã	iI"b        
        class Time < Type
          def function
            "LITERAL"
          end;Fi[	@Ã	i"I"c        
        class Float < Type
          def function
            "LITERAL"
          end;Fi[	@siaI"g        
        class Timestamp < Type
          def function
            "LITERAL"
          end;Fi[	@silI"b        
        class Date < Type
          def function
            "LITERAL"
          end;Fi[	@õiI"N        end
        
        def function
          "LITERAL"
        end;Fi[	@úiI":    end
    
    def function
      "LITERAL"
    end;Fi[	@IiI"m    # Set the i18n scope to overwrite ActiveModel.
    #:nodoc:
    def function
      "LITERAL"
    end;Fi[	@âi	I"r    module StandAlone
      module ConfigurationDefaults
        def function
          "LITERAL"
        end;Fi[	@îiI"D      end
      
      def function
        "LITERAL"
      end;Fi[	@îiI"D      end
      
      def function
        "LITERAL"
      end;Fi[	@îiëI"D      end
      
      def function
        "LITERAL"
      end;Fi[	@îiïI"D      end
      
      def function
        "LITERAL"
      end;Fi[	@∏i"I"D      end
      
      def function
        "LITERAL"
      end;Fi[	@∏i*I"D      end
      
      def function
        "LITERAL"
      end;Fi[	I"2projects//haml_proj/haml/sass_rails_filter.rb;TiI"b      self.default_mime_type = "STRING"
      
      def function
        "LITERAL"
      end;Fi[	@>iI":    end
    
    def function
      "LITERAL"
    end;Fi[	@ó@|i&[&[	@KivI"Ø        if var.acts_like?("LITERAL") then
          var = if (ActiveRecord::Base.default_timezone == "LITERAL") then
            "LITERAL"
          else
            "LITERAL";Fi[	@Ui<I"o            "LITERAL"
          when "LITERAL" then
            "LITERAL"
          else
            super;Fi[	@UiKI"y              "LITERAL"
            when "LITERAL" then
              "LITERAL"
            else
              super;Fi[	@1iåI"Ü      var = arel_attributes_with_values_for_update(var)
      if var.empty? then
        "LITERAL"
      else
        var = self.class;Fi[	@JiÏI"Ö          "LITERAL"
        when Arel::Nodes::Join then
          "LITERAL"
        else
          raise(("STRING" % var.class.name));Fi[	@i\I"é        else
          if lock_strategy_enabled?("LITERAL") and attempts_exceeded? then
            "LITERAL"
          else
            super;Fi[	I"6projects//diaspora_proj/helpers/publics_helper.rb;TiI"é    if var.save then
      if (var["LITERAL"] == "STRING") then
        "LITERAL"
      else
        "LITERAL" if (var["LITERAL"] == "STRING");Fi[	I"'projects//homebrew_proj/cleaner.rb;Ti&I"  def function(var)
    var = if (var.mach_o_executable? or var.text_executable?) then
      "LITERAL"
    else
      "LITERAL";Fi[	@iîI"b        "LITERAL"
      when "LITERAL" then
        "LITERAL"
      else
        # do nothing;Fi[	@iI"Ñ    var.url = var
    var.mode = if ARGV.include?("STRING") then
      "LITERAL"
    else
      "LITERAL" if ARGV.include?("STRING");Fi[	@ijI"ß    when "LITERAL" then
      if @compilers.include?("LITERAL") then
        "LITERAL"
      else
        @compilers.include?("LITERAL") ? ("LITERAL") : (ENV.compiler);Fi[	@ipI"Ω    when "LITERAL" then
      if @compilers.include?("LITERAL") and (MacOS.clang_build_version >= "LITERAL") then
        "LITERAL"
      else
        if @compilers.include?("LITERAL") then;Fi[	@isI"¢      else
        if @compilers.include?("LITERAL") then
          "LITERAL"
        else
          @compilers.include?("LITERAL") ? ("LITERAL") : (ENV.compiler);Fi[	@izI"Ω    when "LITERAL" then
      if @compilers.include?("LITERAL") and (MacOS.clang_build_version >= "LITERAL") then
        "LITERAL"
      else
        if @compilers.include?("LITERAL") then;Fi[	@i}I"¢      else
        if @compilers.include?("LITERAL") then
          "LITERAL"
        else
          @compilers.include?("LITERAL") ? ("LITERAL") : (ENV.compiler);Fi[	@J
i±I"X      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    else
      case extname;Fi[	@J
iπI"a        "LITERAL"
      when "STRING" then
        "LITERAL"
      else
        # do nothing;Fi[	@ÓiI"U      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    else
      "LITERAL";Fi[	@Ói"I"U      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    else
      "LITERAL";Fi[	@›
i{I"i          "LITERAL"
        when "LITERAL" then
          "LITERAL"
        else
          "LITERAL";Fi[	@›
iíI"h          "LITERAL"
        when "STRING" then
          "LITERAL"
        else
          "LITERAL";Fi[	@ﬁi.I"l        "LITERAL"
      when ["LITERAL", "LITERAL"] then
        "LITERAL"
      else
        "LITERAL";Fi[	@ﬁi8I"j        "LITERAL"
      when "LITERAL", "LITERAL" then
        "LITERAL"
      else
        "LITERAL";Fi[	@·iI"t  def function
    if (version == "LITERAL") then
      "LITERAL"
    else
      if (version == "LITERAL") then;Fi[	@·iI"v    else
      if (version == "LITERAL") then
        "LITERAL"
      else
        if (version == "LITERAL") then;Fi[	@·iI"â      else
        if (version == "LITERAL") then
          "LITERAL"
        else
          (version == "LITERAL") ? ("LITERAL") : (nil);Fi[	@·iVI"n      "LITERAL"
    when "STRING" then
      "LITERAL"
    else
      if (Xcode.version >= "STRING") then;Fi[	@·iYI"è    else
      if (Xcode.version >= "STRING") then
        "LITERAL"
      else
        (Xcode.version >= "STRING") ? ("LITERAL") : ("LITERAL");Fi[	@ i`I"≈    raise(TypeError, "STRING") unless var.is_a?(X11Dependency)
    if var.min_version.nil? then
      "LITERAL"
    else
      @min_version.nil? ? ("LITERAL") : ((@min_version <=> var.min_version));Fi[	@ÊiI"u    assert_equal(case MacOS.clang_build_version
    when "LITERAL" then
      "LITERAL"
    else
      "LITERAL";Fi[	@ÊiZI"u    assert_equal(case MacOS.clang_build_version
    when "LITERAL" then
      "LITERAL"
    else
      "LITERAL";Fi[	@˝i)I"Ú        var[(var + "LITERAL")] = Utagx.|((var >> "LITERAL").&(Umaskx)).chr
        var[(var + "LITERAL")] = Utagx.|(var.&(Umaskx)).chr
        "LITERAL"
      else
        (var[(var + "LITERAL")] = Utag4.|((var >> "LITERAL").&("LITERAL")).chr;Fi[	@zi≤I"T      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    else
      var.to_s;Fi[	I"#       end;F@>i&[&[	@`inI"â      #       hash.each do |key, value|
      #         instance_variable_set("@#{key}", value)
      #       end
      #     end
      #;Fi[	@ci I"â      #       hash.each do |key, value|
      #         instance_variable_set("@#{key}", value)
      #       end
      #     end
      #;Fi[	@Çi5I"¡      #       def validate_each(record, attribute, value)
      #         record.errors.add attribute, "must start with 'the'" unless value =~ /\Athe/i
      #       end
      #     end
      #;Fi[	@ãi*I"è      #       if some_complex_logic
      #         record.errors.add :base, 'This record is invalid'
      #       end
      #     end
      #;Fi[	@ÒiKI"}      #         t.integer :developer_id
      #         t.integer :project_id
      #       end
      #     end
      #   end;Fi[	@[isI"t        #       def dom_id
        #         'red_shirts'
        #       end
        #     end
        #   end;Fi[	@hi©I"|    #       xml.level_one do
    #         xml.tag!(:second_level, 'content')
    #       end
    #     end
    #   end;Fi[	@∏i]I"      #       def pending_notifications
      #         @pending_notifications ||= []
      #       end
      #     end
      #;Fi[	@Ôi§I"b    #           haml_concat "more_data"
    #         end
    #       end
    #     end
    #;Fi[	@Êi!I"w    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end;Fi[	@ÊiFI"w    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end;Fi[	@ÊifI"w    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end;Fi[	@ÌiHI"t    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #     ;Fi[	@ÌiRI"q    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end;Fi[	@ÌizI"t    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #     ;Fi[	@ÌiI"q    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end;Fi[	@ÚiBI"h        #           end
        #         end
        #       end
        #     end
        #   end;Fi[	@ıiI"Ü        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end;Fi[	@ıi[I"Ü        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end;Fi[	@ıiI"Ü        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end;Fi[	@i>I"[    #       event :park do
    #         ...
    #       end
    #     end
    #   end;Fi[	@itI"}    #       event :shift_up do
    #         transition :idling => :first_gear
    #       end
    #     end
    #   end;Fi[	@i•I"u    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #   end;Fi[	@i*I"|    #       initialize_state_machines(:static => :force) do
    #         ...
    #       end
    #     end
    #   end;Fi[	@iGI"s    #       event :ignite do
    #         transition all => :idling
    #       end
    #     end
    #   end;Fi[	@iêI"v    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #     ;Fi[	@iñI"q    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end;Fi[	@i«I"q    #       event :turn_off do
    #         transition all => :off
    #       end
    #     end
    #     ;Fi[	@i—I"r    #       event :turn_off do
    #         transition all => :off
    #       end
    #     end
    #   end;Fi[	@$iI"z    #       event :crash
    #         transition all - :parked => :stalled
    #       end
    #     end
    #   end;Fi[	@$i.I"{    #       event :ignite
    #         transition [:idling, :first_gear] => same
    #       end
    #     end
    #   end;Fi[	@3iÁI"w    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end;Fi[	@3i I"w    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end;Fi[	I"autoload("LITERAL");F@Si&[&[	@˘i5I"[    
    eager_autoload do
      autoload("LITERAL")
      autoload("LITERAL")
    end;Fi[	@PiI"t    
    autoload_at("STRING") do
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL");Fi[	@PiI"Ñ    autoload_at("STRING") do
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL");Fi[	@PiI"t      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
    end;Fi[	@PiI"b    
    autoload_at("STRING") do
      autoload("LITERAL")
      autoload("LITERAL")
    end;Fi[	@Pi!I"w    
    autoload_under("STRING") do
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL");Fi[	@Pi"I"á    autoload_under("STRING") do
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL");Fi[	@Pi#I"Å      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL");Fi[	@Pi$I"Å      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL");Fi[	@Pi%I"t      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
    end;Fi[	@Pi*I"t    
    autoload_at("STRING") do
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL");Fi[	@Pi+I"w    autoload_at("STRING") do
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
    end;Fi[	I"1projects//activerecord_proj/active_record.rb;TiLI"ã    autoload("LITERAL", "STRING")
    autoload("LITERAL", "STRING")
    autoload("LITERAL")
    autoload("LITERAL")
    autoload("LITERAL");Fi[	@niMI"Å    autoload("LITERAL", "STRING")
    autoload("LITERAL")
    autoload("LITERAL")
    autoload("LITERAL")
    autoload("LITERAL");Fi[	@niNI"|    autoload("LITERAL")
    autoload("LITERAL")
    autoload("LITERAL")
    autoload("LITERAL")
    autoload("LITERAL");Fi[	@niOI"|    autoload("LITERAL")
    autoload("LITERAL")
    autoload("LITERAL")
    autoload("LITERAL")
    autoload("LITERAL");Fi[	@niPI"|    autoload("LITERAL")
    autoload("LITERAL")
    autoload("LITERAL")
    autoload("LITERAL")
    autoload("LITERAL");Fi[	@niQI"    autoload("LITERAL")
    autoload("LITERAL")
    autoload("LITERAL")
    autoload("LITERAL")
    autoload_under("STRING") do;Fi[	@niTI"Ö    autoload("LITERAL")
    autoload_under("STRING") do
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL");Fi[	@niUI"á    autoload_under("STRING") do
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL");Fi[	@niVI"Å      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL");Fi[	@niWI"Å      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL");Fi[	@niXI"Å      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL");Fi[	@niYI"t      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
    end;Fi[	@nigI"m    
    eager_autoload do
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL");Fi[	@nihI"}    eager_autoload do
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL");Fi[	@niiI"Å      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL");Fi[	@nijI"Å      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL");Fi[	@nikI"Å      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL");Fi[	@nilI"Å      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL");Fi[	@nimI"t      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
      autoload("LITERAL")
    end;Fi[	@nivI"[    
    eager_autoload do
      autoload("LITERAL")
      autoload("LITERAL")
    end;Fi[	@niÉI"[    
    eager_autoload do
      autoload("LITERAL")
      autoload("LITERAL")
    end;Fi[	I"module Nokogiri;FI"module XML;Fi%[%[	I"1projects//nokogiri_proj/nokogiri/xml/attr.rb;Ti I"7module Nokogiri
  module XML
    class Attr < Node;Fi [	@i I"Omodule Nokogiri
  module XML
    class AttributeDecl < Nokogiri::XML::Node;Fi [	@˙i I"3module Nokogiri
  module XML
    class Builder;Fi [	@i I"Gmodule Nokogiri
  module XML
    class CDATA < Nokogiri::XML::Text;Fi [	I";projects//nokogiri_proj/nokogiri/xml/character_data.rb;Ti I"Omodule Nokogiri
  module XML
    class CharacterData < Nokogiri::XML::Node;Fi [	@i I"Jmodule Nokogiri
  module XML
    class Document < Nokogiri::XML::Node;Fi [	@i I"Rmodule Nokogiri
  module XML
    class DocumentFragment < Nokogiri::XML::Node;Fi [	I"0projects//nokogiri_proj/nokogiri/xml/dtd.rb;Ti I"Emodule Nokogiri
  module XML
    class DTD < Nokogiri::XML::Node;Fi [	I"<projects//nokogiri_proj/nokogiri/xml/element_content.rb;Ti I":module Nokogiri
  module XML
    class ElementContent;Fi [	@ i I"Mmodule Nokogiri
  module XML
    class ElementDecl < Nokogiri::XML::Node;Fi [	@#i I"Lmodule Nokogiri
  module XML
    class EntityDecl < Nokogiri::XML::Node;Fi [	I"6projects//nokogiri_proj/nokogiri/xml/namespace.rb;Ti I"5module Nokogiri
  module XML
    class Namespace;Fi [	@)i I"0module Nokogiri
  module XML
    class Node;Fi [	@ÿiI"nrequire("stringio")
require("nokogiri/xml/node/save_options")
module Nokogiri
  module XML
    class Node;Fi[	@(i I"3module Nokogiri
  module XML
    class NodeSet;Fi [	I"5projects//nokogiri_proj/nokogiri/xml/notation.rb;Ti I"bmodule Nokogiri
  module XML
    class Notation < Struct.new("LITERAL", "LITERAL", "LITERAL");Fi [	@,i I"8module Nokogiri
  module XML
    class ParseOptions;Fi [	@+i I"/module Nokogiri
  module XML
    module PP;Fi [	I"4projects//nokogiri_proj/nokogiri/xml/pp/node.rb;Ti I"/module Nokogiri
  module XML
    module PP;Fi [	I"Cprojects//nokogiri_proj/nokogiri/xml/processing_instruction.rb;Ti I"Hmodule Nokogiri
  module XML
    class ProcessingInstruction < Node;Fi [	I"3projects//nokogiri_proj/nokogiri/xml/reader.rb;Ti I"2module Nokogiri
  module XML
    class Reader;Fi [	I"5projects//nokogiri_proj/nokogiri/xml/relax_ng.rb;Ti I"3module Nokogiri
  module XML
    class << self;Fi [	@'i I"0module Nokogiri
  module XML
    module SAX;Fi [	@˝i I"0module Nokogiri
  module XML
    module SAX;Fi [	I"?projects//nokogiri_proj/nokogiri/xml/sax/parser_context.rb;Ti I"0module Nokogiri
  module XML
    module SAX;Fi [	@ i I"0module Nokogiri
  module XML
    module SAX;Fi [	I"3projects//nokogiri_proj/nokogiri/xml/schema.rb;Ti I"3module Nokogiri
  module XML
    class << self;Fi [	I"9projects//nokogiri_proj/nokogiri/xml/syntax_error.rb;Ti I"Qmodule Nokogiri
  module XML
    class SyntaxError < ::Nokogiri::SyntaxError;Fi [	I"1projects//nokogiri_proj/nokogiri/xml/text.rb;Ti I"Omodule Nokogiri
  module XML
    class Text < Nokogiri::XML::CharacterData;Fi [	I"?projects//nokogiri_proj/nokogiri/xml/xpath/syntax_error.rb;Ti I"1module Nokogiri
  module XML
    class XPath;Fi [	I"2projects//nokogiri_proj/nokogiri/xml/xpath.rb;TiI"\require("nokogiri/xml/xpath/syntax_error")
module Nokogiri
  module XML
    class XPath;Fi[	I":projects//nokogiri_proj/nokogiri/xml/xpath_context.rb;Ti I"8module Nokogiri
  module XML
    class XPathContext;Fi [	I"# @rate_limited No;F@mi$[$[	@qioI"•      # @see https://dev.twitter.com/docs/api/1.1/post/direct_messages/destroy
      # @note This method requires an access token with RWD (read, write & direct message) permissions. Consult The Application Permission Model for more information.
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@qi|I"      #
      # @see https://dev.twitter.com/docs/api/1.1/post/direct_messages/new
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@~i3I"       #
      # @see https://dev.twitter.com/docs/api/1.1/post/favorites/destroy
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@~iKI"ˇ      #
      # @see https://dev.twitter.com/docs/api/1.1/post/favorites/create
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@~ilI"¸      #
      # @see https://dev.twitter.com/docs/api/1.1/post/favorites/create
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::AlreadyFavorited] Error raised when tweet has already been favorited.;Fi[	@ÖiyI"      #
      # @see https://dev.twitter.com/docs/api/1.1/post/friendships/create
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@ÖiçI"      #
      # @see https://dev.twitter.com/docs/api/1.1/post/friendships/create
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@Öi™I"      #
      # @see https://dev.twitter.com/docs/api/1.1/post/friendships/destroy
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@ÖiæI"      #
      # @see https://dev.twitter.com/docs/api/1.1/post/friendships/update
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@´iTI"      #
      # @see https://dev.twitter.com/docs/api/1.1/post/lists/members/destroy
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@´i†I"      #
      # @see https://dev.twitter.com/docs/api/1.1/post/lists/subscribers/create
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@´i◊I"      #
      # @see https://dev.twitter.com/docs/api/1.1/post/lists/subscribers/destroy
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@´iÒI"å      # @see https://dev.twitter.com/docs/api/1.1/post/lists/members/create_all
      # @note Lists are limited to having 500 members, and you are limited to adding up to 100 members to a list at a time with this method.
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@´iII"2      # @see https://dev.twitter.com/docs/api/1.1/post/lists/members/create
      # @note Lists are limited to having 500 members.
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@´ifI"+      # @see https://dev.twitter.com/docs/api/1.1/post/lists/destroy
      # @note Must be owned by the authenticated user.
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@´iÄI"˚      #
      # @see https://dev.twitter.com/docs/api/1.1/post/lists/update
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@´iüI"#      # @see https://dev.twitter.com/docs/api/1.1/post/lists/create
      # @note Accounts are limited to 20 lists.
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@´i‚I"      #
      # @see https://dev.twitter.com/docs/api/1.1/post/lists/members/destroy_all
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@Ÿi@I"      #
      # @see https://dev.twitter.com/docs/api/1.1/post/saved_searches/create
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@ŸiPI"T      # @see https://dev.twitter.com/docs/api/1.1/post/saved_searches/destroy/:id
      # @note The search specified by ID must be owned by the authenticating user.
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@i\I"M      # @see https://dev.twitter.com/docs/api/1.1/post/statuses/destroy/:id
      # @note The authenticating user must be the author of the specified Tweets.
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@irI"{      # @see https://dev.twitter.com/docs/api/1.1/post/statuses/update
      # @note A status update with text identical to the authenticating user's current status will be ignored to prevent duplicates.
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@i∏I"y      # @see https://dev.twitter.com/docs/api/1.1/post/statuses/update_with_media
      # @note A status update with text/media identical to the authenticating user's current status will NOT be ignored
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@i>I"      #
      # @see https://dev.twitter.com/docs/api/1.1/post/account/update_delivery_device
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@iNI"7      # @see https://dev.twitter.com/docs/api/1.1/post/account/update_profile
      # @note Only the options specified will be updated.
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@i`I"      #
      # @see https://dev.twitter.com/docs/api/1.1/post/account/update_profile_background_image
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@ipI"      #
      # @see https://dev.twitter.com/docs/api/1.1/post/account/update_profile_colors
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@iÄI"c      # @note Updates the authenticating user's profile image. Note that this method expects raw multipart data, not a URL to an image.
      # @note This method asynchronously processes the uploaded file before updating the user's profile image URL. You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@iﬁI"˝      #
      # @see https://dev.twitter.com/docs/api/1.1/post/blocks/destroy
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@i~I"      #
      # @see https://dev.twitter.com/docs/api/1.1/post/account/remove_profile_banner
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@iéI"˛      # @note Uploads a profile banner on behalf of the authenticating user. For best results, upload an <5MB image that is exactly 1252px by 626px. Images will be resized for a number of display options. Users with an uploaded profile banner will have a profile_banner_url node in their Users objects. More information about sizing variations can be found in User Profile Images and Banners.
      # @note Profile banner images are processed asynchronously. The profile_banner_url and its variant sizes will not necessary be available directly after upload.
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::BadRequest] Error raised when either an image was not provided or the image data could not be processed.;Fi[	@I"#   class Vehicle;Fi#[#[	@ÊiI"i    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do;Fi[	@Êi=I"i    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do;Fi[	@Ìi?I"h    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do;Fi[	@ÌiqI"h    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do;Fi[	@ıiI"u        # 
        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource;Fi[	@ıiQI"u        # 
        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource;Fi[	@ıiuI"t        # 
        # == Example
        # 
        #   class Vehicle
        #     include DataMapper::Resource;Fi[	@i9I"    # 
    # With the default name/attribute and no configuration:
    # 
    #   class Vehicle
    #     state_machine do;Fi[	@iGI"â    # 
    # With a custom name / attribute:
    # 
    #   class Vehicle
    #     state_machine :status, :attribute => :status_value do;Fi[	@iOI"~    # 
    # With a static initial state:
    # 
    #   class Vehicle
    #     state_machine :status, :initial => :parked do;Fi[	@iWI"±    # 
    # With a dynamic initial state:
    # 
    #   class Vehicle
    #     state_machine :status, :initial => lambda {|vehicle| vehicle.speed == 0 ? :parked : :idling} do;Fi[	@ikI"r    # 
    # For example,
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do;Fi[	@iúI"r    # 
    # For example,
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do;Fi[	@i◊I"r    # 
    # For example,
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do;Fi[	@iÂI"£    # 
    # In the following example, a custom +initialize+ method is defined:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do;Fi[	@iˆI"∞    # are called, the custom method *must* call +super+ without any arguments
    # like so:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do;Fi[	@iI"’    # If you want to avoid calling the superclass's constructor, but still want
    # to initialize the state machine attributes:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do;Fi[	@iI"÷    # set.  For example, the following example forces the initialization of
    # static states regardless of their current value:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do;Fi[	@iBI"ø    # When a new state is defined, a predicate method for that state is
    # generated on the class.  For example,
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do;Fi[	@iXI"ß    # state machine.  In most cases, this is the same as the name of the state
    # machine.  For example:
    # 
    #   class Vehicle
    #     attr_accessor :state;Fi[	@iàI"b    # 
    # For example,
    # 
    #   class Vehicle
    #     include DataMapper::Resource;Fi[	@iæI"â    # 
    # For example,
    # 
    #   class Vehicle
    #     state_machine :heater_state, :initial => :off, :namespace => 'heater' do;Fi[	@$i
I"U    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine do;Fi[	@$i)I"U    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine do;Fi[	@)iI"i    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do;Fi[	@)i(I"i    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do;Fi[	@)iCI"i    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do;Fi[	@3i∞I"f    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :action => :save do;Fi[	@3i‚I"T    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine do;Fi[	@3i˚I"h    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do;Fi[	@:I"
false;Fi#[#[	@>i'I"|    #  person = Person.new(id: 1, name: 'bob')
    #  person.persisted? # => false
    def function
      false
    end;Fi[	@®i¨I"¡      # Currently implemented by belongs_to (vanilla and polymorphic) and
      # has_one/has_many :through associations which go through a belongs_to
      def function
        false
      end;Fi[	@iwI"§      # Returns +true+ when the connection adapter supports prepared statement
      # caching, otherwise returns +false+
      def function
        false
      end;Fi[	@∫iI"@      end
      
      def function
        false
      end;Fi[	@∫i I"@      end
      
      def function
        false
      end;Fi[	@∫imI"@      end
      
      def function
        false
      end;Fi[	@PilI"¢      # Does this adapter support migrations? Backend specific, as the
      # abstract adapter always returns +false+.
      def function
        false
      end;Fi[	@PisI"¨      # to an Active Record class, such as join tables? Backend specific, as
      # the abstract adapter always returns +false+.
      def function
        false
      end;Fi[	@Pi{I"¬      # CREATE TABLE or ALTER TABLE get rolled back by a transaction? PostgreSQL,
      # SQL Server, and others support this. MySQL and others do not.
      def function
        false
      end;Fi[	@PiI"@      end
      
      def function
        false
      end;Fi[	@PiÖI"í      # Does this adapter support savepoints? PostgreSQL and MySQL do,
      # SQLite < 3.6.8 does not.
      def function
        false
      end;Fi[	@PiíI"j      
      # Does this adapter support index sort order?
      def function
        false
      end;Fi[	@PióI"i      
      # Does this adapter support partial indices?
      def function
        false
      end;Fi[	@PiùI"´      # Does this adapter support explain? As of this writing sqlite3,
      # mysql2, and postgresql are the only ones that do.
      def function
        false
      end;Fi[	@Pi¢I"Ç      
      # Does this adapter support setting the isolation level for a transaction?
      def function
        false
      end;Fi[	@Pi›I"Ú      # Returns true if its required to reload the connection between requests for development mode.
      # This is not the case for Ruby/MySQL and it's not necessary for any adapters except SQLite.
      def function
        false
      end;Fi[	@úi#I"6    end
    
    def function
      false
    end;Fi[	@úi'I"6    end
    
    def function
      false
    end;Fi[	@8iÚI"@      end
      
      def function
        false
      end;Fi[	@õi,I"∏      # Provider defaults to false. Overridden when using a service-based
      # storage such as Amazon S3, Rackspace Cloud Files or Dropbox
      def function
        false
      end;Fi[	@*icI"@      end
      
      def function
        false
      end;Fi[	@õi5I"@      end
      
      def function
        false
      end;Fi[	@±iI"j      
      # Do not use remember_me behavior with token.
      def function
        false
      end;Fi[	I"3projects//diaspora_proj/models/conversation.rb;Ti0I",  end
  
  def function
    false
  end;Fi[	@’iwI"Ö  
  # @return Returns true if this Post will accept updates (i.e. updates to the caption of a photo).
  def function
    false
  end;Fi[	@’i{I",  end
  
  def function
    false
  end;Fi[	@Ôi\I"∞  # Because `ActionView` helpers may be included in non-`ActionView::Base` classes,
  # it's a good idea to define \{#is\_haml?} for all objects.
  def function
    false
  end;Fi[	@iMI"G    #
    # @return [Boolean]
    def function
      false
    end;Fi[	@ÛiAI"¨      # invoked?  This is used to determine whether to fire off attribute-based
      # event transitions when the action is run.
      def function
        false
      end;Fi[	@”i4I"X          # do nothing
        end
        def function
          false
        end;Fi[	I"module ActiveRecord;FI"module Associations;Fi#[#[	@KiI"{require("active_support/core_ext/string/conversions")
module ActiveRecord
  module Associations
    class AliasTracker;Fi[	@®iI"rrequire("active_support/core_ext/array/wrap")
module ActiveRecord
  module Associations
    class Association;Fi[	@´i I"Imodule ActiveRecord
  module Associations
    class AssociationScope;Fi [	@¸i I"cmodule ActiveRecord
  module Associations
    class BelongsToAssociation < SingularAssociation;Fi [	I"aprojects//activerecord_proj/active_record/associations/belongs_to_polymorphic_association.rb;Ti I"omodule ActiveRecord
  module Associations
    class BelongsToPolymorphicAssociation < BelongsToAssociation;Fi [	@Øi I"\module ActiveRecord
  module Associations
    class CollectionAssociation < Association;Fi [	@≤i I"Smodule ActiveRecord
  module Associations
    class CollectionProxy < Relation;Ti [	I"bprojects//activerecord_proj/active_record/associations/has_and_belongs_to_many_association.rb;Ti I"omodule ActiveRecord
  module Associations
    class HasAndBelongsToManyAssociation < CollectionAssociation;Fi [	I"Sprojects//activerecord_proj/active_record/associations/has_many_association.rb;Ti I"cmodule ActiveRecord
  module Associations
    class HasManyAssociation < CollectionAssociation;Fi [	@Xi I"gmodule ActiveRecord
  module Associations
    class HasManyThroughAssociation < HasManyAssociation;Fi [	@q
i I"`module ActiveRecord
  module Associations
    class HasOneAssociation < SingularAssociation;Fi [	I"Zprojects//activerecord_proj/active_record/associations/has_one_through_association.rb;Ti I"emodule ActiveRecord
  module Associations
    class HasOneThroughAssociation < HasOneAssociation;Fi [	@Si I"Gmodule ActiveRecord
  module Associations
    class JoinDependency;Fi [	@>i I"Gmodule ActiveRecord
  module Associations
    class JoinDependency;Fi [	@Ai I"Gmodule ActiveRecord
  module Associations
    class JoinDependency;Fi [	@Xi I"Gmodule ActiveRecord
  module Associations
    class JoinDependency;Fi [	I"Jprojects//activerecord_proj/active_record/associations/join_helper.rb;Ti I"Dmodule ActiveRecord
  module Associations
    module JoinHelper;Fi [	@[i I"Bmodule ActiveRecord
  module Associations
    class Preloader;Fi [	I"Sprojects//activerecord_proj/active_record/associations/preloader/belongs_to.rb;Ti I"Bmodule ActiveRecord
  module Associations
    class Preloader;Fi [	I"_projects//activerecord_proj/active_record/associations/preloader/collection_association.rb;Ti I"Bmodule ActiveRecord
  module Associations
    class Preloader;Fi [	@Di I"Bmodule ActiveRecord
  module Associations
    class Preloader;Fi [	I"Qprojects//activerecord_proj/active_record/associations/preloader/has_many.rb;Ti I"Bmodule ActiveRecord
  module Associations
    class Preloader;Fi [	I"Yprojects//activerecord_proj/active_record/associations/preloader/has_many_through.rb;Ti I"Bmodule ActiveRecord
  module Associations
    class Preloader;Fi [	I"Pprojects//activerecord_proj/active_record/associations/preloader/has_one.rb;Ti I"Bmodule ActiveRecord
  module Associations
    class Preloader;Fi [	I"Xprojects//activerecord_proj/active_record/associations/preloader/has_one_through.rb;Ti I"Bmodule ActiveRecord
  module Associations
    class Preloader;Fi [	I"]projects//activerecord_proj/active_record/associations/preloader/singular_association.rb;Ti I"Bmodule ActiveRecord
  module Associations
    class Preloader;Fi [	I"\projects//activerecord_proj/active_record/associations/preloader/through_association.rb;Ti I"Bmodule ActiveRecord
  module Associations
    class Preloader;Fi [	@v
i I"Bmodule ActiveRecord
  module Associations
    class Preloader;Fi [	I"Sprojects//activerecord_proj/active_record/associations/singular_association.rb;Ti I"Zmodule ActiveRecord
  module Associations
    class SingularAssociation < Association;Fi [	@˝i I"Lmodule ActiveRecord
  module Associations
    module ThroughAssociation;Fi [	@>@i![![	@]iI"z    #     def attributes
    #       {'name' => nil, 'age' => nil}
    #     end
    #
    #     def capitalized_name;Fi[	@]iHI"Ñ    #     def initialize(data = {})
    #       @data = data
    #     end
    #
    #     def read_attribute_for_serialization(key);Fi[	@`ioI"|      #         instance_variable_set("@#{key}", value)
      #       end
      #     end
      #
      #     def attributes;Fi[	@ciÀI"|      #         instance_variable_set("@#{key}", value)
      #       end
      #     end
      #
      #     def attributes;Fi[	I"Hprojects//activemodel_proj/active_model/validations/confirmation.rb;TiI"¨      #       validates_confirmation_of :email_address,
      #                                 message: 'should match confirmation'
      #     end
      #
      #   View:;Fi[	@Çi6I"∞      #         record.errors.add attribute, "must start with 'the'" unless value =~ /\Athe/i
      #       end
      #     end
      #
      #     validates :name, title: true;Fi[	@ãi+I"      #         record.errors.add :base, 'This record is invalid'
      #       end
      #     end
      #
      #     private;Fi[	@òiMI"      #     validate do |comment|
      #       comment.must_be_friends
      #     end
      #
      #     def must_be_friends;Fi[	@òiI"Å    #     def initialize(data = {})
    #       @data = data
    #     end
    #
    #     def read_attribute_for_validation(key);Fi[	@[iÑI"ê        #     def self.latest_article
        #       order('published_at desc').first
        #     end
        #
        #     def self.titles;Fi[	@zi:I"è      #     archive :my_archive do |archive|
      #       archive.add '/some/directory'
      #     end
      #
      #     compress_with Gzip;Fi[	@ziBI"∞      #       encryptor.passphrase = 'a secret'
      #       encryptor.recipients = ['joe@example.com', 'mary@example.com']
      #     end
      #
      #     store_with SFTP;Fi[	@∏i^I"y      #         @pending_notifications ||= []
      #       end
      #     end
      #
      def function(var, var);Fi[	@æi≤I"≠    #     devise_scope :owner do
    #       post "deactivate", :to => "registrations#deactivate", :as => "deactivate_registration"
    #     end
    #
    def function(var);Fi[	@Ôi•I"H    #         end
    #       end
    #     end
    #
    # outputs;Fi[	@·iI"h    #     def initialize(name)
    #       @name = name
    #     end
    #     
    #     def name;Fi[	@ÌiII"§    #         transition :idling => :parked
    #       end
    #     end
    #     
    #     state_machine :alarm_state, :namespace => 'alarm', :initial => :on do;Fi[	@Ìi{I"®    #         transition :idling => :parked
    #       end
    #     end
    #     
    #     state_machine :alarm_state, :namespace => 'alarm', :initial => :active do;Fi[	@ıi)I"Ü        #     before :save do
        #       # log message
        #     end
        #     
        #     # Target all state machines;Fi[	@ıi.I"∏        #     before_transition :parked => :idling, :on => :ignite do
        #       # put on seatbelt
        #     end
        #     
        #     # Target a specific state machine;Fi[	@ıi3I"ª        #     before_transition :state, any => :idling do
        #       # put on seatbelt
        #     end
        #     
        #     # Target all state machines without requirements;Fi[	@ıiÅI"Æ        #     after_transition_failure do |transition|
        #       # log failure
        #     end
        #     
        #     after_transition_failure :on => :ignite do;Fi[	@iÈI"}    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     
    #     def initialize;Fi[	@i˙I"â    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     
    #     def initialize(attributes = {});Fi[	@iI"â    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     
    #     def initialize(attributes = {});Fi[	@i$I"v    #       state nil, :idling
    #       ...
    #     end
    #     
    #     def initialize(attributes = {});Fi[	@iëI"ë    #         transition :parked => :idling
    #       end
    #     end
    #     
    #     state_machine :alarm_state, :initial => :active do;Fi[	@i»I"°    #         transition all => :off
    #       end
    #     end
    #     
    #     state_machine :alarm_state, :initial => :active, :namespace => 'alarm' do;Fi[	I">#   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;T@Ii![![	@≤i-I"ÿ      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@≤ifI"ÿ      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@≤irI"ª      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(var, var);Ti[	@≤iI"ÿ      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@≤iùI"ÿ      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@≤i„I"Ì      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(var, var);Ti[	@≤iI"ÿ      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@≤iAI"ÿ      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@≤iHI"ÿ      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@≤ibI"ÿ      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@≤iiI"ÿ      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@≤i{I"ÿ      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@≤iÇI"ÿ      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@≤iòI"ÿ      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@≤i∏I"ÿ      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@≤i¬I"¶      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@≤i‘I"ÿ      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@≤i⁄I"¨      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@≤iI"ÿ      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@≤i˙I"¶      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@≤iI"ÿ      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@≤iI"∂      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(var);Ti[	@≤i(I"ÿ      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@≤i2I"¶      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@≤i8I"¶      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@≤iÄI"Ì      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(var, var);Ti[	@≤iòI"ÿ      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@≤i¥I"„      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function;Ti[	I"@var = nil;F@ri![![	@®iI"\      def function
        @var = false
        @var = nil
        @var = nil
      end;Fi[	@[iI"{          @var = var
          @var = (var.first and var.first.class)
          @var = nil
          @var = nil
        end;Fi[	@&i`I"ï        end
        @var = var
        @var = nil
        @var = nil
        unless defined? @explicit_sequence_name and @explicit_sequence_name then;Fi[	@&iI"´        undefine_attribute_methods
        connection.schema_cache.clear_table_cache!(table_name) if table_exists?
        @var = nil
        @var = nil
        @var = nil;Fi[	@&iI"õ        connection.schema_cache.clear_table_cache!(table_name) if table_exists?
        @var = nil
        @var = nil
        @var = nil
        @var = nil;Fi[	@&iI"c        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil;Fi[	@&iI"c        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil;Fi[	@&iI"c        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil;Fi[	@&iI"c        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil;Fi[	@&iI"¶        @var = nil
        @var = nil
        @var = nil
        @var = nil
        unless defined? @explicit_inheritance_column and @explicit_inheritance_column then;Fi[	I"Jprojects//activerecord_proj/active_record/railties/jdbcmysql_error.rb;TiI"P    def function(var)
      super
      @var = nil
      @var = nil
    end;Fi[	@zioI"è        FileUtils.rm_rf(@tempdirs, "LITERAL" => (true)) if @tempdirs
        @var = []
        @var = nil
        @var = nil
        @var = nil;Fi[	@zipI"b        @var = []
        @var = nil
        @var = nil
        @var = nil
        @var = nil;Fi[	@ziqI"c        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil;Fi[	@zirI"Z        @var = nil
        @var = nil
        @var = nil
        @var = nil
      end;Fi[	@Æi*I"æ          @kwargs["STRING"] ||= Sass::Script::Bool.new(true)
          @kwargs["STRING"] ||= Sass::Script::String.new("STRING")
          @var = nil
          @var = nil
          @var = nil;Fi[	@Æi+I"ñ          @kwargs["STRING"] ||= Sass::Script::String.new("STRING")
          @var = nil
          @var = nil
          @var = nil
          @var = nil;Fi[	@Æi,I"m          @var = nil
          @var = nil
          @var = nil
          @var = nil
          @var = var;Fi[	@3
i∂I"W    def function(var)
      @var = false
      @var = nil
      @var = nil
    end;Fi[	@ŸiDI"O    @var = var
    @var = var
    @var = nil
    @var = nil
    @var = nil;Fi[	@ŸiEI"y    @var = var
    @var = nil
    @var = nil
    @var = nil
    if (var.kind_of?(IO) or var.kind_of?(StringIO)) then;Fi[	I".projects//homebrew_proj/test/test_ARGV.rb;TiI"[module ExtendArgvPlusYeast
  def function
    @var = nil
    @var = nil
    @var = nil;Fi[	@†i	I"O  def function
    @var = nil
    @var = nil
    @var = nil
    @var = nil;Fi[	@†i
I"g    @var = nil
    @var = nil
    @var = nil
    @var = nil
    while (ARGV.length > "LITERAL") do;Fi[	@’i≥I"i        def function(var)
          @var = var
          @var = nil
          @var = nil
        end;Fi[	@˙i'I"_          @var = @doc
        end
        @var = nil
        @var = nil
        @var = nil;Fi[	@˙i(I"Ñ        end
        @var = nil
        @var = nil
        @var = nil
        var.each { |var, var| @doc.send(:"#{var}STRING", var) };Fi[	@]iHI"{    def function(var)
      @var = var.map { |var| var.to_s.strip }
      @var = nil
      @var = nil
      validate_queues;Fi[	@@:i [ [	@®iI"{      #
      #   post.comments.aliased_table_name # => "comments"
      #
      def function
        klass.table_name;Fi[	@8inI"ë      #     has_many :tags, through: :taggings
      #   end
      #
      def function
        @var ||= source_reflection_names.collect do |var|;Fi[	@8iI"Ê      #   tags_reflection = Post.reflect_on_association(:tags)
      #   taggings_reflection = tags_reflection.through_reflection
      #
      def function
        @var ||= active_record.reflect_on_association(options["LITERAL"]);Fi[	@8i≈I"{      #
      #   [:singularized, :pluralized]
      #
      def function
        @var ||= (if options["LITERAL"] then;Fi[	@JiI"S    #     end
    #   end
    #
    def function
      extending(NullRelation);Fi[	@zikI"≥      ##
      # Remove any temporary directories and reset all instance variables.
      #
      def function
        FileUtils.rm_rf(@tempdirs, "LITERAL" => (true)) if @tempdirs;Fi[	@zi}I"≤      # messages, like the "Reading passphrase from file descriptor..."
      # messages during symmetric encryption
      #
      def function
        @var ||= (var = ["STRING"];Fi[	@ziëI"´      # we will get those messages on STDOUT for the log, without the actual
      # secret key listing which we don't care about.
      #
      def function
        begin;Fi[	@zi±I"∫      # If any errors occur during this process, we can not proceed.
      # We'll cleanup to remove the tempdir (if created) and raise an error.
      #
      def function
        begin;Fi[	@zi–I"Ã      # Returns the options needed for the gpg command line to perform
      # the encryption based on the #mode.
      #
      def function
        @var ||= (var = symmetric_options if mode.!=("LITERAL");Fi[	@zi›I"≥      # try to use :passphrase_file if it's set.
      # If the option can not be set, log a warning and return nil.
      #
      def function
        var = setup_passphrase_file;Fi[	@ziÔI"≠      # return the file's path. If an error occurs, log a warning.
      # Return false if no :passphrase is set or an error occurs.
      #
      def function
        begin;Fi[	@ziI"÷      # and return the command line options to perform asymmetric encryption.
      # Log a warning and return nil if no valid recipients are found.
      #
      def function
        if user_recipients.empty? then;Fi[	@ziI"»      # a warning will be issued; as we will attempt to encrypt the backup
      # and proceed if at all possible.
      #
      def function
        @var ||= [recipients].flatten.compact.map do |var|;Fi[	@zi-I"¬      # (Hash keys) 'cleaned' for exact matching. If the cleaning process
      # creates duplicate keys, the user will be warned.
      #
      def function
        @var ||= (var = (keys or {});Fi[	@ziXI"√      # keyring (based on #gpg_homedir setting) and return an Array of all
      # identifiers which could be used to specify a valid key.
      #
      def function
        @var ||= (var = false;Fi[	I"Iprojects//cancan_proj/cancan/model_adapters/active_record_adapter.rb;TiJI"      #   cannot :manage, User, :self_managed => true
      #   query(:manage, User).conditions # => "not (self_managed = 't') AND ((manager_id = 1) OR (id = 1))"
      #
      def function
        if (@rules.size == "LITERAL") and @rules.first.base_behavior then;Fi[	@0i}I"˘      #   # allow_unconfirmed_access_for = 0.days
      #   confirmation_period_valid?   # will always return false
      #
      def function
        confirmation_sent_at and (confirmation_sent_at.utc >= self.class.allow_unconfirmed_access_for.ago);Fi[	@0içI"È      #   # confirm_within = nil
      #   confirmation_period_expired?  # will always return false
      #
      def function
        self.class.confirm_within and (Time.now > (self.confirmation_sent_at + self.class.confirm_within));Fi[	@i3I"Ò      #   # reset_password_within = 0.days
      #   reset_password_period_valid?   # will always return false
      #
      def function
        reset_password_sent_at and (reset_password_sent_at.utc >= self.class.reset_password_within.ago);Fi[	@≠
i?I"˚      #   * If any of the authorization headers were sent;
      #   * If all authentication keys are present;
      #
      def function
        http_authenticatable? and (request.authorization and with_authentication_hash("LITERAL", http_auth_hash));Fi[	@≠
iJI"      #   * If the params[scope] returns a hash with credentials;
      #   * If all authentication keys are present;
      #
      def function
        params_authenticatable? and (valid_params_request? and (valid_params? and with_authentication_hash("LITERAL", params_auth_hash)));Fi[	@Ôi9I"§    #     context.init_haml_helpers
    #     context.haml_tag :p, "Stuff"
    #
    def function
      @var = Haml::Buffer.new(haml_buffer, Options.new.for_buffer);Fi[	@ixI"«      # namespaces, and as a result the order may be dependent on the
      # implementation of the underlying XML library.
      #
      def function
        xpath("STRING").inject({}) do |var, var|;Fi[	@iöI"Ø      #   irb> doc.slop!
      #   ... which does absolutely nothing.
      #
      def function
        unless decorators(XML::Node).include?(Nokogiri::Decorators::Slop) then;Fi[	@]iI"q    
    # Find Resque worker pids on Linux and OS X.
    #
    def function
      get_worker_pids("STRING");Fi[	@]iI"j    
    # Find Resque worker pids on Solaris.
    #
    def function
      get_worker_pids("STRING");Fi[	I";#   #       #<Pet id: 2, name: "Spook", person_id: 1>,;T@7i [ [	@≤i,I"·      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤ieI"·      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤iqI"ø      #   person.pets.find(2, 3)
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤i~I"·      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤iúI"·      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤i‚I"·      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤iI"·      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤i@I"·      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤iGI"·      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤iaI"·      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤ihI"·      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤izI"·      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤iÅI"·      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤ióI"·      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤i∑I"·      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤i¡I"¥      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤i”I"·      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤iÔI"·      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤i˘I"¥      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤iI"·      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤iI"¡      #   person.pets.delete(2, 3)
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤i'I"·      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤i1I"¥      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤i7I"÷      #   person.pets.destroy(Pet.find(2), Pet.find(3))
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤iI"·      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤ióI"·      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤i≥I"·      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@£@ˆi[[	@∫iI"á      private
      
      def function(var)
        super
        owner[reflection.foreign_type] = (var and var.class.base_class.name);Fi[	@˜i-I"Ü      
      module ClassMethods
        def function(var)
          super
          if (var == primary_key) and var.!=("STRING") then;Fi[	@i!I"i      end
      
      def function(var)
        super
        if ActiveRecord::Base.connected? then;Fi[	@âi	I"d    attr_accessor("LITERAL", "LITERAL")
    
    def function(var)
      super
      @var = nil;Fi[	@8iëI"q      end
      
      def function(var)
        super
        @var = ["LITERAL", "LITERAL"].include?(macro);Fi[	@niI"•  module Validations
    class PresenceValidator < ActiveModel::Validations::PresenceValidator
      def function(var)
        super
        attributes.each do |var|;Fi[	@ziJI"s      #
      # @api private
      def function(var)
        super
        instance_eval(&var) if block_given?;Fi[	I"7projects//backup_proj/backup/encryptor/open_ssl.rb;TiI"∂      # Creates a new instance of Backup::Encryptor::OpenSSL and
      # sets the password attribute to what was provided
      def function(var)
        super
        @var ||= false;Fi[	@}i(I"Ë        # Once pre-configured defaults and Cloud specific defaults are set,
        # the block from the user's configuration file is evaluated.
        def function(var)
          super
          instance_eval(&var) if block_given?;Fi[	@ÄiI"Ë        # Once pre-configured defaults and Cloud specific defaults are set,
        # the block from the user's configuration file is evaluated.
        def function(var)
          super
          instance_eval(&var) if block_given?;Fi[	I"7projects//backup_proj/backup/syncer/rsync/local.rb;TiI"Ë        # Once pre-configured defaults and RSync specific defaults are set,
        # the block from the user's configuration file is evaluated.
        def function(var)
          super
          instance_eval(&var) if block_given?;Fi[	@Üi$I"◊        # Once pre-configured defaults and RSync specific defaults are set,
        # the block from the user's configuration file is evaluated.
        def function(var)
          super
          @var ||= "LITERAL";Fi[	I"Aprojects//compass_proj/compass/exec/global_options_parser.rb;TiI"hmodule Compass::Exec::GlobalOptionsParser
  def function(var)
    super
    set_global_options(var);Fi[	I"Bprojects//compass_proj/compass/exec/project_options_parser.rb;TiI"jmodule Compass::Exec::ProjectOptionsParser
  def function(var)
    super
    set_project_options(var);Fi[	@ÆiI"j      private
      
      def function(var)
        super
        if var.respond_to?("LITERAL") then;Fi[	@ˇiûI"û    class Haml < Generic
      # @param args [Array<String>] The command-line arguments
      def function(var)
        super
        @options["LITERAL"] = {};Fi[	@ˇi®I"s      #
      # @param opts [OptionParser]
      def function(var)
        super
        var.banner = "STRING";Fi[	@3
iúI"ü    
    class ParseNode < Struct.new("LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL")
      def function(var)
        super
        self.children ||= [];Fi[	@J
ihI"E  end
  
  def function(var)
    super
    $n = ($n + "LITERAL");Fi[	I"6projects//nokogiri_proj/xsd/xmlparser/nokogiri.rb;TiI"o      ###
      # Handle the end_element event with +name+
      def function(var)
        super
      end;Fi[	I"5projects//rescue_proj/resque/failure/multiple.rb;TiI"y      end
      
      def function(var)
        super
        @var = self.class.classes.map { |var| var.new(*var) };Fi[	@iEI"—    # Creates a copy of this event in addition to the list of associated
    # branches to prevent conflicts across events within a class hierarchy.
    def function(var)
      super
      @var = @branches.dup;Fi[	@ji(I"ü    # Creates a copy of this collection such that modifications don't affect
    # the original collection
    def function(var)
      super
      var = @nodes;Fi[	@$iI"D    end
    
    def function(var)
      super
      @var = nil;Fi[	@*iUI"ø    # Creates a copy of this state in addition to the list of associated
    # methods to prevent conflicts across different states.
    def function(var)
      super
      @var = methods.dup;Fi[	I"/projects//twitter_proj/twitter/identity.rb;TiI"     # @raise [ArgumentError] Error raised when supplied argument is missing an :id key.
    # @return [Twitter::Identity]
    def function(var)
      super
      raise(ArgumentError, "STRING") unless id;Fi[	I"#   person.pets;TI"#   # => [;Fi[[	@≤i)I"      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@≤ibI"      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@≤i{I"      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@≤iôI"      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@≤iI"å      #
      #   person.id # => 1
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@≤i=I"ì      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@≤i^I"ì      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@≤iwI"ì      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@≤iîI"ì      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@≤i¥I"ì      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@≤iøI"ç      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@≤i–I"ì      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@≤iÏI"ì      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@≤i˜I"ç      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@≤iI"ì      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@≤i$I"ì      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@≤i/I"ç      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@≤iDI"ç      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,;Ti[	@≤iOI"ç      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,;Ti[	@≤i|I"î      #
      #   person.pets.count # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@≤i∞I"€      #   # Because the collection is loaded, you can
      #   # call the collection with no additional queries:
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@≤iI"ú      # based on the criteria has more than one record.
      #
      #   person.pets
      #   # => [
      #   #      #<Pet name: "Gorby", group: "cats">,;Ti[	@≤iCI"~      #   end
      #
      #   person.pets
      #   # => [
      #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@≤i]I"~      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,;Ti[	@≤iãI"ã      #
      #   person.id # => 1
      #   person.pets
      #   # => [
      #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	I"when "STRING" then;F@;i[[	@ñi=I"ç          when String then
            case var.sql_type
            when "STRING" then
              "STRING"
            when "STRING" then;Fi[	@ñi?I"ã            when "STRING" then
              "STRING"
            when "STRING" then
              "STRING"
            when "LITERAL" then;Fi[	@ÀiI"ù        if var.is_a?(Sass::Script::String) then
          var = case var.value
          when "STRING" then
            "STRING"
          when "STRING" then;Fi[	@ÀiI"Ä          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then;Fi[	@ÀiI"Ä          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then;Fi[	@ÀiI"Ä          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then;Fi[	@Ài I"w          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          else;Fi[	@ÀiDI"ç      var = var.value.split("LITERAL").map do |var|
        case var
        when "STRING" then
          "STRING"
        when "STRING" then;Fi[	@ÀiFI"{        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING"
        when "STRING" then;Fi[	@ÀiHI"{        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING"
        when "STRING" then;Fi[	@ÀiJI"{        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING"
        when "STRING" then;Fi[	@ÀiLI"m        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING"
        else;Fi[	@ÏiıI"ï            else
              case @node.value["LITERAL"]
              when "STRING" then
                "STRING"
              when "STRING" then;Fi[	@Ïi˜I"î              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING"
              when "STRING" then;Fi[	@Ïi˘I"î              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING"
              when "STRING" then;Fi[	@Ïi˚I"î              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING"
              when "STRING" then;Fi[	@Ïi˝I"Ü              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING"
              else;Fi[	@ÏiI"û          if @options.html4? then
            case @node.value["LITERAL"]
            when "STRING" then
              "STRING"
            when "STRING" then;Fi[	@Ïi	I"|            when "STRING" then
              "STRING"
            when "STRING" then
              "STRING"
            else;Fi[	@KigI"ä          when "STRING", "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then;Fi[	@KiiI"Ä          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then;Fi[	@KikI"Ä          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then;Fi[	@KimI"Ä          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then;Fi[	@KioI"Ä          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then;Fi[	@KiqI"w          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          else;Fi[	I"+problem("STRING") if text =~ "LITERAL";F@…i[[	@i≤I"å  
  def function
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    unless (f.name == "STRING") then;Fi[	@iπI"í      end
    end
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL";Fi[	@i∫I"≥    end
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL";Fi[	@iªI"÷    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL";Fi[	@iºI"÷    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL";Fi[	@iΩI"÷    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL";Fi[	@iæI"÷    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL";Fi[	@iøI"÷    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL";Fi[	@i¿I"÷    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL";Fi[	@i¡I"÷    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL";Fi[	@i¬I"÷    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL";Fi[	@i√I"÷    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL";Fi[	@iƒI"÷    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL";Fi[	@i≈I"÷    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL";Fi[	@i∆I"Ó    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL" and text =~ "LITERAL".!;Fi[	@i…I"Ó    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL" and text =~ "LITERAL".!
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL";Fi[	@i I"Ó    problem("STRING") if text =~ "LITERAL" and text =~ "LITERAL".!
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL";Fi[	@iÀI"÷    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL";Fi[	@iÃI"÷    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL";Fi[	@iÕI"÷    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL";Fi[	@iŒI"÷    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL";Fi[	@iœI"÷    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL";Fi[	@i–I"÷    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL";Fi[	@i—I"÷    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL";Fi[	@i“I"±    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
    problem("STRING") if text =~ "LITERAL"
  end;Fi[	I" action { ["LITERAL", var] };FI"(when var = @ss.scan("LITERAL") then;Fi[[	@ i<I"∫          case
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] };Fi[	@ i>I"”            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] };Fi[	@ i@I"”            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] };Fi[	@ iBI"”            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] };Fi[	@ iDI"”            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] };Fi[	@ iFI"”            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] };Fi[	@ iHI"”            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] };Fi[	@ iJI"”            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] };Fi[	@ iLI"”            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] };Fi[	@ iNI"”            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] };Fi[	@ iPI"”            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] };Fi[	@ iRI"”            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] };Fi[	@ iTI"”            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] };Fi[	@ iVI"”            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] };Fi[	@ iXI"”            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] };Fi[	@ iZI"”            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] };Fi[	@ i\I"”            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] };Fi[	@ i^I"”            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] };Fi[	@ i`I"”            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] };Fi[	@ ibI"”            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] };Fi[	@ idI"”            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] };Fi[	@ ifI"”            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] };Fi[	@ ihI"”            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] };Fi[	@ ijI"”            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] };Fi[	@ ilI"Õ            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { [var, var] };Fi[	I"case var;F@i[[	@|i6I"^      
      def function(var)
        case var
        when "LITERAL" then
          nil;Fi[	@XinI"ä      
      def function(var)
        case var
        when "LITERAL" then
          inverse_updates_counter_cache?(through_reflection).!;Fi[	@Xi}I"Ø        var = through_association.scope
        var.where!(construct_join_attributes(*var))
        case var
        when "LITERAL" then
          var = var.destroy_all.length;Fi[	@q
i/I"~      def function(var)
        if load_target then
          case var
          when "LITERAL" then
            target.delete;Fi[	@q
iGI"h      
      def function(var)
        case var
        when "LITERAL" then
          target.delete;Fi[	@UiCI"m        
        def function(var)
          case var
          when "LITERAL" then
            case var;Fi[	@UiEI"}          case var
          when "LITERAL" then
            case var
            when "LITERAL" then
              "LITERAL";Fi[	@Ui–I"{        case var.to_s
        when "STRING" then
          case var
          when "LITERAL" then
            "STRING";Fi[	@Ui€I"s          end
        when "STRING" then
          case var
          when "LITERAL" then
            "STRING";Fi[	@UiÍI"s          end
        when "STRING" then
          case var
          when "LITERAL" then
            "STRING";Fi[	@Ç
iJI"ß            var.each do |var, var|
              var = var[var]
              case var
              when "LITERAL" then
                var.gsub!("LITERAL", "STRING");Fi[	@si#I"ú          def function(var)
            return if var.nil?
            case var
            when "LITERAL" then
              var.gsub!("LITERAL", "STRING");Fi[	@ñiBI"à              "STRING"
            when "LITERAL" then
              case var
              when "LITERAL" then
                "STRING";Fi[	@õiI"π          var = var.reverse_merge("LITERAL" => "STRING")
          var = var.symbolize_keys.sum do |var, var|
            case var
            when "LITERAL" then
              "STRING";Fi[	@õi8I"å          when "STRING" then
            return super unless var
            case var
            when "LITERAL" then
              "STRING";Fi[	@õi@I"è          when "STRING" then
            return "STRING" unless var
            case var
            when "LITERAL" then
              "STRING";Fi[	@„	i√I"ﬁ    # Determine if a transaction included an action for :create, :update, or :destroy. Used in filtering callbacks.
    def function(var)
      case var
      when "LITERAL" then
        transaction_record_state("LITERAL");Fi[	@Œi&I"g  def function(var, var)
    return var if var
    case var
    when "LITERAL" then
      "STRING";Fi[	@Ïi7I"ô      var = "LITERAL"
      @to_merge.each do |var, var, var|
        case var
        when "LITERAL" then
          (var << inspect_obj(var)["LITERAL"]);Fi[	@Êi~I"z  def function(var)
    fetch(var, []).map do |var|
      case var
      when "LITERAL" then
        Pathname.new($1);Fi[	@ÊiåI"Å  def function(var)
    fetch(var, []).map do |var|
      case var
      when "LITERAL" then
        File.basename(var, "STRING");Fi[	@ÈiˆI"f  
  def self.detect_from_url(var)
    case var
    when "LITERAL" then
      CVSDownloadStrategy;Fi[	@ÈiI"l  
  def self.detect_from_symbol(var)
    case var
    when "LITERAL" then
      BazaarDownloadStrategy;Fi[	@J
i£I"    var = nil
    File.open(self) { |var| var = var.read("LITERAL") }
    case var
    when "LITERAL" then
      "LITERAL";Fi[	@fiI"c      
      def function(var)
        case var
        when "LITERAL" then
          "STRING";Fi[	@ˇ@˛i[[	@ i;I"®        when nil then
          case
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then;Fi[	@ i=I"Ÿ          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then;Fi[	@ i?I"Ÿ          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then;Fi[	@ iAI"Ÿ          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then;Fi[	@ iCI"Ÿ          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then;Fi[	@ iEI"Ÿ          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then;Fi[	@ iGI"Ÿ          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then;Fi[	@ iII"Ÿ          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then;Fi[	@ iKI"Ÿ          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then;Fi[	@ iMI"Ÿ          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then;Fi[	@ iOI"Ÿ          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then;Fi[	@ iQI"Ÿ          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then;Fi[	@ iSI"Ÿ          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then;Fi[	@ iUI"Ÿ          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then;Fi[	@ iWI"Ÿ          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then;Fi[	@ iYI"Ÿ          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then;Fi[	@ i[I"Ÿ          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then;Fi[	@ i]I"Ÿ          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then;Fi[	@ i_I"Ÿ          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then;Fi[	@ iaI"Ÿ          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then;Fi[	@ icI"Ÿ          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then;Fi[	@ ieI"Ÿ          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then;Fi[	@ igI"Ÿ          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then;Fi[	@ iiI"Ÿ          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then;Fi[	@ ikI"Ÿ          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then
            action { ["LITERAL", var] }
          when var = @ss.scan("LITERAL") then;Fi[	@I"# Configuration options:;Fi[[	@fiI"œ      #
      # The first_name attribute must be in the object and it must be blank.
      #
      # Configuration options:
      # * <tt>:message</tt> - A custom error message (default is: "must be blank").;Fi[	@ii&I"Ó      # is entirely virtual. This check is performed only if +terms_of_service+
      # is not +nil+ and by default on save.
      #
      # Configuration options:
      # * <tt>:message</tt> - A custom error message (default is: "must be;Fi[	@i/I"Œ      #
      #   validates_presence_of :password_confirmation, if: :password_changed?
      #
      # Configuration options:
      # * <tt>:message</tt> - A custom error message (default is: "doesn't match;Fi[	@qiI"ƒ      #     validates_exclusion_of :karma, in: :reserved_karmas
      #   end
      #
      # Configuration options:
      # * <tt>:in</tt> - An enumerable object of items that the value shouldn't;Fi[	@ti[I"      # In addition, both must be a regular expression or a proc or lambda, or
      # else an exception will be raised.
      #
      # Configuration options:
      # * <tt>:message</tt> - A custom error message (default is: "is invalid").;Fi[	@{iI"√      #     validates_inclusion_of :karma, in: :available_karmas
      #   end
      #
      # Configuration options:
      # * <tt>:in</tt> - An enumerable object of available items. This can be;Fi[	@~iNI"º      #                         tokenizer: ->(str) { str.scan(/\w+/) }
      #   end
      #
      # Configuration options:
      # * <tt>:minimum</tt> - The minimum size of the attribute.;Fi[	@|iTI"ƒ      #     validates_numericality_of :value, on: :create
      #   end
      #
      # Configuration options:
      # * <tt>:message</tt> - A custom error message (default is: "is not a number").;Fi[	@iI"È      # This is due to the way Object#blank? handles boolean values:
      # <tt>false.blank? # => true</tt>.
      #
      # Configuration options:
      # * <tt>:message</tt> - A custom error message (default is: "can't be blank").;Fi[	@ãi9I"º      #     validates_with MyValidator, MyOtherValidator, on: :create
      #   end
      #
      # Configuration options:
      # * <tt>:on</tt> - Specifies when this validation is active;Fi[	@ki"I"Õ      # assigned. If you want to ensure that the association is both present and
      # guaranteed to be valid, you also need to use +validates_presence_of+.
      #
      # Configuration options:
      #;Fi[	@ni.I"‡      # deletes the associated object, thus putting the parent object into an invalid
      # state.
      #
      # Configuration options:
      # * <tt>:message</tt> - A custom error message (default is: "can't be blank").;Fi[	@qiyI"∏      # attribute (that maps to a column). When the record is updated,
      # the same check is made but disregarding the record itself.
      #
      # Configuration options:
      #;Fi[	@i/I"›    # branches/transitions as the source
    # Creates a new event within the context of the given machine
    # 
    # Configuration options:
    # * <tt>:human_name</tt> - The human-readable version of this event's name;Fi[	@i∑I"≥    # 
    # A collection of the generated edges will be returned.
    # 
    # Configuration options:
    # * <tt>:human_name</tt> - Whether to use the event's human name for the;Fi[	@i
I"Í    # Creates a new state machine with the given name.  The default name, if not
    # specified, is <tt>:state</tt>.
    # 
    # Configuration options:
    # * <tt>:attribute</tt> - The name of the attribute to store the state value;Fi[	@jiI"ﬂ    # Creates a new collection of nodes for the given state machine.  By default,
    # the collection is empty.
    # 
    # Configuration options:
    # * <tt>:index</tt> - One or more attributes to automatically generate;Fi[	@$iI"–    # empty path.  In order to start walking the path, it must be populated with
    # an initial transition.
    # 
    # Configuration options:
    # * <tt>:target</tt> - The target state to end the path on;Fi[	@'iI"∆    # The target state for each path
    # Creates a new collection of paths with the given requirements.
    # 
    # Configuration options:
    # * <tt>:from</tt> - The initial state to start from;Fi[	@*i/I"›    # Maps :method_name => UnboundMethod
    # Creates a new state within the context of the given machine.
    # 
    # Configuration options:
    # * <tt>:initial</tt> - Whether this state is the beginning state for the;Fi[	@*iwI"/    #   State.new(machine, :parked, :value => 1).description                  # => "parked (1)"
    #   State.new(machine, :parked, :value => lambda {Time.now}).description  # => "parked (*)
    # 
    # Configuration options:
    # * <tt>:human_name</tt> - Whether to use this state's human name in the;Fi[	@*iŒI"∂    # 
    # The actual node generated on the graph will be returned.
    # 
    # Configuration options:
    # * <tt>:human_name</tt> - Whether to use the state's human name for the;Fi[	@3iÃI"Ù    # Runs the before / after callbacks for this transition.  If a block is
    # provided, then it will be executed between the before and after callbacks.
    # 
    # Configuration options:
    # * +before+ - Whether to run before callbacks.;Fi[	@k
iI"ˇ    # Creates a new collection of transitions that can be run in parallel.  Each
    # transition *must* be for a different attribute.
    # 
    # Configuration options:
    # * <tt>:actions</tt> - Whether to run the action configured for each transition;Fi[	@£@4i[[	@|i5I"`      protected
      
      def function(var)
        case var
        when "LITERAL" then;Fi[	@ÇiïI"Z      end
      
      def function(var)
        case var
        when TrueClass then;Fi[	@XimI"Z      end
      
      def function(var)
        case var
        when "LITERAL" then;Fi[	@q
iFI"Z      end
      
      def function(var)
        case var
        when "LITERAL" then;Fi[	@v
iGI"Y      private
      
      def function(var)
        case var
        when Hash then;Fi[	@Åi,I"_      private
      
      def function(var)
        case var
        when BigDecimal then;Fi[	@UiBI"d        end
        
        def function(var)
          case var
          when "LITERAL" then;Fi[	@ìiâI"c        end
        
        def function(var)
          case var
          when "STRING" then;Fi[	@Ji€I"b    end
    
    def function(var)
      case var
      when String, TrueClass, NilClass then;Fi[	@Qi”I"r    
    # Compares two relations for equality.
    def function(var)
      case var
      when Relation then;Ti[	@∏i+I"ƒ      # them into a valid SQL fragment for a SET clause.
      #   { name: nil, group_id: 4 }  returns "name = NULL , group_id='4'"
      def function(var)
        case var
        when Array then;Fi[	@„	i¬I"∑    
    # Determine if a transaction included an action for :create, :update, or :destroy. Used in filtering callbacks.
    def function(var)
      case var
      when "LITERAL" then;Fi[	@1iI"ømodule Compass::SassExtensions::Functions::Lists
  # Returns true when the object is false, an empty string, or an empty list
  def function(var)
    case var
    when Sass::Script::Bool then;Fi[	@4i¬I"P  end
  
  def function(var)
    case var
    when Sass::Script::Color then;Fi[	I"+projects//compass_proj/compass/util.rb;TiI"Q  end
  
  def function(var)
    case var
    when NilClass, FalseClass then;Fi[	I"-projects//diaspora_proj/models/aspect.rb;TiI"A  end
  
  def function(var)
    case var
    when Post then;Fi[	@˝iYI"Ç    # is not a String.
    # Strings contained in x must be valid UTF-8.
    def function(var)
      case var
      when Hash then;Fi[	@˝idI"K    end
    
    def function(var)
      case var
      when Hash then;Fi[	@˝iÅI"M    end
    
    def function(var)
      case var
      when String then;Fi[	@	iêI"U      end
      
      def function(var)
        case var
        when File then;Fi[	@ciˆI"Y      private
      
      def function(var)
        case var
        when File then;Fi[	@`i"I"õ  #   5. An instance of `Redis`, `Redis::Client`, `Redis::DistRedis`,
  #      or `Redis::Namespace`.
  def function(var)
    case var
    when String then;Fi[	@fiI"^      private
      
      def function(var)
        case var
        when "LITERAL" then;Fi[	I":projects//twitter_proj/twitter/response/parse_json.rb;Ti
I"è  module Response
    class ParseJson < Faraday::Response::Middleware
      def function(var)
        case var
        when "LITERAL", nil then;Fi[	@I"# Returns nothing.;Fi[[	I"0projects//jekyll_proj/jekyll/convertible.rb;TiI"¢    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(var, var);Fi[	@i#I"o    
    # Transform the contents based on the content type.
    #
    # Returns nothing.
    def function;Fi[	@i=I"é    # payload - The site payload Hash.
    # layouts - A Hash of {"name" => "layout"}.
    #
    # Returns nothing.
    def function(var, var);Fi[	I":projects//jekyll_proj/jekyll/generators/pagination.rb;TiI"T    #
    # site - The Site.
    #
    # Returns nothing.
    def function(var);Fi[	@‚i&I"r    #
    # name - The String filename of the layout file.
    #
    # Returns nothing.
    def function(var);Fi[	@i$I"¢    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(var, var);Fi[	@i\I"p    #
    # name - The String filename of the page file.
    #
    # Returns nothing.
    def function(var);Fi[	@igI"ö    # layouts      - The Hash of {"name" => "layout"}.
    # site_payload - The site payload Hash.
    #
    # Returns nothing.
    def function(var, var);Fi[	@i~I"r    #
    # dest - The String path to the destination dir.
    #
    # Returns nothing.
    def function(var);Fi[	@
iBI"¢    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(var, var);Fi[	@
iYI"p    #
    # name - The String filename of the post file.
    #
    # Returns nothing.
    def function(var);Fi[	@
i∫I"ò    # layouts      - A Hash of {"name" => "layout"}.
    # site_payload - The site payload hash.
    #
    # Returns nothing.
    def function(var, var);Fi[	@
iœI"r    #
    # dest - The String path to the destination dir.
    #
    # Returns nothing.
    def function(var);Fi[	@Z
i"I"s    
    # Public: Read, process, and write this Site to output.
    #
    # Returns nothing.
    def function;Fi[	@Z
iBI"|    
    # Load necessary libraries, plugins, converters, and generators.
    #
    # Returns nothing.
    def function;Fi[	@Z
iUI"|    
    # Read Site data from disk and load it into internal data structures.
    #
    # Returns nothing.
    def function;Fi[	@Z
i^I"ê    # Read all the files in <source>/<layouts> and create a new Layout object
    # with each one.
    #
    # Returns nothing.
    def function;Fi[	@Z
ipI"Ñ    #
    # dir - The String relative path of the directory to read. Default: ''.
    #
    # Returns nothing.
    def function(var);Fi[	@Z
iàI"|    #
    # dir - The String relative path of the directory to read.
    #
    # Returns nothing.
    def function(var);Fi[	@Z
i†I"Y    
    # Run each of the Generators.
    #
    # Returns nothing.
    def function;Fi[	@Z
ißI"a    
    # Render the site to the destination.
    #
    # Returns nothing.
    def function;Fi[	@Z
i∂I"y    
    # Remove orphaned files and empty directories in destination.
    #
    # Returns nothing.
    def function;Fi[	@Z
iŸI"c    
    # Write static files, pages, and posts.
    #
    # Returns nothing.
    def function;Fi[	I"$projects//jekyll_proj/jekyll.rb;Ti
I"k#
# path - The String relative path from here to the directory.
#
# Returns nothing.
def function(var);Fi[	I"var = var["LITERAL"];F@;i[[	@Ã	iI"Ö    def function(var)
      var = var.symbolize_keys
      var = var["LITERAL"]
      var = var["LITERAL"]
      var = var["LITERAL"];Fi[	@Ã	iI"Ø      var = var.symbolize_keys
      var = var["LITERAL"]
      var = var["LITERAL"]
      var = var["LITERAL"]
      var = var["LITERAL"] ? (var["LITERAL"].to_s) : ("STRING");Fi[	@õiUI"”            var = (var["LITERAL"] == "STRING")
            var = var["LITERAL"].split("STRING")
            var = var["LITERAL"]
            var = var["LITERAL"]
            var = Hash[query("STRING", "STRING")];Fi[	@ÈiπI"≠    # just like you can do with `dom_id()` and `dom_class()` in Rails
    def function(var)
      var = var["LITERAL"]
      var = var["LITERAL"]
      return {} if var.nil?;Fi[	@ÏiÑI"z        var = false
      else
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"];Fi[	@ÏiÖI"~      else
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"];Fi[	@ÏiÜI"ê        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"];Fi[	@ÏiáI"}        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"]
      end;Fi[	I"5projects//jekyll_proj/jekyll/migrators/drupal.rb;TiI"∂      File.open("STRING", "STRING") { |var| var.puts("STRING") }
      var[QUERY].each do |var|
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"];Fi[	@NiI"í      var[QUERY].each do |var|
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"];Fi[	@NiI"é        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = Time.at(var);Fi[	I"5projects//jekyll_proj/jekyll/migrators/joomla.rb;TiI"à      var = "STRING"
      var[var].each do |var|
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"];Fi[	@UiI"ê      var[var].each do |var|
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"];Fi[	@UiI"≤        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = ("STRING" % [var.year, var.month, var.day, var]);Fi[	I"7projects//jekyll_proj/jekyll/migrators/mephisto.rb;TiI"ó      FileUtils.mkdir_p("STRING")
      var[QUERY].each do |var|
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"];Fi[	@\iI"í      var[QUERY].each do |var|
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"];Fi[	@\iI"¡        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = ([var.year, var.month, var.day, var].join("STRING") + "STRING");Fi[	@	iI"™        var = var["LITERAL"]
        var = var["LITERAL"].gsub("LITERAL", "STRING")
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"];Fi[	@	iI"™        var = var["LITERAL"].gsub("LITERAL", "STRING")
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"];Fi[	@	iI"©        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = ((var + "STRING") + var) if var.!=(nil);Fi[	I":projects//jekyll_proj/jekyll/migrators/textpattern.rb;TiI"ó      FileUtils.mkdir_p("STRING")
      var[QUERY].each do |var|
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"];Fi[	@iiI"í      var[QUERY].each do |var|
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"];Fi[	@iiI"ª        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = var["LITERAL"]
        var = ([var.strftime("STRING"), var].join("STRING") + "STRING");Fi[	I"8projects//jekyll_proj/jekyll/migrators/wordpress.rb;Ti"I"ï    
    def self.process_post(var, var, var)
      var = var["LITERAL"]
      var = var["LITERAL"]
      var = clean_entities(var) if var["LITERAL"];Fi[	I"#     has_many :pets;T@i[[	@≤i&I"i      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #;Ti[	@≤i_I"i      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #;Ti[	@≤i}I"i      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #;Ti[	@≤iñI"i      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #;Ti[	@≤iµI"T      #
      #   class Person
      #     has_many :pets
      #   end
      #;Ti[	@≤i–I"T      #
      #   class Person
      #     has_many :pets
      #   end
      #;Ti[	@≤iÏI"T      #
      #   class Person
      #     has_many :pets
      #   end
      #;Ti[	@≤iI"i      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #;Ti[	@≤iêI"i      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #;Ti[	@≤iI"i      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #;Ti[	@≤i I"i      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #;Ti[	@≤ifI"i      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #;Ti[	@≤ixI"i      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #;Ti[	@≤iéI"i      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #;Ti[	@≤i®I"i      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #;Ti[	@≤i¬I"i      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #;Ti[	@≤i”I"i      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #;Ti[	@≤iıI"i      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #;Ti[	@≤iI"i      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #;Ti[	@≤i@I"i      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #;Ti[	@≤iZI"i      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #;Ti[	@≤iÇI"i      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #;Ti[	@≤i£I"i      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #;Ti[	I"version("STRING") do;FI"def self.active?;Fi[[	I"Uprojects//state_machine_proj/state_machine/integrations/active_model/versions.rb;TiI"æ  module Integrations
    module ActiveModel
      version("STRING") do
        def self.active?
          (defined? ::ActiveModel::VERSION.! or (::ActiveModel::VERSION::MAJOR == "LITERAL"));Fi[	@®iI"“      end
      
      version("STRING") do
        def self.active?
          defined? ::ActiveModel::VERSION and ((::ActiveModel::VERSION::MAJOR == "LITERAL") and (::ActiveModel::VERSION::MINOR == "LITERAL"));Fi[	@ÃiI"   module Integrations
    module ActiveRecord
      version("STRING") do
        def self.active?
          ((::ActiveRecord::VERSION::MAJOR == "LITERAL") or ((::ActiveRecord::VERSION::MAJOR == "LITERAL") and (::ActiveRecord::VERSION::MINOR == "LITERAL")));Fi[	@ÃiI"|      end
      
      version("STRING") do
        def self.active?
          (::ActiveRecord::VERSION::MAJOR == "LITERAL");Fi[	@ÃiHI"≠      end
      
      version("STRING") do
        def self.active?
          (::ActiveRecord::VERSION::MAJOR == "LITERAL") and (::ActiveRecord::VERSION::MINOR < "LITERAL");Fi[	@ÃiQI"ﬁ      end
      
      version("STRING") do
        def self.active?
          (::ActiveRecord::VERSION::MAJOR == "LITERAL") and ((::ActiveRecord::VERSION::MINOR < "LITERAL") or (::ActiveRecord::VERSION::TINY < "LITERAL"));Fi[	@ÃiZI"·      end
      
      version("STRING") do
        def self.active?
          (::ActiveRecord::VERSION::MAJOR == "LITERAL") and ((::ActiveRecord::VERSION::MINOR == "LITERAL") and (::ActiveRecord::VERSION::TINY >= "LITERAL"));Fi[	@ÃicI"Æ      end
      
      version("STRING") do
        def self.active?
          (::ActiveRecord::VERSION::MAJOR == "LITERAL") and (::ActiveRecord::VERSION::MINOR == "LITERAL");Fi[	I"Tprojects//state_machine_proj/state_machine/integrations/data_mapper/versions.rb;TiI"å  module Integrations
    module DataMapper
      version("STRING") do
        def self.active?
          ::DataMapper::VERSION =~ "LITERAL";Fi[	@πiI"ô      end
      
      version("STRING") do
        def self.active?
          (::DataMapper::VERSION =~ "LITERAL" or ::DataMapper::VERSION =~ "LITERAL");Fi[	@πiI"v      end
      
      version("STRING") do
        def self.active?
          ::DataMapper::VERSION =~ "LITERAL";Fi[	@πi%I"w      end
      
      version("STRING") do
        def self.active?
          (::DataMapper::VERSION == "STRING");Fi[	@”iI"å  module Integrations
    module MongoMapper
      version("STRING") do
        def self.active?
          defined? ::MongoMapper::Plugins.!;Fi[	@”iI"ô      end
      
      version("STRING") do
        def self.active?
          (defined? ::MongoMapper::Version.! or ::MongoMapper::Version =~ "LITERAL");Fi[	@”iI"ô      end
      
      version("STRING") do
        def self.active?
          (defined? ::MongoMapper::Version.! or ::MongoMapper::Version =~ "LITERAL");Fi[	@”iBI"Ω      end
      
      version("STRING") do
        def self.active?
          defined? ::MongoMapper::Plugins and (defined? ::MongoMapper::Version.! or ::MongoMapper::Version =~ "LITERAL");Fi[	@”iKI"ñ      end
      
      version("STRING") do
        def self.active?
          defined? ::MongoMapper::Version and ::MongoMapper::Version =~ "LITERAL";Fi[	I"Pprojects//state_machine_proj/state_machine/integrations/mongoid/versions.rb;TiI"Ü  module Integrations
    module Mongoid
      version("STRING") do
        def self.active?
          ::Mongoid::VERSION =~ "LITERAL";Fi[	@ÃiI"s      end
      
      version("STRING") do
        def self.active?
          ::Mongoid::VERSION =~ "LITERAL";Fi[	@ciI"Ì  module Integrations
    module Sequel
      version("STRING") do
        def self.active?
          (defined? ::Sequel::MAJOR.! or ((::Sequel::MAJOR == "LITERAL") or ((::Sequel::MAJOR == "LITERAL") and (::Sequel::MINOR <= "LITERAL"))));Fi[	@ciI"≤      end
      
      version("STRING") do
        def self.active?
          (defined? ::Sequel::MAJOR.! or ((::Sequel::MAJOR == "LITERAL") and (::Sequel::MINOR <= "LITERAL")));Fi[	@ci0I"÷      end
      
      version("STRING") do
        def self.active?
          (defined? ::Sequel::MAJOR.! or ((::Sequel::MAJOR == "LITERAL") or ((::Sequel::MAJOR == "LITERAL") and (::Sequel::MINOR <= "LITERAL"))));Fi[	@ci<I"‘      end
      
      version("STRING") do
        def self.active?
          defined? ::Sequel::MAJOR and ((::Sequel::MAJOR == "LITERAL") and ((::Sequel::MINOR >= "LITERAL") and (::Sequel::MINOR <= "LITERAL")));Fi[	I" def function(var, var, var);F@Hi[[	@XiI"å      attr_reader("LITERAL", "LITERAL", "LITERAL", "LITERAL")
      
      def function(var, var, var)
        @var = var
        @var = var;Fi[	@bidI"å      attr_reader("LITERAL", "LITERAL", "LITERAL", "LITERAL")
      
      def function(var, var, var)
        @var = var
        @var = var;Fi[	@QiI"i    alias "LITERAL" "LITERAL"
    
    def function(var, var, var)
      @var = var
      @var = var;Ti[	@ëiI"|    attr_reader("LITERAL", "LITERAL", "LITERAL")
    
    def function(var, var, var)
      @var = var
      @var = var;Fi[	@÷iI"ç    ##
    # Takes the name of the archive and the configuration block
    def function(var, var, var)
      @var = var
      @var = var.to_s;Fi[	@≤iaI"“        # Instantiates a new Campfire::Room object and sets all the
        # necessary arguments (@room_id, @subdomain, @api_token)
        def function(var, var, var)
          @var = var
          @var = var;Fi[	@ûiI"f    attr_writer("LITERAL")
    
    def function(var, var, var)
      @var = var
      @var = var;Fi[	@õiI"r      attr_accessor("LITERAL")
      
      def function(var, var, var)
        @var = var
        @var = var;Fi[	@∏iI"S  end
  
  def function(var, var, var)
    @var = var
    @var = var.html_safe;Fi[	I".projects//diaspora_proj/models/comment.rb;Ti`I"X    end
    
    def function(var, var, var)
      @var = var
      super(var, var);Fi[	@ŸiAI"}  # Used by formula to unpack after downloading
  # Used by audit
  def function(var, var, var)
    @var = var
    @var = var;Fi[	@ iI"Q  fatal(true)
  
  def function(var, var, var)
    @var = var
    @var = var;Fi[	@ iòI"ä  
  # The user can chose to force installation even in the face of conflicts.
  def function(var, var, var)
    @var = var
    @var = var;Fi[	@‚iI"†    # base - The String path to the source.
    # name - The String filename of the post file.
    def function(var, var, var)
      @var = var
      @var = var;Fi[	@˜i	I"x    module SAX
      class PushParser
        def function(var, var, var)
          @var = var
          @var = var;Fi[	@ÕiJI"É      # The encoding for the document
      # The XML source
      def function(var, var, var)
        @var = var
        @var = [];Fi[	@ iI"         # Create a new PushParser with +doc+ as the SAX Document, providing
        # an optional +file_name+ and +encoding+
        def function(var, var, var)
          @var = var
          @var = var;Fi[	@€irI"¨    #
    # @yield [Options] Yields options to block for further configuration.
    def function(var, var, var)
      @var = var
      @var = self.class.default_options.dup;Fi[	@i+I"˚    # +url_generator+ - the object used to generate URLs, using the interpolator. Defaults to Paperclip::UrlGenerator
    # +escape_url+ - Perform URI escaping to URLs. Defaults to true
    def function(var, var, var)
      @var = var
      @var = var;Fi[	@i	I"~    attr_accessor("LITERAL", "LITERAL", "LITERAL")
    
    def function(var, var, var)
      @var = var
      @var = var;Fi[	@iI"≠    # +definition+ is the style definition from has_attached_file, which
    # can be string, array or hash
    def function(var, var, var)
      @var = var
      @var = var;Fi[	@3iI"≤    # The machine attempting to be transitioned
    # The current state value for the machine
    def function(var, var, var)
      @var = var
      @var = var.states.match!(var);Fi[	@6iI"}      attr_accessor("LITERAL", "LITERAL")
      
      def function(var, var, var)
        @var = var
        @var = var;Fi[	@I"# == Examples;Fi[[	@iI"â      #
      # This method returns <tt>self</tt>.
      #
      # == Examples
      #  # Assuming +td+ is an instance of TableDefinition;Fi[	I"=projects//state_machine_proj/state_machine/assertions.rb;Ti	I"≤    # Validates that the given hash *only* includes the specified valid keys.
    # If any invalid keys are found, an ArgumentError will be raised.
    #
    # == Examples
    # ;Fi[	@iI"|    # exclusive keys.  If more than one key is found, an ArgumentError will be
    # raised.
    # 
    # == Examples
    # ;Fi[	I"9projects//state_machine_proj/state_machine/branch.rb;Ti;I"ñ    # and to state, this will also check whether the configured :if/:unless
    # conditions pass on the given object.
    # 
    # == Examples
    # ;Fi[	@idI"•    # * <tt>:guard</tt> - Whether to guard matches with the if/unless
    #   conditionals defined for this branch.  Default is true.
    # 
    # == Examples
    # ;Fi[	@·iI"I    # * Method / Proc
    # * String
    # 
    # == Examples
    # ;Fi[	@ÊiI"¶    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.
    # 
    # == Examples
    # ;Fi[	@Êi;I"¶    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.
    # 
    # == Examples
    # ;Fi[	@Êi_I"î    # *Note* that if a transition has already been generated for the event, then
    # that transition will be used.
    # 
    # == Examples
    # ;Fi[	@ıiI"≥        # See StateMachine::Machine#before_transition for more
        # information about the various configuration options available.
        # 
        # == Examples
        # ;Fi[	@ıiOI"µ        # Creates a callback that will be invoked *around* a transition so long
        # as the given requirements match the transition.
        # 
        # == Examples
        # ;Fi[	@i5I"à    # For examples on the types of state machine configurations and blocks, see
    # the section below.
    # 
    # == Examples
    # ;Fi[	@liI"n    
    # Generates a blacklist matcher based on the given set of values
    # 
    # == Examples
    # ;Fi[	@li8I"É    # Checks whether the given value exists within the whitelist configured
    # for this matcher.
    # 
    # == Examples
    # ;Fi[	@liKI"Ñ    # Checks whether the given value exists outside the blacklist configured
    # for this matcher.
    # 
    # == Examples
    # ;Fi[	@lifI"û    # Checks whether the given value matches what the value originally was.
    # This value should be defined in the context.
    # 
    # == Examples
    # ;Fi[	@$iI"|  module MatcherHelpers
    # Represents a state that matches all known states in a machine.
    # 
    # == Examples
    # ;Fi[	@$i'I"§    # Represents a state that matches the original +from+ state.  This is useful
    # for defining transitions which are loopbacks.
    # 
    # == Examples
    # ;Fi[	@)iI"Ö    # false, otherwise true.  If the given state is unknown, then an IndexError
    # will be raised.
    # 
    # == Examples
    # ;Fi[	@)i&I"ö    # state machine.  This will attempt to find a known state that matches
    # the value of the attribute on the object.
    # 
    # == Examples
    # ;Fi[	@)iAI"|    # state machine.  If no state is found, then an ArgumentError will be
    # raised.
    # 
    # == Examples
    # ;Fi[	@3iÆI"ô    # with the transition.  The action associated with the transition/machine
    # can be skipped by passing in +false+.
    # 
    # == Examples
    # ;Fi[	@:I"var = "STRING";Fi[[	@∞i-I"l      end
      
      def function
        var = "STRING"
        ActiveSupport::Deprecation.warn(var);Fi[	@iI"P      end
      
      def function
        var = "STRING"
        var = {};Fi[	@Ç
i≠I"v        end
        
        def function
          var = "STRING"
          ActiveSupport::Deprecation.warn(var);Fi[	I"Eprojects//activerecord_proj/active_record/readonly_attributes.rb;TiI"b    end
    
    def function
      var = "STRING"
      ActiveSupport::Deprecation.warn(var);Fi[	@∞i)I"~      end
      
      def function
        var = "STRING"
        (required_libraries or []).each { |var| (var << "STRING") };Fi[	I"Dprojects//compass_proj/compass/installers/manifest_installer.rb;Ti'I"i      end
      
      def function
        var = "STRING"
        manifest.each_stylesheet do |var|;Fi[	I"@projects//devise_proj/generators/devise/devise_generator.rb;TiI"Õ      class_option("LITERAL", "LITERAL" => "STRING", "LITERAL" => "LITERAL", "LITERAL" => (true))
      
      def function
        var = "STRING"
        (var << "STRING") if class_name.include?("STRING");Fi[	@'
i®I"y  end
  
  def function
    var = "STRING"
    if self.username_changed? and Person.exists?("LITERAL" => (var)) then;Fi[	@Ïi∆I"V    end
    
    def function
      var = "STRING"
      unless block_given? then;Fi[	@3
i°I"^      end
      
      def function
        var = "STRING"
        children.each do |var|;Fi[	@J
iëI"S  end
  
  def function
    var = "STRING"
    var = `find #{to_s}STRING`.to_i;Fi[	@—ifI"Nend
class Formula
  def function
    var = "STRING"
    (var << "STRING");Fi[	@ iûI"Y  end
  
  def function
    var = "STRING"
    (var << "STRING") if @opts["LITERAL"];Fi[	I"3projects//homebrew_proj/test/test_inreplace.rb;TiI"érequire("extend/string")
class InreplaceTest < Test::Unit::TestCase
  def function
    var = "STRING"
    var.extend(StringInreplaceExtension);Fi[	@\iI"X  end
  
  def function
    var = "STRING"
    var.extend(StringInreplaceExtension);Fi[	@\iI"X  end
  
  def function
    var = "STRING"
    var.extend(StringInreplaceExtension);Fi[	@\iI"X  end
  
  def function
    var = "STRING"
    var.extend(StringInreplaceExtension);Fi[	@\i$I"X  end
  
  def function
    var = "STRING"
    var.extend(StringInreplaceExtension);Fi[	@\i+I"X  end
  
  def function
    var = "STRING"
    var.extend(StringInreplaceExtension);Fi[	@\i2I"X  end
  
  def function
    var = "STRING"
    var.extend(StringInreplaceExtension);Fi[	I"3projects//paperclip_proj/paperclip/geometry.rb;TiII"∑    
    # Returns the width and height in a format suitable to be passed to Geometry.parse
    def function
      var = "STRING"
      (var << width.to_i.to_s) if (width > "LITERAL");Fi[	@ÚiPI"π        # integration.  This file will only exist for integrations that actually
        # support i18n.
        def function
          var = "STRING"
          var if File.exists?(var);Fi[	@_I"A#   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[[	@≤i*I"Æ      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@≤icI"Æ      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@≤i|I"Æ      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@≤iöI"Æ      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@≤i‡I"º      #
      #   person.pets.find(1, 2, 3)
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@≤i	I"¡      #   person.id # => 1
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@≤i>I"»      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@≤iEI"π      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@≤i_I"»      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@≤ifI"π      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@≤ixI"»      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@≤iI"π      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@≤iïI"»      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@≤iµI"»      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@≤i—I"»      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@≤iÿI"“      #
      #   person.pets.delete(Pet.find(1), Pet.find(3))
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤iÌI"»      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@≤i	I"»      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@≤i%I"»      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@≤i}I"…      #   person.pets.count # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@≤iïI"ÿ      #
      #   person.pets # This will execute a SELECT * FROM query
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@≤i±I"‚      #   # call the collection with no additional queries:
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@I"#   person = Person.new;Fi[[	@ i1I"f      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob';Fi[	@ iUI"f      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob';Fi[	@ iyI"|      #     end
      #   end
      #
      #   person = Person.new
      #   person.name                         # => 'Gem';Fi[	@ iëI"f      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob';Fi[	@ i’I"f      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob';Fi[	@ i¯I"f      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob';Fi[	@0iI"É    #     include ActiveModel::Conversion
    #   end
    #
    #   person = Person.new
    #   person.to_model == person # => true;Fi[	@0i:I"ã    #     include ActiveModel::Conversion
    #   end
    #
    #   person = Person.new
    #   person.to_partial_path # => "people/person";Fi[	@]iI"\    #     end
    #   end
    #
    #   person = Person.new
    #   person.name = 'bob';Fi[	@li#I"t        #     end
        #   end
        #
        #   person = Person.new
        #   person.name = '  bob  ';Fi[	@liEI"m        #     end
        #   end
        #
        #   person = Person.new
        #   person.name = '';Fi[	@ÇiÅI"{      #     validates! :name, presence: true
      #   end
      #
      #   person = Person.new
      #   person.name = '';Fi[	@òi¿I"y    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.valid? # => false;Fi[	@òi—I"q    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.name = '';Fi[	@òi·I"É    #     validates_presence_of :name, on: :new
    #   end
    #
    #   person = Person.new
    #   person.valid?       # => true;Fi[	@òi¯I"q    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.name = '';Fi[	@òiI"Ü    #     validates_presence_of :name, on: :new
    #   end
    #
    #   person = Person.new
    #   person.invalid?       # => false;Fi[	@¸iäI"Ö    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new
    #   person.respond_to(:name)    # => true;Fi[	@¸iûI"â    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new
    #   person.has_attribute?(:name)    # => true;Fi[	@¸i´I"{    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new
    #   person.attribute_names;Fi[	@¸iI"∞    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new
    #   person.column_for_attribute(:name) # the result depends on the ConnectionAdapter;Fi[	@¸iI"x    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new
    #   person[:age] = '22';Fi[	@£I"super("STRING");Fi[[	@ÒiRI"Å  
  class HasAndBelongsToManyAssociationForeignKeyNeeded < ActiveRecordError
    def function(var)
      super("STRING")
    end;Fi[	@ÒiXI"q  
  class EagerLoadPolymorphicError < ActiveRecordError
    def function(var)
      super("STRING")
    end;Fi[	@Òi^I"k  
  class ReadOnlyAssociation < ActiveRecordError
    def function(var)
      super("STRING")
    end;Fi[	@ÒidI"n  
  class DeleteRestrictionError < ActiveRecordError
    def function(var)
      super("STRING")
    end;Fi[	@yijI"a    attr_reader("LITERAL")
    
    def function(var)
      super("STRING")
      @var = var;Fi[	I"-projects//homebrew_proj/test/testball.rb;TiI"xend
class TestBallWithRealPath < TestBall
  def function(var)
    super("STRING")
    @var = Pathname.new("STRING");Fi[	@€iI"H  mirror("STRING")
  
  def function(var)
    super("STRING")
  end;Fi[	@€i+I"k  
  # name parameter required for some Formula::factory
  def function(var)
    super("STRING")
  end;Fi[	@€iyI";  end
  
  def function(var)
    super("STRING")
  end;Fi[	@€içI";  end
  
  def function(var)
    super("STRING")
  end;Fi[	@€iùI";  end
  
  def function(var)
    super("STRING")
  end;Fi[	@€i¨I"M  bottle_sha1("STRING")
  
  def function(var)
    super("STRING")
  end;Fi[	@€iµI"F  head("STRING")
  
  def function(var)
    super("STRING")
  end;Fi[	@€i¿I"F  sha1("STRING")
  
  def function(var)
    super("STRING")
  end;Fi[	@€iÀI"I  version("STRING")
  
  def function(var)
    super("STRING")
  end;Fi[	@€iÿI"~  devel { url("STRING", "LITERAL" => "LITERAL", "LITERAL" => "STRING") }
  
  def function(var)
    super("STRING")
  end;Fi[	@€iÂI"^  bottle { sha1("STRING" => "LITERAL") }
  
  def function(var)
    super("STRING")
  end;Fi[	@€iÚI"^  bottle { sha1("STRING" => "LITERAL") }
  
  def function(var)
    super("STRING")
  end;Fi[	@€iI";  end
  
  def function(var)
    super("STRING")
  end;Fi[	@€iI";  end
  
  def function(var)
    super("STRING")
  end;Fi[	@€i$I"b  version("STRING" => (CustomVersionScheme))
  
  def function(var)
    super("STRING")
  end;Fi[	I"# For example,;F@i[[	@Ôi≈I"Ω    # Returns a hash containing default assignments for the `xmlns`, `lang`, and `xml:lang`
    # attributes of the `html` HTML element.
    # For example,
    #
    #     %html{html_attrs};Fi[	@ÔiôI"^    # use \{#capture\_haml\}.
    #
    # For example,
    #
    #     haml_tag :table do;Fi[	@·i0I"v    # then all arguments are required.
    # 
    # For example,
    # 
    #   person = Person.new('John Smith');Fi[	@iƒI"°    # Generates a nicely formatted description of this event's contents.
    # 
    # For example,
    # 
    #   event = StateMachine::Event.new(machine, :park);Fi[	@ijI"n    #   libraries if supported by the integration.
    # 
    # For example,
    # 
    #   class Vehicle;Fi[	@iõI"x    #   conditionals defined for each one.  Default is true.
    # 
    # For example,
    # 
    #   class Vehicle;Fi[	@i÷I"c    # without properly calling +super+.
    # 
    # For example,
    # 
    #   class Vehicle;Fi[	@iáI"O    # the machine).
    # 
    # For example,
    # 
    #   class Vehicle;Fi[	@iΩI"f    # between the various states / events.
    # 
    # For example,
    # 
    #   class Vehicle;Fi[	@iÚI"≥    # attribute set to one of a given set of states.
    # 
    # For example,
    # 
    #   Vehicle.with_state(:parked)               # => All vehicles where the state is parked;Fi[	@$i+I"¨    # Lists all of the from states that can be reached through this path.
    # 
    # For example,
    # 
    #   path.to_states  # => [:parked, :idling, :first_gear, ...];Fi[	@$i:I"™    # Lists all of the to states that can be reached through this path.
    # 
    # For example,
    # 
    #   path.to_states  # => [:parked, :idling, :first_gear, ...];Fi[	@$iCI"ù    # Lists all of the events that can be fired through this path.
    # 
    # For example,
    # 
    #   path.events # => [:park, :ignite, :shift_up, ...];Fi[	@'i-I"{    # this collection.
    # 
    # For example,
    # 
    #   paths.from_states # => [:parked, :idling, :first_gear, ...];Fi[	@'i7I"~    # this collection.
    # 
    # For example,
    # 
    #   paths.to_states # => [:idling, :first_gear, :second_gear, ...];Fi[	@'iAI"s    # collection.
    # 
    # For example,
    # 
    #   paths.events  # => [:park, :ignite, :shift_up, ...];Fi[	@*ipI"«    # Generates a human-readable description of this state's name / value:
    # 
    # For example,
    # 
    #   State.new(machine, :parked).description                               # => "parked";Fi[	@*iÅI"Ö    # returned.
    # 
    # For example,
    # 
    #   State.new(machine, :parked, :value => 1).value                        # => 1;Fi[	@*iòI"y    # Otherwise, the matcher will determine the result.
    # 
    # For example,
    # 
    #   # Without a matcher;Fi[	@*i‹I"¬    # Generates a nicely formatted description of this state's contents.
    # 
    # For example,
    # 
    #   state = StateMachine::State.new(machine, :parked, :value => 1, :initial => true);Fi[	@3i#I"Õ    # Generates a nicely formatted description of this transitions's contents.
    # 
    # For example,
    # 
    #   transition = StateMachine::Transition.new(object, machine, :ignite, :parked, :idling);Fi[	@;@îi[[	@ñi>I"â            case var.sql_type
            when "STRING" then
              "STRING"
            when "STRING" then
              "STRING";Fi[	@ÀiI"Ç          var = case var.value
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING";Fi[	@ÀiI"}            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING";Fi[	@ÀiI"}            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING";Fi[	@ÀiI"}            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING";Fi[	@ÀiEI"q        case var
        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING";Fi[	@ÀiGI"s          "STRING"
        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING";Fi[	@ÀiII"s          "STRING"
        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING";Fi[	@ÀiKI"s          "STRING"
        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING";Fi[	@ÏiˆI"ù              case @node.value["LITERAL"]
              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING";Fi[	@Ïi¯I"å                "STRING"
              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING";Fi[	@Ïi˙I"å                "STRING"
              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING";Fi[	@Ïi¸I"å                "STRING"
              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING";Fi[	@ÏiI"ì            case @node.value["LITERAL"]
            when "STRING" then
              "STRING"
            when "STRING" then
              "STRING";Fi[	@„iI"d    "STRING".undent
  when "LITERAL" then
    "STRING"
  when "STRING" then
    "STRING".undent;Fi[	@KifI"Ç            "STRING"
          when "STRING", "STRING" then
            "STRING"
          when "STRING" then
            "STRING";Fi[	@KihI"}            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING";Fi[	@KijI"}            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING";Fi[	@KilI"}            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING";Fi[	@KinI"}            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING";Fi[	@KipI"}            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING";Fi[	@p@Ëi[[	@≤i+I"Ê      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤idI"Ê      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤i}I"Ê      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤iõI"Ê      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤i·I"Ù      #   person.pets.find(1, 2, 3)
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤i
I"Ê      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤i?I"Ê      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤iFI"Ò      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤i`I"Ê      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤igI"Ò      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤iyI"Ê      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤iÄI"Ò      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤iñI"Ê      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤i∂I"Ê      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤i“I"Ê      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤iÓI"Ê      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤i
I"Ê      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤i&I"Ê      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤i~I"Ê      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤iñI"      #   person.pets # This will execute a SELECT * FROM query
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤i≤I"Ê      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@@i[[	@i
I"ö    # If any invalid keys are found, an ArgumentError will be raised.
    #
    # == Examples
    # 
    #   options = {:name => 'John Smith', :age => 30};Fi[	@iI"d    # raised.
    # 
    # == Examples
    # 
    #   options = {:only => :on, :except => :off};Fi[	@i<I"ò    # conditions pass on the given object.
    # 
    # == Examples
    # 
    #   branch = StateMachine::Branch.new(:parked => :idling, :on => :ignite);Fi[	@ieI"≠    #   conditionals defined for this branch.  Default is true.
    # 
    # == Examples
    # 
    #   branch = StateMachine::Branch.new(:parked => :idling, :on => :ignite);Fi[	@·iI"    # * String
    # 
    # == Examples
    # 
    # Below are examples of the various ways that a method can be evaluated;Fi[	@ÊiI"w    #   conditionals defined for each one.  Default is true.
    # 
    # == Examples
    # 
    #   class Vehicle;Fi[	@Êi<I"w    #   conditionals defined for each one.  Default is true.
    # 
    # == Examples
    # 
    #   class Vehicle;Fi[	@Êi`I"s    # that transition will be used.
    # 
    # == Examples
    # 
    #   class Vehicle < ActiveRecord::Base;Fi[	@ıiI"é        # information about the various configuration options available.
        # 
        # == Examples
        # 
        #   class Vehicle;Fi[	@ıiPI"        # as the given requirements match the transition.
        # 
        # == Examples
        # 
        #   class Vehicle;Fi[	@i6I"y    # the section below.
    # 
    # == Examples
    # 
    # With the default name/attribute and no configuration:;Fi[	@liI"≠    # Generates a blacklist matcher based on the given set of values
    # 
    # == Examples
    # 
    #   matcher = StateMachine::AllMatcher.instance - [:parked, :idling];Fi[	@li9I"Ä    # for this matcher.
    # 
    # == Examples
    # 
    #   matcher = StateMachine::WhitelistMatcher.new([:parked, :idling]);Fi[	@liLI"Ä    # for this matcher.
    # 
    # == Examples
    # 
    #   matcher = StateMachine::BlacklistMatcher.new([:parked, :idling]);Fi[	@ligI"ã    # This value should be defined in the context.
    # 
    # == Examples
    # 
    #   matcher = StateMachine::LoopbackMatcher.instance;Fi[	@$i	I"    # Represents a state that matches all known states in a machine.
    # 
    # == Examples
    # 
    #   class Vehicle;Fi[	@$i(I"n    # for defining transitions which are loopbacks.
    # 
    # == Examples
    # 
    #   class Vehicle;Fi[	@)iI"P    # will be raised.
    # 
    # == Examples
    # 
    #   class Vehicle;Fi[	@)i'I"j    # the value of the attribute on the object.
    # 
    # == Examples
    # 
    #   class Vehicle;Fi[	@)iBI"H    # raised.
    # 
    # == Examples
    # 
    #   class Vehicle;Fi[	@3iØI"f    # can be skipped by passing in +false+.
    # 
    # == Examples
    # 
    #   class Vehicle;Fi[	@@¸i[[	@ÔiòI"s    # If you need to get the results as a string,
    # use \{#capture\_haml\}.
    #
    # For example,
    #;Fi[	@·i/I"î    # the method defines additional arguments other than the object context,
    # then all arguments are required.
    # 
    # For example,
    # ;Fi[	@i√I"s    
    # Generates a nicely formatted description of this event's contents.
    # 
    # For example,
    # ;Fi[	@iiI"õ    #   the given event.  This may be generated by internationalization
    #   libraries if supported by the integration.
    # 
    # For example,
    # ;Fi[	@iöI"ß    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.
    # 
    # For example,
    # ;Fi[	@i’I"ì    # behavior will *not* work if the class defines an +initialize+ method
    # without properly calling +super+.
    # 
    # For example,
    # ;Fi[	@iÜI"Ä    # generated for the event) or indirectly (through attributes defined on
    # the machine).
    # 
    # For example,
    # ;Fi[	@iºI"ò    # has multiple state machines and it would be difficult to differentiate
    # between the various states / events.
    # 
    # For example,
    # ;Fi[	@iÒI"£    # be automatically created for assisting in finding objects that have the
    # attribute set to one of a given set of states.
    # 
    # For example,
    # ;Fi[	@$i*I"t    
    # Lists all of the from states that can be reached through this path.
    # 
    # For example,
    # ;Fi[	@$i9I"r    
    # Lists all of the to states that can be reached through this path.
    # 
    # For example,
    # ;Fi[	@$iBI"m    
    # Lists all of the events that can be fired through this path.
    # 
    # For example,
    # ;Fi[	@'i,I"à    # Lists all of the states that can be transitioned from through the paths in
    # this collection.
    # 
    # For example,
    # ;Fi[	@'i6I"Ü    # Lists all of the states that can be transitioned to through the paths in
    # this collection.
    # 
    # For example,
    # ;Fi[	@'i@I"|    # Lists all of the events that can be fired through the paths in this
    # collection.
    # 
    # For example,
    # ;Fi[	@*ioI"u    
    # Generates a human-readable description of this state's name / value:
    # 
    # For example,
    # ;Fi[	@*iÄI"}    # original block if it's a lambda block.  Otherwise, the static value is
    # returned.
    # 
    # For example,
    # ;Fi[	@*ióI"¢    # configured, then this will check whether the values are equivalent.
    # Otherwise, the matcher will determine the result.
    # 
    # For example,
    # ;Fi[	@*i€I"s    
    # Generates a nicely formatted description of this state's contents.
    # 
    # For example,
    # ;Fi[	@3i"I"y    
    # Generates a nicely formatted description of this transitions's contents.
    # 
    # For example,
    # ;Fi[	@â@si[[	@≤i%I"¨      # *First:* Specify a subset of fields to be selected from the result set.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end;Ti[	@≤i^I"ä      # error if the object can not be found.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end;Ti[	@≤i|I"Å      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end;Ti[	@≤iïI"Å      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end;Ti[	@≤iI"ì      # and delete/add only records that have changed.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end;Ti[	@≤ièI"q      # option.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end;Ti[	@≤iI"ò      # responding to the +id+ and executes delete on them.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end;Ti[	@≤iI"®      # the +:dependent+ option. Returns an array with the removed records.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end;Ti[	@≤ieI"õ      # Specifies whether the records should be unique or not.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end;Ti[	@≤iwI"Å      # Count all records using SQL.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end;Ti[	@≤içI"´      # +length+ will take one less query. Otherwise +size+ is more efficient.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end;Ti[	@≤ißI"©      # method will take one less query. Otherwise +size+ is more efficient.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end;Ti[	@≤i¡I"ô      # is better to check <tt>collection.length.zero?</tt>.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end;Ti[	@≤i“I"ì      # Returns +true+ if the collection is not empty.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end;Ti[	@≤iÙI"ê      # Equivalent to <tt>collection.size > 1</tt>.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end;Ti[	@≤iI"•      # Returns +true+ if the given object is present in the collection.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end;Ti[	@≤i?I"r      # +false+.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end;Ti[	@≤iYI"¢      # hasn't been loaded, it fetches the records from the database.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end;Ti[	@≤iÅI"{      # chained together.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end;Ti[	@≤i¢I"ç      # Equivalent to <tt>collection(true)</tt>.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end;Ti[	I"# For example:;F@i[[	@|ixI"      # * <tt>:less_than_or_equal_to</tt>
      #
      # For example:
      #
      #   class Person < ActiveRecord::Base;Fi[	@Ÿ	iI"∆      # All commands recorded will end up being recorded reverted
      # and in reverse order.
      # For example:
      #
      #   recorder.revert{ recorder.record(:rename_table, [:old, :new]) };Fi[	@Ÿ	i&I"¶      
      # record +command+. +command+ should be a method name and arguments.
      # For example:
      #
      #   recorder.record(:method_name, [:arg1, :arg2]);Fi[	@ç
ièI"ã    # matched record for destruction.
    #
    # For example:
    #
    #   assign_nested_attributes_for_collection_association(:people, {;Fi[	@JiÚI"â    # result needs to be chainable.
    #
    # For example:
    #
    #   @posts = current_user.visible_posts.where(name: params[:name]);Fi[	@æi°I"ˆ    # list of known actions.  This is important if you add a custom action to a controller that
    # overrides an out of the box Devise controller.
    # For example:
    #
    #    class RegistrationsController < Devise::RegistrationsController;Fi[	I"'projects//haml_proj/haml/engine.rb;TiEI"õ    # It extends {Haml::Helpers}, and various instance variables are set
    # (all prefixed with `haml_`).
    # For example:
    #
    #     s = "foobar";Fi[	@iNI"⁄    #
    # `locals` is a hash of local variables to make available to the template.
    # For example:
    #
    #     Haml::Engine.new("%p= foo").render(Object.new, :foo => "Hello, world!") #=> "<p>Hello, world!</p>";Fi[	@iáI"©    # the local variables which can be assigned must be pre-declared.
    # This is done with the `local_names` argument.
    # For example:
    #
    #     # This works;Fi[	@i©I"ó    # If `object` is a class or module,
    # the method will instead by defined as an instance method.
    # For example:
    #
    #     t = Time.now;Fi[	@i∂I"©    # the local variables which can be assigned must be pre-declared.
    # This is done with the `local_names` argument.
    # For example:
    #
    #     # This works;Fi[	@Ôi1I"´    # This is useful if you want to use the helpers in a context
    # other than the normal setup with ActionView.
    # For example:
    #
    #     context = Object.new;Fi[	@Ôi{I"¥    # and putting the result into `<li>` elements.
    # This creates a list of the results of the block.
    # For example:
    #
    #     = list_of([['hello'], ['yall']]) do |i|;Fi[	@Ôi’I"ê    # Increments the number of tabs the buffer automatically adds
    # to the lines of the template.
    # For example:
    #
    #     %h1 foo;Fi[	@ÔiıI"|    # to the lines of the template,
    # but only for the duration of the block.
    # For example:
    #
    #     %h1 foo;Fi[	@ÔiI"ë    # Surrounds a block of Haml code with strings,
    # with no whitespace in between.
    # For example:
    #
    #     = surround '(', ')' do;Fi[	@Ôi-I"è    # Prepends a string to the beginning of a Haml block,
    # with no whitespace between.
    # For example:
    #
    #     = precede '*' do;Fi[	@Ôi>I"}    # Appends a string to the end of a Haml block,
    # with no whitespace between.
    # For example:
    #
    #     click;Fi[	@i»I"€    # All conditionals based on the static parameters
    # are done as embedded Ruby within this template.
    # For example:
    #
    #     def_static_method(Foo, :my_static_method, [:foo, :bar], :baz, :bang, <<RUBY);Fi[	@iI"é    
    # Moves a scanner through a balanced pair of characters.
    # For example:
    #
    #     Foo (Bar (Baz bang) bop) (Bang (bop bip));Fi[	@£@n
i[[	@∫iI"L      end
      
      def function(var)
        # do nothing
      end;Fi[	@Üi=I"‡      # Returns an array of Column objects for the table specified by +table_name+.
      # See the concrete implementation for details on the expected parameter values.
      def function(var)
        # do nothing
      end;Fi[	@∫i%I"}      
      # This is a noop when there are no open transactions
      def function(var)
        # do nothing
      end;Fi[	I"Iprojects//cancan_proj/generators/cancan/ability/templates/ability.rb;TiI"M  include(CanCan::Ability)
  
  def function(var)
    # do nothing
  end;Fi[	I"Aprojects//compass_proj/compass/exec/command_option_parser.rb;TiI"B    end
    
    def function(var)
      # do nothing
    end;Fi[	@õi1I"°      # The default finalize method -- it is a no-op.
      # This could print out a message or something.
      def function(var)
        # do nothing
      end;Fi[	@
iRI"K  
  class NullLogger
    def function(var)
      # do nothing
    end;Fi[	@
iVI"B    end
    
    def function(var)
      # do nothing
    end;Fi[	I",projects//compass_proj/compass/stats.rb;TiI"L      end
      
      def function(var)
        # do nothing
      end;Fi[	@Ai"I"L      end
      
      def function(var)
        # do nothing
      end;Fi[	@i“I"f    
    if (RUBY_VERSION < "STRING") then
      def function(var)
        # do nothing
      end;Fi[	I"+projects//jekyll_proj/jekyll/plugin.rb;Ti&I"Y    #
    # Returns a new instance.
    def function(var)
      # do nothing
    end;Fi[	@'i'I"á        # Called at the end of an element
        # +name+ is the tag name
        def function(var)
          # do nothing
        end;Fi[	@'iHI"z        #
        # +string+ contains the character data
        def function(var)
          # do nothing
        end;Fi[	@'iOI"ò        # Called when comments are encountered
        # +string+ contains the comment data
        def function(var)
          # do nothing
        end;Fi[	@'iVI"ä        # Called on document warnings
        # +string+ contains the warning
        def function(var)
          # do nothing
        end;Fi[	@'i]I"Ü        # Called on document errors
        # +string+ contains the error
        def function(var)
          # do nothing
        end;Fi[	@'idI"ó        # Called when cdata blocks are found
        # +string+ contains the cdata content
        def function(var)
          # do nothing
        end;Fi[	@>iI"kmodule Paperclip
  class NilAdapter < AbstractAdapter
    def function(var)
      # do nothing
    end;Fi[	@>iI"B    end
    
    def function(var)
      # do nothing
    end;Fi[	@£I"return if var.nil?;Fi[[	@Ã	i˙I"ú        
        class Integer < Type
          def function(var)
            return if var.nil?
            var.to_i rescue var ? ("LITERAL") : ("LITERAL");Fi[	@Ã	iI"ç          end
          
          def function(var)
            return if var.nil?
            ConnectionAdapters::Column.value_to_date(var);Fi[	@Ã	iI"é          end
          
          def function(var)
            return if var.nil?
            ConnectionAdapters::Column.string_to_time(var);Fi[	@Ã	iI"î          end
          
          def function(var)
            return if var.nil?
            ConnectionAdapters::Column.string_to_dummy_time(var);Fi[	@Ã	i&I"m          end
          
          def function(var)
            return if var.nil?
            var.to_f;Fi[	@Ã	i-I"ù        
        class Decimal < Type
          def function(var)
            return if var.nil?
            ConnectionAdapters::Column.value_to_decimal(var);Fi[	@Ã	i4I"ù        
        class Boolean < Type
          def function(var)
            return if var.nil?
            ConnectionAdapters::Column.value_to_boolean(var);Fi[	@si!I"x        
        class Money < Type
          def function(var)
            return if var.nil?
            case var;Fi[	@siSI"ù        
        class Integer < Type
          def function(var)
            return if var.nil?
            ConnectionAdapters::Column.value_to_integer(var);Fi[	@siZI"ù        
        class Boolean < Type
          def function(var)
            return if var.nil?
            ConnectionAdapters::Column.value_to_boolean(var);Fi[	@sieI"ò          end
          
          def function(var)
            return if var.nil?
            ConnectionAdapters::PostgreSQLColumn.string_to_time(var);Fi[	@sipI"ç          end
          
          def function(var)
            return if var.nil?
            ConnectionAdapters::Column.value_to_date(var);Fi[	@siwI"û        
        class Time < Type
          def function(var)
            return if var.nil?
            ConnectionAdapters::Column.string_to_dummy_time(var);Fi[	@si~I"x        
        class Float < Type
          def function(var)
            return if var.nil?
            var.to_f;Fi[	@siÄI"ù        
        class Decimal < Type
          def function(var)
            return if var.nil?
            ConnectionAdapters::Column.value_to_decimal(var);Fi[	@siáI"¶        
        class Hstore < Type
          def function(var)
            return if var.nil?
            ConnectionAdapters::PostgreSQLColumn.string_to_hstore(var);Fi[	@siéI"¢        
        class Cidr < Type
          def function(var)
            return if var.nil?
            ConnectionAdapters::PostgreSQLColumn.string_to_cidr(var);Fi[	@siïI"¢        
        class Json < Type
          def function(var)
            return if var.nil?
            ConnectionAdapters::PostgreSQLColumn.string_to_json(var);Fi[	@siúI"™        
        class IntRange < Type
          def function(var)
            return if var.nil?
            ConnectionAdapters::PostgreSQLColumn.string_to_intrange(var);Fi[	@ÆI"module ConnectionAdapters;Fi[[	@·i I"Nmodule ActiveRecord
  module ConnectionAdapters
    module DatabaseLimits;Fi [	@i I"Rmodule ActiveRecord
  module ConnectionAdapters
    module DatabaseStatements;Fi [	@KiI"}require("active_support/core_ext/big_decimal/conversions")
module ActiveRecord
  module ConnectionAdapters
    module Quoting;Fi[	@i	I"‘require("bigdecimal")
require("bigdecimal/util")
module ActiveRecord
  module ConnectionAdapters
    class IndexDefinition < Struct.new("LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL");Fi[	@Åi I"Lmodule ActiveRecord
  module ConnectionAdapters
    module ColumnDumper;Fi [	@ÜiI"~require("active_record/migration/join_table")
module ActiveRecord
  module ConnectionAdapters
    module SchemaStatements;Fi[	@∫i I"Jmodule ActiveRecord
  module ConnectionAdapters
    class Transaction;Fi [	@PiI"™require("active_record/connection_adapters/abstract/schema_dumper")
require("monitor")
module ActiveRecord
  module ConnectionAdapters
    extend(ActiveSupport::Autoload);Fi[	@UiI"Ürequire("arel/visitors/bind_visitor")
module ActiveRecord
  module ConnectionAdapters
    class AbstractMysqlAdapter < AbstractAdapter;Fi[	@piI"erequire("uri")
module ActiveRecord
  module ConnectionAdapters
    class ConnectionSpecification;Fi[	@
i I"Xmodule ActiveRecord
  module ConnectionAdapters
    class PostgreSQLColumn < Column;Fi [	@ìi I"Xmodule ActiveRecord
  module ConnectionAdapters
    class PostgreSQLColumn < Column;Fi [	@Ç
i I"bmodule ActiveRecord
  module ConnectionAdapters
    class PostgreSQLAdapter < AbstractAdapter;Fi [	@siI"õrequire("active_record/connection_adapters/abstract_adapter")
module ActiveRecord
  module ConnectionAdapters
    class PostgreSQLAdapter < AbstractAdapter;Fi[	@ñi I"bmodule ActiveRecord
  module ConnectionAdapters
    class PostgreSQLAdapter < AbstractAdapter;Fi [	@—	i I"bmodule ActiveRecord
  module ConnectionAdapters
    class PostgreSQLAdapter < AbstractAdapter;Fi [	@õi I"bmodule ActiveRecord
  module ConnectionAdapters
    class PostgreSQLAdapter < AbstractAdapter;Fi [	@øi I"Jmodule ActiveRecord
  module ConnectionAdapters
    class SchemaCache;Fi [	@vi I"Lmodule ActiveRecord
  module ConnectionAdapters
    class StatementPool;Fi [	I"yield);FI"ensure;Fi[[	@Ui€I"i        begin
          (update("STRING")
          yield)
        ensure
          update("STRING");Fi[	@—	iI"¯              execute(tables.collect { |var| "STRING" }.join("STRING")) rescue execute(tables.collect { |var| "STRING" }.join("STRING"))
            end
            yield)
          ensure
            if supports_disable_referential_integrity? then;Fi[	@‘	iUI"ä        (var = Thread.current
        var, var["LITERAL"] = var["LITERAL"], false
        yield)
      ensure
        var["LITERAL"] = var;Fi[	@Ÿ	iI"}          var = @commands
          @var = []
          yield)
        ensure
          (@var = var.concat(@commands.reverse);Fi[	@Qi€I"á      begin
        (var, klass.current_scope = klass.current_scope, self
        yield)
      ensure
        klass.current_scope = var;Ti[	@TiÉI"è          begin
            (self.ignore_default_scope = true
            yield)
          ensure
            self.ignore_default_scope = false;Fi[	@®iwI"]        begin
          (@var = var
          yield)
        ensure
          @var = nil;Fi[	@
i#I"ï        ($stderr.write(color("LITERAL"))
        $stdout.write(color("LITERAL"))
        yield)
      ensure
        ($stderr.write(color("LITERAL"));Fi[	@
i.I"ï        ($stderr.write(color("LITERAL"))
        $stdout.write(color("LITERAL"))
        yield)
      ensure
        ($stderr.write(color("LITERAL"));Fi[	@æioI"ê        var.merge!(var.slice("LITERAL", "LITERAL", "LITERAL"))
        @scope.merge!(var)
        yield)
      ensure
        @scope.merge!(var);Fi[	@,
i3I"r          (@var = true
          var = @_haml_concat_raw
          yield)
        ensure
          @var = var;Fi[	@ÔiLI"Ö        (var = @haml_buffer.active?
        @haml_buffer.active = false
        yield)
      ensure
        @haml_buffer.active = var;Fi[	@Ôi	I"ã        (var = haml_buffer.tabulation
        haml_buffer.tabulation = var
        yield)
      ensure
        haml_buffer.tabulation = var;Fi[	@Ôi:I"∞        var.active, var = false, var.active? if var
        @haml_buffer.active, var = true, @haml_buffer.active?
        yield)
      ensure
        (@haml_buffer.active = var;Fi[	@i2I"p      begin
        (var, $stderr = $stderr, StringIO.new
        yield)
      ensure
        $stderr = var;Fi[	@B
ißI"Ç      var.concat(["STRING", "STRING"]) if quieter?
      var.each { |var| delete(var) }
      yield)
    ensure
      replace(var);Fi[	@G
iI"P      var = pwd
      cd(var)
      yield)
    ensure
      (cd(var) if var;Fi[	@J
iI"W        chmod("LITERAL")
      end
      yield)
    ensure
      chmod(var) if var;Fi[	I"0projects//homebrew_proj/test/testing_env.rb;Ti.I"Ñ      $stderr.reopen("STRING", "STRING")
      $stdout.reopen("STRING", "STRING")
      yield)
    ensure
      ($stderr.reopen(var);Fi[	@£I"+var = Twitter::API::Arguments.new(var);Fi[[	@qibI"Î      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(var)
        var = Twitter::API::Arguments.new(var)
        if var.empty? then;Fi[	@~i&I"’      #   @example Return the 20 most recent favorite Tweets for @sferik
      #     Twitter.favorites('sferik')
      def function(var)
        var = Twitter::API::Arguments.new(var)
        if var = var.pop then;Fi[	@~iVI"˙      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(var)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |var|;Fi[	@~ixI"˙      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(var)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |var|;Fi[	@ÖiRI"H      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      def function(var)
        var = Twitter::API::Arguments.new(var)
        merge_users!(var.options, var);Fi[	@ÖiÄI".      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean] :follow (false) Enable notifications for the target user.
      def function(var)
        var = Twitter::API::Arguments.new(var)
        var.options["LITERAL"] = true if var.options.delete("LITERAL").!.!;Fi[	@ÖiôI".      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean] :follow (false) Enable notifications for the target user.
      def function(var)
        var = Twitter::API::Arguments.new(var)
        var.options["LITERAL"] = true if var.options.delete("LITERAL").!.!;Fi[	@´iHI"›      #     Twitter.list_timeline(7505382, 'presidents')
      #     Twitter.list_timeline(7505382, 8863586)
      def function(var)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop);Fi[	@Ÿi%I"Î      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(var)
        var = Twitter::API::Arguments.new(var)
        if var.empty? then;Fi[	@Ÿi[I"˙      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(var)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |var|;Fi[	@Ëi!I"”      #   @example Return the users in the Art & Design category
      #     Twitter.suggestions("art-design")
      def function(var)
        var = Twitter::API::Arguments.new(var)
        if var = var.pop then;Fi[	@iéI"l      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      def function(var)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |var|;Fi[	@i©I"l      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      def function(var)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |var|;Fi[	@iˆI"Œ      #   @option options [String] :related A value for the TWT related parameter, as described in {https://dev.twitter.com/docs/intents Web Intents}. This value will be forwarded to all Web Intents calls.
      #   @option options [String] :lang Language code for the rendered embed. This will affect the text and localization of the rendered HTML.
      def function(var)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |var|;Fi[	@imI"      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(var)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map { |var| status_activity(var, var.options) };Fi[	@i¶I"”      # @overload block(options={})
      #   @param options [Hash] A customizable set of options.
      def function(var)
        var = Twitter::API::Arguments.new(var)
        merge_user!(var.options, var.pop);Fi[	@iI"7      #     Twitter.users('sferik', 'pengwynn', :method => :get) # Retrieve users with a GET request
      #     Twitter.users(7505382, 14100886, :method => :get)    # Same as above
      def function(var)
        var = Twitter::API::Arguments.new(var)
        var = (var.options.delete("LITERAL") or "LITERAL");Fi[	@iI"∫      #     Twitter.user('sferik')
      #     Twitter.user(7505382)  # Same as above
      def function(var)
        var = Twitter::API::Arguments.new(var)
        if var = var.pop then;Fi[	@i∞I"˜      #     Twitter.profile_banner('sferik')
      #     Twitter.profile_banner(7505382)  # Same as above
      def function(var)
        var = Twitter::API::Arguments.new(var)
        unless (var.options["LITERAL"] or var.options["LITERAL"]) then;Fi[	I"module Twitter;FI"class Error;Fi[[	I">projects//twitter_proj/twitter/error/already_favorited.rb;TiI"prequire("twitter/error/forbidden")
module Twitter
  class Error
    class AlreadyFavorited < Twitter::Error;Fi[	I">projects//twitter_proj/twitter/error/already_retweeted.rb;TiI"prequire("twitter/error/forbidden")
module Twitter
  class Error
    class AlreadyRetweeted < Twitter::Error;Fi[	I"8projects//twitter_proj/twitter/error/bad_gateway.rb;TiI"zrequire("twitter/error/server_error")
module Twitter
  class Error
    class BadGateway < Twitter::Error::ServerError;Fi[	I"8projects//twitter_proj/twitter/error/bad_request.rb;TiI"zrequire("twitter/error/client_error")
module Twitter
  class Error
    class BadRequest < Twitter::Error::ClientError;Fi[	@	iI"arequire("twitter/error")
module Twitter
  class Error
    class ClientError < Twitter::Error;Fi[	I"@projects//twitter_proj/twitter/error/configuration_error.rb;TiI"irequire("twitter/error")
module Twitter
  class Error
    class ConfigurationError < ::ArgumentError;Fi[	I"9projects//twitter_proj/twitter/error/decode_error.rb;TiI"arequire("twitter/error")
module Twitter
  class Error
    class DecodeError < Twitter::Error;Fi[	I"6projects//twitter_proj/twitter/error/forbidden.rb;TiI"yrequire("twitter/error/client_error")
module Twitter
  class Error
    class Forbidden < Twitter::Error::ClientError;Fi[	I"<projects//twitter_proj/twitter/error/gateway_timeout.rb;TiI"~require("twitter/error/server_error")
module Twitter
  class Error
    class GatewayTimeout < Twitter::Error::ServerError;Fi[	I"Cprojects//twitter_proj/twitter/error/identity_map_key_error.rb;TiI"grequire("twitter/error")
module Twitter
  class Error
    class IdentityMapKeyError < ::IndexError;Fi[	I"Bprojects//twitter_proj/twitter/error/internal_server_error.rb;TiI"~require("twitter/error/server_error")
module Twitter
  class Error
    class InternalServerError < Twitter::Error::ServerError;Fi[	I";projects//twitter_proj/twitter/error/not_acceptable.rb;TiI"}require("twitter/error/client_error")
module Twitter
  class Error
    class NotAcceptable < Twitter::Error::ClientError;Fi[	I"6projects//twitter_proj/twitter/error/not_found.rb;TiI"xrequire("twitter/error/client_error")
module Twitter
  class Error
    class NotFound < Twitter::Error::ClientError;Fi[	I"9projects//twitter_proj/twitter/error/server_error.rb;TiI"arequire("twitter/error")
module Twitter
  class Error
    class ServerError < Twitter::Error;Fi[	I"@projects//twitter_proj/twitter/error/service_unavailable.rb;TiI"}require("twitter/error/server_error")
module Twitter
  class Error
    class ServiceUnavailable < Twitter::Error::ServerError;Fi[	I">projects//twitter_proj/twitter/error/too_many_requests.rb;TiI"require("twitter/error/client_error")
module Twitter
  class Error
    class TooManyRequests < Twitter::Error::ClientError;Fi[	I"9projects//twitter_proj/twitter/error/unauthorized.rb;TiI"|require("twitter/error/client_error")
module Twitter
  class Error
    class Unauthorized < Twitter::Error::ClientError;Fi[	I"Aprojects//twitter_proj/twitter/error/unprocessable_entity.rb;TiI"~require("twitter/error/client_error")
module Twitter
  class Error
    class UnprocessableEntity < Twitter::Error::ClientError;Fi[	@H@ˆi[[	@Xi
I"j      include(ThroughAssociation)
      
      def function(var, var)
        super
        @var = {};Fi[	@Ui˙I"b      end
      
      def function(var, var)
        super
        @connection.affected_rows;Fi[	@Ã	iMI"™      
      class StatementPool < ConnectionAdapters::StatementPool
        def function(var, var)
          super
          @var = Hash.new { |var, var| var[var] = {} };Fi[	@Xi2I"™      
      class StatementPool < ConnectionAdapters::StatementPool
        def function(var, var)
          super
          @var = Hash.new { |var, var| var[var] = {} };Fi[	@XiI"\      end
      
      def function(var, var)
        super
        @connection.changes;Fi[	@Èi&I"Z  attr_writer("LITERAL")
  
  def function(var, var)
    super
    @var = var.mirrors;Fi[	@Èi§I"Öend
class CurlBottleDownloadStrategy < CurlDownloadStrategy
  def function(var, var)
    super
    @var = (HOMEBREW_CACHE / "STRING");Fi[	@Èi∞I"~end
class SubversionDownloadStrategy < AbstractDownloadStrategy
  def function(var, var)
    super
    @@svn ||= "STRING";Fi[	@ÈiI"wend
class GitDownloadStrategy < AbstractDownloadStrategy
  def function(var, var)
    super
    @@git ||= "STRING";Fi[	@ÈiYI"ùend
class CVSDownloadStrategy < AbstractDownloadStrategy
  def function(var, var)
    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"));Fi[	@ÈiÑI"£end
class MercurialDownloadStrategy < AbstractDownloadStrategy
  def function(var, var)
    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"));Fi[	@Èi¨I"†end
class BazaarDownloadStrategy < AbstractDownloadStrategy
  def function(var, var)
    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"));Fi[	@Èi I"†end
class FossilDownloadStrategy < AbstractDownloadStrategy
  def function(var, var)
    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"));Fi[	@‘iAI"Wend
class HeadSoftwareSpec < SoftwareSpec
  def function(var, var)
    super
  end;Fi[	@‘iNI"X  attr_reader("LITERAL")
  
  def function(var, var)
    super
    @var = "LITERAL";Fi[	@’iÜI"          end
          
          def function(var, var)
            super
            throw(@jumptag, @encoding) if @encoding;Fi[	@MiI"∏      ###
      # Create a new XSD parser with +host+ and +opt+
      def function(var, var)
        super
        @var = ::Nokogiri::XML::SAX::Parser.new(self, (@charset or "STRING"));Fi[	@H@ø	i[[	@bi(I"_    private
    
    def function(var, var)
      begin
        public_send("STRING", var);Fi[	@¸i%I"V    end
    
    def function(var, var)
      begin
        (var = send(var, var);Fi[	@Ui„I"ÿ      # DATABASE STATEMENTS ======================================
      # Executes the SQL statement in the context of this connection.
      def function(var, var)
        begin
          if (var == "LITERAL") then;Fi[	@õi´I"Õ        
        # Returns the sequence name for a table's primary key or some other specified key.
        def function(var, var)
          begin
            (var = serial_sequence(var, (var or "STRING"));Fi[	@ziDI"∫      # Note that errors raised by Cli::Helpers#run may also be rescued here.
      #
      def function(var, var)
        begin
          (var = Tempfile.open("STRING", Config.tmp_path);Fi[	@æiYI"q    end
    
    def function(var, var)
      begin
        (var, @scope["LITERAL"] = @scope["LITERAL"], nil;Fi[	@Ôi]I"‘    # @yield [args] A block of Haml code that will be converted to a string
    # @yieldparam args [Array] `args`
    def function(var, var)
      begin
        (var = (eval("STRING", var.binding) or haml_buffer);Fi[	I"(projects//homebrew_proj/cmd/link.rb;Ti(I"∆  # Allows us to ensure a puts happens before the block exits so that if say,
  # an exception is thrown, its output starts on a new line.
  def function(var, var)
    begin
      (Kernel.print(var);Fi[	I"-projects//homebrew_proj/extend/object.rb;TiI"zclass Object
  unless method_defined?("LITERAL") then
    def function(var, var)
      begin
        (var = "LITERAL";Fi[	@iI"    #
    # Returns nothing.
    def function(var, var)
      begin
        (self.content = File.read(File.join(var, var));Fi[	@i|I"|    end
    
    def function(var, var)
      begin
        (raise(RuntimeError.new("STRING")) if var.processors.blank?;Fi[	@	irI"Y      end
      
      def function(var, var)
        begin
          (log("STRING");Fi[	@ciÁI"Y      end
      
      def function(var, var)
        begin
          (log("STRING");Fi[	@ˆ
ifI"l      end
      attr_reader :function
      def function(var, var)
        begin
          (@var = true;Fi[	@]ieI"∫    # Also accepts a block which will be passed the job as soon as it
    # has completed processing. Useful for testing.
    def function(var, var)
      begin
        (var = Float(var);Fi[	@]ièI"√    # DEPRECATED. Processes a single job. If none is given, it will
    # try to produce one. Usually run in the child.
    def function(var, var)
      begin
        (unless var ||= reserve then;Fi[	@i2I"ü      #   Twitter.user?('sferik')
      #   Twitter.user?(7505382)  # Same as above
      def function(var, var)
        begin
          (merge_user!(var, var);Fi[	@|@ói[[	@KiwI"ì          var = if (ActiveRecord::Base.default_timezone == "LITERAL") then
            "LITERAL"
          else
            "LITERAL"
          end;Fi[	@Ã	i*I"~      var = if Mysql.const_defined?("LITERAL") then
        Mysql::CLIENT_MULTI_RESULTS
      else
        "LITERAL"
      end;Fi[	I"Kprojects//compass_proj/compass/sass_extensions/functions/font_files.rb;TiI"Ä      var = if (var > (var + "LITERAL")) then
        var[(var + "LITERAL")].value.to_sym
      else
        "LITERAL"
      end;Fi[	I"Dprojects//compass_proj/compass/sass_extensions/sprites/image.rb;Ti[I"†          @var ||= if (position.unitless? or (position.unit_str == "STRING")) then
            position.value
          else
            "LITERAL"
          end;Fi[	@÷iI"a        "LITERAL" if (var["LITERAL"] == "STRING")
      end
    else
      "LITERAL"
    end;Fi[	@Ÿi'I"x    var = if (var.mach_o_executable? or var.text_executable?) then
      "LITERAL"
    else
      "LITERAL"
    end;Fi[	@ÓiI"M    when "LITERAL" then
      "LITERAL"
    else
      "LITERAL"
    end;Fi[	@Ói#I"M    when "LITERAL" then
      "LITERAL"
    else
      "LITERAL"
    end;Fi[	@›
i|I"a        when "LITERAL" then
          "LITERAL"
        else
          "LITERAL"
        end;Fi[	@›
iìI"`        when "STRING" then
          "LITERAL"
        else
          "LITERAL"
        end;Fi[	@ﬁi/I"d      when ["LITERAL", "LITERAL"] then
        "LITERAL"
      else
        "LITERAL"
      end;Fi[	@ﬁi9I"b      when "LITERAL", "LITERAL" then
        "LITERAL"
      else
        "LITERAL"
      end;Fi[	@ﬁiKI"O    when "LITERAL" then
      archs.first
    else
      "LITERAL"
    end;Fi[	@iI"`        when "LITERAL" then
          "STRING"
        else
          "LITERAL"
        end;Fi[	@ÊiI"\    when "LITERAL" then
      "LITERAL"
    else
      "LITERAL"
    end, ENV.compiler);Fi[	@Êi[I"\    when "LITERAL" then
      "LITERAL"
    else
      "LITERAL"
    end, ENV.compiler);Fi[	@›i1I"ö          if var and ["LITERAL", "LITERAL"].include?(var.type) then
            extract_node_name(var)
          else
            "LITERAL"
          end);Fi[	@ßI"+#     include ActiveModel::Validations;Fi[[	@liI"û        # happens.
        #
        #   class Person
        #     include ActiveModel::Validations
        #     include ActiveModel::Validations::Callbacks;Fi[	@li5I"û        # happens.
        #
        #   class Person
        #     include ActiveModel::Validations
        #     include ActiveModel::Validations::Callbacks;Fi[	@Çi$I"Å      #   end
      #
      #   class Person
      #     include ActiveModel::Validations
      #     attr_accessor :name, :email;Fi[	@Çi{I"w      # the validation itself.
      #
      #   class Person
      #     include ActiveModel::Validations
      #;Fi[	@ãi!I"™      # to add errors based on more complex conditions.
      #
      #   class Person
      #     include ActiveModel::Validations
      #     validates_with MyValidator;Fi[	@ãi5I"…      # You may also pass it multiple classes, like so:
      #
      #   class Person
      #     include ActiveModel::Validations
      #     validates_with MyValidator, MyOtherValidator, on: :create;Fi[	@ãiNI"≈      # to the class and available as +options+:
      #
      #   class Person
      #     include ActiveModel::Validations
      #     validates_with MyValidator, my_custom_key: 'my custom value';Fi[	@ãijI"Å    # to add errors based on more complex conditions.
    #
    #   class Person
    #     include ActiveModel::Validations
    #;Fi[	@ãiyI"Å    # You may also pass it multiple classes, like so:
    #
    #   class Person
    #     include ActiveModel::Validations
    #;Fi[	@òiI"Ö      # Validates each attribute against a block.
      #
      #   class Person
      #     include ActiveModel::Validations
      #;Fi[	@òizI"y      # +validates_with+ method.
      #
      #   class Person
      #     include ActiveModel::Validations
      #;Fi[	@òiâI"•      # List all validators that are being used to validate a specific attribute.
      #
      #   class Person
      #     include ActiveModel::Validations
      #;Fi[	@òi∫I"f    # error messages.
    #
    #   class Person
    #     include ActiveModel::Validations
    #;Fi[	@òiÀI"o    # added otherwise +false+.
    #
    #   class Person
    #     include ActiveModel::Validations
    #;Fi[	@òi€I"ô    # against (the context is defined on the validations using <tt>:on</tt>).
    #
    #   class Person
    #     include ActiveModel::Validations
    #;Fi[	@òiÚI"p    # added, +false+ otherwise.
    #
    #   class Person
    #     include ActiveModel::Validations
    #;Fi[	@òiI"ô    # against (the context is defined on the validations using <tt>:on</tt>).
    #
    #   class Person
    #     include ActiveModel::Validations
    #;Fi[	@h@|i[[	@ iwI"v    def function(var, var)
      if super then
        true
      else
        if var.! and super(var, true) then;Fi[	@Øi√I"˙      def function(var)
        if var.first.is_a?(Hash) then
          true
        else
          (loaded? or (owner.new_record? or (options["LITERAL"] or (target.any? { |var| (var.new_record? or var.changed?) } or var.first.kind_of?(Integer))))).!;Fi[	@Qi I"ä      var = tables_in_string(to_sql)
      if (references_values - var).any? then
        true
      else
        if (var - var).any? then;Ti[	@Qi$I"Ä        if (var - var).any? then
          ActiveSupport::Deprecation.warn("STRING")
          true
        else
          false;Ti[	@
i=I"¶      else
        if (var == {}) then
          true
        else
          if var["LITERAL"] and [var["LITERAL"]].flatten.include?(@params["LITERAL"].to_sym).! then;Fi[	@
i@I"·        else
          if var["LITERAL"] and [var["LITERAL"]].flatten.include?(@params["LITERAL"].to_sym).! then
            true
          else
            true if [var["LITERAL"]].flatten.include?(@params["LITERAL"].to_sym);Fi[	I")projects//cancan_proj/cancan/rule.rb;TisI"õ    def function(var, var)
      if var.empty? then
        true
      else
        if model_adapter(var).override_conditions_hash_matching?(var, var) then;Fi[	@»i¥I"ö        def function(var)
          if super then
            true
          else
            inherited_data ? (inherited_data.respond_to?(var)) : (false);Fi[	@≥iNI"µ        else
          if (warden.user(var) == var) and var.delete("LITERAL").! then
            true
          else
            warden.set_user(var, var.merge!("LITERAL" => (var)));Fi[	@iJI"õ        unlock_access! if lock_expired?
        if super and access_locked?.! then
          true
        else
          self.failed_attempts ||= "LITERAL";Fi[	@≠
i)I"{        if var then
          decorate(var)
          true
        else
          fail!(var.unauthenticated_message) if var;Fi[	@'
iKI"Ñ    if self.profile.update_attributes(var) then
      Postzord::Dispatcher.build(self, profile).post
      true
    else
      false;Fi[	@ÏiYI"¢    def function(var)
      if var.value and var.value["LITERAL"] then
        true
      else
        var.parent ? (nuke_inner_whitespace?(var.parent)) : (false);Fi[	I"+projects//homebrew_proj/cmd/cleanup.rb;TiWI"t  def function
    if (keg_only?.! or ARGV.force?) then
      true
    else
      if opt_prefix.directory? then;Fi[	@≈
i*I"r      case File.basename(var)
      when "STRING", "STRING" then
        true
      else
        # do nothing;Fi[	@iII"î    def function
      if instance.valid? then
        true
      else
        instance.errors.none? { |var, var| var.to_s.start_with?(@name.to_s) };Fi[	@	iaI"µ            var = self.class.state_machine(var)
            if var.states.match(self) then
              true
            else
              [false, var.generate_message("LITERAL")];Fi[	@™@i[[	@]iDI"u    #
    #   class MyClass
    #     include ActiveModel::Validations
    #
    #     def initialize(data = {});Fi[	@Çi0I"è      #
      #   class Film
      #     include ActiveModel::Validations
      #
      #     class TitleValidator < ActiveModel::EachValidator;Fi[	@Çi|I"x      #
      #   class Person
      #     include ActiveModel::Validations
      #
      #     attr_accessor :name;Fi[	@ãikI"y    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     validate :instance_validations;Fi[	@ãizI"Å    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     validate :instance_validations, on: :create;Fi[	@òiI"Ö      #
      #   class Person
      #     include ActiveModel::Validations
      #
      #     attr_accessor :first_name, :last_name;Fi[	@òi=I"      #
      #   class Comment
      #     include ActiveModel::Validations
      #
      #     validate :must_be_friends;Fi[	@òiII"{      #
      #   class Comment
      #     include ActiveModel::Validations
      #
      #     validate do |comment|;Fi[	@òiWI"q      #
      #   class Comment
      #     include ActiveModel::Validations
      #
      #     validate do;Fi[	@òi{I"      #
      #   class Person
      #     include ActiveModel::Validations
      #
      #     validates_with MyValidator;Fi[	@òiäI"      #
      #   class Person
      #     include ActiveModel::Validations
      #
      #     attr_accessor :name , :age;Fi[	@òiªI"n    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name;Fi[	@òiÃI"n    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name;Fi[	@òi‹I"n    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name;Fi[	@òiÛI"n    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name;Fi[	@òiI"n    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name;Fi[	@òiI"u    #
    #   class MyClass
    #     include ActiveModel::Validations
    #
    #     def initialize(data = {});Fi[	@I"# Example:;Fi[[	@Çi\I"¿      #   will raise ActiveModel::StrictValidationFailed instead of adding the error.
      #   <tt>:strict</tt> option can also be set to any other exception.
      #
      # Example:
      #;Fi[	@UiRI"Ï      # Create a new MySQL database with optional <tt>:charset</tt> and <tt>:collation</tt>.
      # Charset defaults to utf8.
      #
      # Example:
      #   create_database 'charset_test', charset: 'latin1', collation: 'latin1_bin';Fi[	@Ui\I"u      
      # Drops a MySQL database.
      #
      # Example:
      #   drop_database('sebastian_development');Fi[	@UiÆI"k      
      # Renames a table.
      #
      # Example:
      #   rename_table('octopuses', 'octopi');Fi[	@õiI"Ó        # <tt>:tablespace</tt>, and <tt>:connection_limit</tt> (note that MySQL uses
        # <tt>:charset</tt> while PostgreSQL uses <tt>:encoding</tt>).
        #
        # Example:
        #   create_database config[:database], config;Fi[	@õi2I"~        
        # Drops a PostgreSQL database.
        #
        # Example:
        #   drop_database 'matt_development';Fi[	@õiÿI"ƒ        # Also renames a table's primary key sequence if the sequence name matches the
        # Active Record default.
        #
        # Example:
        #   rename_table('octopuses', 'octopi');Fi[	@XitI"k      
      # Renames a table.
      #
      # Example:
      #   rename_table('octopuses', 'octopi');Fi[	@iºI"z    # guaranteed to match the structure of +coder+ passed to the +init_with+
    # method.
    #
    # Example:
    #;Fi[	@8i/I"´      # association type, pass in the symbol (<tt>:has_many</tt>, <tt>:has_one</tt>,
      # <tt>:belongs_to</tt>) as the first parameter.
      #
      # Example:
      #;Fi[	@≥izI"ƒ      # Returns and delete (if it's navigational format) the url stored in the session for
      # the given scope. Useful for giving redirect backs after sign up:
      #
      # Example:
      #;Fi[	@0itI"¡      # confirmation sent date does not exceed the confirm in time configured.
      # Confirm_within is a model configuration, must always be an integer value.
      #
      # Example:
      #;Fi[	@ªiAI"≤      # method, you should probably override this method to protect other
      # attributes you would not like to be updated without a password.
      #
      # Example:
      #;Fi[	@i%I"“      # Returns true if the resource is not responding to reset_password_sent_at at all.
      # reset_password_within is a model configuration, must always be an integer value.
      #
      # Example:
      #;Fi[	@Ci
I"ì      # Ensures that the given instance or class has an attachment with the
      # given name.
      #
      # Example:
      #   describe User do;Fi[	@Ji
I"≠      # Ensures that the given instance or class validates the content type of
      # the given attachment as specified.
      #
      # Example:
      #   describe User do;Fi[	@`iOI"G  #
  # Returns the number of jobs destroyed.
  #
  # Example:
  #;Fi[	@I"module API;Fi[[	I"4projects//twitter_proj/twitter/api/arguments.rb;Ti I"<module Twitter
  module API
    class Arguments < Array;Fi [	@qi	I"trequire("twitter/direct_message")
require("twitter/user")
module Twitter
  module API
    module DirectMessages;Fi[	@~iI"frequire("twitter/tweet")
require("twitter/user")
module Twitter
  module API
    module Favorites;Fi[	@ÖiI"wrequire("twitter/relationship")
require("twitter/user")
module Twitter
  module API
    module FriendsAndFollowers;Fi[	@¢iI"mrequire("twitter/configuration")
require("twitter/language")
module Twitter
  module API
    module Help;Fi[	@´iI"brequire("twitter/tweet")
require("twitter/user")
module Twitter
  module API
    module Lists;Fi[	@ŒiI"nrequire("twitter/api/utils")
require("twitter/place")
module Twitter
  module API
    module PlacesAndGeo;Fi[	@ŸiI"vrequire("twitter/api/utils")
require("twitter/saved_search")
module Twitter
  module API
    module SavedSearches;Fi[	@‚iI"qrequire("twitter/api/utils")
require("twitter/search_results")
module Twitter
  module API
    module Search;Fi[	@ÂiI"nrequire("twitter/api/utils")
require("twitter/user")
module Twitter
  module API
    module SpamReporting;Fi[	@Ëi	I"prequire("twitter/suggestion")
require("twitter/user")
module Twitter
  module API
    module SuggestedUsers;Fi[	@ÎiI"frequire("twitter/tweet")
require("twitter/user")
module Twitter
  module API
    module Timelines;Fi[	@˙iI"drequire("twitter/place")
require("twitter/trend")
module Twitter
  module API
    module Trends;Fi[	@iI"erequire("twitter/oembed")
require("twitter/tweet")
module Twitter
  module API
    module Tweets;Fi[	@iI"irequire("twitter/tweet")
require("twitter/user")
module Twitter
  module API
    module Undocumented;Fi[	@iI"erequire("twitter/settings")
require("twitter/user")
module Twitter
  module API
    module Users;Fi[	@iI"crequire("twitter/cursor")
require("twitter/user")
module Twitter
  module API
    module Utils;Fi[	I"Y#   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.;FI"=#   @param options [Hash] A customizable set of options.;Fi[[	@´i4I"w      # @return [Array<Twitter::Tweet>]
      # @overload list_timeline(list, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;Fi[	@´i>I"∑      # @overload list_timeline(user, list, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;Fi[	@´iäI"Î      # @return [Twitter::Cursor] The subscribers of the specified list.
      # @overload list_subscribers(list, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@´iíI"
      # @overload list_subscribers(user, list, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@´i•I"K      # @return [Twitter::List] The specified list.
      # @overload list_subscribe(list, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @example Subscribe to the authenticated user's "presidents" list;Fi[	@´i¨I"p      # @overload list_subscribe(user, list, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @example Subscribe to @sferik's "presidents" list;Fi[	@´i‹I"Q      # @return [Twitter::List] The specified list.
      # @overload list_unsubscribe(list, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @example Unsubscribe from the authenticated user's "presidents" list;Fi[	@´i„I"v      # @overload list_unsubscribe(user, list, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @example Unsubscribe from @sferik's "presidents" list;Fi[	@´i1I"¿      # @return [Twitter::Cursor]
      # @overload list_members(list, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@´i9I"      # @overload list_members(user, list, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@´ikI"A      # @return [Twitter::List] The deleted list.
      # @overload list_destroy(list, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @example Delete the authenticated user's "presidents" list;Fi[	@´irI"h      # @overload list_destroy(user, list, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @example Delete @sferik's "presidents" list;Fi[	@´iÖI"|      # @return [Twitter::List] The created list.
      # @overload list_update(list, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [String] :mode ('public') Whether your list is public or private. Values can be 'public' or 'private'.;Fi[	@´iéI"≤      # @overload list_update(user, list, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [String] :mode ('public') Whether your list is public or private. Values can be 'public' or 'private'.;Fi[	@´i∂I"9      # @return [Twitter::List] The specified list.
      # @overload list(list, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @example Show the authenticated user's "presidents" list;Fi[	@´iΩI"^      # @overload list(user, list, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @example Show @sferik's "presidents" list;Fi[	I"module StateMachine;FI"module Integrations;Fi[[	I"Uprojects//state_machine_proj/state_machine/integrations/active_model/observer.rb;Ti I"Emodule StateMachine
  module Integrations
    module ActiveModel;Fi [	I"\projects//state_machine_proj/state_machine/integrations/active_model/observer_update.rb;Ti I"Emodule StateMachine
  module Integrations
    module ActiveModel;Fi [	@®i I"Emodule StateMachine
  module Integrations
    module ActiveModel;Fi [	@Ûi I"Emodule StateMachine
  module Integrations
    module ActiveModel;Fi [	@Ãi I"Fmodule StateMachine
  module Integrations
    module ActiveRecord;Fi [	@)iI"yrequire("state_machine/integrations/active_model")
module StateMachine
  module Integrations
    module ActiveRecord;Fi[	@Úi I">module StateMachine
  module Integrations
    module Base;Fi [	@ıi I"Dmodule StateMachine
  module Integrations
    module DataMapper;Fi [	@πi I"Dmodule StateMachine
  module Integrations
    module DataMapper;Fi [	@	i I"Dmodule StateMachine
  module Integrations
    module DataMapper;Fi [	@”i I"Emodule StateMachine
  module Integrations
    module MongoMapper;Fi [	@,iI"xrequire("state_machine/integrations/active_model")
module StateMachine
  module Integrations
    module MongoMapper;Fi[	@Ãi I"Amodule StateMachine
  module Integrations
    module Mongoid;Fi [	@/i I"Amodule StateMachine
  module Integrations
    module Mongoid;Fi [	@ci I"@module StateMachine
  module Integrations
    module Sequel;Fi [	@Ji I"@module StateMachine
  module Integrations
    module Sequel;Fi [	@HI"super(var);Fi[[	@yi-I"a    attr_reader("LITERAL")
    
    def function(var, var)
      super(var)
      @var = var;Fi[	@ci0I"ë      ##
      # Creates a new instance of the MongoDB database object
      def function(var, var)
        super(var)
        @var ||= Array.new;Fi[	@i)I"é      ##
      # Creates a new instance of the MySQL adapter object
      def function(var, var)
        super(var)
        @var ||= Array.new;Fi[	@i*I"¿      # Sets the PGPASSWORD environment variable to the password
      # so it doesn't prompt and hang in the process
      def function(var, var)
        super(var)
        @var ||= Array.new;Fi[	@fi&I"è      ##
      # Creates a new instance of the Redis database object
      def function(var, var)
        super(var)
        @var ||= Array.new;Fi[	@iiI"û      ##
      # Creates a new instance of the Riak adapter object
      def function(var, var)
        super(var)
        instance_eval(&var) if block_given?;Fi[	I"+projects//backup_proj/backup/errors.rb;TiI"x      end
      
      def function(var, var)
        super(var)
        set_backtrace(var.backtrace) if @var = var;Fi[	@≤iI"á      ##
      # Campfire account's room id
      def function(var, var)
        super(var)
        instance_eval(&var) if block_given?;Fi[	@ü
i(I"≈      # The background color of an error message.
      # One of :yellow, :red, :green, :purple, or :random. (default: yellow)
      def function(var, var)
        super(var)
        @var ||= false;Fi[	@¢
ilI"∞      # Default location is '$HOME/Backup/emails'
      # Example: '/tmp/test-mails'
      def function(var, var)
        super(var)
        instance_eval(&var) if block_given?;Fi[	@πiI"≤      # API-Key
      # Create a Prowl account and request an API key on prowlapp.com.
      def function(var, var)
        super(var)
        instance_eval(&var) if block_given?;Fi[	@¿iI"ç      ##
      # The priority of the notification
      def function(var, var)
        super(var)
        instance_eval(&var) if block_given?;Fi[	@«iI"~      ##
      # OAuth credentials
      def function(var, var)
        super(var)
        instance_eval(&var) if block_given?;Fi[	I"&projects//haml_proj/haml/error.rb;TiI"î    # @param message [String] The error message
    # @param line [Fixnum] See \{#line}
    def function(var, var)
      super(var)
      @var = var;Fi[	@˛i2I"Z    attr("LITERAL")
    
    def function(var, var)
      super(var)
      @var = var;Fi[	@k
iI"«    # * <tt>:after</tt> - Whether to run after callbacks
    # * <tt>:transaction</tt> - Whether to wrap transitions within a transaction
    def function(var, var)
      super(var)
      @var = all?;Fi[	I""autoload("LITERAL", "STRING");F@”i[[	@v
iI"ê      
      eager_autoload do
        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING");Fi[	@v
iI"Ø      eager_autoload do
        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING");Fi[	@v
iI"Ω        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING");Fi[	@v
iI"Ω        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING");Fi[	@v
iI"Ω        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING");Fi[	@v
iI"Ω        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING");Fi[	@v
iI"Ω        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING");Fi[	@v
iI"Ω        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING");Fi[	@v
iI"°        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING")
      end;Fi[	@ÒiíI"Ü    
    eager_autoload do
      autoload("LITERAL", "STRING")
      autoload("LITERAL", "STRING")
      autoload("LITERAL", "STRING");Fi[	@ÒiìI"•    eager_autoload do
      autoload("LITERAL", "STRING")
      autoload("LITERAL", "STRING")
      autoload("LITERAL", "STRING")
      autoload("LITERAL", "STRING");Fi[	@ÒiîI"≥      autoload("LITERAL", "STRING")
      autoload("LITERAL", "STRING")
      autoload("LITERAL", "STRING")
      autoload("LITERAL", "STRING")
      autoload("LITERAL", "STRING");Fi[	@ÒiïI"ó      autoload("LITERAL", "STRING")
      autoload("LITERAL", "STRING")
      autoload("LITERAL", "STRING")
      autoload("LITERAL", "STRING")
    end;Fi[	@niII"|  
  eager_autoload do
    autoload("LITERAL", "STRING")
    autoload("LITERAL", "STRING")
    autoload("LITERAL", "STRING");Fi[	@niJI"ë  eager_autoload do
    autoload("LITERAL", "STRING")
    autoload("LITERAL", "STRING")
    autoload("LITERAL", "STRING")
    autoload("LITERAL");Fi[	@:I"var = [];Fi[[	@÷iI"Y      private
      
      def function
        var = []
        chain.each do |var|;Fi[	@ı	i\I"˝    # may be interleaved. Interleaving of the "index|exit status" outputs
    # should not be an issue, given the small byte size of the data being written.
    def function
      var = []
      @commands.each_with_index { |var, var| (var << "STRING") };Fi[	@&iI"z      end
      
      def function
        var = []
        (var << [sass_path, css_path]) if sass_path and css_path;Fi[	@&i>I"a      end
      
      def function
        var = []
        (var << sass_path) if sass_path;Fi[	@∏i;I"±  # Require jQuery from CDN if possible, falling back to vendored copy, and require
  # vendored jquery_ujs
  def function
    var = []
    if AppConfig.privacy.jquery_cdn? then;Fi[	I"7projects//diaspora_proj/helpers/language_helper.rb;TiI"vmodule LanguageHelper
  def function
    var = []
    AVAILABLE_LANGUAGES.each { |var, var| (var << [var, var]) };Fi[	@iI"@  end
  
  def function
    var = []
    (var << f.caveats);Fi[	@i*I"a  end
  
  def function
    var = []
    if (f.plist or (keg and keg.plist_installed?)) then;Fi[	@iXI"C  end
  
  def function
    var = []
    var = Formula.aliases;Fi[	I"(projects//homebrew_proj/cmd/deps.rb;Ti$I"Tend
class Array
  def function
    var = []
    each { |var| var = var.|(var) };Fi[	I"+projects//homebrew_proj/cmd/missing.rb;Ti	I"\  extend(self)
  
  def function
    var = []
    HOMEBREW_CELLAR.subdirs.each do |var|;Fi[	I",projects//homebrew_proj/cmd/versions.rb;TiI"Mend
class Formula
  def function
    var = []
    rev_list.each do |var|;Fi[	I"5projects//homebrew_proj/keg_fix_install_names.rb;Ti@I"R  end
  
  def function
    var = []
    var = ["STRING", "STRING", "STRING"];Fi[	@·iÇI"¨  # http://github.com/mxcl/homebrew/issues/#issue/41
  # http://github.com/mxcl/homebrew/issues/#issue/48
  def function
    var = []
    ["STRING", "STRING"].each do |var|;Fi[	@,icI"z      alias "LITERAL" "LITERAL"
      
      def function
        var = []
        self.class.constants.each do |var|;Fi[	@I"# ==== Examples;Fi[[	I"?projects//activerecord_proj/active_record/counter_cache.rb;TiI"•      # * +id+ - The id of the object you wish to reset a counter on.
      # * +counters+ - One or more counter names to reset
      #
      # ==== Examples
      #;Fi[	@i6I"ø      # * +counters+ - An Array of Hashes containing the names of the fields
      #   to update as keys and the amount to update the field by as values.
      #
      # ==== Examples
      #;Fi[	@i\I"«      # * +counter_name+ - The name of the field that should be incremented.
      # * +id+ - The id of the object that should be incremented or an Array of ids.
      #
      # ==== Examples
      #;Fi[	@inI"«      # * +counter_name+ - The name of the field that should be decremented.
      # * +id+ - The id of the object that should be decremented or an Array of ids.
      #
      # ==== Examples
      #;Fi[	@&iI"∫      # Nested classes are given table names prefixed by the singular form of
      # the parent's table name. Enclosing modules are not considered.
      #
      # ==== Examples
      #;Fi[	@1iI"’      # +create+ respects mass-assignment security and accepts either +:as+ or +:without_protection+ options
      # in the +options+ parameter.
      #
      # ==== Examples
      #   # Create a single new object;Fi[	@QiYI"Ü    #
    # Expects arguments in the same format as +Base.create+.
    #
    # ==== Examples
    #   users = User.where(name: 'Oscar');Ti[	@Qi{I"◊    # Finds the first record with the given attributes, or creates a record with the attributes
    # if one is not found.
    #
    # ==== Examples
    #   # Find the first user named Pen√©lope or create a new one.;Ti[	@QiÈI"Å    #
    # * +updates+ - A string, array, or hash representing the SET part of an SQL statement.
    #
    # ==== Examples
    #;Ti[	@QiI"∏    # * +id+ - This should be the id or an array of ids to be updated.
    # * +attributes+ - This should be a hash of attributes or an array of hashes.
    #
    # ==== Examples
    #;Ti[	@Qi1I"Ç    #   Conditions section in the introduction to ActiveRecord::Base for
    #   more information.
    #
    # ==== Examples
    #;Ti[	@QiII"k    #
    # * +id+ - Can be either an Integer or an Array of Integers.
    #
    # ==== Examples
    #;Ti[	@QiÜI"Å    # your application that ensures referential integrity or performs other
    # essential jobs.
    #
    # ==== Examples
    #;Ti[	@æiI"à    # generate all needed routes for devise, based on what modules you have
    # defined in your model.
    #
    # ==== Examples
    #;Fi[	I"opoo("STRING");F@	i[[	@iWI"b    require("erb")
    if version.nil? then
      opoo("STRING")
      puts("STRING")
    end;Fi[	@»
i9I"{  def function
    unless MacOS.macports_or_fink.empty? then
      opoo("STRING")
      puts("STRING")
      puts("STRING");Fi[	@niI"u    ARGV.kegs.each do |var|
      if var.linked? then
        opoo("STRING")
        puts("STRING")
        next;Fi[	@˚i=I"à  # up in the DSL section.
  def function(var, var)
    opoo("STRING")
    puts("STRING")
    FailsWithLLVM.new(var, var).handle_failure;Ti[	@—iÚI"ë      (ohai("STRING") if ARGV.verbose?
      if f.class.skip_clean_all? then
        opoo("STRING")
        puts("STRING")
        puts("STRING");Fi[	@—i¸I"â      Cleaner.new(f))
    rescue Exception => var
      opoo("STRING")
      puts("STRING")
      ohai(var, var.backtrace) if ARGV.debug?;Fi[	@—iI"∞        var = (HOMEBREW_PREFIX / var.basename).realpath
        unless ORIGINAL_PATHS.include?(var) then
          opoo("STRING")
          puts("STRING")
          @var = true;Fi[	@—iI"  def function
    if (f.prefix + "STRING").directory? then
      opoo("STRING")
      puts("STRING")
      puts("STRING");Fi[	@—i"I"  def function
    if (f.prefix + "STRING").directory? then
      opoo("STRING")
      puts("STRING")
      puts("STRING");Fi[	@—i-I"ô    var = f.lib.children.select { |var| var.to_s =~ "LITERAL" }
    unless var.empty? then
      opoo("STRING")
      puts("STRING")
      puts("STRING");Fi[	@—i@I"f    end
    unless var.empty? then
      opoo("STRING")
      puts("STRING")
      puts("STRING");Fi[	@—iLI"©    var = f.bin.children.select { |var| (var.directory? or var.executable?.!) }
    unless var.empty? then
      opoo("STRING")
      puts("STRING")
      puts("STRING");Fi[	@—iXI"™    var = f.sbin.children.select { |var| (var.directory? or var.executable?.!) }
    unless var.empty? then
      opoo("STRING")
      puts("STRING")
      puts("STRING");Fi[	@‘iI"É      var.verify_checksum(@checksum)
    rescue ChecksumMissingError
      opoo("STRING")
      puts("STRING")
      puts("STRING");Fi[	@ŸI"var = "LITERAL";Fi[[	@Ã	iÖI"ñ      alias "LITERAL" "LITERAL"
      
      def function(var, var, var)
        var = "LITERAL"
        exec_query(var, var, var) { |var| var = var };Fi[	I"3projects//nokogiri_proj/nokogiri/css/parser.rb;Ti>I"[      end
      
      def function(var, var, var)
        var = "LITERAL"
        var;Fi[	@^iCI"[      end
      
      def function(var, var, var)
        var = "LITERAL"
        var;Fi[	@^iHI"[      end
      
      def function(var, var, var)
        var = "LITERAL"
        var;Fi[	@^iMI"[      end
      
      def function(var, var, var)
        var = "LITERAL"
        var;Fi[	@^iRI"[      end
      
      def function(var, var, var)
        var = "LITERAL"
        var;Fi[	@^iWI"[      end
      
      def function(var, var, var)
        var = "LITERAL"
        var;Fi[	@^iPI"k      
      # reduce 62 omitted
      def function(var, var, var)
        var = "LITERAL"
        var;Fi[	@^iUI"[      end
      
      def function(var, var, var)
        var = "LITERAL"
        var;Fi[	@^iZI"[      end
      
      def function(var, var, var)
        var = "LITERAL"
        var;Fi[	@^i_I"[      end
      
      def function(var, var, var)
        var = "LITERAL"
        var;Fi[	@^idI"[      end
      
      def function(var, var, var)
        var = "LITERAL"
        var;Fi[	@^iiI"[      end
      
      def function(var, var, var)
        var = "LITERAL"
        var;Fi[	@^inI"[      end
      
      def function(var, var, var)
        var = "LITERAL"
        var;Fi[	I"`#   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.;F@di[[	@´i=I"^      #     Twitter.list_timeline(8863586)
      # @overload list_timeline(user, list, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.;Fi[	@´iaI"≥      #     Twitter.list_remove_member(8863586, 'BarackObama')
      # @overload list_remove_member(user, list, user_to_remove, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param user_to_remove [Integer, String] The user id or screen name of the list member to remove.;Fi[	@´iëI"d      #     Twitter.list_subscribers(8863586)
      # @overload list_subscribers(user, list, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.;Fi[	@´i´I"`      #     Twitter.list_subscribe(8863586)
      # @overload list_subscribe(user, list, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.;Fi[	@´i∆I"≥      #     Twitter.list_subscriber?('presidents', 'BarackObama')
      # @overload list_subscriber?(user, list, user_to_check, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param user_to_check [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.;Fi[	@´i‚I"d      #     Twitter.list_unsubscribe(8863586)
      # @overload list_unsubscribe(user, list, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.;Fi[	@´iˇI"‹      #     Twitter.list_add_members(8863586, [813286, 18755393])
      # @overload list_add_members(user, list, users, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.;Fi[	@´iI"õ      #     Twitter.list_member?(8863586, 'BarackObama')
      # @overload list_member?(user, list, user_to_check, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param user_to_check [Integer, String] The user ID or screen name of the list member.;Fi[	@´i8I"\      #     Twitter.list_members(8863586)
      # @overload list_members(user, list, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.;Fi[	@´iUI"ñ      #     Twitter.list_add_member(8863586, 813286)
      # @overload list_add_member(user, list, user_to_add, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param user_to_add [Integer, String] The user id or screen name to add to the list.;Fi[	@´iqI"\      #     Twitter.list_destroy(8863586)
      # @overload list_destroy(user, list, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.;Fi[	@´içI"ò      #     Twitter.list_update(8863586, :description => "Presidents of the United States of America")
      # @overload list_update(user, list, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.;Fi[	@´iºI"L      #     Twitter.list(8863586)
      # @overload list(user, list, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.;Fi[	@´iI"‚      #     Twitter.list_remove_members(8863586, [813286, 18755393])
      # @overload list_remove_members(user, list, users, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.;Fi[	@@i[[	@∏iWI"î    #       values.each do |family, max_age|
    #       ...
    #       end
    #
    #   Person.calculate(:count, :all) # The same as Person.count;Fi[	@∏iSI"µ      #       def send_devise_notification(notification)
      #         pending_notifications << notification
      #       end
      #
      #       def send_pending_notifications;Fi[	@∏iYI"ã      #           devise_mailer.send(n, self).deliver
      #         end
      #       end
      #
      #       def pending_notifications;Fi[	@ÊiI"Ä    #       event :park do
    #         transition :idling => :parked
    #       end
    #       
    #       event :ignite do;Fi[	@ÊiBI"Ä    #       event :park do
    #         transition :idling => :parked
    #       end
    #       
    #       event :ignite do;Fi[	@ÌiDI"Ä    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do;Fi[	@ÌiNI"    #       event :enable do
    #         transition all => :active
    #       end
    #       
    #       event :disable do;Fi[	@ÌivI"Ä    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do;Fi[	@Ìi{I"    #       event :enable do
    #         transition all => :active
    #       end
    #       
    #       event :disable do;Fi[	@ipI"Ñ    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :shift_up do;Fi[	@i°I"Ä    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do;Fi[	@i√I"}    #       event :turn_on do
    #         transition all => :on
    #       end
    #       
    #       event :turn_off do;Fi[	@iÕI"Å    #       event :turn_on do
    #         transition all => :active
    #       end
    #       
    #       event :turn_off do;Fi[	@$iI"z    #       event :park
    #         transition all => :parked
    #       end
    #       
    #       event :crash;Fi[	@@Hi[[	@i7I"L      #               constructor: Proc.new { |ip| IPAddr.new(ip, Socket::AF_INET) },
      #               converter: Proc.new { |ip| ip.is_a?(Integer) ? IPAddr.new(ip, Socket::AF_INET) : IPAddr.new(ip.to_s) }
      #
      def function(var, var)
        var.assert_valid_keys("LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL");Fi[	@1i»I"ƒ    # * updated_at/updated_on column is updated if that column is available.
    # * Updates all the attributes that are dirty in this object.
    #
    def function(var, var)
      var = var.to_s;Fi[	@Ji;I"ƒ    #   Topic.select('a.title').from(Topic.approved, :a)
    #   # => SELECT a.title FROM (SELECT * FROM topics WHERE approved = 't') a
    #
    def function(var, var)
      spawn.from!(var, var);Fi[	@i;I"        # method previously used to set the accessor being deprecated.
        # #method_missing will handle any calls to `name=`.
        #
        def function(var, var)
          deprecations[var] = { "LITERAL" => (nil), "LITERAL" => (nil), "LITERAL" => (nil) }.merge(var);Fi[	@i^I"¿      # i.e. if an option will accept being set as an Array, then it
      # should be explicitly set as such. e.g. option = [val1, val2]
      #
      def function(var, var)
        var = nil;Fi[	@ziCI"©      # If the import fails, return nil.
      # Note that errors raised by Cli::Helpers#run may also be rescued here.
      #
      def function(var, var)
        begin;Fi[	@≥iDI"È      #   sign_in @user, :event => :authentication  # sign_in(resource, options)
      #   sign_in @user, :bypass => true            # sign_in(resource, options)
      #
      def function(var, var)
        var = var.extract_options!;Fi[	@∏i_I"~      #       end
      #     end
      #
      def function(var, var)
        devise_mailer.send(var, self, var).deliver;Fi[	@ªiHI"o      #     super(params)
      #   end
      #
      def function(var, var)
        var.delete("LITERAL");Fi[	@æiÍI"z    #     root :to => "admin/dashboard#show"
    #   end
    #
    def function(var, var)
      var = lambda do |var|;Fi[	@æiI"j    #
    #   root :to => 'landing#show'
    #
    def function(var, var)
      var = lambda do |var|;Fi[	@Qi$I"º    #   sign_in :user, @user   # sign_in(scope, resource)
    #   sign_in @user          # sign_in(resource)
    #
    def function(var, var)
      var ||= Devise::Mapping.find_scope!(var);Fi[	@ÿi•I"      #     config.format.as_xml
      #   end
      #
      def function(var, var)
        var = if var.first.is_a?(Hash) then;Fi[	@ÿiÁI"£      #
      #   node.write_to(io, :indent_text => '-', :indent => 2
      #
      def function(var, var)
        var = var.first.is_a?(Hash) ? (var.shift) : ({});Fi[	I"Gassert_equal("LITERAL", (version("STRING") <=> version("STRING")));F@‘i[[	@>iI"Ê  
  def function
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")));Fi[	@>iI"*  def function
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")));Fi[	@>iI"b    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")));Fi[	@>iI"b    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")));Fi[	@>iI"b    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")));Fi[	@>iI"b    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")));Fi[	@>iI"b    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")));Fi[	@>iI"b    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")));Fi[	@>iI"b    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")));Fi[	@>iI"b    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")));Fi[	@>iI"b    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")));Fi[	@>iI"b    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")));Fi[	@>i I"b    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")));Fi[	@>i!I"L    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_equal("LITERAL", (version("STRING") <=> version("STRING")))
    assert_nil((version("STRING") <=> "STRING"));Fi[	@£@öi[[	@KibI"q      
      # Quotes the column name. Defaults to no quoting.
      def function(var)
        var
      end;Fi[	@iI"≤    
    class ColumnDefinition < Struct.new("LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL")
      def function(var)
        var
      end;Fi[	@PiI"C      end
      
      def function(var)
        var
      end;Fi[	@Ã	iÓI"W          end
          
          def function(var)
            var
          end;Fi[	@Ã	iÙI"e        
        class Identity < Type
          def function(var)
            var
          end;Fi[	@siI"W          end
          
          def function(var)
            var
          end;Fi[	@siI"e        
        class Identity < Type
          def function(var)
            var
          end;Fi[	@si=I"Æ          # to cast the values.  Unfortunately, the current Rails behavior
          # is to just return the string.
          def function(var)
            var
          end;Fi[	@∏iüI"ë            var.column_types.fetch(var) do
              Class.new do
                def function(var)
                  var
                end;Fi[	I"(projects//haml_proj/haml/filters.rb;TièI"R      
      # @see Base#render
      def function(var)
        var
      end;Fi[	I"8projects//jekyll_proj/jekyll/converters/identity.rb;TiI"9    end
    
    def function(var)
      var
    end;Fi[	@
iI"9    end
    
    def function(var)
      var
    end;Fi[	I"Gprojects//paperclip_proj/paperclip/io_adapters/identity_adapter.rb;TiI"gmodule Paperclip
  class IdentityAdapter < AbstractAdapter
    def function(var)
      var
    end;Fi[	@li+I"^    
    # Always returns the given set of values
    def function(var)
      var
    end;Fi[	@:I"Jdefine_helper("LITERAL", "STRING", "STRING", ("LITERAL" + "LITERAL"));Fi[[	@®iI"⁄          (defined? ::ActiveModel::VERSION.! or (::ActiveModel::VERSION::MAJOR == "LITERAL"))
        end
        def function
          define_helper("LITERAL", "STRING", "STRING", ("LITERAL" + "LITERAL"))
        end;Fi[	@ÃiI"          ((::ActiveRecord::VERSION::MAJOR == "LITERAL") or ((::ActiveRecord::VERSION::MAJOR == "LITERAL") and (::ActiveRecord::VERSION::MINOR == "LITERAL")))
        end
        def function
          define_helper("LITERAL", "STRING", "STRING", ("LITERAL" + "LITERAL"))
        end;Fi[	@)i1I"ì      
      # Initializes static states
      def function
        define_helper("LITERAL", "STRING", "STRING", ("LITERAL" + "LITERAL"))
      end;Fi[	@)i6I"î      
      # Initializes dynamic states
      def function
        define_helper("LITERAL", "STRING", "STRING", ("LITERAL" + "LITERAL"))
      end;Fi[	@	iUI"≈      # initial state of the machine *before* any attributes are set on the
      # object
      def function
        define_helper("LITERAL", "STRING", "STRING", ("LITERAL" + "LITERAL"))
      end;Fi[	@”iI"ä          var
        end
        def function
          define_helper("LITERAL", "STRING", "STRING", ("LITERAL" + "LITERAL"))
        end;Fi[	@”iFI"ı          defined? ::MongoMapper::Plugins and (defined? ::MongoMapper::Version.! or ::MongoMapper::Version =~ "LITERAL")
        end
        def function
          define_helper("LITERAL", "STRING", "STRING", ("LITERAL" + "LITERAL"))
        end;Fi[	@,i)I"≈      # initial state of the machine *before* any attributes are set on the
      # object
      def function
        define_helper("LITERAL", "STRING", "STRING", ("LITERAL" + "LITERAL"))
      end;Fi[	@ÃiI"¶          ::Mongoid::VERSION =~ "LITERAL"
        end
        def function
          define_helper("LITERAL", "STRING", "STRING", ("LITERAL" + "LITERAL"))
        end;Fi[	@/i-I"≈      # initial state of the machine *before* any attributes are set on the
      # object
      def function
        define_helper("LITERAL", "STRING", "STRING", ("LITERAL" + "LITERAL"))
      end;Fi[	@ciI"          (defined? ::Sequel::MAJOR.! or ((::Sequel::MAJOR == "LITERAL") or ((::Sequel::MAJOR == "LITERAL") and (::Sequel::MINOR <= "LITERAL"))))
        end
        def function
          define_helper("LITERAL", "STRING", "STRING", ("LITERAL" + "LITERAL"))
        end;Fi[	@ciI"Ã          define_helper("LITERAL", "STRING", "STRING", ("LITERAL" + "LITERAL"))
        end
        def function
          define_helper("LITERAL", "STRING", "STRING", ("LITERAL" + "LITERAL"))
        end;Fi[	@JiII"≈      # initial state of the machine *before* any attributes are set on the
      # object
      def function
        define_helper("LITERAL", "STRING", "STRING", ("LITERAL" + "LITERAL"))
      end;Fi[	@Ji]I"¥      
      # Adds hooks into validation for automatically firing events
      def function
        define_helper("LITERAL", "STRING", "STRING", ("LITERAL" + "LITERAL"))
      end;Fi[	I"#  end;F@i[[	@>i#I"Ö    #    include ActiveModel::Model
    #    attr_accessor :id, :name
    #  end
    #
    #  person = Person.new(id: 1, name: 'bob');Fi[	@òi°I"q      #
      #    attr_accessor :name
      #  end
      #
      #  User.attribute_method?(:name) # => true;Fi[	@ÜibI"à      #    t.column :name, :string, limit: 60
      #    # Other fields here
      #  end
      #
      # === Block form, with shorthand;Fi[	@ÜiiI"v      #    t.string :name, limit: 60
      #    # Other fields here
      #  end
      #
      # === Regular form;Fi[	@Üi„I"®      #    t.column :name, :string, limit: 60
      #    # Other column alterations here
      #  end
      #
      # The +options+ hash can include the following keys:;Fi[	@ÜiÔI"ê      #  change_table(:suppliers) do |t|
      #    t.column :name, :string, limit: 60
      #  end
      #
      # ====== Add 2 integer columns;Fi[	@ÜiÙI"¨      #  change_table(:suppliers) do |t|
      #    t.integer :width, :height, null: false, default: 0
      #  end
      #
      # ====== Add created_at/updated_at columns;Fi[	@Üi˘I"}      #  change_table(:suppliers) do |t|
      #    t.timestamps
      #  end
      #
      # ====== Add a foreign key column;Fi[	@Üi˛I"î      #  change_table(:suppliers) do |t|
      #    t.references :company
      #  end
      #
      # Creates a <tt>company_id(integer)</tt> column;Fi[	@ÜiI"…      #  change_table(:suppliers) do |t|
      #    t.belongs_to :company, polymorphic: true
      #  end
      #
      # Creates <tt>company_type(varchar)</tt> and <tt>company_id(integer)</tt> columns;Fi[	@ÜiI"Ä      #  change_table(:suppliers) do |t|
      #    t.remove :company
      #  end
      #
      # ====== Remove several columns;Fi[	@ÜiI"|      #    t.remove :company_id
      #    t.remove :width, :height
      #  end
      #
      # ====== Remove an index;Fi[	@ÜiI"â      #  change_table(:suppliers) do |t|
      #    t.remove_index :company_id
      #  end
      #
      # See also Table for details on;Fi[	@icI"Á    #      transition all => :parked, :unless => :seatbelt_on?                  # Transitions to :parked if seatbelt is off
    #    end
    #  end
    # 
    # See StateMachine::Machine#transition for a description of the possible;Fi[	I"module ActiveModel;FI"module Validations;Fi[[	@fi I"Wmodule ActiveModel
  module Validations
    class AbsenceValidator < EachValidator;Fi [	@ii I"Zmodule ActiveModel
  module Validations
    class AcceptanceValidator < EachValidator;Fi [	@li I"Amodule ActiveModel
  module Validations
    module Callbacks;Fi [	I"Eprojects//activemodel_proj/active_model/validations/clusivity.rb;TiI"jrequire("active_support/core_ext/range")
module ActiveModel
  module Validations
    module Clusivity;Fi[	@i I"\module ActiveModel
  module Validations
    class ConfirmationValidator < EachValidator;Fi [	@qiI"Çrequire("active_model/validations/clusivity")
module ActiveModel
  module Validations
    class ExclusionValidator < EachValidator;Fi[	@ti I"Vmodule ActiveModel
  module Validations
    class FormatValidator < EachValidator;Fi [	@{iI"Çrequire("active_model/validations/clusivity")
module ActiveModel
  module Validations
    class InclusionValidator < EachValidator;Fi[	@~i I"Vmodule ActiveModel
  module Validations
    class LengthValidator < EachValidator;Fi [	@|i I"\module ActiveModel
  module Validations
    class NumericalityValidator < EachValidator;Fi [	@i I"Xmodule ActiveModel
  module Validations
    class PresenceValidator < EachValidator;Fi [	@ÇiI"rrequire("active_support/core_ext/hash/slice")
module ActiveModel
  module Validations
    module ClassMethods;Fi[	@ãi I"Emodule ActiveModel
  module Validations
    module HelperMethods;Fi [	@òiI"¶require("active_support/core_ext/hash/keys")
require("active_support/core_ext/hash/except")
module ActiveModel
  module Validations
    extend(ActiveSupport::Concern);Fi[	@e@£i[[	@qiaI"      #   @see https://dev.twitter.com/docs/api/1.1/get/direct_messages/show
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(var)
        var = Twitter::API::Arguments.new(var);Fi[	@qiyI"1      # @overload direct_message_destroy(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(var)
        threaded_object_from_response(Twitter::DirectMessage, "LITERAL", "STRING", var);Fi[	@~i=I"      # @overload unfavorite(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(var)
        threaded_object_from_response(Twitter::Tweet, "LITERAL", "STRING", var);Fi[	@~iUI"˙      # @overload favorite(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(var)
        var = Twitter::API::Arguments.new(var);Fi[	@~iwI"˙      # @overload favorite(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(var)
        var = Twitter::API::Arguments.new(var);Fi[	@ÖiQI"P      # @overload friendships(*users, options)
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      def function(var)
        var = Twitter::API::Arguments.new(var);Fi[	@Öi¥I"d      # @overload unfollow(*users, options)
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      def function(var)
        threaded_user_objects_from_response("LITERAL", "STRING", var);Fi[	@Ÿi$I"       #   @see https://dev.twitter.com/docs/api/1.1/get/saved_searches/show/:id
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(var)
        var = Twitter::API::Arguments.new(var);Fi[	@ŸiZI"      # @overload saved_search_destroy(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(var)
        var = Twitter::API::Arguments.new(var);Fi[	@ÂiI"g      # @overload report_spam(*users, options)
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      def function(var)
        threaded_user_objects_from_response("LITERAL", "STRING", var);Fi[	@ilI"      # @overload statuses_activity(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(var)
        var = Twitter::API::Arguments.new(var);Fi[	@i•I"»      #   Twitter.blocking_ids
      # @overload block(options={})
      #   @param options [Hash] A customizable set of options.
      def function(var)
        var = Twitter::API::Arguments.new(var);Fi[	@i÷I"a      # @overload block(*users, options)
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      def function(var)
        threaded_user_objects_from_response("LITERAL", "STRING", var);Fi[	@iÈI"c      # @overload unblock(*users, options)
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      def function(var)
        threaded_user_objects_from_response("LITERAL", "STRING", var);Fi[	@y@ei[[	@~i I"o      #   Returns the 20 most recent favorite Tweets for the specified user
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 100.;Fi[	@ÖiI"’      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@Öi8I"2      #   Returns an array of numeric IDs for every user following the specified user
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@ÖiI"’      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@Öi+I"’      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@´i!I"#      #     Twitter.lists
      # @overload lists(user, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @example Return all lists that @sferik subscribes to;Fi[	@´i|I"ƒ      #     Twitter.memberships
      # @overload memberships(user, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@´i’I"»      #     Twitter.subscriptions
      # @overload subscriptions(user, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@Îi/I"~      # @return [Array<Twitter::Tweet>]
      # @overload user_timeline(user, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;Fi[	@iAI"ƒ      #   Returns users following followers of the authenticated user
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #     @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@iI"      #   Returns extended information for a given user
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @example Return extended information for @sferik;Fi[	@iZI"t      #     Twitter.contributees
      # @overload contributees(user, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.;Fi[	@iqI"t      #     Twitter.contributors
      # @overload contributors(user, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.;Fi[	I"# @return [Integer];F@:i[[	I"0projects//twitter_proj/twitter/geo/point.rb;Ti	I"{  class Geo
    class Point < Twitter::Geo
      # @return [Integer]
      def function
        coordinates["LITERAL"];Fi[	@∞iI"w      alias "LITERAL" "LITERAL"
      
      # @return [Integer]
      def function
        coordinates["LITERAL"];Fi[	@[i&I"R    end
    
    # @return [Integer]
    def function
      @attrs["LITERAL"];Fi[	I",projects//twitter_proj/twitter/place.rb;TiI"[    end
    
    # @return [Integer]
    def function
      @var ||= @attrs["LITERAL"];Fi[	@riI"W    end
    
    # @return [Integer]
    def function
      var = @attrs["STRING"];Fi[	@riI"W    end
    
    # @return [Integer]
    def function
      var = @attrs["STRING"];Fi[	@ri"I"x    end
    
    # @return [Integer]
    def function
      [(reset_at - Time.now).ceil, "LITERAL"].max if reset_at;Fi[	I"5projects//twitter_proj/twitter/search_results.rb;TiI"q    end
    
    # @return [Integer]
    def function
      @attrs["LITERAL"]["LITERAL"] if search_metadata?;Fi[	@¿iI"q    end
    
    # @return [Integer]
    def function
      @attrs["LITERAL"]["LITERAL"] if search_metadata?;Fi[	@¿i%I"q    end
    
    # @return [Integer]
    def function
      @attrs["LITERAL"]["LITERAL"] if search_metadata?;Fi[	@¿i0I"q    end
    
    # @return [Integer]
    def function
      @attrs["LITERAL"]["LITERAL"] if search_metadata?;Fi[	I",projects//twitter_proj/twitter/tweet.rb;Ti"I"X    end
    
    # @return [Integer]
    def function
      var = @attrs["LITERAL"];Fi[	@…i]I"X    end
    
    # @return [Integer]
    def function
      var = @attrs["LITERAL"];Fi[	@Y@öi[[	@^i?I"[      
      def function(var, var, var)
        var = "LITERAL"
        var
      end;Fi[	@^iDI"[      
      def function(var, var, var)
        var = "LITERAL"
        var
      end;Fi[	@^iII"[      
      def function(var, var, var)
        var = "LITERAL"
        var
      end;Fi[	@^iNI"[      
      def function(var, var, var)
        var = "LITERAL"
        var
      end;Fi[	@^iSI"[      
      def function(var, var, var)
        var = "LITERAL"
        var
      end;Fi[	@^iXI"[      
      def function(var, var, var)
        var = "LITERAL"
        var
      end;Fi[	@^iQI"n      # reduce 62 omitted
      def function(var, var, var)
        var = "LITERAL"
        var
      end;Fi[	@^iVI"[      
      def function(var, var, var)
        var = "LITERAL"
        var
      end;Fi[	@^i[I"[      
      def function(var, var, var)
        var = "LITERAL"
        var
      end;Fi[	@^i`I"[      
      def function(var, var, var)
        var = "LITERAL"
        var
      end;Fi[	@^ieI"[      
      def function(var, var, var)
        var = "LITERAL"
        var
      end;Fi[	@^ijI"[      
      def function(var, var, var)
        var = "LITERAL"
        var
      end;Fi[	@^ioI"[      
      def function(var, var, var)
        var = "LITERAL"
        var
      end;Fi[	I"&Backup::Dependency.load("STRING");FI"module Backup;Fi[[	@≤i I"FBackup::Dependency.load("STRING")
module Backup
  module Notifier;Fi [	@ü
i I"FBackup::Dependency.load("STRING")
module Backup
  module Notifier;Fi [	@¢
i I"FBackup::Dependency.load("STRING")
module Backup
  module Notifier;Fi [	@πi I"FBackup::Dependency.load("STRING")
module Backup
  module Notifier;Fi [	@«i I"FBackup::Dependency.load("STRING")
module Backup
  module Notifier;Fi [	@oi I"EBackup::Dependency.load("STRING")
module Backup
  module Storage;Fi [	@¯	i I"EBackup::Dependency.load("STRING")
module Backup
  module Storage;Fi [	@ri I"EBackup::Dependency.load("STRING")
module Backup
  module Storage;Fi [	@ui I"EBackup::Dependency.load("STRING")
module Backup
  module Storage;Fi [	@zi I"EBackup::Dependency.load("STRING")
module Backup
  module Storage;Fi [	I"0projects//backup_proj/backup/storage/scp.rb;TiI"gBackup::Dependency.load("STRING")
Backup::Dependency.load("STRING")
module Backup
  module Storage;Fi[	I"1projects//backup_proj/backup/storage/sftp.rb;TiI"gBackup::Dependency.load("STRING")
Backup::Dependency.load("STRING")
module Backup
  module Storage;Fi[	@%iI"fBackup::Dependency.load("STRING")
Backup::Dependency.load("STRING")
module Backup
  module Syncer;Fi[	I"module Devise;FI"module Models;Fi[[	@∏iI"arequire("devise/hooks/activatable")
module Devise
  module Models
    module Authenticatable;Fi[	@0i I"9module Devise
  module Models
    module Confirmable;Fi [	@ªiI"àrequire("devise/strategies/database_authenticatable")
require("bcrypt")
module Devise
  module Models
    module DatabaseAuthenticatable;Fi[	@iI"Wrequire("devise/hooks/lockable")
module Devise
  module Models
    module Lockable;Fi[	I"8projects//devise_proj/devise/models/omniauthable.rb;TiI"Urequire("devise/omniauth")
module Devise
  module Models
    module Omniauthable;Fi[	@i I"9module Devise
  module Models
    module Recoverable;Fi [	I"8projects//devise_proj/devise/models/registerable.rb;Ti I":module Devise
  module Models
    module Registerable;Fi [	@NiI"}require("devise/hooks/rememberable")
require("devise/hooks/forgetable")
module Devise
  module Models
    module Rememberable;Fi[	I"7projects//devise_proj/devise/models/timeoutable.rb;TiI"]require("devise/hooks/timeoutable")
module Devise
  module Models
    module Timeoutable;Fi[	@iI"urequire("devise/strategies/token_authenticatable")
module Devise
  module Models
    module TokenAuthenticatable;Fi[	I"5projects//devise_proj/devise/models/trackable.rb;TiI"Yrequire("devise/hooks/trackable")
module Devise
  module Models
    module Trackable;Fi[	@´i I"9module Devise
  module Models
    module Validatable;Fi [	@°i I"Mmodule Devise
  module Models
    class MissingAttribute < StandardError;Fi [	I"require("twitter/base");F@i[[	I"4projects//twitter_proj/twitter/configuration.rb;Ti I"Qrequire("twitter/base")
module Twitter
  class Configuration < Twitter::Base;Fi [	I"-projects//twitter_proj/twitter/entity.rb;Ti I"Jrequire("twitter/base")
module Twitter
  class Entity < Twitter::Base;Fi [	I"*projects//twitter_proj/twitter/geo.rb;Ti I"Grequire("twitter/base")
module Twitter
  class Geo < Twitter::Base;Fi [	I"/projects//twitter_proj/twitter/language.rb;Ti I"Lrequire("twitter/base")
module Twitter
  class Language < Twitter::Base;Fi [	I"/projects//twitter_proj/twitter/metadata.rb;Ti I"Lrequire("twitter/base")
module Twitter
  class Metadata < Twitter::Base;Fi [	I"-projects//twitter_proj/twitter/oembed.rb;Ti I"Jrequire("twitter/base")
module Twitter
  class OEmbed < Twitter::Base;Fi [	I"5projects//twitter_proj/twitter/profile_banner.rb;Ti I"Qrequire("twitter/base")
module Twitter
  class ProfileBanner < Twitter::Base;Fi [	I"3projects//twitter_proj/twitter/relationship.rb;Ti I"Prequire("twitter/base")
module Twitter
  class Relationship < Twitter::Base;Fi [	@¿i I"Qrequire("twitter/base")
module Twitter
  class SearchResults < Twitter::Base;Fi [	I"/projects//twitter_proj/twitter/settings.rb;Ti I"Lrequire("twitter/base")
module Twitter
  class Settings < Twitter::Base;Fi [	I"+projects//twitter_proj/twitter/size.rb;Ti I"Hrequire("twitter/base")
module Twitter
  class Size < Twitter::Base;Fi [	I"1projects//twitter_proj/twitter/suggestion.rb;Ti I"Nrequire("twitter/base")
module Twitter
  class Suggestion < Twitter::Base;Fi [	I",projects//twitter_proj/twitter/trend.rb;Ti I"Irequire("twitter/base")
module Twitter
  class Trend < Twitter::Base;Fi [	I"#       event :ignite do;FI",#         transition :parked => :idling;Fi[[	@ÊiI"z    #       end
    #       
    #       event :ignite do
    #         transition :parked => :idling
    #       end;Fi[	@ÊiDI"z    #       end
    #       
    #       event :ignite do
    #         transition :parked => :idling
    #       end;Fi[	@ÊidI"≤    #   class Vehicle < ActiveRecord::Base
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end;Fi[	@ÌiBI"ù    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end;Fi[	@ÌitI"ù    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end;Fi[	@ıiI"¶        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end;Fi[	@ıiYI"¶        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end;Fi[	@ıi}I"¶        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end;Fi[	@inI"•    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end;Fi[	@iüI"•    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end;Fi[	@iéI"í    #     
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end;Fi[	@3iÂI"â    #   class Vehicle
    #     state_machine do
    #       event :ignite do
    #         transition :parked => :idling
    #       end;Fi[	@3i˛I"ù    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end;Fi[	@I"#     attr_accessor :name;Fi[[	@ i&I"ù      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_prefix 'clear_';Fi[	@ iJI"û      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?';Fi[	@ inI"º      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_affix prefix: 'reset_', suffix: '_to_default!';Fi[	@ iÑI"û      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?';Fi[	@ i∆I"û      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?';Fi[	@ iÌI"û      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?';Fi[	@liI"û        #     include ActiveModel::Validations
        #     include ActiveModel::Validations::Callbacks
        #
        #     attr_accessor :name
        #;Fi[	@Çi}I"ò      #   class Person
      #     include ActiveModel::Validations
      #
      #     attr_accessor :name
      #     validates! :name, presence: true;Fi[	@òiºI"â    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name;Fi[	@òiÕI"â    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name;Fi[	@òi›I"ì    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name, on: :new;Fi[	@òiÙI"â    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name;Fi[	@òiI"ì    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name, on: :new;Fi[	I"# :nodoc:;F@:i[[	@ÇiêI"      # When creating custom validators, it might be useful to be able to specify
      # additional default keys. This can be done by overwriting this method.
      # :nodoc:
      def function
        ["LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL"];Fi[	@¸i*I"f      end
      
      # :nodoc:
      def function
        super if attribute_methods_generated?;Fi[	@iI"ó    #
    # See also http://tenderlovemaking.com/2011/06/28/til-its-ok-to-return-nil-from-to_ary.html
    # :nodoc:
    def function
      # do nothing;Fi[	@‘	iI"∑    # currently collected. A false value indicates collecting is turned
    # off. Otherwise it is an array of queries.
    # :nodoc:
    def function
      return yield unless logger;Fi[	@‘	i,I"ø    # Relation#explain needs to be able to collect the queries regardless of
    # whether auto explain is enabled. This method serves that purpose.
    # :nodoc:
    def function
      begin;Fi[	@&i¬I"l      end
      
      # :nodoc:
      def function
        @var ||= decorate_columns(columns_hash.dup);Fi[	@äi3I"Û      NORMAL_VALUES = ((Relation::SINGLE_VALUE_METHODS + Relation::MULTI_VALUE_METHODS) - ["LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL"])
      
      # :nodoc:
      def function
        NORMAL_VALUES;Fi[	@JiAI"Q    end
    
    # :nodoc:
    def function
      (@values["LITERAL"] or {});Fi[	@TieI"x        end
        
        # :nodoc:
        def function
          if Base.is_a?(method("LITERAL").owner).! then;Fi[	@Ti~I"Õ        # situation where a default scope references a scope which has a default
        # scope which references a scope...
        # :nodoc:
        def function
          return if ignore_default_scope?;Fi[	@[i&I"⁄        # Collects attributes from scopes that should be applied when creating
        # an AR instance for the particular class this is called on.
        # :nodoc:
        def function
          if current_scope then;Fi[	@+iI"S        end
        
        # :nodoc:
        def function
          "STRING";Fi[	@«i	I"~    module PP
      module Node
        # :nodoc:
        def function
          var = inspect_attributes.reject do |var|;Fi[	@V@i[[	@Êi I"x    #       
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end;Fi[	@ÊiEI"x    #       
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end;Fi[	@ÊieI"ï    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end;Fi[	@ÌiCI"î    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       ;Fi[	@ÌiuI"î    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       ;Fi[	@ıiI"©        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end;Fi[	@ıiZI"©        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end;Fi[	@ıi~I"©        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end;Fi[	@ioI"ú    #     state_machine :state, :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       ;Fi[	@i†I"ú    #     state_machine :state, :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       ;Fi[	@ièI"ï    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end;Fi[	@3iÊI"Å    #     state_machine do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end;Fi[	@3iˇI"ï    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end;Fi[	I"@var = {};F@…i[[	@i.I"e      def function(var)
        @var = []
        @var = {}
        @var = {}
        @var = var;Fi[	@øiI"e      def function(var)
        @var = var
        @var = {}
        @var = {}
        @var = {};Fi[	@øiI"_        @var = var
        @var = {}
        @var = {}
        @var = {}
        @var = {};Fi[	@øiI"i        @var = {}
        @var = {}
        @var = {}
        @var = {}
        prepare_default_proc;Fi[	@iØI"J        end
      end
      @var = {}
      @var = {}
      @var = {};Fi[	@i∞I"P      end
      @var = {}
      @var = {}
      @var = {}
      @var = true;Fi[	@iI"å      var = self.class.primary_key
      @attributes[var] = nil unless @attributes.key?(var)
      @var = {}
      @var = {}
      @var = {};Fi[	@iI"~      @attributes[var] = nil unless @attributes.key?(var)
      @var = {}
      @var = {}
      @var = {}
      @var = {};Fi[	@iI"T      @var = {}
      @var = {}
      @var = {}
      @var = {}
      @var = {};Fi[	@iI"W      @var = {}
      @var = {}
      @var = {}
      @var = {}
      @var = false;Fi[	@i2I"Y      @var = true
      @var = []
      @var = {}
      @var = {}
      @var = false;Fi[	@i¥I"Z      else
        queue_all_for_delete
        @var = {}
        @var = {}
      end;Fi[	@@£i[[	@ i∏I"á      #       ...
      #     end
      #   end
      def function(var)
        var.flatten.each { |var| define_attribute_method(var) };Fi[	@-i,I"ü    #       # obj is the MyModel instance that the callback is being called on
    #     end
    #   end
    def function(var)
      var = var.extract_options!;Fi[	@9iI"y    #       @errors = ActiveModel::Errors.new(self)
    #     end
    #   end
    def function(var)
      @var = var;Fi[	@|i}I"      #     validates_numericality_of :width, less_than: ->(person) { person.height }
      #     validates_numericality_of :width, greater_than: :minimum_weight
      #   end
      def function(var)
        validates_with(NumericalityValidator, _merge_attributes(var));Fi[	@ØieI"º      #   Author.first.books.transaction do
      #     # same effect as calling Book.transaction
      #   end
      def function(var)
        reflection.klass.transaction(*var) { yield };Fi[	@&i©I"¬      #   class Project < ActiveRecord::Base
      #     self.sequence_name = "projectseq"   # default would have been "project_seq"
      #   end
      def function(var)
        @var = var.to_s;Fi[	@Ci8I"⁄    #   Person.all.find_in_batches(start: 2000, batch_size: 2000) do |group|
    #     group.each { |person| person.party_all_night! }
    #   end
    def function(var)
      var.assert_valid_keys("LITERAL", "LITERAL");Fi[	@‹	i"I"§    #     person.visits += 1
    #     person.save!
    #   end
    def function(var)
      block_given? ? (to_a.find { |var| yield(*var) }) : (find_with_ids(*var));Fi[	@Ti\I"¨        #       # Should return a scope, you can call 'super' here etc.
        #     end
        #   end
        def function(var)
          var = Proc.new if block_given?;Fi[	@€i4I"¢      #     include OmniAuth::Strategy
      #     configure foo: 'bar'
      #   end
      def function(var)
        yield(default_options) and return unless var;Fi[	@CiI"ü      #   describe User do
      #     it { should have_attached_file(:avatar) }
      #   end
      def function(var)
        HaveAttachedFileMatcher.new(var);Fi[	@JiI"Ÿ      #                   allowing('image/png', 'image/gif').
      #                   rejecting('text/plain', 'text/xml') }
      #   end
      def function(var)
        ValidateAttachmentContentTypeMatcher.new(var);Fi[	@I" #   person.pets.size # => 3;Ti[[	@≤i;I"ê      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets;Ti[	@≤i\I"}      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets;Ti[	@≤iuI"Ä      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets;Ti[	@≤iíI"m      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets;Ti[	@≤i≤I"ê      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets;Ti[	@≤iŒI"}      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets;Ti[	@≤iÍI"Ä      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets;Ti[	@≤iI"m      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets;Ti[	@≤i"I"m      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets;Ti[	@≤iBI"Œ      # You can pass +Fixnum+ or +String+ values, it finds the records
      # responding to the +id+ and then deletes them from the database.
      #
      #   person.pets.size # => 3
      #   person.pets;Ti[	@≤iêI"Ø      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   # executes something like SELECT COUNT(*) FROM "pets" WHERE "pets"."person_id" = 1;Ti[	@≤iöI"∆      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size # => 3
      #   # Because the collection is already loaded, this will behave like;Ti[	I"I#   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.;F@ei[[	@qi`I"ˆ      #
      #   @see https://dev.twitter.com/docs/api/1.1/get/direct_messages/show
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(var);Fi[	@qixI"      #     Twitter.direct_message_destroy(1825785544)
      # @overload direct_message_destroy(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(var);Fi[	@~i<I"˘      #     Twitter.unfavorite(25938088801)
      # @overload unfavorite(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(var);Fi[	@~iTI"ı      #     Twitter.favorite(25938088801)
      # @overload favorite(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(var);Fi[	@~ivI"ı      #     Twitter.favorite(25938088801)
      # @overload favorite(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(var);Fi[	@Ÿi#I"˘      #
      #   @see https://dev.twitter.com/docs/api/1.1/get/saved_searches/show/:id
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(var);Fi[	@ŸiYI"
      #     Twitter.saved_search_destroy(16129012)
      # @overload saved_search_destroy(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(var);Fi[	@iQI"ö      #     Twitter.statuses(25938088801)
      # @overload statuses(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@ieI"¶      #     Twitter.status_destroy(25938088801)
      # @overload status_destroy(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@iãI"ò      #     Twitter.retweet(28561922516)
      # @overload retweet(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@i¶I"ö      #     Twitter.retweet!(28561922516)
      # @overload retweet!(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@ikI"      #     Twitter.statuses_activity(25938088801)
      # @overload statuses_activity(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(var);Fi[	@;@;i[[	@>iêI"|  
  def function
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
  end;Fi[	@>i˝I"¶  # end
  def function
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING");Fi[	@>i˛I"Œ  def function
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING");Fi[	@>iˇI"Ô    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING");Fi[	@>i I"Ô    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING");Fi[	@>iI"Ô    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING");Fi[	@>iI"Ô    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING");Fi[	@>iI"Ô    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING");Fi[	@>iI"Ô    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING");Fi[	@>iI"Ô    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING");Fi[	@>iI"Ô    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING");Fi[	@>iI"≈    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
  end;Fi[	@:I"execute("STRING");Fi[[	@Ui"I"L      end
      
      def function
        execute("STRING")
      end;Fi[	@Ui&I"L      end
      
      def function
        execute("STRING")
      end;Fi[	@Ui*I"L      end
      
      def function
        execute("STRING")
      end;Fi[	@Ç
iöI"j        
        # Begins a transaction.
        def function
          execute("STRING")
        end;Fi[	@Ç
i§I"k        
        # Commits a transaction.
        def function
          execute("STRING")
        end;Fi[	@Ç
i©I"j        
        # Aborts a transaction.
        def function
          execute("STRING")
        end;Fi[	@Ç
i≥I"V        end
        
        def function
          execute("STRING")
        end;Fi[	@Ç
i∑I"V        end
        
        def function
          execute("STRING")
        end;Fi[	@Ç
iªI"V        end
        
        def function
          execute("STRING")
        end;Fi[	@Xi,I"L      end
      
      def function
        execute("STRING")
      end;Fi[	@Xi0I"L      end
      
      def function
        execute("STRING")
      end;Fi[	@Xi4I"L      end
      
      def function
        execute("STRING")
      end;Fi[	I"ï#   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.;F@ei[[	@ÖiPI"g      #     Twitter.friendships(7505382, 14100886)    # Same as above
      # @overload friendships(*users, options)
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      def function(var);Fi[	@Öi}I"á      #     Twitter.follow('sferik')
      # @overload follow(*users, options)
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean] :follow (false) Enable notifications for the target user.;Fi[	@ÖiñI"â      #     Twitter.follow!('sferik')
      # @overload follow!(*users, options)
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean] :follow (false) Enable notifications for the target user.;Fi[	@Öi≥I"E      #     Twitter.unfollow('sferik')
      # @overload unfollow(*users, options)
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      def function(var);Fi[	@´i˜I"—      # @overload list_add_members(list, users, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      #   @example Add @BarackObama and @pengwynn to the authenticated user's "presidents" list;Fi[	@´iI"Ë      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      #   @example Add @BarackObama and @pengwynn to @sferik's "presidents" list;Fi[	@´iËI"Ÿ      # @overload list_remove_members(list, users, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      #   @example Remove @BarackObama and @pengwynn from the authenticated user's "presidents" list;Fi[	@´iÚI"Ì      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      #   @example Remove @BarackObama and @pengwynn from @sferik's "presidents" list;Fi[	@ÂiI"[      #     Twitter.report_spam(14589771) # Same as above
      # @overload report_spam(*users, options)
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      def function(var);Fi[	@i’I"O      #     Twitter.block(7505382)  # Same as above
      # @overload block(*users, options)
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      def function(var);Fi[	@iËI"S      #     Twitter.unblock(7505382)  # Same as above
      # @overload unblock(*users, options)
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      def function(var);Fi[	@i˚I"·      #     Twitter.users(7505382, 14100886)     # Same as above using twitter_ids
      # @overload users(*users, options)
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Symbol, String] :method Requests users via a GET request instead of the standard POST request if set to ':get'.;Fi[	@eI"Õ#   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[[	@Öi I"≠      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return @sferik's friends' IDs;Fi[	@Öi1I"∂      #   Returns an array of numeric IDs for every user following the authenticated user
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the authenticated user's followers' IDs;Fi[	@ÖiI"˛      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.;Fi[	@Öi,I"˛      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.;Fi[	@´ivI"<      # @return [Twitter::Cursor]
      # @overload memberships(options={})
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :filter_to_owned_lists When set to true, t or 1, will return just lists the authenticating user owns, and the user represented by user_id or screen_name is a member of.;Fi[	@´i}I"Ç      # @overload memberships(user, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :filter_to_owned_lists When set to true, t or 1, will return just lists the authenticating user owns, and the user represented by user_id or screen_name is a member of.;Fi[	@´iãI"˙      # @overload list_subscribers(list, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the subscribers of the authenticated user's "presidents" list;Fi[	@´iìI"      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the subscribers of @sferik's "presidents" list;Fi[	@´i2I"Ú      # @overload list_members(list, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the members of the authenticated user's "presidents" list;Fi[	@´i:I"      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the members of @sferik's "presidents" list;Fi[	@´i–I"°      # @return [Twitter::Cursor]
      # @overload subscriptions(options={})
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example List the lists the authenticated user follows;Fi[	@´i÷I"›      # @overload subscriptions(user, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example List the lists that @sferik follows;Fi[	@£@<i[[	@ki8I"Å    end
    
    def function(var)
      var = "STRING"
      model.class_attribute(var.to_sym) unless model.method_defined?(var);Fi[	@Øi±I"q      end
      
      def function(var)
        var = "STRING"
        (owner.class.send(var.to_sym) or []);Fi[	@PiˆI"q      end
      
      def function(var)
        var = "STRING"
        ActiveSupport::Deprecation.warn(var);Fi[	@UióI"º      
      # Returns an array of +Column+ objects for the table specified by +table_name+.
      def function(var)
        var = "STRING"
        execute_and_free(var, "STRING") do |var|;Fi[	@
irI"|    end
    
    def function(var)
      var = "STRING"
      var = Compass::Frameworks::ALL.inject("LITERAL") do |var, var|;Fi[	@¶i\I"x    end
    
    def function(var)
      var = "STRING"
      ((var << position.to_s(var)) << "STRING") if position;Fi[	@¶iàI"Ö    end
    
    def function(var)
      var = "STRING"
      ((var << position_or_angle.to_s(var)) << "STRING") if position_or_angle;Fi[	@¶i‘I"D    end
    
    def function(var)
      var = "STRING"
    end;Fi[	I"Uprojects//compass_proj/compass/sass_extensions/monkey_patches/browser_support.rb;Ti(I"D    end
    
    def function(var)
      var = "STRING"
    end;Fi[	@Ôi¸I"∑    # @param text [String] The string to sanitize
    # @return [String] The sanitized string
    def function(var)
      var = "STRING"
      var = if (RUBY_VERSION >= "STRING") then;Fi[	@ÔiI"∑    # @param text [String] The string to sanitize
    # @return [String] The sanitized string
    def function(var)
      var = "STRING"
      var = if (RUBY_VERSION >= "STRING") then;Fi[	@@itI"o    #
    # Returns the formatted String.
    def function(var)
      var = "STRING"
      case var.length;Fi[	I"(var << "STRING");F@∫ i[[	I"5projects//diaspora_proj/helpers/mobile_helper.rb;Ti(I"Z    else
      var = "STRING"
      (var << "STRING")
      (var << "STRING")
    end;Fi[	@i@I"¶        f.plist_startup ? ((var << "STRING")) : ((var << "STRING"))
        if f.plist_manual then
          (var << "STRING")
          (var << "STRING")
        end;Fi[	@iGI"ó          (var << "STRING")
          if f.plist_startup then
            (var << "STRING")
            (var << "STRING")
            (var << "STRING");Fi[	@iHI"ä          if f.plist_startup then
            (var << "STRING")
            (var << "STRING")
            (var << "STRING")
          else;Fi[	@iKI"{            (var << "STRING")
          else
            (var << "STRING")
            (var << "STRING")
          end;Fi[	@ÊiII"ß    (var << "STRING") if ARGV.include?("STRING")
    (var << "STRING") unless ARGV.verbose?
    (var << "STRING")
    (var << "STRING")
    safe_system("STRING", *var);Fi[	@·iDI"√        (var << `#{locate("STRING")}STRING#{var}STRING`.chomp)
      end
      (var << "STRING")
      (var << "STRING")
      var.map { |var| Pathname.new(var) }.detect { |var| var.directory? });Fi[	@^iI"Ø      def function(var, var, var)
        if (var["LITERAL"] == "STRING") then
          (var << "STRING")
          (var << "STRING")
          var = Node.new("LITERAL", var);Fi[	@ˆ
i∂I"s      var = Resque.info
      var = []
      (var << "STRING")
      (var << "STRING")
      (var << "STRING");Fi[	@ˆ
i∑I"s      var = []
      (var << "STRING")
      (var << "STRING")
      (var << "STRING")
      (var << "STRING");Fi[	@ˆ
i∏I"|      (var << "STRING")
      (var << "STRING")
      (var << "STRING")
      (var << "STRING")
      (var << "STRING");Fi[	@ˆ
iπI"î      (var << "STRING")
      (var << "STRING")
      (var << "STRING")
      (var << "STRING")
      Resque.queues.each { |var| (var << "STRING") };Fi[	@|I"raise("STRING");Fi[[	@CiJI"Å        if var then
          var = var.where(table[primary_key].gt(var)).to_a
        else
          raise("STRING")
        end;Fi[	@ƒi/I"¬                  if var.is_a?(Symbol) then
                    Compass::AppIntegration.lookup(var).configuration
                  else
                    raise("STRING")
                  end;Fi[	@Ni6I"ê          if respond_to?("LITERAL") and var = authenticatable_salt then
            var
          else
            raise("STRING")
          end;Fi[	I"5projects//diaspora_proj/helpers/stream_helper.rb;TiI"∂          if controller.instance_of?(StreamsController) then
            stream_path("LITERAL" => (time_for_scroll(@stream)))
          else
            raise("STRING")
          end;Fi[	@Òi$I"Z    when Photo then
      (self.photos << var)
    else
      raise("STRING")
    end;Fi[	@ˇiI"{          when ::Haml::Error then
            raise("STRING")
          else
            raise("STRING")
          end;Fi[	@ÑirI"{        ohai("STRING")
        var.children.each { |var| puts("STRING") }
      else
        raise("STRING")
      end;Fi[	@Èi,I"d    when "LITERAL" then
      SubversionDownloadStrategy
    else
      raise("STRING")
    end;Fi[	@ﬁi"I"}    when "LITERAL", "LITERAL", "LITERAL", "LITERAL" then
      (var << "LITERAL")
    else
      raise("STRING")
    end;Fi[	I"1projects//homebrew_proj/test/test_updater.rb;TiI"\      (@called << var)
      @outputs[var].shift
    else
      raise("STRING")
    end;Fi[	@Z
i!I"[      if var = var.first then
        var
      else
        raise("STRING")
      end;Fi[	@ØI"class Preloader;Fi[[	@[iI"Zmodule ActiveRecord
  module Associations
    class Preloader
      class Association;Fi[	@€iI"nmodule ActiveRecord
  module Associations
    class Preloader
      class BelongsTo < SingularAssociation;Fi[	@ﬁiI"rmodule ActiveRecord
  module Associations
    class Preloader
      class CollectionAssociation < Association;Fi[	@DiI"zmodule ActiveRecord
  module Associations
    class Preloader
      class HasAndBelongsToMany < CollectionAssociation;Fi[	@„iI"nmodule ActiveRecord
  module Associations
    class Preloader
      class HasMany < CollectionAssociation;Fi[	@ÊiI"umodule ActiveRecord
  module Associations
    class Preloader
      class HasManyThrough < CollectionAssociation;Fi[	@ÈiI"kmodule ActiveRecord
  module Associations
    class Preloader
      class HasOne < SingularAssociation;Fi[	@ÏiI"rmodule ActiveRecord
  module Associations
    class Preloader
      class HasOneThrough < SingularAssociation;Fi[	@ÔiI"pmodule ActiveRecord
  module Associations
    class Preloader
      class SingularAssociation < Association;Fi[	@ÚiI"bmodule ActiveRecord
  module Associations
    class Preloader
      module ThroughAssociation;Fi[	@v
iI"hmodule ActiveRecord
  module Associations
    class Preloader
      extend(ActiveSupport::Autoload);Fi[	@@^i[[	@≤i(I"\      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [;Ti[	@≤iaI"\      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [;Ti[	@≤iI"\      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [;Ti[	@≤iòI"\      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [;Ti[	@≤iI"ê      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [#<Pet id: 1, name: "Gorby", group: "cats", person_id: 1>];Ti[	@≤i"I"ü      #
      #   person.pets.replace(other_pets)
      #
      #   person.pets
      #   # => [#<Pet id: 2, name: "Puff", group: "celebrities", person_id: 1>];Ti[	@≤i‡I"µ      # is the same, it returns true if the collection based on the
      # criteria is not empty.
      #
      #   person.pets
      #   # => [#<Pet name: "Snoop", group: "dogs">];Ti[	@≤iI"¶      # behavior is the same, it returns true if the collection
      # based on the criteria has more than one record.
      #
      #   person.pets
      #   # => [;Ti[	@≤iBI"\      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [;Ti[	@≤i\I"\      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [;Ti[	@≤ioI"ú      #   other_pets
      #   # => [#<Pet id: nil, name: "BooGoo", person_id: 1>]
      #
      #   person.pets
      #   # This is not affected by replace;Ti[	@£@Ùi[[	@XiXI"]      protected
      
      def function(var)
        var = []
        var = var.parent;Fi[	@bi?I"S    end
    
    def function(var)
      var = []
      var.each do |var, var|;Fi[	@—i¨I"ç      
      # Removes empty hashes and moves everything into arrays.
      def function(var)
        var = []
        var.each do |var, var|;Fi[	@äiI"Î  FONT_TYPES = { "LITERAL" => "STRING", "LITERAL" => "STRING", "LITERAL" => "STRING", "LITERAL" => "STRING", "LITERAL" => "STRING", "LITERAL" => "STRING", "LITERAL" => "STRING" }
  
  def function(var)
    var = []
    var = var.length;Fi[	@¶iûI"Ø    
    # Output the original webkit gradient syntax
    def function(var)
      var = []
      (var << grad_point((position_or_angle or Sass::Script::String.new("STRING"))));Fi[	I"(projects//homebrew_proj/cmd/list.rb;TiKI";  end
  
  def function(var)
    var = []
    var = [];Fi[	@J
iI"b  OLD_BOTTLE_EXTNAME_RX = "LITERAL"
  
  def function(var)
    var = []
    var.each do |var|;Fi[	@J
i;I"n  
  # Creates symlinks to sources in this folder.
  def function(var)
    var = []
    var.each do |var|;Fi[	@˝inI"≥    # Scans s and returns a list of json tokens,
    # excluding white space (as defined in RFC 4627).
    def function(var)
      var = []
      while (var.length > "LITERAL") do;Fi[	@ÙiBI"É      
      # Find a node by type using +types+
      def function(var)
        var = []
        (var << self) if (to_type == var);Fi[	@]i"I"º    # Returns an Array of string pids of all the other workers on this
    # machine. Useful when pruning dead workers on startup.
    def function(var)
      var = []
      var = `#{var}`;Fi[	@|I"nil;Fi[[	@UiI"∑            var = $1.split("STRING").map { |var| var.delete("STRING") }
            (var.length == "LITERAL") ? ([var.first, nil]) : (nil)
          else
            nil
          end;Fi[	@¶iªI"è        if var.value.is_a?(Array) and var.value.all? { |var| color_stop?(var) } then
          var.value
        else
          nil
        end;Fi[	I"Iprojects//diaspora_proj/controllers/aspect_memberships_controller.rb;TiI"~    var = if @contact then
      @contact.aspect_memberships.where("LITERAL" => (@aspect_id)).first
    else
      nil
    end;Fi[	@”i#I"`          var.email_the_user(var, var)
          var
        else
          nil
        end;Fi[	@“i|I"â      if var["LITERAL"].present? and var = User.find_by_username(var["LITERAL"]) then
        var.person
      else
        nil
      end;Fi[	@igI"ä      (var = if var.instance_variable_defined?("STRING") then
        var.instance_variable_get("STRING")
      else
        nil
      end;Fi[	@ÊidI"Y    when /^#{HOMEBREW_LIBRARY}STRING/ then
      "STRING"
    else
      nil
    end;Fi[	@
iÁI"é      if var and (var < (self.site.posts.length - "LITERAL")) then
        self.site.posts[(var + "LITERAL")]
      else
        nil
      end;Fi[	@ÍiéI"x      when String then
        var.scan("LITERAL").first("LITERAL").join("STRING")
      else
        nil
      end;Fi[	@]i.I"H        var.to_s = var
        var
      else
        nil
      end;Fi[	I"Eprojects//state_machine_proj/state_machine/yard/handlers/base.rb;TiI"v          when "LITERAL" then
            var.jump("LITERAL").source
          else
            nil
          end;Fi[	@4@îi[[	@
i6I"Ñ            else
              if var then
                case var
                when "STRING" then
                  var = false;Fi[	@
i@I"                end
              else
                case var
                when "STRING" then
                  var = true;Fi[	@ìiI"ô        def function(var)
          return var unless String.===(var)
          case var
          when "STRING" then
            ("LITERAL" / "LITERAL");Fi[	@ìiäI"g        
        def function(var)
          case var
          when "STRING" then
            var;Fi[	@∏i2I"b    
    def function(var, var, var)
      case var
      when "STRING" then
        var.to_i;Fi[	@ÀiCI"à    def function(var)
      var = var.value.split("LITERAL").map do |var|
        case var
        when "STRING" then
          "STRING";Fi[	@3
iHI"±      var = false if @options["LITERAL"]
      var = ((var == "STRING") or (var.!=("STRING") and @options["LITERAL"]))
      case var
      when "STRING" then
        var = true;Fi[	@3
i”I"µ      var = {}
      var.scan("LITERAL") do |var, var|
        case var
        when "STRING" then
          var["STRING"] ? (var["STRING"] += "STRING") : (var["STRING"] = "STRING");Fi[	@›
iI"Ω  
  PRUNEABLE_DIRECTORIES = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"].map do |var|
    case var
    when "STRING" then
      (HOMEBREW_LIBRARY / var);Fi[	@˝i I"õ      raise(Error, "STRING") if (var.length < "LITERAL")
      var, var, var = var["LITERAL"]
      case var
      when "STRING" then
        objparse(var);Fi[	@˝i/I"õ      raise(Error, "STRING") if (var.length < "LITERAL")
      var, var, var = var["LITERAL"]
      case var
      when "STRING" then
        objparse(var);Fi[	@|I"(flash["LITERAL"] = I18n.t("STRING");Fi[[	I"Dprojects//diaspora_proj/controllers/conversations_controller.rb;Ti$I"◊      Postzord::Dispatcher.build(current_user, @conversation).post
      flash["LITERAL"] = I18n.t("STRING")
    else
      flash["LITERAL"] = I18n.t("STRING")
      flash["LITERAL"] = I18n.t("STRING") if var.blank?;Fi[	I"?projects//diaspora_proj/controllers/messages_controller.rb;TiI"ï      Rails.logger.info("STRING")
      Postzord::Dispatcher.build(current_user, var).post
    else
      flash["LITERAL"] = I18n.t("STRING")
    end;Fi[	I"=projects//diaspora_proj/controllers/people_controller.rb;TiçI"°      @var = @contact.aspects
      @var = @aspects_with_person.map(&"LITERAL")
    else
      flash["LITERAL"] = I18n.t("STRING")
      redirect_to(people_path);Fi[	@“i"I"l        end
      end
    else
      flash["LITERAL"] = I18n.t("STRING")
      redirect_to(people_path);Fi[	@µi,I"ú    if current_user.update_profile(@profile_attrs) then
      flash["LITERAL"] = I18n.t("STRING")
    else
      flash["LITERAL"] = I18n.t("STRING")
    end;Fi[	I"?projects//diaspora_proj/controllers/services_controller.rb;Ti$I"ƒ      end
      flash["LITERAL"] = I18n.t("STRING")
    else
      flash["LITERAL"] = I18n.t("STRING")
      if var = Service.where("LITERAL" => (var.type.to_s), "LITERAL" => (var.uid)).first then;Fi[	I"<projects//diaspora_proj/controllers/users_controller.rb;Ti(I"ì            var = true
            flash["LITERAL"] = I18n.t("STRING")
          else
            flash["LITERAL"] = I18n.t("STRING")
          end;Fi[	@Å!i/I"µ            if @user.update_attributes(var) then
              flash["LITERAL"] = I18n.t("STRING")
            else
              flash["LITERAL"] = I18n.t("STRING")
            end;Fi[	@Å!i7I"π                I18n.locale = @user.language
                flash["LITERAL"] = I18n.t("STRING")
              else
                flash["LITERAL"] = I18n.t("STRING")
              end;Fi[	@Å!i@I"Î                  (@user.mail_confirm_email == @user.email)
                  flash["LITERAL"] = I18n.t("STRING") if @user.unconfirmed_email
                else
                  flash["LITERAL"] = I18n.t("STRING")
                end;Fi[	@Å!iGI"”                  if @user.update_attributes(var) then
                    flash["LITERAL"] = I18n.t("STRING")
                  else
                    flash["LITERAL"] = I18n.t("STRING")
                  end;Fi[	@@i[[	@Çi]I"≈      #   <tt>:strict</tt> option can also be set to any other exception.
      #
      # Example:
      #
      #   validates :password, presence: true, confirmation: true, if: :password_required?;Fi[	@iΩI"U    # method.
    #
    # Example:
    #
    #   class Post < ActiveRecord::Base;Fi[	@8i0I"∑      # <tt>:belongs_to</tt>) as the first parameter.
      #
      # Example:
      #
      #   Account.reflect_on_all_associations             # returns an array of all associations;Fi[	I"6projects//compass_proj/compass/browser_support.rb;TiI"…    # No browsers implement this yet.
    # Adds support for one or more aspects for the given simple function
    # Example:
    #
    #   Compass::BrowserSupport.add_support("image", "moz", "webkit");Fi[	@î!i&I"®    
    # Removes support for one or more aspects for the given simple function
    # Example:
    #
    #   Compass::BrowserSupport.remove_support("image", "o", "ms");Fi[	@≥i{I"ß      # the given scope. Useful for giving redirect backs after sign up:
      #
      # Example:
      #
      #   redirect_to stored_location_for(:user) || root_path;Fi[	@∏iîI"Â        # Overwrite to add customized conditions, create a join, or maybe use a
        # namedscope to filter records while authenticating.
        # Example:
        #
        #   def self.find_for_authentication(conditions={});Fi[	@0iuI"ƒ      # Confirm_within is a model configuration, must always be an integer value.
      #
      # Example:
      #
      #   # allow_unconfirmed_access_for = 1.day and confirmation_sent_at = today;Fi[	@ªiBI"ô      # attributes you would not like to be updated without a password.
      #
      # Example:
      #
      #   def update_without_password(params={});Fi[	@i&I"∆      # reset_password_within is a model configuration, must always be an integer value.
      #
      # Example:
      #
      #   # reset_password_within = 1.day and reset_password_sent_at = today;Fi[	@`iPI"z  # Returns the number of jobs destroyed.
  #
  # Example:
  #
  #   # Removes all jobs of class `UpdateNetworkGraph`;Fi[	@@i[[	@iI"†      # * +counters+ - One or more counter names to reset
      #
      # ==== Examples
      #
      #   # For Post with id #1 records reset the comments_count;Fi[	@i7I"ø      #   to update as keys and the amount to update the field by as values.
      #
      # ==== Examples
      #
      #   # For the Post with id of 5, decrement the comment_count by 1, and;Fi[	@i]I"≈      # * +id+ - The id of the object that should be incremented or an Array of ids.
      #
      # ==== Examples
      #
      #   # Increment the post_count column for the record with an id of 5;Fi[	@ioI"≈      # * +id+ - The id of the object that should be decremented or an Array of ids.
      #
      # ==== Examples
      #
      #   # Decrement the post_count column for the record with an id of 5;Fi[	@&iI"ô      # the parent's table name. Enclosing modules are not considered.
      #
      # ==== Examples
      #
      #   class Invoice < ActiveRecord::Base;Fi[	@QiÍI"¥    # * +updates+ - A string, array, or hash representing the SET part of an SQL statement.
    #
    # ==== Examples
    #
    #   # Update all customers with the given attributes;Ti[	@QiI"é    # * +attributes+ - This should be a hash of attributes or an array of hashes.
    #
    # ==== Examples
    #
    #   # Updates one record;Ti[	@Qi2I"v    #   more information.
    #
    # ==== Examples
    #
    #   Person.destroy_all("last_login < '2004-04-04'");Ti[	@QiJI"Ç    # * +id+ - Can be either an Integer or an Array of Integers.
    #
    # ==== Examples
    #
    #   # Destroy a single object;Ti[	@QiáI"X    # essential jobs.
    #
    # ==== Examples
    #
    #   # Delete a single row;Ti[	@æiI"Ü    # defined in your model.
    #
    # ==== Examples
    #
    # Let's say you have an User model configured to use authenticatable,;Fi[	I"var.add("LITERAL");F@Ω!i[[	I"+projects//diaspora_proj/models/like.rb;TiI"q  
  api_accessible("LITERAL") do |var|
    var.add("LITERAL")
    var.add("LITERAL")
    var.add("LITERAL");Fi[	@¿!iI"Ä  api_accessible("LITERAL") do |var|
    var.add("LITERAL")
    var.add("LITERAL")
    var.add("LITERAL")
    var.add("LITERAL");Fi[	@¿!iI"f    var.add("LITERAL")
    var.add("LITERAL")
    var.add("LITERAL")
    var.add("LITERAL")
  end;Fi[	I"4projects//diaspora_proj/models/participation.rb;TiI"q  
  api_accessible("LITERAL") do |var|
    var.add("LITERAL")
    var.add("LITERAL")
    var.add("LITERAL");Fi[	@«!iI"Ä  api_accessible("LITERAL") do |var|
    var.add("LITERAL")
    var.add("LITERAL")
    var.add("LITERAL")
    var.add("LITERAL");Fi[	@«!iI"f    var.add("LITERAL")
    var.add("LITERAL")
    var.add("LITERAL")
    var.add("LITERAL")
  end;Fi[	@“iI"q  
  api_accessible("LITERAL") do |var|
    var.add("LITERAL")
    var.add("LITERAL")
    var.add("LITERAL");Fi[	@“iI"≥  api_accessible("LITERAL") do |var|
    var.add("LITERAL")
    var.add("LITERAL")
    var.add("LITERAL")
    var.add(lambda { |var| var.diaspora_handle }, "LITERAL" => "LITERAL");Fi[	@∫iI"q  
  api_accessible("LITERAL") do |var|
    var.add("LITERAL")
    var.add("LITERAL")
    var.add("LITERAL");Fi[	@∫iI"Ä  api_accessible("LITERAL") do |var|
    var.add("LITERAL")
    var.add("LITERAL")
    var.add("LITERAL")
    var.add("LITERAL");Fi[	@∫iI"|    var.add("LITERAL")
    var.add("LITERAL")
    var.add("LITERAL")
    var.add("LITERAL")
    var.add(lambda do |var|;Fi[	I"#       ...;F@>i[[	@ ivI"n      #
      #     def reset_attribute_to_default!(attr)
      #       ...
      #     end
      #   end;Fi[	@ i∂I"b      #
      #     def clear_attribute(attr)
      #       ...
      #     end
      #   end;Fi[	@iJI"    #   class Vehicle
    #     state_machine :status, :attribute => :status_value do
    #       ...
    #     end
    #   end;Fi[	@iRI"|    #   class Vehicle
    #     state_machine :status, :initial => :parked do
    #       ...
    #     end
    #   end;Fi[	@iZI"©    #   class Vehicle
    #     state_machine :status, :initial => lambda {|vehicle| vehicle.speed == 0 ? :parked : :idling} do
    #       ...
    #     end
    #   end;Fi[	@i⁄I"{    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #   end;Fi[	@iËI"z    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     ;Fi[	@i˘I"z    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     ;Fi[	@iI"z    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     ;Fi[	@i#I"~    #     state_machine :state, :initial => :parked do
    #       state nil, :idling
    #       ...
    #     end
    #     ;Fi[	@3i≥I"p    #   class Vehicle
    #     state_machine :action => :save do
    #       ...
    #     end
    #   end;Fi[	I"%# @param request_method [Symbol];FI"# @param path [String];Fi[[	@´iI"y      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array];Fi[	@ŒitI"z      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param params [Hash];Fi[	@iˇI"y      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array];Fi[	@iI"y      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array];Fi[	@iI"u      end
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array];Fi[	@i'I"É      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array];Fi[	@i2I"Ö      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param options [Hash];Fi[	@iCI"É      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array];Fi[	@iOI"Ö      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param options [Hash];Fi[	@iZI"§      # @param collection_name [Symbol]
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array];Fi[	@iiI"¶      # @param collection_name [Symbol]
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param options [Hash];Fi[	@I"#     private;Fi[[	@ i*I"{      #     attribute_method_prefix 'clear_'
      #     define_attribute_methods :name
      #
      #     private
      #;Fi[	@ iNI"|      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name
      #
      #     private
      #;Fi[	@ irI"ö      #     attribute_method_affix prefix: 'reset_', suffix: '_to_default!'
      #     define_attribute_methods :name
      #
      #     private
      #;Fi[	@ iäI"]      #
      #     alias_attribute :nickname, :name
      #
      #     private
      #;Fi[	@ i≤I"ç      #     # attribute_method_affix declares.
      #     define_attribute_methods :name, :age, :address
      #
      #     private
      #;Fi[	@ iŒI"|      #     # attribute_method_affix declares.
      #     define_attribute_method :name
      #
      #     private
      #;Fi[	@ iÒI"{      #     attribute_method_suffix '_short?'
      #     define_attribute_method :name
      #
      #     private
      #;Fi[	@liI"l        #
        #     before_validation :remove_whitespaces
        #
        #     private
        #;Fi[	@li>I"c        #
        #     after_validation :set_status
        #
        #     private
        #;Fi[	@ãi,I"g      #       end
      #     end
      #
      #     private
      #       def some_complex_logic;Fi[	@ñi)I"      #     before_filter :find_book_by_permalink, :only => :show
      #     load_resource
      #
      #     private
      #;Fi[	@î@ói[[	@J
i∂I"å      when "STRING", "STRING", "STRING", "STRING" then
        "LITERAL"
      when "STRING" then
        "LITERAL"
      when "STRING" then;Fi[	@J
i∏I"e      when "STRING" then
        "LITERAL"
      when "STRING" then
        "LITERAL"
      else;Fi[	@›
irI"â      link_dir("STRING", var) do |var|
        case var.to_s
        when "STRING" then
          "LITERAL"
        when INFOFILE_RX then;Fi[	@›
i}I"Ü      link_dir("STRING", var) do |var|
        case var.to_s
        when "STRING" then
          "LITERAL"
        when "STRING" then;Fi[	@›
iI"~        when "STRING" then
          "LITERAL"
        when "STRING" then
          "LITERAL"
        when "LITERAL" then;Fi[	@›
iÉI"~        when "LITERAL" then
          "LITERAL"
        when "STRING" then
          "LITERAL"
        when "STRING" then;Fi[	@›
iÖI"}        when "STRING" then
          "LITERAL"
        when "STRING" then
          "LITERAL"
        when "STRING" then;Fi[	@›
iáI"~        when "STRING" then
          "LITERAL"
        when "STRING" then
          "LITERAL"
        when "LITERAL" then;Fi[	@›
içI"        when "LITERAL" then
          "LITERAL"
        when "STRING" then
          "LITERAL"
        when "LITERAL" then;Fi[	@›
iëI"p        when "LITERAL" then
          "LITERAL"
        when "STRING" then
          "LITERAL"
        else;Fi[	@·iUI"\    when "LITERAL" then
      "LITERAL"
    when "STRING" then
      "LITERAL"
    else;Fi[	@:I"var = {};Fi[[	@ci I"Å          end
          
          def function
            var = {}
            var["LITERAL"] = "STRING" if (type == "LITERAL");Fi[	@®iïI"¢      end
      
      def function
        var = {}
        if ((reflection.macro == "LITERAL") or (reflection.macro == "LITERAL")) and options["LITERAL"].! then;Fi[	@ØiI"Ü      end
      
      def function
        var = {}
        load_target.find_all { |var| var[var.id] = true unless var.key?(var.id) };Fi[	@Di(I"∑        # actual records, ensuring that we don't create more than one instances of the same
        # record
        def function
          var = {}
          super.each do |var, var|;Fi[	@—idI"È      # Returns the associations used in conditions for the :joins option of a search.
      # See ModelAdditions#accessible_by
      def function
        var = {}
        @rules.each { |var| merge_joins(var, var.associations_hash) };Fi[	@›iNI"Z    end
    
    def function
      var = {}
      if @conditions.kind_of?(Hash) then;Fi[	@»i¬I"d        end
        
        def function
          var = {}
          ATTRIBUTES.each do |var|;Fi[	I"0projects//devise_proj/devise/failure_app.rb;TiUI"S    end
    
    def function
      var = {}
      var = :"new_#{scope}STRING";Fi[	@]
i"I"J    end
    
    def function
      var = {}
      var["STRING"] = [];Fi[	@iWI"Ô    # Arguments other than the standard geometry, format etc are just passed through from
    # initialization and any procs are called here, just before post-processing.
    def function
      var = {}
      @other_args.each do |var, var|;Fi[	@›ibI"‰        # Gets a list of all attributes for the current class, including those
        # that are inherited
        def function
          var = {}
          loaded_superclasses.each { |var| var.merge!(var.instance_attributes) };Fi[	@|I"#raise(ArgumentError, "STRING");Fi[[	@v
iOI"|        when String then
          preload_one(var.to_sym)
        else
          raise(ArgumentError, "STRING")
        end;Fi[	@UiI"†            if var.blank? then
              (null or strict) ? (nil) : ("STRING")
            else
              raise(ArgumentError, "STRING")
            end;Fi[	@ç
iRI"‰            var = var.collection? ? ("LITERAL") : ("LITERAL")
            generated_feature_methods.module_eval("STRING", "STRING", ("LITERAL" + "LITERAL"))
          else
            raise(ArgumentError, "STRING")
          end;Fi[	@ç
iI"™            if respond_to?(var) then
              send(var, var.except(*UNASSIGNABLE_KEYS))
            else
              raise(ArgumentError, "STRING")
            end;Fi[	I"9projects//compass_proj/compass/configuration/data.rb;Ti}I"Æ              @set_attributes["LITERAL"] = true
              @var = Proc.new { |var, var| nil }
            else
              raise(ArgumentError, "STRING")
            end;Fi[	@Îi>I"Ü      when Hash then
        var, var = var.keys.first, var.values.flatten
      else
        raise(ArgumentError, "STRING")
      end;Fi[	@	iõI"è          if var.respond_to?("LITERAL") then
            var.call(self)
          else
            raise(ArgumentError, "STRING")
          end;Fi[	@ci˛I"k        when Hash then
          var
        else
          raise(ArgumentError, "STRING")
        end;Fi[	@$iI"x        when Array then
          var, var = *var
        else
          raise(ArgumentError, "STRING")
        end;Fi[	@·iPI"â      when String then
        eval(var, var.instance_eval { binding }, &var)
      else
        raise(ArgumentError, "STRING")
      end;Fi[	I".projects//twitter_proj/twitter/factory.rb;TiI"º        var = var.gsub("LITERAL") { "STRING" }.gsub("LITERAL") { $1.upcase }
        var.const_get(var.to_sym).fetch_or_new(var)
      else
        raise(ArgumentError, "STRING")
      end;Fi[	I"assert(var.ppc7400?.!);FI"assert(var.ppc64?.!);Fi[[	I".projects//homebrew_proj/test/test_mach.rb;TiI"|    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?);Fi[	@u"iI"    assert(var.i386?)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?);Fi[	@u"i+I"    assert(var.i386?.!)
    assert(var.x86_64?)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?);Fi[	@u"i9I"~    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!);Fi[	@u"iGI"~    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!);Fi[	@u"iUI"|    assert(var.i386?)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!);Fi[	@u"icI"|    assert(var.i386?.!)
    assert(var.x86_64?)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!);Fi[	@u"iqI"~    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!);Fi[	@u"iêI"~    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!);Fi[	@u"i†I"~    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!);Fi[	@u"i∞I"~    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!);Fi[	I"# @return [String];F@:i[[	@≥
iXI"G  end
  
  # @return [String]
  def function
    case self.service;Fi[	@≥
idI"G  end
  
  # @return [String]
  def function
    case self.service;Fi[	I".projects//diaspora_proj/models/request.rb;Ti!I"X  
  # Alias of sender_handle
  # @return [String]
  def function
    sender_handle;Fi[	@ì"i'I"i  
  # @note Used for XML marshalling
  # @return [String]
  def function
    sender.diaspora_handle;Fi[	@ì"i1I"l  
  # @note Used for XML marshalling
  # @return [String]
  def function
    recipient.diaspora_handle;Fi[	@∑iI"q    end
    
    # @return [String]
    def function
      @var ||= (@attrs["LITERAL"] or @attrs["LITERAL"]);Fi[	@∑iI"è    end
    
    # @return [String]
    def function
      @var ||= (@attrs["LITERAL"] or (@attrs["LITERAL"] and @attrs["LITERAL"]["LITERAL"]));Fi[	@¿i I"p    end
    
    # @return [String]
    def function
      @attrs["LITERAL"]["LITERAL"] if search_metadata?;Fi[	@…i2I"É    alias "LITERAL" "LITERAL"
    
    # @return [String]
    def function
      (@attrs["LITERAL"] or (user and user.screen_name));Fi[	@…izI"    alias "LITERAL" "LITERAL"
    
    # @return [String]
    def function
      var = (@attrs["LITERAL"] or @attrs["LITERAL"]);Fi[	I".projects//twitter_proj/twitter/version.rb;TiI"|    
    class << self
      # @return [String]
      def function
        [MAJOR, MINOR, PATCH, PRE].compact.join("STRING");Fi[	@ˆ@|i[[	@ iaI"†    def function(var, var, var)
      if respond_to_without_attributes?(var, true) then
        super
      else
        var = match_attribute_method?(var.to_s);Fi[	@¸iCI"≠        end
        if (superclass == Base) then
          super
        else
          var = method_defined_within?(var, superclass, superclass.generated_attribute_methods);Fi[	@¸izI"ö    def function(var, var, var)
      if self.class.attribute_methods_generated? then
        super
      else
        self.class.define_attribute_methods;Fi[	@Ui3I"ò      def function(var, var)
        if (var.limit or (var.offset or var.orders.any?)) then
          super
        else
          var.table(var.source);Fi[	@i3I"u      def function
        if (self == Base) then
          super
        else
          if abstract_class? then;Fi[	@hi∂I"Ã        var = @serializable.class
        var = if var.serialized_attributes.key?(name) then
          super
        else
          var.columns_hash.key?(name) ? (var.columns_hash[name].type) : (NilClass);Fi[	@iYI"ö      def function
        if Devise.paranoid then
          super
        else
          if lock_strategy_enabled?("LITERAL") and attempts_exceeded? then;Fi[	I"@projects//nokogiri_proj/nokogiri/html/sax/parser_context.rb;TiI"©        def self.new(var, var)
          if ["LITERAL", "LITERAL"].all? { |var| var.respond_to?(var) } then
            super
          else
            memory(var, var);Fi[	I",projects//omni_proj/omniauth/builder.rb;Ti
I"a    def function(var, var)
      if rack14? then
        super
      else
        @var = var;Fi[	@Ãi'I"µ        def function(var, var, var, var)
          if defined? I18n then
            super
          else
            var.errors.add(self.attribute(var), generate_message(var, var));Fi[	I"var = "LITERAL".match(var);FI".return var.captures.first unless var.nil?;Fi[[	@zi{I"—    var = "LITERAL".match(var)
    return var.captures.first.gsub("STRING", "STRING") unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var);Fi[	@zi}I"∏    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var);Fi[	@ziI"∏    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var);Fi[	@zi|I"∏    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var);Fi[	@zi~I"∏    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var);Fi[	@ziÄI"∏    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var);Fi[	@ziÇI"∏    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var);Fi[	@ziÑI"∏    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var);Fi[	@ziÜI"∏    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var);Fi[	@ziàI"Ω    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var.to_s);Fi[	@ŸI"super(var, var);Fi[[	@XibI"b      end
      
      def function(var, var, var)
        super(var, var)
        @var = nil;Fi[	@oiI"é      ##
      # Creates a new instance of the storage object
      def function(var, var, var)
        super(var, var)
        @var ||= false;Fi[	@¯	i I"ë      ##
      # Creates a new instance of the storage object
      def function(var, var, var)
        super(var, var)
        @var ||= "STRING";Fi[	I"0projects//backup_proj/backup/storage/ftp.rb;TiI"í      ##
      # Creates a new instance of the storage object
      def function(var, var, var)
        super(var, var)
        @var ||= "LITERAL";Fi[	I"2projects//backup_proj/backup/storage/local.rb;TiI"À      ##
      # Creates a new instance of the storage object
      def function(var, var, var)
        super(var, var)
        @var ||= File.join(File.expand_path((ENV["STRING"] or "STRING")), "STRING");Fi[	@riI"ë      ##
      # Creates a new instance of the storage object
      def function(var, var, var)
        super(var, var)
        @var ||= "STRING";Fi[	@uiI"í      ##
      # Creates a new instance of the storage object
      def function(var, var, var)
        super(var, var)
        @var ||= "LITERAL";Fi[	@ziI"ë      ##
      # Creates a new instance of the storage object
      def function(var, var, var)
        super(var, var)
        @var ||= "STRING";Fi[	@iI"í      ##
      # Creates a new instance of the storage object
      def function(var, var, var)
        super(var, var)
        @var ||= "LITERAL";Fi[	@iI"í      ##
      # Creates a new instance of the storage object
      def function(var, var, var)
        super(var, var)
        @var ||= "LITERAL";Fi[	@¿"@ø"i[[	@zixI"Â    return var.captures.first unless var.nil?
    var = "LITERAL".match(var.to_s)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first.gsub("STRING", "STRING") unless var.nil?;Fi[	@zi|I"‡    return var.captures.first.gsub("STRING", "STRING") unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?;Fi[	@zi~I"«    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?;Fi[	@zi{I"«    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?;Fi[	@zi}I"«    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?;Fi[	@ziI"«    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?;Fi[	@ziÅI"«    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?;Fi[	@ziÉI"«    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?;Fi[	@ziÖI"«    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?;Fi[	@ziáI"«    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?;Fi[	@"@i[[	@ i+I"y      #     define_attribute_methods :name
      #
      #     private
      #
      #     def clear_attribute(attr);Fi[	@ iOI"z      #     define_attribute_methods :name
      #
      #     private
      #
      #     def attribute_short?(attr);Fi[	@ isI"Ä      #     define_attribute_methods :name
      #
      #     private
      #
      #     def reset_attribute_to_default!(attr);Fi[	@ iãI"|      #     alias_attribute :nickname, :name
      #
      #     private
      #
      #     def attribute_short?(attr);Fi[	@ i≥I"Ñ      #     define_attribute_methods :name, :age, :address
      #
      #     private
      #
      #     def clear_attribute(attr);Fi[	@ iœI"y      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr);Fi[	@ iÚI"y      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr);Fi[	@liI"Ç        #     before_validation :remove_whitespaces
        #
        #     private
        #
        #     def remove_whitespaces;Fi[	@li?I"v        #     after_validation :set_status
        #
        #     private
        #
        #     def set_status;Fi[	@ñi*I"i      #     load_resource
      #
      #     private
      #
      #     def find_book_by_permalink;Fi[	I"require("twitter/user");F@i[[	@qiI"wrequire("twitter/api/utils")
require("twitter/direct_message")
require("twitter/user")
module Twitter
  module API;Fi[	@~i
I"trequire("twitter/error/forbidden")
require("twitter/tweet")
require("twitter/user")
module Twitter
  module API;Fi[	@Öi
I"{require("twitter/error/forbidden")
require("twitter/relationship")
require("twitter/user")
module Twitter
  module API;Fi[	@´iI"irequire("twitter/list")
require("twitter/tweet")
require("twitter/user")
module Twitter
  module API;Fi[	@ÂiI"Urequire("twitter/api/utils")
require("twitter/user")
module Twitter
  module API;Fi[	@ËiI"srequire("twitter/api/utils")
require("twitter/suggestion")
require("twitter/user")
module Twitter
  module API;Fi[	@ÎiI"nrequire("twitter/api/utils")
require("twitter/tweet")
require("twitter/user")
module Twitter
  module API;Fi[	@i
I"krequire("twitter/cursor")
require("twitter/tweet")
require("twitter/user")
module Twitter
  module API;Fi[	@iI"vrequire("twitter/profile_banner")
require("twitter/settings")
require("twitter/user")
module Twitter
  module API;Fi[	@iI"srequire("twitter/api/arguments")
require("twitter/cursor")
require("twitter/user")
module Twitter
  module API;Fi[	I"# states for the attribute;F@£i[[	@)iII"ƒ      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(var)
        create_scope(var, lambda { |var| ["STRING", var] });Fi[	@)iOI"«      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(var)
        create_scope(var, lambda { |var| ["STRING", var] });Fi[	@	iwI"¬      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(var)
        lambda { |var, var| var.all(attribute => (var)) };Fi[	@	i}I"–      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(var)
        lambda { |var, var| var.all(attribute.to_sym.not => (var)) };Fi[	@,iBI"      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(var)
        define_scope(var, lambda { |var| { "LITERAL" => ({ attribute => ({ "STRING" => (var) }) }) } });Fi[	@,iHI"Û      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(var)
        define_scope(var, lambda { |var| { "LITERAL" => ({ attribute => ({ "STRING" => (var) }) }) } });Fi[	@/iFI"›      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(var)
        define_scope(var, lambda { |var| { attribute => ({ "STRING" => (var) }) } });Fi[	@/iLI"‡      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(var)
        define_scope(var, lambda { |var| { attribute => ({ "STRING" => (var) }) } });Fi[	@JisI"ﬂ      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(var)
        create_scope(var, lambda { |var, var| var.filter(attribute_column => (var)) });Fi[	@JiyI"„      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(var)
        create_scope(var, lambda { |var, var| var.exclude(attribute_column => (var)) });Fi[	@|I"8render("LITERAL" => (true), "LITERAL" => "LITERAL");Fi[[	I"?projects//diaspora_proj/controllers/comments_controller.rb;TiI"e        end
      end
    else
      render("LITERAL" => (true), "LITERAL" => "LITERAL")
    end;Fi[	I"<projects//diaspora_proj/controllers/likes_controller.rb;TiI"e        end
      end
    else
      render("LITERAL" => (true), "LITERAL" => "LITERAL")
    end;Fi[	@w!iI"≤      Webfinger.in_background(params["LITERAL"], "LITERAL" => (true))
      render("LITERAL" => (true))
    else
      render("LITERAL" => (true), "LITERAL" => "LITERAL")
    end;Fi[	@“iFI"o          end
        end
      else
        render("LITERAL" => (true), "LITERAL" => "LITERAL")
      end;Fi[	@“iII"ê        render("LITERAL" => (true), "LITERAL" => "LITERAL")
      end
    else
      render("LITERAL" => (true), "LITERAL" => "LITERAL")
    end;Fi[	I"<projects//diaspora_proj/controllers/posts_controller.rb;Ti0I"ø      var = OEmbedPresenter.new(var, params.slice("LITERAL", "LITERAL", "LITERAL"))
      render("LITERAL" => (var))
    else
      render("LITERAL" => (true), "LITERAL" => "LITERAL")
    end;Fi[	I">projects//diaspora_proj/controllers/publics_controller.rb;Ti#I"ë    if @person.present? and @person.local? then
      render("STRING")
    else
      render("LITERAL" => (true), "LITERAL" => "LITERAL")
    end;Fi[	I"?projects//diaspora_proj/controllers/reshares_controller.rb;TiI"#      current_user.dispatch_post(@reshare, "LITERAL" => (post_url(@reshare)), "LITERAL" => (@reshare.root_author))
      render("LITERAL" => (ExtremePostPresenter.new(@reshare, current_user)), "LITERAL" => "LITERAL")
    else
      render("LITERAL" => (true), "LITERAL" => "LITERAL")
    end;Fi[	I"Eprojects//diaspora_proj/controllers/tag_followings_controller.rb;TiI"∂      if @tag_following.save then
        render("LITERAL" => (@tag.to_json), "LITERAL" => "LITERAL")
      else
        render("LITERAL" => (true), "LITERAL" => "LITERAL")
      end;Fi[	@Å!ièI"Ñ    if var.present? then
      redirect_to(var.image_url)
    else
      render("LITERAL" => (true), "LITERAL" => "LITERAL")
    end;Fi[	@HI" assert_type(var, "LITERAL");Fi[[	I"Gprojects//compass_proj/compass/sass_extensions/functions/colors.rb;TiI"€module Compass::SassExtensions::Functions::Colors
  # a genericized version of lighten/darken so that negative values can be used.
  def function(var, var)
    assert_type(var, "LITERAL")
    assert_type(var, "LITERAL");Fi[	@j#iI"  # If the amount is negative, the color is scaled darker, if positive, it is scaled lighter.
  # This will never return a pure light or dark color unless the amount is 100%.
  def function(var, var)
    assert_type(var, "LITERAL")
    assert_type(var, "LITERAL");Fi[	@j#iI"≥  
  # a genericized version of saturation/desaturate so that negative values can be used.
  def function(var, var)
    assert_type(var, "LITERAL")
    assert_type(var, "LITERAL");Fi[	@j#i I"  # If the amount is negative, the color is desaturated, if positive, it is saturated.
  # This will never return a pure saturated or desaturated color unless the amount is 100%.
  def function(var, var)
    assert_type(var, "LITERAL")
    assert_type(var, "LITERAL");Fi[	@j#i&I"f  end
  
  def function(var, var)
    assert_type(var, "LITERAL")
    assert_type(var, "LITERAL");Fi[	@j#i-I"f  end
  
  def function(var, var)
    assert_type(var, "LITERAL")
    assert_type(var, "LITERAL");Fi[	@¶iGI"¥    
    # returns the end position of the gradient from the color stop
    def function(var, var)
      assert_type(var, "LITERAL")
      var = Sass::Script::Number.new("LITERAL");Fi[	@1i I"Å  
  # Get the nth value from a list
  def function(var, var)
    assert_type(var, "LITERAL")
    if (var.value == "STRING") then;Fi[	I"Eprojects//compass_proj/compass/sass_extensions/functions/math.rb;Ti$I"å  Sass::Script::Functions.declare("LITERAL", [])
  
  def function(var, var)
    assert_type(var, "LITERAL")
    assert_type(var, "LITERAL");Fi[	@{#i:I"ï  Sass::Script::Functions.declare("LITERAL", ["LITERAL"])
  
  def function(var, var)
    assert_type(var, "LITERAL")
    assert_type(var, "LITERAL");Fi[	I"module Compass;FI"module SassExtensions;Fi[[	I"Xprojects//compass_proj/compass/sass_extensions/sprites/engines/chunky_png_engine.rb;Ti
I"Z  require("chunky_png")
end
module Compass
  module SassExtensions
    module Sprites;Fi[	I"Fprojects//compass_proj/compass/sass_extensions/sprites/engines.rb;Ti I">module Compass
  module SassExtensions
    module Sprites;Fi [	@çi I">module Compass
  module SassExtensions
    module Sprites;Fi [	I"Lprojects//compass_proj/compass/sass_extensions/sprites/image_methods.rb;Ti I">module Compass
  module SassExtensions
    module Sprites;Fi [	I"Hprojects//compass_proj/compass/sass_extensions/sprites/image_row.rb;TiI"Urequire("forwardable")
module Compass
  module SassExtensions
    module Sprites;Fi[	I"Mprojects//compass_proj/compass/sass_extensions/sprites/layout_methods.rb;Ti I">module Compass
  module SassExtensions
    module Sprites;Fi [	I"Iprojects//compass_proj/compass/sass_extensions/sprites/row_fitter.rb;TiI"Urequire("forwardable")
module Compass
  module SassExtensions
    module Sprites;Fi[	@Æi I">module Compass
  module SassExtensions
    module Sprites;Fi [	@ûi I">module Compass
  module SassExtensions
    module Sprites;Fi [	I">projects//compass_proj/compass/sass_extensions/sprites.rb;TiI"wrequire("digest/md5")
require("compass/sprite_importer")
module Compass
  module SassExtensions
    module Sprites;Fi[	I"# ==== Parameters;F@i[[	@∞iI"Æ        # <tt>SerializationTypeMismatch</tt> will be raised.
        #
        # ==== Parameters
        #
        # * +attr_name+ - The field name that should be serialized.;Fi[	@iI"≠      # counter has been corrupted or modified directly by SQL.
      #
      # ==== Parameters
      #
      # * +id+ - The id of the object you wish to reset a counter on.;Fi[	@i1I"´      # given by the corresponding value:
      #
      # ==== Parameters
      #
      # * +id+ - The id of the object you wish to update a counter on or an Array of ids.;Fi[	@iXI"¥      # posts and comments there are each time it is displayed.
      #
      # ==== Parameters
      #
      # * +counter_name+ - The name of the field that should be incremented.;Fi[	@ijI"ò      # 1 instead of increasing it.
      #
      # ==== Parameters
      #
      # * +counter_name+ - The name of the field that should be decremented.;Fi[	I":projects//activerecord_proj/active_record/querying.rb;Ti=I"Î    # using the ActiveRecord::Calculations class methods. Look into those before using this.
    #
    # ==== Parameters
    #
    # * +sql+ - An SQL statement which should return a count query from the database, see the example below.;Fi[	@QiÊI"ì    # or validations.
    #
    # ==== Parameters
    #
    # * +updates+ - A string, array, or hash representing the SET part of an SQL statement.;Ti[	@QiI"—    # The resulting object is returned whether the object was saved successfully to the database or not.
    #
    # ==== Parameters
    #
    # * +id+ - This should be the id or an array of ids to be updated.;Ti[	@Qi+I"ä    # +delete_all+ instead.
    #
    # ==== Parameters
    #
    # * +conditions+ - A string, array, or hash that specifies which records;Ti[	@QiFI"õ    # from the attributes, and then calls destroy on it.
    #
    # ==== Parameters
    #
    # * +id+ - Can be either an Integer or an Array of Integers.;Ti[	@˛@^i[[	@≤i<I"c      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [;Ti[	@≤i]I"c      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [;Ti[	@≤ivI"c      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [;Ti[	@≤iìI"c      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [;Ti[	@≤i≥I"c      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [;Ti[	@≤iœI"c      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [;Ti[	@≤iÎI"c      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [;Ti[	@≤iI"c      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [;Ti[	@≤i#I"c      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [;Ti[	@≤iCI"ò      # responding to the +id+ and then deletes them from the database.
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [;Ti[	@n@|i[[	@ izI"Ö      else
        if var.! and super(var, true) then
          false
        else
          match_attribute_method?(var.to_s).nil?.!;Fi[	@XirI"Ü          inverse_updates_counter_cache?(through_reflection).!
        when "LITERAL" then
          false
        else
          true;Fi[	I"Iprojects//activerecord_proj/active_record/attribute_methods/query.rb;TiI"{          true
        when false, nil then
          false
        else
          (var = self.class.columns_hash[var];Fi[	@ iI"{      def function
        if (self == Base) then
          false
        else
          if superclass.abstract_class? then;Fi[	@
i:I"Ñ      var = @controller.class.cancan_skipper[var][@name]
      if var.nil? then
        false
      else
        if (var == {}) then;Fi[	@¶ióI"⁄    def function(var)
      if ["STRING", "STRING"].include?(var) and (position_or_angle.is_a?(Sass::Script::Number) and position_or_angle.numerator_units.include?("STRING")) then
        false
      else
        super;Fi[	I".projects//diaspora_proj/models/contact.rb;Ti`I"é    if user and user.blocks.where("LITERAL" => (person_id)).exists? then
      (errors["LITERAL"] << "STRING")
      false
    else
      true;Fi[	@≥
ijI"Y      self.identifier
    when "STRING" then
      false
    else
      # do nothing;Fi[	I"4projects//diaspora_proj/models/tag_following.rb;TiI"√  def self.user_is_following?(var, var)
    if var.nil? then
      false
    else
      joins("LITERAL").where("LITERAL" => ({ "LITERAL" => (var.downcase) })).where("LITERAL" => (var.id)).exists?;Fi[	@'
iñI"{      self.remove_hidden_shareable(var, var)
      self.save
      false
    else
      self.add_hidden_shareable(var, var);Fi[	I"+unless method_defined?("LITERAL") then;F@:i[[	I"-projects//homebrew_proj/extend/symbol.rb;TiI"zclass Symbol
  unless method_defined?("LITERAL") then
    def function
      proc { |var, var| var.send(self, *var) };Fi[	I"Jprojects//nokogiri_proj/nokogiri/html/element_description_defaults.rb;TiI"~      private("LITERAL")
      
      unless method_defined?("LITERAL") then
        def function
          var = default_desc;Fi[	@Ï#iI"t      end
      
      unless method_defined?("LITERAL") then
        def function
          var = default_desc;Fi[	@Ï#i%I"t      end
      
      unless method_defined?("LITERAL") then
        def function
          var = default_desc;Fi[	@Ï#i,I"t      end
      
      unless method_defined?("LITERAL") then
        def function
          var = default_desc;Fi[	@Ï#i3I"t      end
      
      unless method_defined?("LITERAL") then
        def function
          var = default_desc;Fi[	@Ï#i:I"t      end
      
      unless method_defined?("LITERAL") then
        def function
          var = default_desc;Fi[	@Ï#iAI"t      end
      
      unless method_defined?("LITERAL") then
        def function
          var = default_desc;Fi[	@Ï#iHI"t      end
      
      unless method_defined?("LITERAL") then
        def function
          var = default_desc;Fi[	@Ï#iOI"t      end
      
      unless method_defined?("LITERAL") then
        def function
          var = default_desc;Fi[	@Å#I"module Sprites;Fi[[	@Ñ#iI"Ñend
module Compass
  module SassExtensions
    module Sprites
      class ChunkyPngEngine < Compass::SassExtensions::Sprites::Engine;Fi[	@á#iI"Qmodule Compass
  module SassExtensions
    module Sprites
      class Engine;Fi[	@çiI"Pmodule Compass
  module SassExtensions
    module Sprites
      class Image;Fi[	@å#iI"Xmodule Compass
  module SassExtensions
    module Sprites
      module ImageMethods;Fi[	@è#iI"jrequire("forwardable")
module Compass
  module SassExtensions
    module Sprites
      class ImageRow;Fi[	@í#iI"Ymodule Compass
  module SassExtensions
    module Sprites
      module LayoutMethods;Fi[	@ï#iI"krequire("forwardable")
module Compass
  module SassExtensions
    module Sprites
      class RowFitter;Fi[	@ÆiI"lmodule Compass
  module SassExtensions
    module Sprites
      class SpriteMap < Sass::Script::Literal;Fi[	@ûiI"Ymodule Compass
  module SassExtensions
    module Sprites
      module SpriteMethods;Fi[	@ú#iI"irequire("compass/sprite_importer")
module Compass
  module SassExtensions
    module Sprites
    end;Fi[	I"included do;FI"5class_attribute("LITERAL", "LITERAL" => (false));Fi[[	I"Hprojects//activerecord_proj/active_record/attribute_methods/read.rb;TiI"˚      ATTRIBUTE_TYPES_CACHED_BY_DEFAULT = ["LITERAL", "LITERAL", "LITERAL", "LITERAL"]
      
      included do
        class_attribute("LITERAL", "LITERAL" => (false))
        self.attribute_types_cached_by_default = ATTRIBUTE_TYPES_CACHED_BY_DEFAULT;Fi[	@∞i
I"û      extend(ActiveSupport::Concern)
      
      included do
        class_attribute("LITERAL", "LITERAL" => (false))
        self.serialized_attributes = {};Fi[	@ i
I"ï    extend(ActiveSupport::Concern)
    
    included do
      class_attribute("LITERAL", "LITERAL" => (false))
      self.store_full_sti_class = true;Fi[	@#i	I"ú    extend(ActiveSupport::Concern)
    
    included do
      class_attribute("LITERAL", "LITERAL" => (false))
      self.cache_timestamp_format = "LITERAL";Fi[	I"Dprojects//activerecord_proj/active_record/locking/optimistic.rb;Ti
I"û      extend(ActiveSupport::Concern)
      
      included do
        class_attribute("LITERAL", "LITERAL" => (false))
        self.lock_optimistically = true;Fi[	@ç
iI"ò    extend(ActiveSupport::Concern)
    
    included do
      class_attribute("LITERAL", "LITERAL" => (false))
      self.nested_attributes_options = {};Fi[	@Ei	I"ç    extend(ActiveSupport::Concern)
    
    included do
      class_attribute("LITERAL", "LITERAL" => (false))
      self._attr_readonly = [];Fi[	@Ti
I"ó      extend(ActiveSupport::Concern)
      
      included do
        class_attribute("LITERAL", "LITERAL" => (false))
        self.default_scopes = [];Fi[	@ªi
I"ê    extend(ActiveSupport::Concern)
    
    included do
      class_attribute("LITERAL", "LITERAL" => (false))
      self.stored_attributes = {};Fi[	@∏iI"j      BLACKLIST_FOR_SERIALIZATION = ["LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL"]
      
      included do
        class_attribute("LITERAL", "LITERAL" => (false))
        self.devise_modules ||= [];Fi[	@H@<i[[	@÷iI"j      end
      
      def function(var, var)
        var = "STRING"
        (var << "STRING") if var;Fi[	@ÅiYI"î      
      # DATABASE STATEMENTS ======================================
      def function(var, var)
        var = "STRING"
        var = Time.now;Fi[	@Ç
i	I"À    class PostgreSQLAdapter < AbstractAdapter
      module DatabaseStatements
        def function(var, var)
          var = "STRING"
          ExplainPrettyPrinter.new.pp(exec_query(var, "STRING", var));Fi[	@Xi‰I"¡      
      # DATABASE STATEMENTS ======================================
      def function(var, var)
        var = "STRING"
        ExplainPrettyPrinter.new.pp(exec_query(var, "STRING", var));Fi[	@XiHI"û      
      # SCHEMA STATEMENTS ========================================
      def function(var, var)
        var = "STRING"
        (var << "STRING") if var;Fi[	@Xi∑I"~      end
      
      def function(var, var)
        var = "STRING"
        var = lambda { |var| yield(var) if block_given? };Fi[	@
iI"¨    
    # Record an action that has occurred
    def function(var, var)
      var = "STRING"
      (var << color(ACTION_COLORS[var])) if Compass.configuration.color_output;Fi[	@›i%I"n  end
  
  def function(var, var)
    var = "STRING"
    var.photos.each { |var| var = (var + "STRING") };Fi[	@i4I"{    end
    
    def function(var, var)
      var = "STRING"
      var = Haml::Util.handle_interpolation(var.dump) do |var|;Fi[	@$i3I"ﬂ  # Looks for Makefile style variable defintions and replaces the
  # value with "new_value", or removes the definition entirely.
  def function(var, var)
    var = "STRING"
    var = gsub!(Regexp.new("STRING"), var, false);Fi[	@â@i[[	@0iI"í    # the object is persisted or not. If there no key attributes, returns +nil+.
    #
    #   class Person < ActiveRecord::Base
    #   end
    #;Fi[	@0i+I"x    # or +nil+ if <tt>persisted?</tt> is +false+.
    #
    #   class Person < ActiveRecord::Base
    #   end
    #;Fi[	@¸i_I"i      # +false+ otherwise.
      #
      #   class Person < ActiveRecord::Base
      #   end
      #;Fi[	@¸ilI"Ñ      # table exists. Otherwise it returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #   end
      #;Fi[	@¸iàI"`    # not been generated.
    #
    #   class Person < ActiveRecord::Base
    #   end
    #;Fi[	@¸iúI"õ    # Returns +true+ if the given attribute is in the attributes hash, otherwise +false+.
    #
    #   class Person < ActiveRecord::Base
    #   end
    #;Fi[	@¸i©I"é    # Returns an array of names for the attributes available on this object.
    #
    #   class Person < ActiveRecord::Base
    #   end
    #;Fi[	@¸iµI"±    # Returns a hash of all the attributes with their names as keys and the values of the attributes as values.
    #
    #   class Person < ActiveRecord::Base
    #   end
    #;Fi[	@¸iÓI"h    # named attribute not exists.
    #
    #   class Person < ActiveRecord::Base
    #   end
    #;Fi[	@¸iI"Ç    # (Alias for the protected <tt>write_attribute</tt> method).
    #
    #   class Person < ActiveRecord::Base
    #   end
    #;Fi[	@|I"if var["LITERAL"] then;Fi[[	I".projects//compass_proj/compass/actions.rb;Ti-I"¨          log_action("LITERAL", basename(var), var)
          var = true
        else
          if var["LITERAL"] then
            log_action("LITERAL", basename(var), var);Fi[	@ƒifI"√          if var.raw_project_type then
            add_configuration(var.raw_project_type.to_sym)
          else
            if var["LITERAL"] then
              add_configuration(var["LITERAL"]);Fi[	@Å!i2I"¶              flash["LITERAL"] = I18n.t("STRING")
            end
          else
            if var["LITERAL"] then
              if @user.update_attributes(var) then;Fi[	@Å!i:I"¥                flash["LITERAL"] = I18n.t("STRING")
              end
            else
              if var["LITERAL"] then
                @user.unconfirmed_email = var["LITERAL"];Fi[	@Å!iCI"∫                  flash["LITERAL"] = I18n.t("STRING")
                end
              else
                if var["LITERAL"] then
                  if @user.update_attributes(var) then;Fi[	@∫iWI"©      var = var.delete("LITERAL")
      var.unprocessed_image.store!(var)
    else
      if var["LITERAL"] then
        var.remote_unprocessed_image_url = var["LITERAL"];Fi[	@˝i¡I"        if var["LITERAL"] and var["LITERAL"].! then
          ["LITERAL", var["LITERAL"], (Integer(var["LITERAL"]) * ("LITERAL" ** Integer(var["LITERAL"]["LITERAL"])))]
        else
          if var["LITERAL"] then
            ["LITERAL", var["LITERAL"], Float(var["LITERAL"])];Fi[	I"8projects//nokogiri_proj/nokogiri/decorators/slop.rb;TiI"µ            if var["LITERAL"] then
              var = css("STRING")
            else
              if var["LITERAL"] then
                var = Array(var["LITERAL"]).join("STRING");Fi[	@	iI"y        if var.nil? then
          "STRING"
        else
          if var["LITERAL"] then
            var["LITERAL"];Fi[	@	iI"ù          if var["LITERAL"] then
            var["LITERAL"]
          else
            if var["LITERAL"] then
              var = Array(var["LITERAL"]).first;Fi[	@;!@|i[[	@|i8I"\        case var
        when "LITERAL" then
          nil
        else
          begin;Fi[	@ìiI"|        def function(var)
          if var.nil? then
            nil
          else
            if String.===(var) then;Fi[	@ìi"I"Â              Hash[var.scan(HstorePair).map do |var, var|
                var = if (var.upcase == "STRING") then
                  nil
                else
                  var.gsub("LITERAL", "STRING").gsub("LITERAL", "STRING");Fi[	@ìiTI"~        def function(var)
          if var.nil? then
            nil
          else
            if ("STRING" == var) then;Fi[	@ìinI"{        def function(var)
          if var.nil? then
            nil
          else
            if Range.===(var) then;Fi[	@õi]I"æ            var = var.scan("LITERAL").flatten["LITERAL"]
            if var.empty? then
              nil
            else
              IndexDefinition.new(var, var, var, var, [], var, var);Fi[	I"8projects//compass_proj/compass/commands/registry.rb;TiI"t      else
        if var =~ "LITERAL" then
          nil
        else
          if (var.size > "LITERAL") then;Fi[	@ƒiI"è      def function(var, var, var)
        if var.nil? then
          nil
        else
          if var.is_a?(Compass::Configuration::Data) then;Fi[	@»iìI"î          else
            if inherited_data.nil? then
              nil
            else
              if inherited_data.respond_to?("STRING") then;Fi[	@iI"Å        case var
        when "LITERAL", nil then
          nil
        else
          MultiJson.decode(var, "LITERAL" => (true));Fi[	@ÎI"module Storage;Fi[[	@õi I"2module Backup
  module Storage
    class Base;Fi [	@oiI"aBackup::Dependency.load("STRING")
module Backup
  module Storage
    class CloudFiles < Base;Fi[	@¯	iI"^Backup::Dependency.load("STRING")
module Backup
  module Storage
    class Dropbox < Base;Fi[	@‡"iI"Krequire("net/ftp")
module Backup
  module Storage
    class FTP < Base;Fi[	@„"i I":module Backup
  module Storage
    class Local < Base;Fi [	@riI"_Backup::Dependency.load("STRING")
module Backup
  module Storage
    class Ninefold < Base;Fi[	@uiI"\Backup::Dependency.load("STRING")
module Backup
  module Storage
    class RSync < Base;Fi[	@ziI"YBackup::Dependency.load("STRING")
module Backup
  module Storage
    class S3 < Base;Fi[	@iI"|Backup::Dependency.load("STRING")
Backup::Dependency.load("STRING")
module Backup
  module Storage
    class SCP < Base;Fi[	@iI"}Backup::Dependency.load("STRING")
Backup::Dependency.load("STRING")
module Backup
  module Storage
    class SFTP < Base;Fi[	@@ü#i[[	@∞iI"¨        # serialized object must be of that class on retrieval or
        # <tt>SerializationTypeMismatch</tt> will be raised.
        #
        # ==== Parameters
        #;Fi[	@iI"µ      # count query. This is useful when adding new counter caches, or if the
      # counter has been corrupted or modified directly by SQL.
      #
      # ==== Parameters
      #;Fi[	@i0I"û      # with the given ID, altering the given hash of counters by the amount
      # given by the corresponding value:
      #
      # ==== Parameters
      #;Fi[	@iWI"ª      # and comments_count to avoid running an SQL query to calculate the number of
      # posts and comments there are each time it is displayed.
      #
      # ==== Parameters
      #;Fi[	@iiI"ú      # This works the same as increment_counter but reduces the column value by
      # 1 instead of increasing it.
      #
      # ==== Parameters
      #;Fi[	@¨#i<I"‚    # The use of this method should be restricted to complicated SQL queries that can't be executed
    # using the ActiveRecord::Calculations class methods. Look into those before using this.
    #
    # ==== Parameters
    #;Fi[	@QiÂI"£    # database. It does not instantiate the involved models and it does not trigger Active Record callbacks
    # or validations.
    #
    # ==== Parameters
    #;Ti[	@QiI"Î    # Updates an object (or multiple objects) and saves it to the database, if validations pass.
    # The resulting object is returned whether the object was saved successfully to the database or not.
    #
    # ==== Parameters
    #;Ti[	@Qi*I"ä    # rows quickly, without concern for their associations or callbacks, use
    # +delete_all+ instead.
    #
    # ==== Parameters
    #;Ti[	@QiEI"¿    # This essentially finds the object (or multiple objects) with the given id, creates a new object
    # from the attributes, and then calls destroy on it.
    #
    # ==== Parameters
    #;Ti[	I"##;FI"3# Creates a new instance of the storage object;Fi[[	@õiI"„      # same type. This will be appended to the YAML storage file used for
      # cycling backups.
      ##
      # Creates a new instance of the storage object
      # * Called with super(model, storage_id) from each subclass;Fi[	@oiI"û      ##
      # Rackspace Cloud Files container name and path
      ##
      # Creates a new instance of the storage object
      def function(var, var, var);Fi[	@¯	iI"ô      ##
      # Path to where the backups will be stored
      ##
      # Creates a new instance of the storage object
      def function(var, var, var);Fi[	@‡"iI"Ç      ##
      # use passive mode?
      ##
      # Creates a new instance of the storage object
      def function(var, var, var);Fi[	@„"iI"ñ      ##
      # Path where the backup will be stored.
      ##
      # Creates a new instance of the storage object
      def function(var, var, var);Fi[	@riI"à      ##
      # Ninefold directory path
      ##
      # Creates a new instance of the storage object
      def function(var, var, var);Fi[	@uiI"ä      ##
      # Flag to use local backups
      ##
      # Creates a new instance of the storage object
      def function(var, var, var);Fi[	@ziI"í      ##
      # Region of the specified S3 bucket
      ##
      # Creates a new instance of the storage object
      def function(var, var, var);Fi[	@iI"â      ##
      # Path to store backups to
      ##
      # Creates a new instance of the storage object
      def function(var, var, var);Fi[	@iI"â      ##
      # Path to store backups to
      ##
      # Creates a new instance of the storage object
      def function(var, var, var);Fi[	I"/#     state_machine :initial => :parked do;F@Ui[[	@ÊicI"©    # 
    #   class Vehicle < ActiveRecord::Base
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling;Fi[	@ÌiAI"î    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling;Fi[	@ÌisI"î    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling;Fi[	@ıiI"π        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling;Fi[	@ıiXI"π        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling;Fi[	@ıi|I"π        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling;Fi[	@iDI"ê    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition all => :idling;Fi[	@içI"°    #     property :id, Serial
    #     
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling;Fi[	@3i˝I"î    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling;Fi[	@|@hi[[	@XisI"X        when "LITERAL" then
          false
        else
          true
        end;Fi[	@¸iTI"Ã          if (var.method_defined?(var) or var.private_method_defined?(var)) then
            var.instance_method(var).owner.!=(var.instance_method(var).owner)
          else
            true
          end;Fi[	@‹#iaI"R      (errors["LITERAL"] << "STRING")
      false
    else
      true
    end;Fi[	I".projects//diaspora_proj/models/message.rb;TiaI"é    if self.parent and self.parent.participants.include?(self.author).! then
      (errors["LITERAL"] << "STRING")
    else
      true
    end;Fi[	@∫i?I"ë    if self.status_message_guid and self.status_message.text_and_photos_blank? then
      self.status_message.destroy
    else
      true
    end;Fi[	@∫iHI"|    if self.status_message_guid and var then
      (self.diaspora_handle == var.diaspora_handle)
    else
      true
    end;Fi[	@‘inI"Z    when "LITERAL" then
      (MacOS.version < "LITERAL")
    else
      true
    end;Fi[	@	i4I"Z            @options["LITERAL"]
          end
        else
          true
        end;Fi[	@3iXI"N        raise(var) if var
        var.!
      else
        true
      end;Fi[	@4I"when Array then;Fi[[	@ñiI"ö        def function(var, var)
          return super unless var
          case var
          when Array then
            var.array ? ("STRING") : (super);Fi[	@Ji∂I"ò      @var = true
      var.map do |var|
        case var
        when Array then
          var = Arel.sql(var.join("STRING")) if array_of_strings?(var);Fi[	@∏iI"à      def function(var, var)
        return nil if var.blank?
        case var
        when Array then
          sanitize_sql_array(var);Fi[	@∏i,I"≠      #   { name: nil, group_id: 4 }  returns "name = NULL , group_id='4'"
      def function(var)
        case var
        when Array then
          sanitize_sql_array(var);Fi[	@QiCI"ö      var = @controller.request.env
      var ||= {}
      case var
      when Array then
        if (var.first == "LITERAL") and intercept_401?(var) then;Fi[	@;imI"π      def function(var, var)
        var = with_output_buffer_without_haml_xss(*var, &var)
        case var
        when Array then
          var.map { |var| Haml::Util.html_safe(var) };Fi[	@J
iI"g    var = []
    var.each do |var|
      case var
      when Array then
        if var.empty? then;Fi[	@J
i>I"Ç    var = []
    var.each do |var|
      case var
      when Array then
        var.each { |var| (var << install_symlink_p(var)) };Fi[	@>iI"á      
      def self.modify_keys(var, var)
        case var
        when Array then
          var.map { |var| modify_keys(var, &var) };Fi[	@ŸI"#var = Node.new("LITERAL", var);Fi[[	@^ijI"j      end
      
      def function(var, var, var)
        var = Node.new("LITERAL", var)
        var;Fi[	@^ipI"z      
      # reduce 13 omitted
      def function(var, var, var)
        var = Node.new("LITERAL", var)
        var;Fi[	@^iuI"j      end
      
      def function(var, var, var)
        var = Node.new("LITERAL", var)
        var;Fi[	@^iêI"z      
      # reduce 22 omitted
      def function(var, var, var)
        var = Node.new("LITERAL", var)
        var;Fi[	@^i(I"à      # reduce 49 omitted
      # reduce 50 omitted
      def function(var, var, var)
        var = Node.new("LITERAL", var)
        var;Fi[	@^i-I"j      end
      
      def function(var, var, var)
        var = Node.new("LITERAL", var)
        var;Fi[	@^i2I"j      end
      
      def function(var, var, var)
        var = Node.new("LITERAL", var)
        var;Fi[	@^i7I"j      end
      
      def function(var, var, var)
        var = Node.new("LITERAL", var)
        var;Fi[	@^i@I"à      # reduce 57 omitted
      # reduce 58 omitted
      def function(var, var, var)
        var = Node.new("LITERAL", var)
        var;Fi[	@%@öi[[	@^ikI"j      
      def function(var, var, var)
        var = Node.new("LITERAL", var)
        var
      end;Fi[	@^iqI"}      # reduce 13 omitted
      def function(var, var, var)
        var = Node.new("LITERAL", var)
        var
      end;Fi[	@^ivI"j      
      def function(var, var, var)
        var = Node.new("LITERAL", var)
        var
      end;Fi[	@^iëI"}      # reduce 22 omitted
      def function(var, var, var)
        var = Node.new("LITERAL", var)
        var
      end;Fi[	@^i)I"}      # reduce 50 omitted
      def function(var, var, var)
        var = Node.new("LITERAL", var)
        var
      end;Fi[	@^i.I"j      
      def function(var, var, var)
        var = Node.new("LITERAL", var)
        var
      end;Fi[	@^i3I"j      
      def function(var, var, var)
        var = Node.new("LITERAL", var)
        var
      end;Fi[	@^i8I"j      
      def function(var, var, var)
        var = Node.new("LITERAL", var)
        var
      end;Fi[	@^iAI"}      # reduce 58 omitted
      def function(var, var, var)
        var = Node.new("LITERAL", var)
        var
      end;Fi[	@∫$@Ÿi[[	@oiI"≠      # Rackspace Cloud Files container name and path
      ##
      # Creates a new instance of the storage object
      def function(var, var, var)
        super(var, var);Fi[	@¯	iI"®      # Path to where the backups will be stored
      ##
      # Creates a new instance of the storage object
      def function(var, var, var)
        super(var, var);Fi[	@‡"iI"ë      # use passive mode?
      ##
      # Creates a new instance of the storage object
      def function(var, var, var)
        super(var, var);Fi[	@„"iI"•      # Path where the backup will be stored.
      ##
      # Creates a new instance of the storage object
      def function(var, var, var)
        super(var, var);Fi[	@riI"ó      # Ninefold directory path
      ##
      # Creates a new instance of the storage object
      def function(var, var, var)
        super(var, var);Fi[	@uiI"ô      # Flag to use local backups
      ##
      # Creates a new instance of the storage object
      def function(var, var, var)
        super(var, var);Fi[	@ziI"°      # Region of the specified S3 bucket
      ##
      # Creates a new instance of the storage object
      def function(var, var, var)
        super(var, var);Fi[	@iI"ò      # Path to store backups to
      ##
      # Creates a new instance of the storage object
      def function(var, var, var)
        super(var, var);Fi[	@iI"ò      # Path to store backups to
      ##
      # Creates a new instance of the storage object
      def function(var, var, var)
        super(var, var);Fi[	@£I"if var then;Fi[[	@9i∆I"π    #   person.to_hash       # => {:name=>["can not be nil"]}
    #   person.to_hash(true) # => {:name=>["name can not be nil"]}
    def function(var)
      if var then
        var = {};Fi[	@¸i3I"ô      end
      
      def function(var)
        if var then
          owner[reflection.foreign_key] = var[reflection.association_primary_key(var.class)];Fi[	@˜iI"ë  module Associations
    class SingularAssociation < Association
      def function(var)
        if var then
          klass.uncached { reload };Fi[	@õiîI"™        #
        # This should be not be called manually but set in database.yml.
        def function(var)
          if var then
            execute("STRING", "STRING");Fi[	@‹	iRI"ı    #   Person.order("created_on DESC").offset(5).first
    #   Person.first(3) # returns the first three objects fetched by SELECT * FROM people LIMIT 3
    def function(var)
      if var then
        if order_values.empty? and primary_key then;Fi[	@‹	isI"ö    #
    #   [#<Person id:4>, #<Person id:3>, #<Person id:2>]
    def function(var)
      if var then
        if order_values.empty? and primary_key then;Fi[	@Qi7I"¢    #   Person.destroy_all(status: "inactive")
    #   Person.where(age: 0..18).destroy_all
    def function(var)
      if var then
        where(var).destroy_all;Ti[	I"0projects//rescue_proj/resque/multi_queue.rb;Ti I"≤    # Pass +true+ for a non-blocking pop.  If nothing is read on a non-blocking
    # pop, a ThreadError is raised.
    def function(var)
      if var then
        synchronize do;Fi[	@iCI"≤    # Pass +true+ for a non-blocking pop.  If nothing is read on a non-blocking
    # pop, a ThreadError is raised.
    def function(var)
      if var then
        synchronize do;Fi[	@nI" # @return [Twitter::Cursor];Fi[[	@ÖiI"˚      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={});Fi[	@Öi,I"˝      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload follower_ids(options={});Fi[	@Öi]I"      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @param options [Hash] A customizable set of options.;Fi[	@ÖilI"      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @param options [Hash] A customizable set of options.;Fi[	@Öi˛I"˚      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={});Fi[	@ÖiI"˚      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={});Fi[	@´isI"¸      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload memberships(options={});Fi[	@´i.I"      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload list_members(list, options={});Fi[	@´iÕI"˛      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload subscriptions(options={});Fi[	@I"L# There is also a list of default options supported by every validator:;Fi[[	@fiI"˜      # Configuration options:
      # * <tt>:message</tt> - A custom error message (default is: "must be blank").
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.;Fi[	@ii1I"Ò      #   a database column, since the attribute is typecast from "1" to +true+
      #   before validation.
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.;Fi[	@i3I"Ô      # * <tt>:message</tt> - A custom error message (default is: "doesn't match
      #   confirmation").
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.;Fi[	@qi+I"      # * <tt>:allow_blank</tt> - If set to true, skips this validation if the
      #   attribute is blank(default is +false+).
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.;Fi[	@tilI"(      #   anchors that match the beginning or end of lines as opposed to the
      #   beginning or end of the string. These anchors are <tt>^</tt> and <tt>$</tt>.
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.;Fi[	@{i*I"      # * <tt>:allow_blank</tt> - If set to +true+, skips this validation if the
      #   attribute is blank (default is +false+).
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.;Fi[	@~igI"      #   as in above example). Defaults to <tt>->(value) { value.split(//) }</tt>
      #   which counts individual characters.
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.;Fi[	@|ijI"      # * <tt>:odd</tt> - Specifies the value must be an odd number.
      # * <tt>:even</tt> - Specifies the value must be an even number.
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+ .;Fi[	@i I"¯      # Configuration options:
      # * <tt>:message</tt> - A custom error message (default is: "can't be blank").
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.;Fi[	I"assert(var.x86_64?.!);F@q"i[[	@u"iI"Ä    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!);Fi[	@u"iI"Ä    assert(var.universal?.!)
    assert(var.i386?)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!);Fi[	@u"i8I"Ä    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!);Fi[	@u"iFI"Ä    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!);Fi[	@u"iTI"Ä    assert(var.universal?.!)
    assert(var.i386?)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!);Fi[	@u"ipI"Ç    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!);Fi[	@u"ièI"Ç    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!);Fi[	@u"iüI"Ç    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!);Fi[	@u"iØI"Ç    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!);Fi[	@£I"var = var.extract_options!;Fi[[	@-i-I"    #     end
    #   end
    def function(var)
      var = var.extract_options!
      var = { "LITERAL" => "STRING", "LITERAL" => (true), "LITERAL" => (["LITERAL", "LITERAL"]), "LITERAL" => (["LITERAL", "LITERAL", "LITERAL"]) }.merge!(var);Fi[	@ÇiÜI"∏      #   person.valid?
      #   # => ActiveModel::StrictValidationFailed: Name can't be blank
      def function(var)
        var = var.extract_options!
        var["LITERAL"] = true;Fi[	@iÊI"”      # Appends <tt>:datetime</tt> columns <tt>:created_at</tt> and
      # <tt>:updated_at</tt> to the table.
      def function(var)
        var = var.extract_options!
        column("LITERAL", "LITERAL", var);Fi[	@iÏI"t      end
      
      def function(var)
        var = var.extract_options!
        var = var.delete("LITERAL");Fi[	@iÑI"º      #  t.belongs_to(:supplier, polymorphic: true)
      #
      def function(var)
        var = var.extract_options!
        var.each { |var| @base.add_reference(@table_name, var, var) };Fi[	@iëI"∆      #  t.remove_belongs_to(:supplier, polymorphic: true)
      #
      def function(var)
        var = var.extract_options!
        var.each { |var| @base.remove_reference(@table_name, var, var) };Fi[	@ñi∆I"≥      #
      # You can also pass the resource name as the first argument to skip that resource.
      def function(var)
        var = var.extract_options!
        var = var.first;Fi[	@ñi÷I"≥      #
      # You can also pass the resource name as the first argument to skip that resource.
      def function(var)
        var = var.extract_options!
        var = var.first;Fi[	I"=projects//diaspora_proj/helpers/error_messages_helper.rb;TiI"‹module ErrorMessagesHelper
  # Render error messages for the given objects. The :message and :header_message options are allowed.
  def function(var)
    var = var.extract_options!
    var["LITERAL"] ||= I18n.t("STRING");Fi[	@ÆI"module AttributeMethods;Fi[[	@Ùi I"Lmodule ActiveRecord
  module AttributeMethods
    module BeforeTypeCast;Fi [	I"Iprojects//activerecord_proj/active_record/attribute_methods/dirty.rb;TiI"|require("active_support/core_ext/module/attribute_accessors")
module ActiveRecord
  module AttributeMethods
    module Dirty;Fi[	@˜iI"Wrequire("set")
module ActiveRecord
  module AttributeMethods
    module PrimaryKey;Fi[	@”#i I"Cmodule ActiveRecord
  module AttributeMethods
    module Query;Fi [	@$i I"Bmodule ActiveRecord
  module AttributeMethods
    module Read;Fi [	@∞i I"Kmodule ActiveRecord
  module AttributeMethods
    module Serialization;Fi [	@≥i I"Pmodule ActiveRecord
  module AttributeMethods
    module TimeZoneConversion;Fi [	I"Iprojects//activerecord_proj/active_record/attribute_methods/write.rb;Ti I"Cmodule ActiveRecord
  module AttributeMethods
    module Write;Fi [	@¸iI"~require("active_support/core_ext/enumerable")
module ActiveRecord
  module AttributeMethods
    extend(ActiveSupport::Concern);Fi[	@@:i[[	@i$I"ö    # Transform the contents based on the content type.
    #
    # Returns nothing.
    def function
      self.content = converter.convert(self.content);Fi[	@Z
i#I"    # Public: Read, process, and write this Site to output.
    #
    # Returns nothing.
    def function
      self.reset;Fi[	@Z
iCI"ö    # Load necessary libraries, plugins, converters, and generators.
    #
    # Returns nothing.
    def function
      require("classifier") if self.lsi;Fi[	@Z
iVI"è    # Read Site data from disk and load it into internal data structures.
    #
    # Returns nothing.
    def function
      self.read_layouts;Fi[	@Z
i_I"|    # with each one.
    #
    # Returns nothing.
    def function
      var = File.join(self.source, self.config["STRING"]);Fi[	@Z
i°I"á    # Run each of the Generators.
    #
    # Returns nothing.
    def function
      self.generators.each { |var| var.generate(self) };Fi[	@Z
i®I"h    # Render the site to the destination.
    #
    # Returns nothing.
    def function
      begin;Fi[	@Z
i∑I"É    # Remove orphaned files and empty directories in destination.
    #
    # Returns nothing.
    def function
      var = Set.new;Fi[	@Z
i⁄I"é    # Write static files, pages, and posts.
    #
    # Returns nothing.
    def function
      self.posts.each { |var| var.write(self.dest) };Fi[	@/@—$i[[	@ÊiI"}    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :park do;Fi[	@Êi>I"}    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :park do;Fi[	@Ìi@I"~    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do;Fi[	@ÌirI"~    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do;Fi[	@iCI"î    # generated on the class.  For example,
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do;Fi[	@)iI"~    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling;Fi[	@)i)I"~    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling;Fi[	@)iDI"~    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling;Fi[	@3i¸I"~    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do;Fi[	@:I"@var = true;Fi[[	@®i.I"ò      
      # Asserts the \target has been loaded setting the \loaded flag to +true+.
      def function
        @var = true
        @var = stale_state;Fi[	@∫iII"U      end
      
      def function
        @var = true
        perform_rollback;Fi[	@∫iOI"S      end
      
      def function
        @var = true
        perform_commit;Fi[	@iI"Z    
    # Marks this record as read only.
    def function
      @var = true
    end;Fi[	I"4projects//compass_proj/compass/commands/base.rb;Ti!I"F      end
      
      def function
        @var = true
      end;Fi[	@0i^I"ß      # If you don't want reconfirmation to be sent, neither a code
      # to be generated, call skip_reconfirmation!
      def function
        @var = true
      end;Fi[	@0i¨I"h      end
      
      def function
        @var = true
        self.unconfirmed_email = self.email;Fi[	I"?projects//diaspora_proj/controllers/contacts_controller.rb;TiI"R  end
  
  def function
    @var = true
    @var = Person.community_spotlight;Fi[	@k
iœI"n    
    # Tracks that before callbacks have now completed
    def function
      @var = true
      super;Fi[	@@£i[[	@iI"p    # site - The Site.
    #
    # Returns nothing.
    def function(var)
      var.pages.dup.each do |var|;Fi[	@‚i'I"ä    # name - The String filename of the layout file.
    #
    # Returns nothing.
    def function(var)
      self.ext = File.extname(var);Fi[	@i]I"à    # name - The String filename of the page file.
    #
    # Returns nothing.
    def function(var)
      self.ext = File.extname(var);Fi[	@iI"Ñ    # dest - The String path to the destination dir.
    #
    # Returns nothing.
    def function(var)
      var = destination(var);Fi[	@
iZI"v    # name - The String filename of the post file.
    #
    # Returns nothing.
    def function(var)
      begin;Fi[	@
i–I"Ñ    # dest - The String path to the destination dir.
    #
    # Returns nothing.
    def function(var)
      var = destination(var);Fi[	@Z
iqI"¶    # dir - The String relative path of the directory to read. Default: ''.
    #
    # Returns nothing.
    def function(var)
      var = File.join(self.source, var);Fi[	@Z
iâI"£    # dir - The String relative path of the directory to read.
    #
    # Returns nothing.
    def function(var)
      var = File.join(self.source, var, "STRING");Fi[	@8iI"ù# path - The String relative path from here to the directory.
#
# Returns nothing.
def function(var)
  var = File.join(File.dirname("STRING"), var, "STRING");Fi[	@I"# == Example;Fi[[	@Ìi=I"¢    # *after* callback with only affect that event's transition.  Other
    # transitions will continue to run their own callbacks.
    # 
    # == Example
    # ;Fi[	@ÌioI"t    # 
    # See StateMachine::InstanceMethods#fire_events for more information.
    # 
    # == Example
    # ;Fi[	@Úi3I"†        # integration is activated, each version that is marked as active will
        # also extend the integration.
        # 
        # == Example
        # ;Fi[	@ıisI"Ã        # Creates a callback that will be invoked *after* a transition failures to
        # be performed so long as the given requirements match the transition.
        # 
        # == Example
        # ;Fi[	@3iìI"~    # Does this transition represent a loopback (i.e. the from and to state
    # are the same)
    # 
    # == Example
    # ;Fi[	@3i°I"©    # A hash of all the core attributes defined for this transition with their
    # names as keys and values of the attributes as values.
    # 
    # == Example
    # ;Fi[	@3i‡I"ë    # transition.  Once the state is persisted, it cannot be persisted again
    # until this transition is reset.
    # 
    # == Example
    # ;Fi[	@3i˘I"£    # Rolls back changes made to the object's state via this transition.  This
    # will revert the state back to the +from+ value.
    # 
    # == Example
    # ;Fi[	@3iñI"í    # Gets a hash of the context defining this unique transition (including
    # event, from state, and to state).
    # 
    # == Example
    # ;Fi[	@<@|i[[	@XiﬁI"ú          var = var.name
          if (var == "STRING") then
            var = "STRING"
          else
            var = var["LITERAL"] if (var == "STRING");Fi[	@∏i˘I"¢      var = var
      if (var == "STRING") and (var == "LITERAL") then
        var = "STRING"
      else
        var = column_alias_for([var, var].join("STRING"));Fi[	@ÏiöI"ì      else
        if var.empty? then
          var = "STRING"
        else
          (var.size == "LITERAL") ? (var = "STRING") : (var = "STRING");Fi[	@Ôi∫I"û        if (var.count("STRING") > "LITERAL") then
          var = var.gsub("STRING", "STRING")
          var = "STRING"
        else
          var = var.strip;Fi[	@i$I"á    def function(var)
      if var.include?("STRING").! then
        var = "STRING"
      else
        if var.include?("STRING").! then;Fi[	@i'I"{      else
        if var.include?("STRING").! then
          var = "STRING"
        else
          return var.inspect;Fi[	@.!iUI"£        if block_given? and yield(var) then
          puts(var)
          var = "STRING"
        else
          (var << var) unless (var.basename.to_s == "STRING");Fi[	@‘iõI"m        var = "STRING"
      when "STRING" then
        var = "STRING"
      else
        var = "STRING";Fi[	@$iI"j        end
        var = Time.now.strftime("STRING")
        var = "STRING"
      else
        super;Fi[	@ÿI"&var.flatten.threaded_map do |var|;Fi[[	@~iWI"ø      #   @param options [Hash] A customizable set of options.
      def function(var)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |var|
          begin;Fi[	@~iyI"ø      #   @param options [Hash] A customizable set of options.
      def function(var)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |var|
          begin;Fi[	@Ÿi\I"      #   @param options [Hash] A customizable set of options.
      def function(var)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |var|
          object_from_response(Twitter::SavedSearch, "LITERAL", "STRING", var.options);Fi[	@ièI"=      #   @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      def function(var)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |var|
          begin;Fi[	@i™I"=      #   @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      def function(var)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |var|
          begin;Fi[	@i˜I"R      #   @option options [String] :lang Language code for the rendered embed. This will affect the text and localization of the rendered HTML.
      def function(var)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |var|
          object_from_response(Twitter::OEmbed, "LITERAL", "STRING", var.options);Fi[	@iI"ı      # @return [Array<Twitter::Tweet>]
      def function(var, var, var)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |var|
          object_from_response(Twitter::Tweet, var, (var + "STRING"), var.options);Fi[	@iI"˜      # @return [Array<Twitter::User>]
      def function(var, var, var)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |var|
          object_from_response(Twitter::User, var, var, merge_user(var.options, var));Fi[	@iHI"Ï      # @return [Array]
      def function(var, var, var, var)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |var|
          object_from_response(var, var, var, var.options.merge("LITERAL" => (var)));Fi[	@ôI"module HTML;Fi[[	I"5projects//nokogiri_proj/nokogiri/html/builder.rb;Ti I"Mmodule Nokogiri
  module HTML
    class Builder < Nokogiri::XML::Builder;Fi [	@’i I"Omodule Nokogiri
  module HTML
    class Document < Nokogiri::XML::Document;Fi [	I"?projects//nokogiri_proj/nokogiri/html/document_fragment.rb;Ti I"_module Nokogiri
  module HTML
    class DocumentFragment < Nokogiri::XML::DocumentFragment;Fi [	@i I"?module Nokogiri
  module HTML
    class ElementDescription;Fi [	@Ï#i I"?module Nokogiri
  module HTML
    class ElementDescription;Fi [	I";projects//nokogiri_proj/nokogiri/html/entity_lookup.rb;Ti I"lmodule Nokogiri
  module HTML
    class EntityDescription < Struct.new("LITERAL", "LITERAL", "LITERAL");Fi [	I"8projects//nokogiri_proj/nokogiri/html/sax/parser.rb;Ti I"1module Nokogiri
  module HTML
    module SAX;Fi [	@∑"i I"1module Nokogiri
  module HTML
    module SAX;Fi [	@˜i I"1module Nokogiri
  module HTML
    module SAX;Fi [	@:I"var = default_desc;Fi[[	@Ï#iI"å      
      unless method_defined?("LITERAL") then
        def function
          var = default_desc
          var ? (var.startTag) : (nil);Fi[	@Ï#iI"ä      
      unless method_defined?("LITERAL") then
        def function
          var = default_desc
          var ? (var.endTag) : (nil);Fi[	@Ï#i&I"é      
      unless method_defined?("LITERAL") then
        def function
          var = default_desc
          var ? (var.saveEndTag) : (nil);Fi[	@Ï#i-I"à      
      unless method_defined?("LITERAL") then
        def function
          var = default_desc
          var ? (var.depr) : (nil);Fi[	@Ï#i4I"à      
      unless method_defined?("LITERAL") then
        def function
          var = default_desc
          var ? (var.desc) : (nil);Fi[	@Ï#i;I"ë      
      unless method_defined?("LITERAL") then
        def function
          var = default_desc
          var ? (var.defaultsubelt) : (nil);Fi[	@Ï#iBI"å      
      unless method_defined?("LITERAL") then
        def function
          var = default_desc
          var ? (var.attrs_opt) : ([]);Fi[	@Ï#iII"ç      
      unless method_defined?("LITERAL") then
        def function
          var = default_desc
          var ? (var.attrs_depr) : ([]);Fi[	@Ï#iPI"å      
      unless method_defined?("LITERAL") then
        def function
          var = default_desc
          var ? (var.attrs_req) : ([]);Fi[	I"module Jobs;FI"module Mail;Fi[[	I"?projects//diaspora_proj/models/jobs/mail/also_commented.rb;Ti I"=module Jobs
  module Mail
    class AlsoCommented < Base;Fi [	I"@projects//diaspora_proj/models/jobs/mail/comment_on_post.rb;Ti I"=module Jobs
  module Mail
    class CommentOnPost < Base;Fi [	I">projects//diaspora_proj/models/jobs/mail/confirm_email.rb;Ti I"<module Jobs
  module Mail
    class ConfirmEmail < Base;Fi [	I"Eprojects//diaspora_proj/models/jobs/mail/invite_user_by_email.rb;Ti I"Amodule Jobs
  module Mail
    class InviteUserByEmail < Base;Fi [	I"6projects//diaspora_proj/models/jobs/mail/liked.rb;Ti I"5module Jobs
  module Mail
    class Liked < Base;Fi [	I":projects//diaspora_proj/models/jobs/mail/mentioned.rb;Ti I"9module Jobs
  module Mail
    class Mentioned < Base;Fi [	I"@projects//diaspora_proj/models/jobs/mail/private_message.rb;Ti I">module Jobs
  module Mail
    class PrivateMessage < Base;Fi [	I"9projects//diaspora_proj/models/jobs/mail/reshared.rb;Ti I"8module Jobs
  module Mail
    class Reshared < Base;Fi [	I"@projects//diaspora_proj/models/jobs/mail/started_sharing.rb;Ti I">module Jobs
  module Mail
    class StartedSharing < Base;Fi [	@ó@îi[[	@J
iµI"Ü      case extname
      when "STRING", "STRING", "STRING", "STRING" then
        "LITERAL"
      when "STRING" then
        "LITERAL";Fi[	@J
i∑I"l        "LITERAL"
      when "STRING" then
        "LITERAL"
      when "STRING" then
        "LITERAL";Fi[	@›
i~I"x        case var.to_s
        when "STRING" then
          "LITERAL"
        when "STRING" then
          "LITERAL";Fi[	@›
iÇI"w          "LITERAL"
        when "LITERAL" then
          "LITERAL"
        when "STRING" then
          "LITERAL";Fi[	@›
iÑI"v          "LITERAL"
        when "STRING" then
          "LITERAL"
        when "STRING" then
          "LITERAL";Fi[	@›
iÜI"v          "LITERAL"
        when "STRING" then
          "LITERAL"
        when "STRING" then
          "LITERAL";Fi[	@›
iåI"w          "LITERAL"
        when "LITERAL" then
          "LITERAL"
        when "STRING" then
          "LITERAL";Fi[	@›
iêI"w          "LITERAL"
        when "LITERAL" then
          "LITERAL"
        when "STRING" then
          "LITERAL";Fi[	@·iTI"c      "LITERAL"
    when "LITERAL" then
      "LITERAL"
    when "STRING" then
      "LITERAL";Fi[	I"@var = var["LITERAL"];F@¡&i[[	@„	iÆI"¿          var = var["LITERAL"]
          @var = @attributes.dup if @attributes.frozen?
          @var = var["LITERAL"]
          @var = var["LITERAL"]
          if var.has_key?("LITERAL") then;Fi[	@i7I"ú      @var = var["LITERAL"]
      @var = var["LITERAL"].new(self, @options)
      @var = var["LITERAL"]
      @var = var["LITERAL"]
      initialize_storage;Fi[	@>iI"¢    def function
      if var = (@string and @string.match(FORMAT)) then
        @var = var["LITERAL"]
        @var = var["LITERAL"]
        @var = var["LITERAL"];Fi[	@>iI"Ø      if var = (@string and @string.match(FORMAT)) then
        @var = var["LITERAL"]
        @var = var["LITERAL"]
        @var = var["LITERAL"]
        @var = var["LITERAL"];Fi[	@>iI"Å        @var = var["LITERAL"]
        @var = var["LITERAL"]
        @var = var["LITERAL"]
        @var = var["LITERAL"]
      end;Fi[	@b
i$I"‰      @var = (var["LITERAL"] or Geometry).parse(var)
      @var = (var["LITERAL"] or Geometry).from_file(@file)
      @var = var["LITERAL"]
      @var = var["LITERAL"]
      @var = var["LITERAL"].nil? ? (true) : (var["LITERAL"]);Fi[	@$iI"f      @var = var
      @var = var
      @var = var["LITERAL"]
      @var = var["LITERAL"]
    end;Fi[	@'i%I"ﬂ      @var = var.states.fetch(var["LITERAL"]).name
      @var = (var["LITERAL"] and var.states.fetch(var["LITERAL"]).name)
      @var = var["LITERAL"]
      @var = var["LITERAL"]
      initial_paths.each { |var| walk(var) };Fi[	@*iBI"Ó      @var = (var["LITERAL"] or @name ? (@name.to_s.tr("STRING", "STRING")) : ("STRING"))
      @var = var.include?("LITERAL") ? (var["LITERAL"]) : (var and var.to_s)
      @var = var["LITERAL"]
      @var = var["LITERAL"]
      @var = {};Fi[	@"&@i[[	@Ìi>I"u    # transitions will continue to run their own callbacks.
    # 
    # == Example
    # 
    #   class Vehicle;Fi[	@ÌipI"~    # See StateMachine::InstanceMethods#fire_events for more information.
    # 
    # == Example
    # 
    #   class Vehicle;Fi[	@Úi4I"v        # also extend the integration.
        # 
        # == Example
        # 
        #   module StateMachine;Fi[	@ıitI"ì        # be performed so long as the given requirements match the transition.
        # 
        # == Example
        # 
        #   class Vehicle;Fi[	@3iîI"c    # are the same)
    # 
    # == Example
    # 
    #   machine = StateMachine.new(Vehicle);Fi[	@3i¢I"Ü    # names as keys and values of the attributes as values.
    # 
    # == Example
    # 
    #   machine = StateMachine.new(Vehicle);Fi[	@3i·I"_    # until this transition is reset.
    # 
    # == Example
    # 
    #   class Vehicle;Fi[	@3i˙I"o    # will revert the state back to the +from+ value.
    # 
    # == Example
    # 
    #   class Vehicle;Fi[	@3ióI"w    # event, from state, and to state).
    # 
    # == Example
    # 
    #   machine = StateMachine.new(Vehicle);Fi[	@Ä#I"module Configuration;Fi[[	@&i I">module Compass
  module Configuration
    module Adapters;Fi [	@≈i I">module Compass
  module Configuration
    module Comments;Fi [	@a"i I"9module Compass
  module Configuration
    class Data;Fi [	@îi I">module Compass
  module Configuration
    module Defaults;Fi [	I">projects//compass_proj/compass/configuration/file_data.rb;Ti I"Dmodule Compass
  module Configuration
    class FileData < Data;Fi [	@ƒi I";module Compass
  module Configuration
    @var = false;Fi [	@»i I"Amodule Compass
  module Configuration
    module Inheritance;Fi [	@∞i I"Cmodule Compass
  module Configuration
    module Serialization;Fi [	I"4projects//compass_proj/compass/configuration.rb;Ti I"Zmodule Compass
  module Configuration
    def self.attributes_for_directory(var, var);Fi [	@nI"&# @return [Array<Twitter::Tweet>];Fi[[	@´i1I"
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @overload list_timeline(list, options={});Fi[	@ÎiI"      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.;Fi[	@Îi,I"
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @overload user_timeline(user, options={});Fi[	@ÎiDI"8      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.;Fi[	@Îi\I"      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.;Fi[	@ÎiqI"      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.;Fi[	@ÎiÉI"      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.;Fi[	@ÎiòI"      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.;Fi[	@iI"      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param id [Integer] The numerical ID of the desired Tweet.;Fi[	I"# Produces:;F@i[[	@ÔiÄI"L    #       = i[0]
    #
    # Produces:
    #
    #     <li>hello</li>;Fi[	@ÔiãI"C    #       %p= val
    #
    # Produces:
    #
    #     <li>;Fi[	@ÔiõI"g    #       %a{ href="#" }= item
    #
    # Produces:
    #
    #     <li class='nav' role='nav'>;Fi[	@Ôi›I"M    #     %strong baz
    #
    # Produces:
    #
    #     <h1>foo</h1>;Fi[	@Ôi¸I"M    #     %strong baz
    #
    # Produces:
    #
    #     <h1>foo</h1>;Fi[	@ÔiI"o    #       %a{:href => "food"} chicken
    #
    # Produces:
    #
    #     (<a href='food'>chicken</a>);Fi[	@ÔiI"]    #       %strong angry
    #
    # Produces:
    #
    #     *<strong>angry</strong>*;Fi[	@Ôi2I"t    #       %span.small Not really
    #
    # Produces:
    #
    #     *<span class='small'>Not really</span>;Fi[	@ÔiDI"T    #       %a{:href=>"thing"} here
    #
    # Produces:
    #
    #     click;Fi[	I"%require("twitter/api/arguments");FI"!require("twitter/api/utils");Fi[[	@qi I"drequire("twitter/api/arguments")
require("twitter/api/utils")
require("twitter/direct_message");Fi [	@~i I"mrequire("twitter/api/arguments")
require("twitter/api/utils")
require("twitter/error/already_favorited");Fi [	@Öi I"\require("twitter/api/arguments")
require("twitter/api/utils")
require("twitter/cursor");Fi [	@´i I"irequire("twitter/api/arguments")
require("twitter/api/utils")
require("twitter/core_ext/enumerable");Fi [	@Ÿi I"brequire("twitter/api/arguments")
require("twitter/api/utils")
require("twitter/saved_search");Fi [	@Ëi I"`require("twitter/api/arguments")
require("twitter/api/utils")
require("twitter/suggestion");Fi [	@i I"mrequire("twitter/api/arguments")
require("twitter/api/utils")
require("twitter/error/already_retweeted");Fi [	@iI"~require("twitter/action_factory")
require("twitter/api/arguments")
require("twitter/api/utils")
require("twitter/cursor");Fi[	@i I"irequire("twitter/api/arguments")
require("twitter/api/utils")
require("twitter/core_ext/enumerable");Fi [	I"	puts;F@	i[[	@Ë	i®I"y      def function
        unless options.any? then
          puts
          puts("STRING")
          puts("STRING");Fi[	@Ë	i´I"w          puts("STRING")
          puts("STRING")
          puts
          puts("STRING")
          puts("STRING");Fi[	@Ë	iÆI"w          puts("STRING")
          puts("STRING")
          puts
          puts("STRING")
          puts("STRING");Fi[	@Ë	iæI"t        end
        if options["LITERAL"] then
          puts
          puts("STRING")
          puts("STRING");Fi[	@ÑiNI"      puts(var.homepage)
      if var.keg_only? then
        puts
        puts("STRING")
        puts(var.keg_only_reason);Fi[	@7iI"Æ        if var.to_s.empty?.! and ($stdout.tty? and var = blacklisted?(var)) then
          unless var.empty? then
            puts
            puts("STRING")
            puts;Fi[	@Êi'I"c      puts("STRING")
      puts("STRING")
      puts
      puts("STRING")
      puts("STRING");Fi[	@˛iaI"X  def function
    if ARGV.verbose?.! then
      puts
      puts("STRING")
    else;Fi[	@}iI"~        var.process
      rescue Jekyll::FatalException => var
        puts
        puts("STRING")
        puts("STRING");Fi[	@£@;i[[	@XiÕI"H      end
      
      def function(var)
        "STRING"
      end;Fi[	@≤i}I"Ö        ##
        # Returns the url for the specified room (in JSON format)
        def function(var)
          "STRING"
        end;Fi[	I"/projects//compass_proj/compass/compiler.rb;Ti5I">    end
    
    def function(var)
      "STRING"
    end;Fi[	I".projects//diaspora_proj/models/profile.rb;Ti∆I"4  end
  
  def function(var)
    "STRING"
  end;Fi[	@i∏I"W      
      # @see Base#render
      def function(var)
        "STRING"
      end;Fi[	@ıi-I"M  (var.bottle.revision + "LITERAL")
end
def function(var)
  "STRING"
end;Fi[	@Í
iZI">    end
    
    def function(var)
      "STRING"
    end;Fi[	@W
iI">    end
    
    def function(var)
      "STRING"
    end;Fi[	@KiyI"H      end
      
      def function(var)
        "STRING"
      end;Fi[	I"%# @return [Array<Twitter::User>];F@:i[[	I"4projects//twitter_proj/twitter/action/follow.rb;TiI"…      # A collection of users who followed a user
      #
      # @return [Array<Twitter::User>]
      def function
        @var = Array(@attrs["LITERAL"]).map { |var| Twitter::User.fetch_or_new(var) };Fi[	@o'iI"…      # A collection containing the followed user
      #
      # @return [Array<Twitter::User>]
      def function
        @var = Array(@attrs["LITERAL"]).map { |var| Twitter::User.fetch_or_new(var) };Fi[	I"?projects//twitter_proj/twitter/action/list_member_added.rb;TiI"–      # A collection of users who added a user to a list
      #
      # @return [Array<Twitter::User>]
      def function
        @var = Array(@attrs["LITERAL"]).map { |var| Twitter::User.fetch_or_new(var) };Fi[	@t'iI"Œ      # A collection of users who were added to a list
      #
      # @return [Array<Twitter::User>]
      def function
        @var = Array(@attrs["LITERAL"]).map { |var| Twitter::User.fetch_or_new(var) };Fi[	I"5projects//twitter_proj/twitter/action/mention.rb;TiI"       # A collection of users who mentioned a user
      #
      # @return [Array<Twitter::User>]
      def function
        @var = Array(@attrs["LITERAL"]).map { |var| Twitter::User.fetch_or_new(var) };Fi[	@y'i%I"       # A collection containing the mentioned user
      #
      # @return [Array<Twitter::User>]
      def function
        @var = Array(@attrs["LITERAL"]).map { |var| Twitter::User.fetch_or_new(var) };Fi[	I"5projects//twitter_proj/twitter/action/retweet.rb;TiI"       # A collection containing the retweeted user
      #
      # @return [Array<Twitter::User>]
      def function
        @var = Array(@attrs["LITERAL"]).map { |var| Twitter::User.fetch_or_new(var) };Fi[	I"3projects//twitter_proj/twitter/action/tweet.rb;TiI"æ      attr_reader("LITERAL", "LITERAL")
      
      # @return [Array<Twitter::User>]
      def function
        @var = Array(@attrs["LITERAL"]).map { |var| Twitter::User.fetch_or_new(var) };Fi[	@OiI"ò    end
    
    # @return [Array<Twitter::User>]
    def function
      @var ||= Array(@attrs["LITERAL"]).map { |var| Twitter::User.fetch_or_new(var) };Fi[	@@'i[[	@ÔiI"e    #     = list_of([['hello'], ['yall']]) do |i|
    #       = i[0]
    #
    # Produces:
    #;Fi[	@ÔiäI"R    #       %h3= key.humanize
    #       %p= val
    #
    # Produces:
    #;Fi[	@ÔiöI"ú    #     = list_of(["Home", "About", "Contact", "FAQ"], {class: "nav", role: "nav"}) do |item|
    #       %a{ href="#" }= item
    #
    # Produces:
    #;Fi[	@Ôi‹I"K    #     - tab_down
    #     %strong baz
    #
    # Produces:
    #;Fi[	@Ôi˚I"I    #       %p bar
    #     %strong baz
    #
    # Produces:
    #;Fi[	@ÔiI"i    #     = surround '(', ')' do
    #       %a{:href => "food"} chicken
    #
    # Produces:
    #;Fi[	@ÔiI"V    #     = surround '*' do
    #       %strong angry
    #
    # Produces:
    #;Fi[	@Ôi1I"^    #     = precede '*' do
    #       %span.small Not really
    #
    # Produces:
    #;Fi[	@ÔiCI"_    #     = succeed '.' do
    #       %a{:href=>"thing"} here
    #
    # Produces:
    #;Fi[	@g#@g#i[[	@j#iI"  # a genericized version of lighten/darken so that negative values can be used.
  def function(var, var)
    assert_type(var, "LITERAL")
    assert_type(var, "LITERAL")
    var.with("LITERAL" => (Compass::Util.restrict((var.lightness + var.value), "LITERAL")));Fi[	@j#iI"Ú  # This will never return a pure light or dark color unless the amount is 100%.
  def function(var, var)
    assert_type(var, "LITERAL")
    assert_type(var, "LITERAL")
    var.with("LITERAL" => (scale_color_value(var.lightness, var.value)));Fi[	@j#iI"  # a genericized version of saturation/desaturate so that negative values can be used.
  def function(var, var)
    assert_type(var, "LITERAL")
    assert_type(var, "LITERAL")
    var.with("LITERAL" => (Compass::Util.restrict((var.saturation + var.value), "LITERAL")));Fi[	@j#i!I"˛  # This will never return a pure saturated or desaturated color unless the amount is 100%.
  def function(var, var)
    assert_type(var, "LITERAL")
    assert_type(var, "LITERAL")
    var.with("LITERAL" => (scale_color_value(var.saturation, var.value)));Fi[	@j#i'I"†  
  def function(var, var)
    assert_type(var, "LITERAL")
    assert_type(var, "LITERAL")
    var = Sass::Script::Color.new(["LITERAL", "LITERAL", "LITERAL"]);Fi[	@j#i.I"†  
  def function(var, var)
    assert_type(var, "LITERAL")
    assert_type(var, "LITERAL")
    var = Sass::Script::Color.new(["LITERAL", "LITERAL", "LITERAL"]);Fi[	@{#i%I"ó  
  def function(var, var)
    assert_type(var, "LITERAL")
    assert_type(var, "LITERAL")
    raise(Sass::SyntaxError, "STRING") unless var.unitless?;Fi[	@{#i;I"ó  
  def function(var, var)
    assert_type(var, "LITERAL")
    assert_type(var, "LITERAL")
    raise(Sass::SyntaxError, "STRING") unless var.unitless?;Fi[	@4iòI"≠  #     background-position: 3px -36px;
  def function(var, var, var, var)
    assert_type(var, "LITERAL")
    assert_type(var, "LITERAL")
    var = convert_sprite_name(var);Fi[	I"require("rubygems");FI"require("sequel");Fi[[	@Ni I"?require("rubygems")
require("sequel")
require("fileutils");Fi [	I"3projects//jekyll_proj/jekyll/migrators/enki.rb;TiI"Mrequire("fileutils")
require("rubygems")
require("sequel")
module Jekyll;Fi[	@Ui I"?require("rubygems")
require("sequel")
require("fileutils");Fi [	@\i I"?require("rubygems")
require("sequel")
require("fastercsv");Fi [	@	i I"?require("rubygems")
require("sequel")
require("fileutils");Fi [	@ii I"?require("rubygems")
require("sequel")
require("fileutils");Fi [	I"3projects//jekyll_proj/jekyll/migrators/typo.rb;TiI"Orequire("fileutils")
require("rubygems")
require("sequel")
require("yaml");Fi[	@pi I"?require("rubygems")
require("sequel")
require("fileutils");Fi [	@x%I"-# +:if+, +:unless+, +:on+ and +:strict+.;Fi[[	@fiI"$      # * <tt>:message</tt> - A custom error message (default is: "must be blank").
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information;Fi[	@ii2I"Ì      #   before validation.
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information;Fi[	@i4I"Í      #   confirmation").
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information;Fi[	@qi,I"      #   attribute is blank(default is +false+).
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information;Fi[	@timI"'      #   beginning or end of the string. These anchors are <tt>^</tt> and <tt>$</tt>.
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information;Fi[	@{i+I"      #   attribute is blank (default is +false+).
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information;Fi[	@~ihI"˛      #   which counts individual characters.
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information;Fi[	@i!I"%      # * <tt>:message</tt> - A custom error message (default is: "can't be blank").
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information;Fi[	@|@	i[[	@≥
iBI"|    if email_like_identifer then
      EmailInviter.new(self.identifier, sender).send!
    else
      puts("STRING")
    end;Fi[	@Ïi*I"è              if ARGV.dry_run? then
                puts("STRING")
              else
                puts("STRING")
                rm_rf(var);Fi[	@ÏiGI"}          if ARGV.dry_run? then
            puts("STRING")
          else
            puts("STRING")
            rm(var);Fi[	@ÑiI"U          puts("STRING")
        end
      else
        puts("STRING")
      end;Fi[	@ÑiaI"t          puts("STRING") unless var.used_options.empty?
        end
      else
        puts("STRING")
      end;Fi[	@.!iiI"R    when "LITERAL" then
      puts(var)
    else
      puts("STRING")
    end;Fi[	@Êi(I"]    if var.empty? then
      puts("STRING")
    else
      puts("STRING")
      var.dump;Fi[	@Xi)I"b      when "LITERAL" then
        var = var.first
      else
        puts("STRING")
      end;Fi[	I"require("testing_env");FI"require("test/testball");Fi[[	@≈i I"Arequire("testing_env")
require("test/testball")
module MacOS;Fi [	I"0projects//homebrew_proj/test/test_bucket.rb;Ti I"Prequire("testing_env")
require("test/testball")
class MockFormula < Formula;Fi [	I"3projects//homebrew_proj/test/test_checksums.rb;Ti I"_require("testing_env")
require("test/testball")
class ChecksumTests < Test::Unit::TestCase;Fi [	@Êi I"_require("testing_env")
require("test/testball")
class CompilerTests < Test::Unit::TestCase;Fi [	@3i I"Srequire("testing_env")
require("test/testball")
class AbstractDownloadStrategy;Fi [	I"-projects//homebrew_proj/test/test_keg.rb;Ti I"Crequire("testing_env")
require("test/testball")
require("keg");Fi [	I"1projects//homebrew_proj/test/test_patches.rb;Ti I"Crequire("testing_env")
require("test/testball")
require("set");Fi [	@i I"Vrequire("testing_env")
require("test/testball")
class DefaultPatchBall < TestBall;Fi [	@HI"@var = [];Fi[[	@∫i1I"s      def function(var, var, var)
        super(var)
        @var = var
        @var = []
        @var = false;Fi[	@iKI"Z  
  def function(var)
    @var = var
    @var = []
    @var = var.text.without_patch;Fi[	@‘iI"O  def function(var, var)
    @var = var
    @var = var
    @var = []
  end;Fi[	@ inI"F  
  def function(var)
    @var = var
    @var = []
    @var = [];Fi[	@ÕiKI"u      # The XML source
      def function(var, var, var)
        @var = var
        @var = []
        @var = var;Fi[	@JiI"á      class ValidateAttachmentContentTypeMatcher
        def function(var)
          @var = var
          @var = []
          @var = [];Fi[	@jiI"ù      assert_valid_keys(var, "LITERAL")
      var = { "LITERAL" => "LITERAL" }.merge(var)
      @var = var
      @var = []
      @var = Array(var["LITERAL"]);Fi[	@3iSI"x    def function(var, var, var, var, var, var)
      @var = var
      @var = var
      @var = []
      @var = false;Fi[	I"%#     extend ActiveModel::Naming;F@i[[	@AiI"X    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #;Fi[	@Ai)I"X    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #;Fi[	@Ai7I"X    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #;Fi[	@AiHI"X    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #;Fi[	@AiWI"X    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #;Fi[	@AifI"X    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #;Fi[	@AitI"X    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #;Fi[	@AiöI"X    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #;Fi[	@π$I"I# Removes the transferred archive file(s) from the storage location.;Fi[[	@oi9I"ú      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@¯	i[I"ú      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@‡"iCI"ú      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@„"i$I"ú      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@riAI"ú      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@zi<I"ú      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@i9I"ú      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@i7I"ú      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@I"# :call-seq:;Fi[[	@AiI"F    ##
    # :method: ==
    #
    # :call-seq:
    #   ==(other);Fi[	@Ai"I"H    ##
    # :method: ===
    #
    # :call-seq:
    #   ===(other);Fi[	@Ai0I"G    ##
    # :method: <=>
    #
    # :call-seq:
    #   ==(other);Fi[	@Ai?I"G    ##
    # :method: =~
    #
    # :call-seq:
    #   =~(regexp);Fi[	@AiOI"G    ##
    # :method: !~
    #
    # :call-seq:
    #   !~(regexp);Fi[	@Ai^I"J    ##
    # :method: eql?
    #
    # :call-seq:
    #   eql?(other);Fi[	@AimI"E    ##
    # :method: to_s
    #
    # :call-seq:
    #   to_s();Fi[	@AizI"I    ##
    # :method: to_str
    #
    # :call-seq:
    #   to_str();Fi[	I"{# @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;FI"|# @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;Fi[[	@qiI"      # @return [Array<Twitter::DirectMessage>] Direct messages sent to the authenticating user.
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[	@qi*I"      # @return [Array<Twitter::DirectMessage>] Direct messages sent by the authenticating user.
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[	@ÎiI"‚      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[	@ÎiHI"      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[	@Îi_I"‚      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[	@ÎitI"‚      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[	@ÎiÜI"‚      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[	@ÎiúI"u      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@I"#   class BlogPost;Fi[[	@AiI"∫    # Equivalent to <tt>String#==</tt>. Returns +true+ if the class name and
    # +other+ are equal, otherwise +false+.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming;Fi[	@Ai'I"n    #
    # Equivalent to <tt>#==</tt>.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming;Fi[	@Ai5I"u    #
    # Equivalent to <tt>String#<=></tt>.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming;Fi[	@AiFI"†    # regexp. Returns the position where the match starts or +nil+ if there is
    # no match.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming;Fi[	@AiUI"÷    # Equivalent to <tt>String#!~</tt>. Match the class name against the given
    # regexp. Returns +true+ if there is no match, otherwise +false+.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming;Fi[	@AidI"”    # Equivalent to <tt>String#eql?</tt>. Returns +true+ if the class name and
    # +other+ have the same length and content, otherwise +false+.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming;Fi[	@AirI"j    #
    # Returns the class name.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming;Fi[	@AiòI"     # Transform the model name into a more humane format, using I18n. By default,
    # it will underscore then humanize the class name.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming;Fi[	@:I"$var = remote_path_for(@package);Fi[[	@oi/I"ƒ      ##
      # Transfers the archived file to the specified Cloud Files container
      def function
        var = remote_path_for(@package)
        files_to_transfer_for(@package) do |var, var|;Fi[	@¯	iQI"Ω      ##
      # Transfers the archived file to the specified Dropbox folder
      def function
        var = remote_path_for(@package)
        files_to_transfer_for(@package) do |var, var|;Fi[	@‡"i8I"¢      ##
      # Transfers the archived file to the specified remote server
      def function
        var = remote_path_for(@package)
        connection do |var|;Fi[	@„"iI"ú      ##
      # Transfers the archived file to the specified path
      def function
        var = remote_path_for(@package)
        FileUtils.mkdir_p(var);Fi[	@ri6I"©      ##
      # Transfers the archived file to the specified directory
      def function
        var = remote_path_for(@package)
        var = directory_for(var, true);Fi[	@zi1I"ß      ##
      # Transfers the archived file to the specified Amazon S3 bucket
      def function
        var = remote_path_for(@package)
        connection.sync_clock;Fi[	@i.I"¢      ##
      # Transfers the archived file to the specified remote server
      def function
        var = remote_path_for(@package)
        connection do |var|;Fi[	@i,I"¢      ##
      # Transfers the archived file to the specified remote server
      def function
        var = remote_path_for(@package)
        connection do |var|;Fi[	@a(@(i[[	@AiI"~    # +other+ are equal, otherwise +false+.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end;Fi[	@Ai(I"t    # Equivalent to <tt>#==</tt>.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end;Fi[	@Ai6I"{    # Equivalent to <tt>String#<=></tt>.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end;Fi[	@AiGI"b    # no match.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end;Fi[	@AiVI"ì    # regexp. Returns +true+ if there is no match, otherwise +false+.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end;Fi[	@AieI"ê    # +other+ have the same length and content, otherwise +false+.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end;Fi[	@AisI"p    # Returns the class name.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end;Fi[	@AiôI"Ñ    # it will underscore then humanize the class name.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end;Fi[	I"%assert(var.mach_o_executable?.!);FI"#assert(var.text_executable?.!);Fi[[	@u"iI"õ    assert(var.ppc64?.!)
    assert(var.dylib?)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert((var.arch == "LITERAL"));Fi[	@u"i I"ò    assert(var.ppc64?.!)
    assert(var.dylib?)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?.!);Fi[	@u"i.I"ò    assert(var.ppc64?.!)
    assert(var.dylib?)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?.!);Fi[	@u"iJI"ò    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?);Fi[	@u"iXI"ò    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?);Fi[	@u"ifI"ò    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?);Fi[	@u"itI"ö    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?.!);Fi[	@u"i≥I"ô    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert_equal([], var.archs);Fi[	@H@Œi[[	@ÒiI"ämodule ActiveRecord
  class InverseOfAssociationNotFoundError < ActiveRecordError
    def function(var, var)
      super("STRING")
    end;Fi[	@ÒiI"~  
  class HasManyThroughAssociationNotFoundError < ActiveRecordError
    def function(var, var)
      super("STRING")
    end;Fi[	@ÒiI"à  
  class HasManyThroughAssociationPolymorphicThroughError < ActiveRecordError
    def function(var, var)
      super("STRING")
    end;Fi[	@Òi:I"ê  
  class HasManyThroughCantAssociateThroughHasOneOrManyReflection < ActiveRecordError
    def function(var, var)
      super("STRING")
    end;Fi[	@Òi@I"}  
  class HasManyThroughCantAssociateNewRecords < ActiveRecordError
    def function(var, var)
      super("STRING")
    end;Fi[	@ÒiFI"~  
  class HasManyThroughCantDissociateNewRecords < ActiveRecordError
    def function(var, var)
      super("STRING")
    end;Fi[	@ÒiLI"É  
  class HasManyThroughNestedAssociationsAreReadonly < ActiveRecordError
    def function(var, var)
      super("STRING")
    end;Fi[	@yi?I"q    attr_reader("LITERAL", "LITERAL")
    
    def function(var, var)
      super("STRING")
      @var = var;Fi[	@r"I"assert(var.dylib?.!);Fi[[	@u"i:I"â    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?);Fi[	@u"iHI"ã    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!);Fi[	@u"iVI"ã    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!);Fi[	@u"idI"â    assert(var.x86_64?)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!);Fi[	@u"irI"ã    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!);Fi[	@u"iëI"ã    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!);Fi[	@u"i°I"ã    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!);Fi[	@u"i±I"ã    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!);Fi[	@|@<i[[	@ØiI"¡        if (loaded? or options["LITERAL"]) then
          load_target.map { |var| var.send(reflection.association_primary_key) }
        else
          var = "STRING"
          scope.pluck(var);Fi[	@_$i0I"∏          if var["LITERAL"] then
            log_action("LITERAL", basename(var), var)
          else
            var = "STRING"
            raise(Compass::FilesystemConflict.new(var));Fi[	@_$i:I"á      if var then
        FileUtils.touch(var) unless var["LITERAL"]
      else
        var = "STRING"
        (var << "STRING") if var;Fi[	@»i=I"Ø            if var = @data.raw(var) then
              "STRING"
            else
              var = "STRING"
              if var = @data.instance_variable_get("STRING") then;Fi[	@Ω i&I"≤    if (var > "LITERAL") then
      link_to("STRING", post_comments_path(var, "LITERAL" => "STRING"), "LITERAL" => "STRING")
    else
      var = "STRING"
      (var << "STRING");Fi[	@∫ihI"Ñ    if self.unprocessed_image.url.match("LITERAL") then
      var = self.unprocessed_image.url
    else
      var = "STRING"
    end;Fi[	@‘iúI"`      when "STRING" then
        var = "STRING"
      else
        var = "STRING"
      end;Fi[	@giI"Ö          var = "STRING"
          var = [dump_exception(var)]
        else
          var = "STRING"
          var = pretty(var, var);Fi[	I"	end);F@Æi[[	@gitI"î                raise(ConnectionTimeoutError, var)
              end
            end)
          ensure
            @var = (@num_waiting - "LITERAL");Fi[	I"9projects//activerecord_proj/active_record/railtie.rb;TiYI"ﬂ          unless var.config.active_record.delete("LITERAL").nil? then
            ActiveSupport::Deprecation.warn("STRING".strip_heredoc, [])
          end)
        ensure
          ActiveSupport::Deprecation.behavior = var;Fi[	@uiGI"ê              run((("STRING" + "STRING") + "STRING"))
            end
          end)
        ensure
          remove_password_file! unless local;Fi[	@ˇ	iI"†              Logger.message("STRING")
              run((("STRING" + "STRING") + "STRING"))
            end)
          ensure
            remove_password_file!;Fi[	@ÏiI"ç        else
          send(:"compile_#{var.type}") { var.children.each { |var| compile(var) } }
        end)
      ensure
        @var = var;Fi[	@i{I"ó      rescue ::SyntaxError => var
        raise(SyntaxError, var.message)
      end)
      ensure
        var.instance_eval { @var = var.upper if var };Fi[	@ÔinI"â          end
          var.map { |var| var[(var.."LITERAL")] }.join
        end)
      ensure
        haml_buffer.capture_position = nil;Fi[	@i¢I"û        unless @failure_hooks_ran then
          failure_hooks.each { |var| payload_class.send(var, var, *var) }
        end)
      ensure
        @var = true;Fi[	@:I"!var = Pathname.new("STRING");Fi[[	@u"i
I"~end
class MachOPathnameTests < Test::Unit::TestCase
  def function
    var = Pathname.new("STRING")
    assert(var.universal?);Fi[	@u"iI"Z  end
  
  def function
    var = Pathname.new("STRING")
    assert(var.universal?.!);Fi[	@u"i&I"Z  end
  
  def function
    var = Pathname.new("STRING")
    assert(var.universal?.!);Fi[	@u"i4I"X  end
  
  def function
    var = Pathname.new("STRING")
    assert(var.universal?);Fi[	@u"iBI"X  end
  
  def function
    var = Pathname.new("STRING")
    assert(var.universal?);Fi[	@u"iPI"Z  end
  
  def function
    var = Pathname.new("STRING")
    assert(var.universal?.!);Fi[	@u"i^I"Z  end
  
  def function
    var = Pathname.new("STRING")
    assert(var.universal?.!);Fi[	@u"ilI"Z  end
  
  def function
    var = Pathname.new("STRING")
    assert(var.universal?.!);Fi[	I"module ClassMethods;F@£i[[	I"Sprojects//activemodel_proj/active_model/deprecated_mass_assignment_security.rb;Ti	I"t    extend(ActiveSupport::Concern)
    
    module ClassMethods
      def function(var)
        raise("STRING");Fi[	@˜i,I"Y      end
      
      module ClassMethods
        def function(var)
          super;Fi[	@iI"j    end
    
    module ClassMethods
      def function(var)
        var.initialize_generated_modules;Fi[	@i(I"t      end
      
      module ClassMethods
        def function(var)
          var, var = super, var["LITERAL"];Fi[	@»iI"e      end
      
      module ClassMethods
        def function(var)
          var.each do |var|;Fi[	@¶i4I"^    end
    
    module ClassMethods
      def function(var)
        class_eval("STRING");Fi[	@≥iI"π      included { helper_method("LITERAL", "LITERAL", "LITERAL") }
      
      module ClassMethods
        def function(var)
          var["LITERAL"] ||= "LITERAL" unless var["LITERAL"];Fi[	@i-I"î      end
      
      module ClassMethods
        def function(var)
          find_for_authentication("LITERAL" => (var[token_authentication_key]));Fi[	@n!@|i[[	@q!i#I"œ    if var.present? and @conversation.save then
      Postzord::Dispatcher.build(current_user, @conversation).post
      flash["LITERAL"] = I18n.t("STRING")
    else
      flash["LITERAL"] = I18n.t("STRING");Fi[	@µi+I"ú    end
    if current_user.update_profile(@profile_attrs) then
      flash["LITERAL"] = I18n.t("STRING")
    else
      flash["LITERAL"] = I18n.t("STRING");Fi[	@~!i#I"æ        Resque.enqueue(Jobs::FetchProfilePhoto, current_user.id, var.id, var["STRING"])
      end
      flash["LITERAL"] = I18n.t("STRING")
    else
      flash["LITERAL"] = I18n.t("STRING");Fi[	@Å!i"I"–      if var["LITERAL"] then
        @user.update_user_preferences(var["LITERAL"])
        flash["LITERAL"] = I18n.t("STRING")
      else
        if var["LITERAL"] and (var["LITERAL"] and var["LITERAL"]) then;Fi[	@Å!i'I"∑          if @user.update_with_password(var) then
            var = true
            flash["LITERAL"] = I18n.t("STRING")
          else
            flash["LITERAL"] = I18n.t("STRING");Fi[	@Å!i.I"⁄          if (var["LITERAL"] or var["LITERAL"]) then
            if @user.update_attributes(var) then
              flash["LITERAL"] = I18n.t("STRING")
            else
              flash["LITERAL"] = I18n.t("STRING");Fi[	@Å!i6I"⁄              if @user.update_attributes(var) then
                I18n.locale = @user.language
                flash["LITERAL"] = I18n.t("STRING")
              else
                flash["LITERAL"] = I18n.t("STRING");Fi[	@Å!iFI"‰                if var["LITERAL"] then
                  if @user.update_attributes(var) then
                    flash["LITERAL"] = I18n.t("STRING")
                  else
                    flash["LITERAL"] = I18n.t("STRING");Fi[	@H@|i[[	@NiI"f      if var.is_a?(Hash) then
        @var = nil
        @var = var
      else
        @var = var;Fi[	I"-projects//backup_proj/backup/template.rb;TiI"y    def function(var)
      if var.is_a?(Binding) then
        @var = var
      else
        if var.is_a?(Hash) then;Fi[	@a"i\I"à        if block_given? then
          @set_attributes["LITERAL"] = true
          @var = var
        else
          if @asset_host then;Fi[	@a"iwI"á        if block_given? then
          @set_attributes["LITERAL"] = true
          @var = var
        else
          if var.nil?.! then;Fi[	@®iSI"j        if var then
          @var = var
          @var = var
        else
          @welcome_message;Fi[	@˙i I"É        if var then
          @var = var.document
          @var = var
        else
          var = self.class.name.split("STRING");Fi[	@iI"â        @var = var.delete("LITERAL")
        @var = var.delete("LITERAL")
        @var = var
      else
        if var.is_a?(String) then;Fi[	@`i/I"¥      @var = Redis::Namespace.new(var, "LITERAL" => (var))
    when Redis::Namespace then
      @var = var
    else
      @var = Redis::Namespace.new("LITERAL", "LITERAL" => (var));Fi[	@|@M%i[[	@ÀiI"á        if var and var.! then
          var.destroy
        else
          if var then
            var = construct_join_attributes(var);Fi[	@ÜiuI"Ê          var = var["LITERAL"].to_s if var.key?("LITERAL")
          var = var["LITERAL"] ? ("STRING") : ("STRING") if supports_partial_index?
        else
          if var then
            var = (("STRING" + "STRING") + "STRING");Fi[	@
i4I"}              (var << var)
              var = false
            else
              if var then
                case var;Fi[	@Ç
i,I"ç          if var and use_insert_returning? then
            select_value("STRING")
          else
            if var then
              super;Fi[	@%iéI"q                end
              end
            else
              if var then
                if var then;Fi[	I"5projects//diaspora_proj/models/status_message.rb;TiTI"≤      if var["LITERAL"] then
        var ? (ERB::Util.h(var.name)) : (ERB::Util.h($~["LITERAL"]))
      else
        if var then
          person_link(var, "LITERAL" => "STRING");Fi[	@
iàI"~          var = "STRING"
          var = var
        else
          if var then
            var = "STRING" if var =~ "LITERAL";Fi[	@6iXI"†          @var = var
          parse_time
        else
          if var then
            if (@at.is_a?(Time) or (@at.is_a?(Numeric) and (@at > "LITERAL"))) then;Fi[	@£I"var = remote_path_for(var);Fi[[	@oi=I"Á      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(var)
        var = remote_path_for(var)
        transferred_files_for(var) do |var, var|;Fi[	@¯	i_I"«      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(var)
        var = remote_path_for(var)
        var = [];Fi[	@‡"iGI"“      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(var)
        var = remote_path_for(var)
        connection do |var|;Fi[	@„"i(I"«      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(var)
        var = remote_path_for(var)
        var = [];Fi[	@riEI"ﬂ      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(var)
        var = remote_path_for(var)
        if var = directory_for(var) then;Fi[	@zi@I"‘      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(var)
        var = remote_path_for(var)
        connection.sync_clock;Fi[	@i=I"«      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(var)
        var = remote_path_for(var)
        var = [];Fi[	@i;I"“      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(var)
        var = remote_path_for(var)
        connection do |var|;Fi[	@|@ni[[	@Øi	I"            loaded? ? (target.include?(var)) : (scope.exists?(var))
          end
        else
          false
        end;Fi[	@¸iWI"L            true
          end
        else
          false
        end;Fi[	@Qi%I"p          ActiveSupport::Deprecation.warn("STRING")
          true
        else
          false
        end;Ti[	@ÓiI"T    when String, Array then
      var.length.zero?
    else
      false
    end;Fi[	@ivI"õ        if unlock_strategy_enabled?("LITERAL") then
          locked_at and (locked_at < self.class.unlock_in.ago)
        else
          false
        end;Fi[	@'
iãI"Ö    if self.hidden_shareables.has_key?(var) then
      self.hidden_shareables[var].include?(var.id.to_s)
    else
      false
    end;Fi[	@'
iLI"a      Postzord::Dispatcher.build(self, profile).post
      true
    else
      false
    end;Fi[	@i@I"ç      if (var.length == var.length) then
        TransitionCollection.new(var, "LITERAL" => (var)).perform
      else
        false
      end;Fi[	I"B# and a warning will be logged, containing the error message.;F@£i[[	@oi<I"      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(var)
        var = remote_path_for(var);Fi[	@¯	i^I"      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(var)
        var = remote_path_for(var);Fi[	@‡"iFI"      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(var)
        var = remote_path_for(var);Fi[	@„"i'I"      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(var)
        var = remote_path_for(var);Fi[	@riDI"      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(var)
        var = remote_path_for(var);Fi[	@zi?I"      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(var)
        var = remote_path_for(var);Fi[	@i<I"      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(var)
        var = remote_path_for(var);Fi[	@i:I"      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(var)
        var = remote_path_for(var);Fi[	I"6# Any error raised will be rescued during Cycling;F@|)i[[	@oi;I"Á      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(var);Fi[	@¯	i]I"Á      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(var);Fi[	@‡"iEI"Á      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(var);Fi[	@„"i&I"Á      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(var);Fi[	@riCI"Á      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(var);Fi[	@zi>I"Á      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(var);Fi[	@i;I"Á      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(var);Fi[	@i9I"Á      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(var);Fi[	@ÎI"module Syncer;Fi[[	I"0projects//backup_proj/backup/syncer/base.rb;Ti I"1module Backup
  module Syncer
    class Base;Fi [	@%iI"wBackup::Dependency.load("STRING")
Backup::Dependency.load("STRING")
module Backup
  module Syncer
    module Cloud;Fi[	@}i I"3module Backup
  module Syncer
    module Cloud;Fi [	@Äi I"3module Backup
  module Syncer
    module Cloud;Fi [	@Éi I"3module Backup
  module Syncer
    module RSync;Fi [	@8i I"3module Backup
  module Syncer
    module RSync;Fi [	@ˇ	i I"3module Backup
  module Syncer
    module RSync;Fi [	@Üi I"3module Backup
  module Syncer
    module RSync;Fi [	@I"# @param hash [Hash];Fi[[	@´i=I"∆      
      # Take a list and merge it into the hash with the correct key
      #
      # @param hash [Hash]
      # @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.;Fi[	@´iQI"Œ      
      # Take an owner and merge it into the hash with the correct key
      #
      # @param hash [Hash]
      # @param user[Integer, String, Twitter::User] A Twitter user ID, screen_name, or object.;Fi[	@i|I"Õ      
      # Take a user and merge it into the hash with the correct key
      #
      # @param hash [Hash]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen_name, or object.;Fi[	@iÖI"Õ      
      # Take a user and merge it into the hash with the correct key
      #
      # @param hash [Hash]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen_name, or object.;Fi[	@iòI"      
      # Take a multiple users and merge them into the hash with the correct keys
      #
      # @param hash [Hash]
      # @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen_names, or objects.;Fi[	@i°I"      
      # Take a multiple users and merge them into the hash with the correct keys
      #
      # @param hash [Hash]
      # @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen_names, or objects.;Fi[	I"1projects//twitter_proj/twitter/exceptable.rb;TiI"~    
    # Return a hash that includes everything but the given keys.
    #
    # @param hash [Hash]
    # @param key [Symbol];Fi[	@≈)iI"r    
    # Replaces the hash without the given keys.
    #
    # @param hash [Hash]
    # @param key [Symbol];Fi[	@	@|i[[	@Ïi)I"ü            if Keg.new(var).linked?.! then
              if ARGV.dry_run? then
                puts("STRING")
              else
                puts("STRING");Fi[	@ÏiFI"ÿ        if ((var and (var.version > var)) or ((ARGV.switch?("STRING") and (var and var.installed?.!)) or var)) then
          if ARGV.dry_run? then
            puts("STRING")
          else
            puts("STRING");Fi[	I"'projects//homebrew_proj/cmd/diy.rb;TiI"™    var = ((HOMEBREW_CELLAR / var) / var)
    if File.file?("STRING") then
      puts("STRING")
    else
      File.file?("STRING") ? (puts("STRING")) : (raise("STRING"));Fi[	@IiI"a      puts("STRING")
      puts("STRING")
      puts("STRING")
    else
      ohai("STRING");Fi[	I",projects//homebrew_proj/cmd/outdated.rb;TiI"µ      if $stdout.tty? and ARGV.flag?("STRING").! then
        var = var.rack.subdirs.map { |var| Keg.new(var).version }.sort
        puts("STRING")
      else
        puts(var.name);Fi[	@Êi'I"    Homebrew.link_tap_formula(var.new_tapped_formula)
    if var.empty? then
      puts("STRING")
    else
      puts("STRING");Fi[	@Èi@I"l      ohai("STRING")
      if @tarball_path.exist? then
        puts("STRING")
      else
        begin;Fi[	@˛ibI"g    if ARGV.verbose?.! then
      puts
      puts("STRING")
    else
      require("cmd/--config");Fi[	@'(@è)i[[	@oi:I"÷      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@¯	i\I"÷      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@‡"iDI"÷      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@„"i%I"÷      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@riBI"÷      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@zi=I"÷      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@i:I"÷      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@i8I"÷      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	I"J# See <tt>ActiveModel::Validation#validates</tt> for more information;F@£i[[	@fiI"!      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(var)
        validates_with(AbsenceValidator, _merge_attributes(var));Fi[	@ii4I"$      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(var)
        validates_with(AcceptanceValidator, _merge_attributes(var));Fi[	@i6I"&      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(var)
        validates_with(ConfirmationValidator, _merge_attributes(var));Fi[	@qi.I"#      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(var)
        validates_with(ExclusionValidator, _merge_attributes(var));Fi[	@tioI"       # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(var)
        validates_with(FormatValidator, _merge_attributes(var));Fi[	@{i-I"#      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(var)
        validates_with(InclusionValidator, _merge_attributes(var));Fi[	@~ijI"       # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(var)
        validates_with(LengthValidator, _merge_attributes(var));Fi[	@i#I""      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(var)
        validates_with(PresenceValidator, _merge_attributes(var));Fi[	@Ÿ@n
i[[	@iDI"´      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(var, var, var)
        # do nothing
      end;Fi[	@iI"à      
      # Set the sequence to the max value of the table's column.
      def function(var, var, var)
        # do nothing
      end;Fi[	@iiI"≠      # Returns an array of record hashes with the column names as keys and
      # column values as values.
      def function(var, var, var)
        # do nothing
      end;Fi[	I"Dprojects//activerecord_proj/active_record/explain_subscriber.rb;TiI"mmodule ActiveRecord
  class ExplainSubscriber
    def function(var, var, var)
      # do nothing
    end;Fi[	@úi;I"L    end
    
    def function(var, var, var)
      # do nothing
    end;Fi[	I"6projects//compass_proj/compass/sprite_importer.rb;Ti"I"L    end
    
    def function(var, var, var)
      # do nothing
    end;Fi[	@ iI"y  module XML
    class ProcessingInstruction < Node
      def function(var, var, var)
        # do nothing
      end;Fi[	@'iI"Ö        ###
        # Called when an XML declaration is parsed
        def function(var, var, var)
          # do nothing
        end;Fi[	@ƒ'@)i[[	@fiI"Ë      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(var);Fi[	@ii3I"Ë      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(var);Fi[	@i5I"Ë      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(var);Fi[	@qi-I"Ë      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(var);Fi[	@tinI"Ë      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(var);Fi[	@{i,I"Ë      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(var);Fi[	@~iiI"Ë      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(var);Fi[	@i"I"Ë      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(var);Fi[	I"@var ||= false;FI"(instance_eval(&var) if block_given?;Fi[[	I"5projects//backup_proj/backup/compressor/bzip2.rb;TiI"â      def function(var)
        load_defaults!
        @var ||= false
        instance_eval(&var) if block_given?
        @var = "STRING";Fi[	I"4projects//backup_proj/backup/compressor/gzip.rb;TiI"â      def function(var)
        load_defaults!
        @var ||= false
        instance_eval(&var) if block_given?
        @var = "STRING";Fi[	I"4projects//backup_proj/backup/compressor/lzma.rb;TiI"à        load_defaults!
        @var ||= false
        @var ||= false
        instance_eval(&var) if block_given?
        @var = "STRING";Fi[	I"6projects//backup_proj/backup/compressor/pbzip2.rb;TiI"à        @var ||= false
        @var ||= false
        @var ||= false
        instance_eval(&var) if block_given?
        @var = "STRING";Fi[	@ci5I"ò        @var ||= Array.new
        @var ||= false
        @var ||= false
        instance_eval(&var) if block_given?
        @var ||= utility("LITERAL");Fi[	@‡"iI"§        @var ||= "LITERAL"
        @var ||= "STRING"
        @var ||= false
        instance_eval(&var) if block_given?
        @var = path.sub("LITERAL", "STRING");Fi[	@ui!I"§        @var ||= "LITERAL"
        @var ||= "STRING"
        @var ||= false
        instance_eval(&var) if block_given?
        @var = path.sub("LITERAL", "STRING");Fi[	@Üi'I"          super
          @var ||= "LITERAL"
          @var ||= false
          instance_eval(&var) if block_given?
        end;Fi[	@|I"[];Fi[[	@
i#I"W            File.basename(var)
          end
        else
          []
        end;Fi[	I"&projects//compass_proj/compass.rb;TiI"ï      if ENV["STRING"] and File.directory?(ENV["STRING"]) then
        [File.join(ENV["STRING"], "STRING", "STRING")]
      else
        []
      end;Fi[	I"Gprojects//diaspora_proj/helpers/interim_stream_hackiness_helper.rb;Ti#I"}    if defined? @stream and (params["LITERAL"] == "STRING") then
      @stream.post_from_group(var)
    else
      []
    end;Fi[	@˝ißI"}      if (var["LITERAL", "LITERAL"] == "STRING") then
        ["LITERAL", "STRING", nil]
      else
        []
      end;Fi[	@˝iØI"~      if (var["LITERAL", "LITERAL"] == "STRING") then
        ["LITERAL", "STRING", true]
      else
        []
      end;Fi[	@˝i∑I"      if (var["LITERAL", "LITERAL"] == "STRING") then
        ["LITERAL", "STRING", false]
      else
        []
      end;Fi[	@˝i»I">          end
        end
      else
        []
      end;Fi[	@@yi[[	@~iI""      # @overload favorites(user, options={})
      #   Returns the 20 most recent favorite Tweets for the specified user
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.;Fi[	@ÖiI"0      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.;Fi[	@Öi7I"/      # @overload follower_ids(user, options={})
      #   Returns an array of numeric IDs for every user following the specified user
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.;Fi[	@ÖiI"0      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.;Fi[	@Öi*I"0      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.;Fi[	@i@I")      # @overload following_followers_of(user, options={})
      #   Returns users following followers of the authenticated user
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.;Fi[	@iI"	      # @overload user(user, options={})
      #   Returns extended information for a given user
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.;Fi[	@@ei[[	@~iI":      # @overload favorites(options={})
      #   Returns the 20 most recent favorite Tweets for the authenticating user
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 100.;Fi[	@ÖiI"       # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@Öi0I"ü      # @overload follower_ids(options={})
      #   Returns an array of numeric IDs for every user following the authenticated user
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@ÖiI"       # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@Öi!I"       # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@i7I"ì      # @overload following_followers_of(options={})
      #   Returns users following followers of the specified user
      #
      #   @param options [Hash] A customizable set of options.
      #     @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@iI"&      # @overload user(options={})
      #   Returns extended information for the authenticated user
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :skip_status Do not include user's Tweets when set to true, 't' or 1.;Fi[	@I"# @param attrs [Hash];Fi[[	@oi7I"f    
    # Initializes a new object
    #
    # @param attrs [Hash]
    # @return [Twitter::Base];Fi[	@oiNI"p    
    # Update the attributes of an object
    #
    # @param attrs [Hash]
    # @return [Twitter::Base];Fi[	@/iI"°    
    # Initializes a new Cursor
    #
    # @param attrs [Hash]
    # @param collection_name [String, Symbol] The name of the method to return the collection;Fi[	@[iI"õ    
    # Initializes a new object
    #
    # @param attrs [Hash]
    # @raise [ArgumentError] Error raised when supplied argument is missing an :id key.;Fi[	@ri*I"w    
    # Update the attributes of a RateLimit
    #
    # @param attrs [Hash]
    # @return [Twitter::RateLimit];Fi[	@Di	I"â  class Relationship < Twitter::Base
    # Initializes a new object
    #
    # @param attrs [Hash]
    # @return [Twitter::Relationship];Fi[	@DiI"}    
    # Update the attributes of a Relationship
    #
    # @param attrs [Hash]
    # @return [Twitter::Relationship];Fi[	I"module Resque;FI"module Failure;Fi[[	I"5projects//rescue_proj/resque/failure/airbrake.rb;TiI"fend
require("resque/failure/thoughtbot")
module Resque
  module Failure
    class Airbrake < Base;Fi[	@i I"2module Resque
  module Failure
    class Base;Fi [	I"4projects//rescue_proj/resque/failure/hoptoad.rb;TiI"eend
require("resque/failure/thoughtbot")
module Resque
  module Failure
    class Hoptoad < Base;Fi[	@Pi I"=module Resque
  module Failure
    class Multiple < Base;Fi [	I"2projects//rescue_proj/resque/failure/redis.rb;TiI"Jrequire("time")
module Resque
  module Failure
    class Redis < Base;Fi[	I"7projects//rescue_proj/resque/failure/thoughtbot.rb;Ti I"9module Resque
  module Failure
    module Thoughtbot;Fi [	I",projects//rescue_proj/resque/failure.rb;Ti I"<module Resque
  module Failure
    def self.create(var);Fi [	@@l'i[[	@o'iI"      
      # A collection of users who followed a user
      #
      # @return [Array<Twitter::User>]
      def function;Fi[	@o'iI"      
      # A collection containing the followed user
      #
      # @return [Array<Twitter::User>]
      def function;Fi[	@t'iI"Å      
      # A collection of users who added a user to a list
      #
      # @return [Array<Twitter::User>]
      def function;Fi[	@t'iI"      
      # A collection of users who were added to a list
      #
      # @return [Array<Twitter::User>]
      def function;Fi[	@y'iI"{      
      # A collection of users who mentioned a user
      #
      # @return [Array<Twitter::User>]
      def function;Fi[	@y'i$I"{      
      # A collection containing the mentioned user
      #
      # @return [Array<Twitter::User>]
      def function;Fi[	@~'iI"{      
      # A collection containing the retweeted user
      #
      # @return [Array<Twitter::User>]
      def function;Fi[	I"+File.open("STRING", "STRING") do |var|;FI"var.puts(var);Fi[[	@Ni#I"°          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |var|
          var.puts(var)
          var.puts("STRING");Fi[	@UiI"°          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |var|
          var.puts(var)
          var.puts("STRING");Fi[	@\i"I"°          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |var|
          var.puts(var)
          var.puts("STRING");Fi[	@	iI"°          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |var|
          var.puts(var)
          var.puts("STRING");Fi[	I"8projects//jekyll_proj/jekyll/migrators/posterous.rb;Ti/I"´            (var.nil? or (var == "STRING"))
          end.to_yaml
          File.open("STRING", "STRING") do |var|
            var.puts(var)
            var.puts("STRING");Fi[	@iiI"°          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |var|
          var.puts(var)
          var.puts("STRING");Fi[	@pi]I"ó        (var.nil? or (var == "STRING"))
      end.to_yaml
      File.open("STRING", "STRING") do |var|
        var.puts(var)
        var.puts("STRING");Fi[	@:@ri[[	@®iVI"E      end
      
      def function
        @var = nil
      end;Fi[	@8i—I"E      end
      
      def function
        @var = nil
      end;Fi[	@ƒi:I"X      
      # Support for testing.
      def function
        @var = nil
      end;Fi[	@Æi
I"¿    class Rememberable < Authenticatable
      # A valid strategy for rememberable needs a remember token in the cookies.
      def function
        @var = nil
        remember_cookie.present?;Fi[	@†iI"crequire("testing_env")
module ExtendArgvPlusYeast
  def function
    @var = nil
    @var = nil;Fi[	@’ixI"r          attr_reader("LITERAL")
          
          def function
            @var = nil
            super();Fi[	I"2projects//paperclip_proj/paperclip/helpers.rb;Ti?I";    end
    
    def function
      @var = nil
    end;Fi[	@ßI"0#     include ActiveModel::AttributeMethods;Fi[[	@ i$I"~      # at least the +attr+ argument.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #;Fi[	@ iHI"{      # least the +attr+ argument.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #;Fi[	@ ilI"Ö      # accept at least the +attr+ argument.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #;Fi[	@ iÇI"ã      # Allows you to make aliases for attributes.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #;Fi[	@ i®I"É      # methods, or they will not hook in.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #;Fi[	@ iƒI"Ç      # method, or they will not hook in.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #;Fi[	@ iÎI"ß      # Removes all the previously dynamically defined methods from the class.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #;Fi[	I"$(var.nil? or (var == "STRING"));FI"end.to_yaml;Fi[[	@Ni!I"        var = ((var.strftime("STRING") + var) + "STRING")
        var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var) }.delete_if do |var, var|
          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |var|;Fi[	@UiI"Q        var = ("STRING" % [var.year, var.month, var.day, var])
        var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var["LITERAL"]), "STRING" => (var["LITERAL"]), "STRING" => (var) }.delete_if do |var, var|
          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |var|;Fi[	@\i I"/        var = ([var.year, var.month, var.day, var].join("STRING") + "STRING")
        var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var["LITERAL"]) }.delete_if do |var, var|
          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |var|;Fi[	@	iI"W        var = (([var.year, var.month, var.day, var].join("STRING") + "STRING") + self.suffix(var))
        var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var["LITERAL"]), "STRING" => (var) }.delete_if do |var, var|
          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |var|;Fi[	@∏*i-I"          var = ("STRING" % [var.year, var.month, var.day, var])
          var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var) }.delete_if do |var, var|
            (var.nil? or (var == "STRING"))
          end.to_yaml
          File.open("STRING", "STRING") do |var|;Fi[	@iiI"9        var = ([var.strftime("STRING"), var].join("STRING") + "STRING")
        var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var["LITERAL"].split("STRING")) }.delete_if do |var, var|
          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |var|;Fi[	@pi[I"∂      end
      var = { "STRING" => (var["LITERAL"].to_s), "STRING" => (var["LITERAL"].to_s), "STRING" => ((var["LITERAL"].to_s == "STRING")), "STRING" => (var.to_s), "STRING" => (var["LITERAL"].to_s), "STRING" => (var["LITERAL"].to_s), "STRING" => (var["LITERAL"].to_s), "STRING" => (var["LITERAL"].to_s), "STRING" => (var), "STRING" => (var), "STRING" => (var["LITERAL"]), "STRING" => (var["LITERAL"].to_s), "STRING" => (var), "STRING" => (var["LITERAL"] ? (var) : (nil)), "STRING" => (var["LITERAL"] ? (var) : (nil)), "STRING" => (var["LITERAL"] ? (var) : (nil)) }.delete_if do |var, var|
        (var.nil? or (var == "STRING"))
      end.to_yaml
      File.open("STRING", "STRING") do |var|;Fi[	I" require("twitter/identity");F@i[[	I"1projects//twitter_proj/twitter/basic_user.rb;Ti I"Urequire("twitter/identity")
module Twitter
  class BasicUser < Twitter::Identity;Fi [	I"5projects//twitter_proj/twitter/direct_message.rb;TiI"vrequire("twitter/creatable")
require("twitter/identity")
module Twitter
  class DirectMessage < Twitter::Identity;Fi[	I"+projects//twitter_proj/twitter/list.rb;TiI"mrequire("twitter/creatable")
require("twitter/identity")
module Twitter
  class List < Twitter::Identity;Fi[	I"2projects//twitter_proj/twitter/media/photo.rb;Ti I">require("twitter/identity")
module Twitter
  module Media;Fi [	@∑i I"Qrequire("twitter/identity")
module Twitter
  class Place < Twitter::Identity;Fi [	I"3projects//twitter_proj/twitter/saved_search.rb;TiI"trequire("twitter/creatable")
require("twitter/identity")
module Twitter
  class SavedSearch < Twitter::Identity;Fi[	@…iI"árequire("twitter/creatable")
require("twitter/exceptable")
require("twitter/identity")
module Twitter
  class Tweet < Twitter::Identity;Fi[	I"%def function(var, var, var, var);F@Hi[[	@[iI"¶        attr_reader("LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL")
        
        def function(var, var, var, var)
          @var = var
          @var = var;Fi[	@˛iOI"b  attr("LITERAL")
  
  def function(var, var, var, var)
    @var = var
    @var = ENV.to_hash;Fi[	@iMI"     # num_pages - The Integer number of pages or nil if you'd like the number
    #             of pages calculated.
    def function(var, var, var, var)
      @var = var
      @var = var["STRING"].to_i;Fi[	@iI"≤    # dir  - The String path between the source and the file.
    # name - The String filename of the file.
    def function(var, var, var, var)
      @var = var
      @var = var;Fi[	@
i%I"Ç    #
    # Returns the new Post.
    def function(var, var, var, var)
      @var = var
      @var = File.join(var, var, "STRING");Fi[	@ÌiI"∞    # dir  - The String path between <source> and the file.
    # name - The String filename of the file.
    def function(var, var, var, var)
      @var = var
      @var = var;Fi[	@iI"–      # The string name of the queue from which the failed job was pulled
      # The payload object associated with the failed job
      def function(var, var, var, var)
        @var = var
        @var = var;Fi[	@–*@i[[	@ i%I"}      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name;Fi[	@ iII"}      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name;Fi[	@ imI"}      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name;Fi[	@ iÉI"}      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name;Fi[	@ i©I"à      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name, :age, :address;Fi[	@ i≈I"}      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name;Fi[	@ iÏI"}      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name;Fi[	@‚*@¨*i[[	@Ni"I"Ó        var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var) }.delete_if do |var, var|
          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |var|
          var.puts(var);Fi[	@UiI"*        var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var["LITERAL"]), "STRING" => (var["LITERAL"]), "STRING" => (var) }.delete_if do |var, var|
          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |var|
          var.puts(var);Fi[	@\i!I"˘        var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var["LITERAL"]) }.delete_if do |var, var|
          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |var|
          var.puts(var);Fi[	@	iI"        var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var["LITERAL"]), "STRING" => (var) }.delete_if do |var, var|
          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |var|
          var.puts(var);Fi[	@∏*i.I"¯          var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var) }.delete_if do |var, var|
            (var.nil? or (var == "STRING"))
          end.to_yaml
          File.open("STRING", "STRING") do |var|
            var.puts(var);Fi[	@iiI"	        var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var["LITERAL"].split("STRING")) }.delete_if do |var, var|
          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |var|
          var.puts(var);Fi[	@pi\I"¬      var = { "STRING" => (var["LITERAL"].to_s), "STRING" => (var["LITERAL"].to_s), "STRING" => ((var["LITERAL"].to_s == "STRING")), "STRING" => (var.to_s), "STRING" => (var["LITERAL"].to_s), "STRING" => (var["LITERAL"].to_s), "STRING" => (var["LITERAL"].to_s), "STRING" => (var["LITERAL"].to_s), "STRING" => (var), "STRING" => (var), "STRING" => (var["LITERAL"]), "STRING" => (var["LITERAL"].to_s), "STRING" => (var), "STRING" => (var["LITERAL"] ? (var) : (nil)), "STRING" => (var["LITERAL"] ? (var) : (nil)), "STRING" => (var["LITERAL"] ? (var) : (nil)) }.delete_if do |var, var|
        (var.nil? or (var == "STRING"))
      end.to_yaml
      File.open("STRING", "STRING") do |var|
        var.puts(var);Fi[	@àI"module YARD;Fi[[	@S!i I":module StateMachine
  module YARD
    module Handlers;Fi [	I"Fprojects//state_machine_proj/state_machine/yard/handlers/event.rb;Ti I":module StateMachine
  module YARD
    module Handlers;Fi [	@›iI"Nrequire("tempfile")
module StateMachine
  module YARD
    module Handlers;Fi[	I"Fprojects//state_machine_proj/state_machine/yard/handlers/state.rb;Ti I":module StateMachine
  module YARD
    module Handlers;Fi [	@˚
i I":module StateMachine
  module YARD
    module Handlers;Fi [	I"@projects//state_machine_proj/state_machine/yard/handlers.rb;Ti I":module StateMachine
  module YARD
    module Handlers;Fi [	I"7projects//state_machine_proj/state_machine/yard.rb;Ti I",module StateMachine
  module YARD
  end;Fi [	@≠*I"var.puts("STRING");Fi[[	@Ni$I"è        end.to_yaml
        File.open("STRING", "STRING") do |var|
          var.puts(var)
          var.puts("STRING")
          var.puts(var);Fi[	@UiI"è        end.to_yaml
        File.open("STRING", "STRING") do |var|
          var.puts(var)
          var.puts("STRING")
          var.puts(var);Fi[	@\i#I"è        end.to_yaml
        File.open("STRING", "STRING") do |var|
          var.puts(var)
          var.puts("STRING")
          var.puts(var);Fi[	@	iI"è        end.to_yaml
        File.open("STRING", "STRING") do |var|
          var.puts(var)
          var.puts("STRING")
          var.puts(var);Fi[	@∏*i0I"ô          end.to_yaml
          File.open("STRING", "STRING") do |var|
            var.puts(var)
            var.puts("STRING")
            var.puts(var);Fi[	@iiI"è        end.to_yaml
        File.open("STRING", "STRING") do |var|
          var.puts(var)
          var.puts("STRING")
          var.puts(var);Fi[	@pi^I"Ö      end.to_yaml
      File.open("STRING", "STRING") do |var|
        var.puts(var)
        var.puts("STRING")
        var.puts(var);Fi[	I"module MultiJson;FI"module Adapters;Fi[[	I"Fprojects//homebrew_proj/vendor/multi_json/adapters/json_common.rb;Ti I"=module MultiJson
  module Adapters
    module JsonCommon;Fi [	I"Cprojects//homebrew_proj/vendor/multi_json/adapters/json_gem.rb;TiI"Ürequire("json") unless defined? ::JSON
require("multi_json/adapters/json_common")
module MultiJson
  module Adapters
    class JsonGem;Fi[	I"Dprojects//homebrew_proj/vendor/multi_json/adapters/json_pure.rb;TiI"årequire("json/pure") unless defined? ::JSON
require("multi_json/adapters/json_common")
module MultiJson
  module Adapters
    class JsonPure;Fi[	@·iI"ôframework("STRING")
require("multi_json/adapters/ok_json")
module MultiJson
  module Adapters
    class Nsjsonserialization < MultiJson::Adapters::OkJson;Fi[	I"=projects//homebrew_proj/vendor/multi_json/adapters/oj.rb;TiI"Wrequire("oj") unless defined? ::Oj
module MultiJson
  module Adapters
    class Oj;Fi[	@>iI"crequire("vendor/multi_json/vendor/okjson")
module MultiJson
  module Adapters
    class OkJson;Fi[	I"?projects//homebrew_proj/vendor/multi_json/adapters/yajl.rb;TiI"]require("yajl") unless defined? ::Yajl
module MultiJson
  module Adapters
    class Yajl;Fi[	I"*require("twitter/error/client_error");F@i[[	@i I"Grequire("twitter/error/client_error")
module Twitter
  class Error;Fi [	@i I"Grequire("twitter/error/client_error")
module Twitter
  class Error;Fi [	@%i I"Grequire("twitter/error/client_error")
module Twitter
  class Error;Fi [	@(i I"Grequire("twitter/error/client_error")
module Twitter
  class Error;Fi [	@1i I"Grequire("twitter/error/client_error")
module Twitter
  class Error;Fi [	@4i I"Grequire("twitter/error/client_error")
module Twitter
  class Error;Fi [	@7i I"Grequire("twitter/error/client_error")
module Twitter
  class Error;Fi [	@Ÿ@ø	i[[	@PiI"Ã      protected
      
      def function(var, var, var)
        begin
          @instrumenter.instrument("STRING", "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => (object_id), "LITERAL" => (var)) do;Fi[	@Ÿ	iÖI"ô      
      # Forwards any missing method call to the \target.
      def function(var, var, var)
        begin
          @delegate.send(var, *var, &var);Fi[	@∏i`I"v    #
    #   Person.sum("2 * age")
    def function(var, var, var)
      begin
        (var = with_default_scope;Fi[	@æihI"ù    DEVISE_SCOPE_KEYS = ["LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL"]
    
    def function(var, var, var)
      begin
        (var = {};Fi[	@icI"Á    # @param block [#to_proc] A block that can be yielded to within the template
    # @return [String] The rendered template
    def function(var, var, var)
      begin
      (var = if var.instance_variable_defined?("STRING") then;Fi[	@˝iºI"Æ    # If no valid UTF-8 char exists at position i,
    # ucharcopy writes Ustrerr and returns 1.
    def function(var, var, var)
      begin
        (var = (var.length - var);Fi[	@´iI"w      end
      
      def function(var, var, var)
        begin
          (var = Twitter::API::Arguments.new(var);Fi[	I"require("formula");FI"module Homebrew;Fi[[	@≈
i I"6require("formula")
module Homebrew
  extend(self);Fi [	@Bi I"6require("formula")
module Homebrew
  extend(self);Fi [	@i I"6require("formula")
module Homebrew
  extend(self);Fi [	I"&projects//homebrew_proj/cmd/sh.rb;TiI"Jrequire("superenv")
require("formula")
module Homebrew
  extend(self);Fi[	@;
iI"Erequire("keg")
require("formula")
module Homebrew
  extend(self);Fi[	I"(projects//homebrew_proj/cmd/uses.rb;Ti I"6require("formula")
module Homebrew
  extend(self);Fi [	@i I"6require("formula")
module Homebrew
  extend(self);Fi [	@I"(#   class Post < ActiveRecord::Base;Fi[[	@iHI"Ú      
      # Returns an instance of <tt>Arel::Table</tt> loaded with the current table name.
      #
      #   class Post < ActiveRecord::Base
      #     scope :published_and_commented, published.and(self.arel_table[:comments_count].gt(0));Fi[	@i~I"ì    # the attributes necessary for initializing an empty model object. For
    # example:
    #
    #   class Post < ActiveRecord::Base
    #   end;Fi[	@iæI"S    #
    # Example:
    #
    #   class Post < ActiveRecord::Base
    #   end;Fi[	@&iEI"¡      # own computation. (Possibly using <tt>super</tt> to manipulate the default
      # table name.) Example:
      #
      #   class Post < ActiveRecord::Base
      #     def self.table_name;Fi[	@8iiI"Ì      # Gets the source of the through reflection. It checks both a singularized
      # and pluralized form for <tt>:belongs_to</tt> or <tt>:has_many</tt>.
      #
      #   class Post < ActiveRecord::Base
      #     has_many :taggings;Fi[	@8iwI"Â      # Returns the AssociationReflection object specified in the <tt>:through</tt> option
      # of a HasManyThrough or HasOneThrough association.
      #
      #   class Post < ActiveRecord::Base
      #     has_many :taggings;Fi[	@TiI"π      module ClassMethods
        # Returns a scope for the model without the +default_scope+.
        #
        #   class Post < ActiveRecord::Base
        #     def self.default_scope;Fi[	I".# to perform the database dumping process;F@:i[[	@ciÜI"º      ##
      # Builds the MongoDB credentials syntax to authenticate the user
      # to perform the database dumping process
      def function
        ["STRING", "STRING"].map do |var|;Fi[	@ciêI"¿      ##
      # Builds the MongoDB connectivity options syntax to connect the user
      # to perform the database dumping process
      def function
        ["STRING", "STRING"].map do |var|;Fi[	@iZI"∫      ##
      # Builds the credentials MySQL syntax to authenticate the user
      # to perform the database dumping process
      def function
        ["STRING", "STRING"].map do |var|;Fi[	@idI"»      ##
      # Builds the MySQL connectivity options syntax to connect the user
      # to perform the database dumping process
      def function
        ["STRING", "STRING", "STRING"].map do |var|;Fi[	@iYI"Ã      ##
      # Builds the credentials PostgreSQL syntax to authenticate the user
      # to perform the database dumping process
      def function
        username.to_s.empty? ? ("STRING") : ("STRING");Fi[	@fi]I"«      ##
      # Builds the Redis credentials syntax to authenticate the user
      # to perform the database dumping process
      def function
        password.to_s.empty? ? ("STRING") : ("STRING");Fi[	@fidI"»      ##
      # Builds the Redis connectivity options syntax to connect the user
      # to perform the database dumping process
      def function
        ["STRING", "STRING", "STRING"].map do |var|;Fi[	I";# @param options [Hash] A customizable set of options.;F@M(i[[	@qiI"      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::DirectMessage>] Direct messages sent to the authenticating user.
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;Fi[	@qi)I"      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::DirectMessage>] Direct messages sent by the authenticating user.
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;Fi[	@ÎiI"“      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;Fi[	@ÎiGI"…      # @return [Array<Twitter::Tweet>]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;Fi[	@Îi^I"“      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;Fi[	@ÎisI"“      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;Fi[	@ÎiÖI"“      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;Fi[	@@Hi[[	@ãiWI"ö      #       options[:my_custom_key] # => "my custom value"
      #     end
      #   end
      def function(var, var)
        var = var.extract_options!;Fi[	@∞i!I"õ        #   class User < ActiveRecord::Base
        #     serialize :preferences
        #   end
        def function(var, var)
          include(Behavior);Fi[	@1i"I"º      #   User.create([{ first_name: 'Jamie' }, { first_name: 'Jeremy' }]) do |u|
      #     u.is_admin = false
      #   end
      def function(var, var)
        if var.is_a?(Array) then;Fi[	@Ji}I"û    #       # pagination code goes here
    #     end
    #   end
    def function(var, var)
      (var.any? or var) ? (spawn.extending!(*var, &var)) : (self);Fi[	@hi´I"|    #       end
    #     end
    #   end
    def function(var, var)
      XmlSerializer.new(self, var).serialize(&var);Fi[	@€iHI"Ä      #     option :foo, 'bar'
      #     option 
      #   end
      def function(var, var)
        default_options[var] = var;Fi[	@iBI"¢    #   Paperclip.configure do |c|
    #     c.register_processor :watermarker, WatermarkingProcessor.new
    #   end
    def function(var, var)
      @var ||= {};Fi[	@îI"var.print("STRING");Fi[[	@˝iëI"ã      while (var < var.length) do
        case var[var]
        when "STRING" then
          var.print("STRING")
        when "STRING" then;Fi[	@˝iìI"å        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then;Fi[	@˝iïI"å        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then;Fi[	@˝ióI"å        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then;Fi[	@˝iôI"å        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then;Fi[	@˝iõI"å        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then;Fi[	@˝iùI"~        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        else;Fi[	I"require("fileutils");FI"require("yaml");Fi[[	@NiI"]require("rubygems")
require("sequel")
require("fileutils")
require("yaml")
module Jekyll;Fi[	@UiI"]require("rubygems")
require("sequel")
require("fileutils")
require("yaml")
module Jekyll;Fi[	@	iI"]require("rubygems")
require("sequel")
require("fileutils")
require("yaml")
module Jekyll;Fi[	I"2projects//jekyll_proj/jekyll/migrators/rss.rb;Ti	I"^require("rss/2.0")
require("open-uri")
require("fileutils")
require("yaml")
module Jekyll;Fi[	@iiI"]require("rubygems")
require("sequel")
require("fileutils")
require("yaml")
module Jekyll;Fi[	@piI"]require("rubygems")
require("sequel")
require("fileutils")
require("yaml")
module Jekyll;Fi[	@ÄiI"`require("rubygems")
require("hpricot")
require("fileutils")
require("yaml")
require("time");Fi[	@ø(@ô(i[[	@u"iII"î    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!);Fi[	@u"iWI"î    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!);Fi[	@u"ieI"î    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!);Fi[	@u"isI"î    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!);Fi[	@u"iíI"í    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?);Fi[	@u"i¢I"í    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?);Fi[	@u"i≤I"î    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!);Fi[	@O+@≠*i[[	@Ni%I"á        File.open("STRING", "STRING") do |var|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end;Fi[	@UiI"á        File.open("STRING", "STRING") do |var|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end;Fi[	@\i$I"á        File.open("STRING", "STRING") do |var|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end;Fi[	@	iI"á        File.open("STRING", "STRING") do |var|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end;Fi[	@∏*i1I"ë          File.open("STRING", "STRING") do |var|
            var.puts(var)
            var.puts("STRING")
            var.puts(var)
          end;Fi[	@iiI"á        File.open("STRING", "STRING") do |var|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end;Fi[	@pi_I"}      File.open("STRING", "STRING") do |var|
        var.puts(var)
        var.puts("STRING")
        var.puts(var)
      end;Fi[	@I"# Examples:;Fi[[	@[i.I"¢    module ClassMethods
      # Sets the model class for a fixture when the class name cannot be inferred from the fixture name.
      #
      # Examples:
      #;Fi[	@ç
i<I"¨      #   whether the <tt>:id</tt> is present. The option is ignored for collection
      #   associations.
      #
      # Examples:
      #   # creates avatar_attributes=;Fi[	@≥i=I"¿      # the user straight in session. This option is useful in cases the user is already
      # signed in, but we want to refresh the credentials in session.
      #
      # Examples:
      #;Fi[	@≥iXI"´      # after deleting accounts. Returns true if there was a logout and false if there
      # is no user logged in on the referred scope
      #
      # Examples:
      #;Fi[	@QiI"õ    # sign_in a given resource by storing its keys in the session.
    # This method bypass any warden authentication callback.
    #
    # Examples:
    #;Fi[	@Qi.I"ñ    # Sign out a given resource or scope by calling logout on Warden.
    # This method bypass any warden logout callback.
    #
    # Examples:
    #;Fi[	@Vi
I"ƒ      # Ensures that the given instance or class validates the size of the
      # given attachment as specified.
      #
      # Examples:
      #   it { should validate_attachment_size(:avatar).;Fi[	@<@<i[[	@*iI"à    
    def self.find_all_sprite_map_files(var)
      var = "STRING"
      var = "STRING"
      Dir.glob(File.join(var, "STRING", var));Fi[	@Èi…I"c      var = "STRING"
      if var then
        var = "STRING"
        var = "STRING"
      end;Fi[	@ÏiEI"|      var = var.keys if (Hash == var)
      (var.map do |var|
        var = "STRING"
        var = "STRING"
        "STRING";Fi[	@ÏiUI"ˆ      ((var << block_given?.!) << @options["LITERAL"])
      var = (@options["LITERAL"] and (var["LITERAL"] or (var["LITERAL"] or var["LITERAL"])).!)
      var = "STRING"
      var = "STRING"
      push_merged_text("STRING") unless var["LITERAL"];Fi[	@Ñi<I"i    else
      var.parent.cd { var = github_fork }
      var = "STRING"
      var = "STRING"
    end;Fi[	@iáI"Ø    if (@old_compiler == ENV.compiler) then
      var = Compiler.new(ENV.compiler)
      var = "STRING"
      var = "STRING"
      var = (var + "STRING") unless var.cause.nil?;Fi[	@\iI"k  module Mephisto
    def self.postgres(var)
      var = "STRING"
      var = "STRING"
      puts(var);Fi[	@N(I"w# @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[[	@qiI"      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Integer] :page Specifies the page of results to retrieve.;Fi[	@qi+I"      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Integer] :page Specifies the page of results to retrieve.;Fi[	@ÎiI"u      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@ÎiII"u      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@Îi`I"u      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@ÎiuI"u      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@ÎiáI"u      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	I"# @return [Boolean];F@:i[[	@iLI"y    # Overridden in haml/template.rb if this is the case.
    #
    # @return [Boolean]
    def function
      false;Fi[	I"3projects//twitter_proj/twitter/configurable.rb;Ti!I"X    end
    
    # @return [Boolean]
    def function
      credentials.values.all?;Fi[	@/i>I"l    alias "LITERAL" "LITERAL"
    
    # @return [Boolean]
    def function
      previous_cursor.zero?;Fi[	@/iEI"h    alias "LITERAL" "LITERAL"
    
    # @return [Boolean]
    def function
      next_cursor.zero?;Fi[	@…iI"Ä    def_delegators("LITERAL", "LITERAL", "LITERAL")
    
    # @return [Boolean]
    def function
      @attrs["LITERAL"].nil?.!;Fi[	@…ieI"p    alias "LITERAL" "LITERAL"
    
    # @return [Boolean]
    def function
      in_reply_to_status_id.!.!;Fi[	@…ijI"U    end
    
    # @return [Boolean]
    def function
      retweeted_status.!.!;Fi[	@|I"var = var;Fi[[	@∏iÚI"¨        var = ((var.size == "LITERAL") and (var and (var.macro == "LITERAL")))
        var = Array((var ? (var.foreign_key) : (var)))
      else
        var = var
      end;Fi[	I"Jprojects//compass_proj/compass/sass_extensions/functions/selectors.rb;Ti9I"≤        var = Sass::Script::Number.new("LITERAL")
        var = Sass::Script::Number.new("LITERAL")
      else
        var = var
        var = Sass::Script::Number.new("LITERAL");Fi[	@ÏiéI"É            var.include?(var) ? (var = var.gsub(var, var)) : (var = var)
          end
        else
          var = var
        end;Fi[	@inI"¶        var = eval("STRING", var)
        var = var.instance_eval { binding } if block_given?
      else
        var = var
        var = var.instance_eval { binding };Fi[	@iôI"†      if (var.is_a?(Binding) or var.is_a?(Proc)) then
        var = eval("STRING", var)
      else
        var = var
        var = var.instance_eval { binding };Fi[	@^iÒI"ò            var = ["STRING", "STRING", "STRING", "STRING"]
            var = Node.new("LITERAL", var)
          else
            var = var
          end;Fi[	@6iI"“        if var and var.is_a?(String) then
          var = var and var.=~(REGEX) ? ([var]) : (var.split("STRING"))
        else
          var = var
          var = [var] unless var and var.respond_to?("LITERAL");Fi[	@e,@£i[[	@oi`I"ß    
    # @param other [Twitter::Base]
    # @return [Boolean]
    def function(var)
      (self.class == var.class) and (var.attrs.empty?.! and (attrs == var.attrs));Fi[	@5iI"ñ    
    # @param other [Twitter::Geo]
    # @return [Boolean]
    def function(var)
      (super or (attr_equal("LITERAL", var) or attrs_equal(var)));Fi[	@[i!I"õ    
    # @param other [Twitter::Identity]
    # @return [Boolean]
    def function(var)
      (super or (attr_equal("LITERAL", var) or attrs_equal(var)));Fi[	@LiI"å    
    # @param other [Twitter::Size]
    # @return [Boolean]
    def function(var)
      (super or (size_equal(var) or attrs_equal(var)));Fi[	@LiI"ø    
    # @param other [Twitter::Size]
    # @return [Boolean]
    def function(var)
      (self.class == var.class) and (var.h.nil?.! and ((h == var.h) and (var.w.nil?.! and (w == var.w))));Fi[	@OiI"ù    
    # @param other [Twitter::Suggestion]
    # @return [Boolean]
    def function(var)
      (super or (attr_equal("LITERAL", var) or attrs_equal(var)));Fi[	@RiI"ò    
    # @param other [Twitter::Trend]
    # @return [Boolean]
    def function(var)
      (super or (attr_equal("LITERAL", var) or attrs_equal(var)));Fi[	@I"SubversionDownloadStrategy;Fi[[	@ÈiI"à    when "LITERAL" then
      MercurialDownloadStrategy
    when "LITERAL" then
      SubversionDownloadStrategy
    when "LITERAL" then;Fi[	@ÈiI"â    when "LITERAL" then
      SubversionDownloadStrategy
    when "LITERAL" then
      SubversionDownloadStrategy
    when "LITERAL" then;Fi[	@Èi	I"à    when "LITERAL" then
      MercurialDownloadStrategy
    when "LITERAL" then
      SubversionDownloadStrategy
    when "LITERAL" then;Fi[	@ÈiI"â    when "LITERAL" then
      SubversionDownloadStrategy
    when "LITERAL" then
      SubversionDownloadStrategy
    when "LITERAL" then;Fi[	@ÈiI"â    when "LITERAL" then
      SubversionDownloadStrategy
    when "LITERAL" then
      SubversionDownloadStrategy
    when "LITERAL" then;Fi[	@ÈiI"π    when "LITERAL" then
      CurlApacheMirrorDownloadStrategy
    when "LITERAL" then
      SubversionDownloadStrategy
    when bottle_native_regex, bottle_regex, old_bottle_regex then;Fi[	@Èi*I"}    when "LITERAL" then
      CurlPostDownloadStrategy
    when "LITERAL" then
      SubversionDownloadStrategy
    else;Fi[	@HI"@var = false;Fi[[	@PiFI"í      def function(var, var, var)
        super()
        @var = var
        @var = false
        @var = ActiveSupport::Notifications.instrumenter;Fi[	@Ÿ	iI"`      def function(var)
        @var = []
        @var = var
        @var = false
      end;Fi[	@3
iTI"ô    def function(var, var)
      @var = (var.rstrip.split("LITERAL") + ["LITERAL", "LITERAL"])
      @var = var
      @var = false
      @var = "LITERAL";Fi[	@—iI"{  def function(var, var)
    @var = var
    @var = var
    @var = false
    @var = (ARGV.ignore_deps? or ARGV.interactive?);Fi[	@˝i0I"o          check_encoding(var)
          @var = var
          @var = var
          @var = false
        end;Fi[	@iI"\    def function(var, var)
      @var = var
      @var = var
      @var = false
    end;Fi[	@iI"s      @var = "STRING"
      @var = var
      @var = var
      @var = false
      @redis.sadd("LITERAL", @name);Fi[	@:I"with_temp_folder do;Fi[[	I":projects//homebrew_proj/test/test_pathname_install.rb;TiI"Z  end
  
  def function
    with_temp_folder do
      TARGET_FOLDER.install("STRING");Fi[	@æ,i"I"f  end
  
  def function
    with_temp_folder do
      TARGET_FOLDER.install(["STRING", "STRING"]);Fi[	@æ,i*I"_  end
  
  def function
    with_temp_folder do
      TARGET_FOLDER.install(Dir["STRING"]);Fi[	@æ,i2I"V  end
  
  def function
    with_temp_folder do
      FileUtils.mkdir_p("STRING");Fi[	@æ,i<I"f  end
  
  def function
    with_temp_folder do
      TARGET_FOLDER.install("STRING" => "STRING");Fi[	@æ,iEI"|  end
  
  def function
    with_temp_folder do
      TARGET_FOLDER.install("STRING" => "STRING", "STRING" => "STRING");Fi[	@æ,iOI"V  end
  
  def function
    with_temp_folder do
      FileUtils.mkdir_p("STRING");Fi[	@Ú!I"# @param args [Array];Fi[[	@´iI"ç      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>];Fi[	@i I"é      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::Tweet>];Fi[	@iI"ç      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>];Fi[	@iI"ç      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>];Fi[	@i(I"î      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array];Fi[	@iDI"î      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array];Fi[	@i[I"†      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @param method_name [Symbol];Fi[	@:I"var = TestBall.new;Fi[[	@Ú'iI"b  end
  
  def function
    var = TestBall.new
    var.stable.instance_eval { md5("STRING") };Fi[	@Ú'iI"b  end
  
  def function
    var = TestBall.new
    var.stable.instance_eval { md5("STRING") };Fi[	@Ú'iI"c  end
  
  def function
    var = TestBall.new
    var.stable.instance_eval { sha1("STRING") };Fi[	@Ú'i"I"c  end
  
  def function
    var = TestBall.new
    var.stable.instance_eval { sha1("STRING") };Fi[	@Ú'i(I"e  end
  
  def function
    var = TestBall.new
    var.stable.instance_eval { sha256("STRING") };Fi[	@Ú'i.I"e  end
  
  def function
    var = TestBall.new
    var.stable.instance_eval { sha256("STRING") };Fi[	I"9projects//homebrew_proj/test/test_formula_install.rb;Ti)I"f  end
  
  def function
    var = TestBall.new
    assert_equal(Formula.path(var.name), var.path);Fi[	@,I"module Jekyll;Fi[[	@NiI"Yrequire("sequel")
require("fileutils")
require("yaml")
module Jekyll
  module Drupal;Fi[	@UiI"Yrequire("sequel")
require("fileutils")
require("yaml")
module Jekyll
  module Joomla;Fi[	@	iI"Urequire("sequel")
require("fileutils")
require("yaml")
module Jekyll
  module MT;Fi[	@
,i
I"_require("open-uri")
require("fileutils")
require("yaml")
module Jekyll
  module MigrateRSS;Fi[	@iiI"^require("sequel")
require("fileutils")
require("yaml")
module Jekyll
  module TextPattern;Fi[	@ø'iI"Vrequire("rubygems")
require("sequel")
require("yaml")
module Jekyll
  module Typo;Fi[	@piI"\require("sequel")
require("fileutils")
require("yaml")
module Jekyll
  module WordPress;Fi[	I"assert(var.i386?.!);F@ç%i[[	@u"iI"à    var = Pathname.new("STRING")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!);Fi[	@u"i7I"à    var = Pathname.new("STRING")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!);Fi[	@u"iEI"à    var = Pathname.new("STRING")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!);Fi[	@u"ioI"ä    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!);Fi[	@u"iéI"Å    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!);Fi[	@u"iûI"Å    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!);Fi[	@u"iÆI"Å    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!);Fi[	I"u# +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.;F@i[[	@ÿiI"I      ###
      # Add +node_or_tags+ as a child of this Node.
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).;Fi[	@ÿiI"      ###
      # Add +node_or_tags+ as a child of this Node.
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns self, to support chaining of calls (e.g., root << child1 << child2);Fi[	@ÿiI"T      ###
      # Insert +node_or_tags+ before this Node (as a sibling).
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).;Fi[	@ÿiI"S      ###
      # Insert +node_or_tags+ after this Node (as a sibling).
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).;Fi[	@ÿi'I"¸      ####
      # Insert +node_or_tags+ before this node (as a sibling).
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns self, to support chaining of calls.;Fi[	@ÿi]I"E      ####
      # Replace this Node with +node_or_tags+.
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).;Fi[	@ÿiuI"Á      ####
      # Swap this Node for +node_or_tags+
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns self, to support chaining of calls.;Fi[	@:I""STRING".undent;Fi[[	@ibI"6  end
  
  def function
    "STRING".undent
  end;Fi[	@ iI"V  satisfy { quiet_system(*the_test) }
  
  def function
    "STRING".undent
  end;Fi[	@ iYI"6  end
  
  def function
    "STRING".undent
  end;Fi[	@ iØI"l  satisfy("LITERAL" => (false)) { MacOS::Xcode.installed? }
  
  def function
    "STRING".undent
  end;Fi[	@ i∫I"N  satisfy { which("STRING") }
  
  def function
    "STRING".undent
  end;Fi[	@ i≈I"N  satisfy { which("STRING") }
  
  def function
    "STRING".undent
  end;Fi[	@ i–I"c  satisfy { (which("STRING") or which("STRING")) }
  
  def function
    "STRING".undent
  end;Fi[	@£@<"i[[	@biNI"N    end
    
    def function(var)
      var = {}
      var.each do |var|;Fi[	@¸i>I"“    # Returns a Hash of the Arel::Attributes and attribute values that have been
    # type casted for use in an Arel insert/update method.
    def function(var)
      var = {}
      var = self.class.arel_table;Fi[	@∏iAI"‘      #     { address: Address.new("813 abc st.", "chicago") }
      #       # => { address_street: "813 abc st.", address_city: "chicago" }
      def function(var)
        var = {}
        var.each do |var, var|;Fi[	@›iDI"W    end
    
    def function(var)
      var = {}
      if var.kind_of?(Hash) then;Fi[	I"<projects//diaspora_proj/helpers/aspect_global_helper.rb;TiI"\  end
  
  def function(var)
    var = {}
    var.each { |var| var[var.to_s] = var.id };Fi[	@3
i‡I"Y    end
    
    def function(var)
      var = {}
      var = StringScanner.new(var);Fi[	@iI"D  end
  
  def function(var)
    var = {}
    var.each do |var|;Fi[	I"# @return [Hash];F@Hi[[	I"4projects//diaspora_proj/models/user/querying.rb;Ti~I"å  protected
  
  # @return [Hash]
  def function(var, var)
    var = { "LITERAL" => "STRING", "LITERAL" => "LITERAL", "LITERAL" => (false) };Fi[	@´i@I"∏      # @param hash [Hash]
      # @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      # @return [Hash]
      def function(var, var)
        case var;Fi[	@´iTI"’      # @param hash [Hash]
      # @param user[Integer, String, Twitter::User] A Twitter user ID, screen_name, or object.
      # @return [Hash]
      def function(var, var)
        merge_user!(var, var, "STRING");Fi[	@iõI"      # @param hash [Hash]
      # @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen_names, or objects.
      # @return [Hash]
      def function(var, var)
        merge_users!(var.dup, var);Fi[	@i§I"      # @param hash [Hash]
      # @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen_names, or objects.
      # @return [Hash]
      def function(var, var)
        var, var = [], [];Fi[	@≈)iI"~    # @param hash [Hash]
    # @param key [Symbol]
    # @return [Hash]
    def function(var, var)
      except!(var.dup, var);Fi[	@≈)i"I"}    # @param hash [Hash]
    # @param key [Symbol]
    # @return [Hash]
    def function(var, var)
      var.delete(var);Fi[	@I"module Action;Fi[[	I"6projects//twitter_proj/twitter/action/favorite.rb;TiI"orequire("twitter/action/tweet")
module Twitter
  module Action
    class Favorite < Twitter::Action::Tweet;Fi[	@o'iI"yrequire("twitter/base")
require("twitter/creatable")
module Twitter
  module Action
    class Follow < Twitter::Base;Fi[	@t'iI"}require("twitter/base")
require("twitter/creatable")
module Twitter
  module Action
    class ListMemberAdded < Twitter::Base;Fi[	@y'iI"zrequire("twitter/base")
require("twitter/creatable")
module Twitter
  module Action
    class Mention < Twitter::Base;Fi[	I"3projects//twitter_proj/twitter/action/reply.rb;TiI"lrequire("twitter/action/tweet")
module Twitter
  module Action
    class Reply < Twitter::Action::Tweet;Fi[	@~'iI"nrequire("twitter/action/tweet")
module Twitter
  module Action
    class Retweet < Twitter::Action::Tweet;Fi[	@Å'iI"xrequire("twitter/base")
require("twitter/creatable")
module Twitter
  module Action
    class Tweet < Twitter::Base;Fi[	@ÎI"module Notifier;Fi[[	@‹i I"3module Backup
  module Notifier
    class Base;Fi [	@≤iI"`Backup::Dependency.load("STRING")
module Backup
  module Notifier
    class Campfire < Base;Fi[	@ü
iI"_Backup::Dependency.load("STRING")
module Backup
  module Notifier
    class Hipchat < Base;Fi[	@¢
iI"\Backup::Dependency.load("STRING")
module Backup
  module Notifier
    class Mail < Base;Fi[	@πiI"]Backup::Dependency.load("STRING")
module Backup
  module Notifier
    class Prowl < Base;Fi[	@¿iI"Srequire("net/https")
module Backup
  module Notifier
    class Pushover < Base;Fi[	@«iI"_Backup::Dependency.load("STRING")
module Backup
  module Notifier
    class Twitter < Base;Fi[	@:I"if ARGV.named.empty? then;Fi[[	I"+projects//homebrew_proj/cmd/--cache.rb;TiI"^  extend(self)
  
  def function
    if ARGV.named.empty? then
      puts(HOMEBREW_CACHE);Fi[	I",projects//homebrew_proj/cmd/--cellar.rb;TiI"_  extend(self)
  
  def function
    if ARGV.named.empty? then
      puts(HOMEBREW_CELLAR);Fi[	I",projects//homebrew_proj/cmd/--prefix.rb;TiI"_  extend(self)
  
  def function
    if ARGV.named.empty? then
      puts(HOMEBREW_PREFIX);Fi[	@ÏiI"l  extend(self)
  
  def function
    if ARGV.named.empty? then
      if HOMEBREW_CELLAR.directory? then;Fi[	I"(projects//homebrew_proj/cmd/home.rb;TiI"d  extend(self)
  
  def function
    if ARGV.named.empty? then
      exec_browser(HOMEBREW_WWW);Fi[	@ÑiI"`  end
  
  def function
    if ARGV.named.empty? then
      if ARGV.include?("STRING") then;Fi[	I"'projects//homebrew_proj/cmd/log.rb;TiI"a  extend(self)
  
  def function
    if ARGV.named.empty? then
      cd(HOMEBREW_REPOSITORY);Fi[	@<I")var.extend(StringInreplaceExtension);Fi[[	@\i	I"¢class InreplaceTest < Test::Unit::TestCase
  def function
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING");Fi[	@\iI"  
  def function
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING");Fi[	@\iI"  
  def function
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING");Fi[	@\iI"  
  def function
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING");Fi[	@\i%I"  
  def function
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING");Fi[	@\i,I"u  
  def function
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.remove_make_var!("STRING");Fi[	@\i3I"|  
  def function
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.remove_make_var!(["STRING", "STRING"]);Fi[	@/I"7#     state_machine :state, :initial => :parked do;Fi[[	@ilI"É    # For example,
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       event :ignite do;Fi[	@iùI"É    # For example,
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       event :ignite do;Fi[	@iÿI"{    # For example,
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...;Fi[	@iÊI"¨    # In the following example, a custom +initialize+ method is defined:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...;Fi[	@i˜I"w    # like so:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...;Fi[	@iI"ï    # to initialize the state machine attributes:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...;Fi[	@i I"©    # static states regardless of their current value:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       state nil, :idling;Fi[	I"def self.included(var);FI"var.extend(ClassMethods);Fi[[	@iI"v  module Configuration
    module Helpers
      def self.included(var)
        var.extend(ClassMethods)
      end;Fi[	@ñiI"    end
    
    def self.included(var)
      var.extend(ClassMethods)
      var.helper_method("LITERAL", "LITERAL", "LITERAL");Fi[	I"4projects//cancan_proj/cancan/model_additions.rb;TiI"S    end
    
    def self.included(var)
      var.extend(ClassMethods)
    end;Fi[	@¶i0I"[  
  module Gradient
    def self.included(var)
      var.extend(ClassMethods)
    end;Fi[	@´iI"x      end
      
      def self.included(var)
        var.extend(ClassMethods)
        assert_validations_api!(var);Fi[	I"/projects//paperclip_proj/paperclip/glue.rb;Ti
I"}module Paperclip
  module Glue
    def self.included(var)
      var.extend(ClassMethods)
      var.send("LITERAL", Callbacks);Fi[	@ñ*iI"s  module Failure
    module Thoughtbot
      def self.included(var)
        var.extend(ClassMethods)
      end;Fi[	@:I"var = super;Fi[[	@∫i I"|      end
      
      def function
        var = super
        var and [var.to_s, owner[reflection.foreign_type].to_s];Fi[	@ÑiI"q    end
    
    def function
      var = super
      add_counter_cache_callbacks(var) if options["LITERAL"];Fi[	@iI"N    end
    
    def function
      var = super
      define_destroy_hook;Fi[	@˝iI"Ù      #   1. To get the default_scope conditions for any of the other reflections in the chain
      #   2. To get the type conditions for any STI models in the chain
      def function
        var = super
        chain["LITERAL"].each do |var|;Fi[	@#$i1I"s      end
      
      def function
        var = super
        if locking_enabled? and var.!=("LITERAL") then;Fi[	@#$i9I"]      end
      
      def function
        var = super
        if locking_enabled? then;Fi[	I".projects//omni_proj/omniauth/auth_hash.rb;Ti/I"[      end
      
      def function
        var = super
        var["STRING"] ||= name;Fi[	I"@var ||= "STRING";F@**i[[	@ü
i.I"É        @var ||= "STRING"
        @var ||= "STRING"
        @var ||= "STRING"
        instance_eval(&var) if block_given?
      end;Fi[	@oiI"~        super(var, var)
        @var ||= false
        @var ||= "STRING"
        instance_eval(&var) if block_given?
      end;Fi[	@riI"â      def function(var, var, var)
        super(var, var)
        @var ||= "STRING"
        instance_eval(&var) if block_given?
      end;Fi[	@ziI"â      def function(var, var, var)
        super(var, var)
        @var ||= "STRING"
        instance_eval(&var) if block_given?
      end;Fi[	@iI"•        super(var, var)
        @var ||= "LITERAL"
        @var ||= "STRING"
        instance_eval(&var) if block_given?
        @var = path.sub("LITERAL", "STRING");Fi[	@iI"•        super(var, var)
        @var ||= "LITERAL"
        @var ||= "STRING"
        instance_eval(&var) if block_given?
        @var = path.sub("LITERAL", "STRING");Fi[	I":#   #       #<Pet id: 6, name: "Boss",  person_id: 1>;T@Ii[[	@≤iHI"Œ      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #;Ti[	@≤iRI"¢      #   # => [
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #;Ti[	@≤iXI"¢      #   # => [
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #;Ti[	@≤iaI"Œ      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #;Ti[	@≤ihI"Œ      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #;Ti[	@≤iuI"Ÿ      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      def function;Ti[	I"rescue LoadError;FI"STDERR.puts("STRING");Fi[[	@Í
i!I"ú            @redcarpet_extensions[var.to_sym] = true
          end)
        rescue LoadError
          STDERR.puts("STRING")
          STDERR.puts("STRING");Fi[	@Í
i)I"Ñ        begin
          require("kramdown")
        rescue LoadError
          STDERR.puts("STRING")
          STDERR.puts("STRING");Fi[	@Í
i2I"ø          (require("rdiscount")
          @var = @config["STRING"]["STRING"].map { |var| var.to_sym })
        rescue LoadError
          STDERR.puts("STRING")
          STDERR.puts("STRING");Fi[	@Í
iHI"¨            MaRuKu::Globals["LITERAL"] = @config["STRING"]["STRING"]
          end)
        rescue LoadError
          STDERR.puts("STRING")
          STDERR.puts("STRING");Fi[	@W
iI"É        require("redcloth")
        @var = true)
      rescue LoadError
        STDERR.puts("STRING")
        STDERR.puts("STRING");Fi[	@pitI"}        (require("unidecode")
        var = var.to_ascii)
      rescue LoadError
        STDERR.puts("STRING")
      end;Fi[	@îI"E["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]];Fi[[	@˝iÉI"™    def function(var)
      case var["LITERAL"]
      when "STRING" then
        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then;Fi[	@˝iÖI"‹      when "STRING" then
        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then
        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then;Fi[	@˝iáI"‹      when "STRING" then
        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then
        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then;Fi[	@˝iâI"‹      when "STRING" then
        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then
        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then;Fi[	@˝iãI"‹      when "STRING" then
        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then
        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then;Fi[	@˝içI"‹      when "STRING" then
        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then
        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then;Fi[	I"&merge_list!(var.options, var.pop);FI"Cunless (var.options["LITERAL"] or var.options["LITERAL"]) then;Fi[[	@´iJI"ı      def function(var)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options["LITERAL"] or var.options["LITERAL"]) then
          merge_owner!(var.options, (var.pop or screen_name));Fi[	@´iI"ˇ      def function(var, var, var)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options["LITERAL"] or var.options["LITERAL"]) then
          merge_owner!(var.options, (var.pop or screen_name));Fi[	@´iI"      def function(var, var, var, var)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options["LITERAL"] or var.options["LITERAL"]) then
          merge_owner!(var.options, (var.pop or screen_name));Fi[	@´iI"          (var = Twitter::API::Arguments.new(var)
          merge_user!(var.options, var.pop)
          merge_list!(var.options, var.pop)
          unless (var.options["LITERAL"] or var.options["LITERAL"]) then
            merge_owner!(var.options, (var.pop or screen_name));Fi[	@´i)I"        var = Twitter::API::Arguments.new(var)
        merge_user!(var.options, var.pop)
        merge_list!(var.options, var.pop)
        unless (var.options["LITERAL"] or var.options["LITERAL"]) then
          merge_owner!(var.options, (var.pop or screen_name));Fi[	@´i3I"Û        var = Twitter::API::Arguments.new(var)
        var = var.pop
        merge_list!(var.options, var.pop)
        unless (var.options["LITERAL"] or var.options["LITERAL"]) then
          merge_owner!(var.options, (var.pop or screen_name));Fi[	@I"6#   class BooksController < ApplicationController;Fi[[	@ñi
I"7      # Sets up a before filter which loads and authorizes the current resource. This performs both
      # load_resource and authorize_resource and accepts the same arguments. See those methods for details.
      #
      #   class BooksController < ApplicationController
      #     load_and_authorize_resource;Fi[	@ñiI"ú      #
      # Call this method directly on the controller class.
      #
      #   class BooksController < ApplicationController
      #     load_resource;Fi[	@ñi%I"+      # A resource is not loaded if the instance variable is already set. This makes it easy to override
      # the behavior through a before_filter on certain actions.
      #
      #   class BooksController < ApplicationController
      #     before_filter :find_book_by_permalink, :only => :show;Fi[	@ñi3I"˛      # If a name is provided which does not match the controller it assumes it is a parent resource. Child
      # resources can then be loaded through it.
      #
      #   class BooksController < ApplicationController
      #     load_resource :author;Fi[	@ñi{I"°      #
      # Call this method directly on the controller class.
      #
      #   class BooksController < ApplicationController
      #     authorize_resource;Fi[	@ñiÇI"Ë      # If you pass in the name of a resource which does not match the controller it will assume
      # it is a parent resource.
      #
      #   class BooksController < ApplicationController
      #     authorize_resource :author;Fi[	@£I"if var.nil? then;Fi[[	@¸i+I"¥      
      # Checks whether record is different to the current target, without loading it
      def function(var)
        if var.nil? then
          owner[reflection.foreign_key];Fi[	@ìiI"^        end
        
        def function(var)
          if var.nil? then
            nil;Fi[	@ìiRI"^        end
        
        def function(var)
          if var.nil? then
            nil;Fi[	@ìilI"^        end
        
        def function(var)
          if var.nil? then
            nil;Fi[	@ìi}I"è        /(#{var}STRING#{var}STRING#{var}STRING#{var}STRING/)
        
        def function(var)
          if var.nil? then
            "STRING";Fi[	@‘i]I"≈  # Used in the bottle DSL to set @revision, but acts as an
  # as accessor for @version to preserve the interface
  def function(var)
    if var.nil? then
      return @var ||= Version.parse(@url);Fi[	I";#   #       #<Pet id: 5, name: "Brain", person_id: 1>,;T@Ë-i[[	@≤iGI"◊      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ];Ti[	@≤iQI"∞      #   person.pets
      #   # => [
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ];Ti[	@≤iWI"æ      #   person.pets.destroy(5, 6)
      #   # => [
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ];Ti[	@≤i`I"◊      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ];Ti[	@≤igI"◊      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ];Ti[	@≤itI"◊      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ];Ti[	@£I"if block_given? then;Fi[[	@Øi)I"|      end
      
      def function(var)
        if block_given? then
          load_target.select.each { |var| yield(var) };Fi[	@Øi1I"|      end
      
      def function(var)
        if block_given? then
          load_target.find(*var) { |var| yield(*var) };Fi[	@Åi+I"”      
      # HELPER METHODS ===========================================
      def function(var)
        if block_given? then
          var.each("LITERAL" => "LITERAL", "LITERAL" => (true)) { |var| yield(var) };Fi[	@Ã	iÇI"ü      
      # HELPER METHODS ===========================================
      def function(var)
        if block_given? then
          var.each_hash do |var|;Fi[	@∏i8I"å    #
    #   Person.sum('age') # => 4562
    def function(var)
      if block_given? then
        ActiveSupport::Deprecation.warn("STRING");Fi[	@JiÆI"Ÿ    #   Model.select(:field).first.other_field
    #   # => ActiveModel::MissingAttributeError: missing attribute: other_field
    def function(var)
      if block_given? then
        to_a.select { |var| yield(*var) };Fi[	I"7# Notify the user of the backup operation results.;FI"/# `status` indicates one of the following:;Fi[[	@≤iI"Å      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[	@ü
i5I"Å      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[	@¢
itI"Å      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[	@πiI"Å      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[	@¿i%I"Å      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[	@«iI"Å      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[	@H@ri[[	@&i_I"z          reset_column_information if connected?
        end
        @var = var
        @var = nil
        @var = nil;Fi[	@QiI"[      @var = var
      @var = var
      @var = var
      @var = nil
      @var = false;Ti[	@ëiI"h    def function(var, var, var)
      @var = var
      @var = var
      @var = nil
      @var = var;Fi[	@ŸiCI"^  def function(var, var, var)
    @var = var
    @var = var
    @var = nil
    @var = nil;Fi[	@’i≤I"f        
        def function(var)
          @var = var
          @var = nil
          @var = nil;Fi[	@iI"o      else
        if var.is_a?(String) then
          @var = var
          @var = nil
          @var = {};Fi[	@c.@i[[	@≤iI"ç      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[	@ü
i6I"ç      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[	@¢
iuI"ç      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[	@πiI"ç      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[	@¿i&I"ç      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[	@«iI"ç      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[	I"# `:success`;FI"+# : The backup completed successfully.;Fi[[	@≤i I"æ      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[	@ü
i8I"æ      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[	@¢
iwI"æ      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[	@πiI"æ      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[	@¿i(I"æ      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[	@«iI"æ      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[	@è.I"D# : Notification will be sent if `on_success` was set to `true`;Fi[[	@≤i!I"ï      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[	@ü
i9I"ï      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[	@¢
ixI"ï      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[	@πiI"ï      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[	@¿i)I"ï      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[	@«iI"ï      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[	@û.@i[[	@≤i"I"†      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[	@ü
i:I"†      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[	@¢
iyI"†      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[	@πi I"†      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[	@¿i*I"†      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[	@«iI"†      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[	I"# `:warning`;FI"D# : The backup completed successfully, but warnings were logged;Fi[[	@≤i$I"Î      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[	@ü
i<I"Î      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[	@¢
i{I"Î      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[	@πi"I"Î      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[	@¿i,I"Î      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[	@«i I"Î      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[	I"assert(var.universal?.!);F@-i[[	@u"i(I"|  def function
    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?);Fi[	@u"i`I"|  def function
    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?);Fi[	@u"inI"~  def function
    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!);Fi[	@u"içI"ç    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!);Fi[	@u"iùI"ç    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!);Fi[	@u"i≠I"ç    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!);Fi[	@º.I"C# : Notification will be sent, including a copy of the current;Fi[[	@≤i%I"›      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[	@ü
i=I"›      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[	@¢
i|I"›      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[	@πi#I"›      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[	@¿i-I"›      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[	@«i!I"›      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[	@⁄.I"6# : backup log, if `on_warning` was set to `true`;Fi[[	@≤i&I"›      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[	@ü
i>I"›      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[	@¢
i}I"›      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[	@πi$I"›      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[	@¿i.I"›      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[	@«i"I"›      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[	@I"# `:failure`;Fi[[	@≤i(I"æ      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[	@ü
i@I"æ      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[	@¢
iI"æ      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[	@πi&I"æ      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[	@¿i0I"æ      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[	@«i$I"æ      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[	@3,@i[[	@[i/I"∆      # Sets the model class for a fixture when the class name cannot be inferred from the fixture name.
      #
      # Examples:
      #
      #   set_fixture_class some_fixture:        SomeModel,;Fi[	@≥i>I"∂      # signed in, but we want to refresh the credentials in session.
      #
      # Examples:
      #
      #   sign_in :user, @user                      # sign_in(scope, resource);Fi[	@≥iYI"É      # is no user logged in on the referred scope
      #
      # Examples:
      #
      #   sign_out :user     # sign_out(scope);Fi[	@0iÉI"ª      
      # Checks if the user confirmation happens before the token becomes invalid
      # Examples:
      #
      #   # confirm_within = 3.days and confirmation_sent_at = 2.days.ago;Fi[	@Qi I"í    # This method bypass any warden authentication callback.
    #
    # Examples:
    #
    #   sign_in :user, @user   # sign_in(scope, resource);Fi[	@Qi/I"}    # This method bypass any warden logout callback.
    #
    # Examples:
    #
    #   sign_out :user     # sign_out(scope);Fi[	@È.@i[[	@≤i'I"›      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[	@ü
i?I"›      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[	@¢
i~I"›      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[	@πi%I"›      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[	@¿i/I"›      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[	@«i#I"›      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[	I"MockFormula.new("STRING");F@#/i[[	@Ô'iI"ã  def function
    assert_nothing_raised do
      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING");Fi[	@Ô'iI"ú    assert_nothing_raised do
      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING");Fi[	@Ô'iI"ü      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING");Fi[	@Ô'iI"ü      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING");Fi[	@Ô'iI"ü      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING");Fi[	@Ô'i I"á      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING")
    end;Fi[	I"!var.in_repo_expect("STRING");FI"+var.in_repo_expect("STRING", "STRING");Fi[[	@Ï i3I"¨    HOMEBREW_REPOSITORY.cd do
      var = UpdaterMock.new
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING");Fi[	@Ï i6I"¬      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING");Fi[	@Ï iEI"¨    HOMEBREW_REPOSITORY.cd do
      var = UpdaterMock.new
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING");Fi[	@Ï iHI"«      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING", var);Fi[	@Ï iYI"¨    HOMEBREW_REPOSITORY.cd do
      var = UpdaterMock.new
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING");Fi[	@Ï i\I"«      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING", var);Fi[	I" sha1("STRING" => "LITERAL");F@B/i[[	@€itI"s  
  bottle do
    sha1("STRING" => "LITERAL")
    sha1("STRING" => "LITERAL")
    sha1("STRING" => "LITERAL");Fi[	@€iuI"v  bottle do
    sha1("STRING" => "LITERAL")
    sha1("STRING" => "LITERAL")
    sha1("STRING" => "LITERAL")
  end;Fi[	@€i˛I"s  
  bottle do
    sha1("STRING" => "LITERAL")
    sha1("STRING" => "LITERAL")
    sha1("STRING" => "LITERAL");Fi[	@€iˇI"v  bottle do
    sha1("STRING" => "LITERAL")
    sha1("STRING" => "LITERAL")
    sha1("STRING" => "LITERAL")
  end;Fi[	@€iI"Ç  bottle do
    version("LITERAL")
    sha1("STRING" => "LITERAL")
    sha1("STRING" => "LITERAL")
    sha1("STRING" => "LITERAL");Fi[	@€iI"|    version("LITERAL")
    sha1("STRING" => "LITERAL")
    sha1("STRING" => "LITERAL")
    sha1("STRING" => "LITERAL")
  end;Fi[	@nI"6# @return [Twitter::User] The authenticated user.;Fi[[	@i/I"%      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::User] The authenticated user.
      # @param options [Hash] A customizable set of options.;Fi[	@i@I"%      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::User] The authenticated user.
      # @param device [String] Must be one of: 'sms', 'none'.;Fi[	@iPI"$      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::User] The authenticated user.
      # @param options [Hash] A customizable set of options.;Fi[	@ibI"	      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::User] The authenticated user.
      # @param image [File] The background image for the profile, base64-encoded. Must be a valid GIF, JPG, or PNG image of less than 800 kilobytes in size. Images with width larger than 2048 pixels will be forcibly scaled down. The image must be provided as raw multipart data, not a URL.;Fi[	@irI"$      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::User] The authenticated user.
      # @param options [Hash] A customizable set of options.;Fi[	@iÇI"      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::User] The authenticated user.
      # @param image [File] The avatar image for the profile, base64-encoded. Must be a valid GIF, JPG, or PNG image of less than 700 kilobytes in size. Images with width larger than 500 pixels will be scaled down. Animated GIFs will be converted to a static GIF of the first frame, removing the animation.;Fi[	@¯.I"%# : The backup operation failed.;Fi[[	@≤i)I"√      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[	@ü
iAI"√      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[	@¢
i{I"√      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[	@πi'I"√      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[	@¿i1I"√      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[	@«i%I"√      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[	@£I"return unless var;Fi[[	@É$iI"W    end
    
    def function(var)
      return unless var
      @var ||= Hash.new;Fi[	@’icI"n  end
  
  def function(var)
    return unless var
    reshares.where("LITERAL" => (var.person.id)).first;Fi[	@’ihI"k  end
  
  def function(var)
    return unless var
    likes.where("LITERAL" => (var.person.id)).first;Fi[	I"(projects//haml_proj/haml/options.rb;Ti—I"î      attr_writer("LITERAL")
    else
      def function(var)
        return unless var
        @var = var.is_a?(Encoding) ? (var.name) : (var.to_s);Fi[	@iWI"ô    # @param text [String, nil]
    # @return [String, nil] `text`, marked as HTML-safe
    def function(var)
      return unless var
      var.html_safe;Fi[	@úiI"K    end
    
    def function(var)
      return unless var
      begin;Fi[	@|I"$raise(Compass::Error, "STRING");Fi[[	@É$iI"ù          if (var.size > "LITERAL") then
            raise(Compass::Error, "STRING")
          else
            raise(Compass::Error, "STRING")
          end;Fi[	@\'i,I"∂      if (var.index(from) == "LITERAL") then
        var[((from.length + "LITERAL").."LITERAL")].sub("LITERAL", "STRING")
      else
        raise(Compass::Error, "STRING")
      end;Fi[	@õi{I"ã          if respond_to?(var) then
            targetize("STRING")
          else
            raise(Compass::Error, "STRING")
          end;Fi[	@Œi;I"b    when "LITERAL" then
      "STRING"
    else
      raise(Compass::Error, "STRING")
    end;Fi[	@ŒiCI"à    if File.readable?(var) then
      File.open(var, "STRING") { |var| var.read }
    else
      raise(Compass::Error, "STRING")
    end;Fi[	@*i?I"~      if var.=~(SPRITE_IMPORTER_REGEX) then
        [$1, $3]
      else
        raise(Compass::Error, "STRING")
      end;Fi[	@.@îi[[	@˝iÑI"›      case var["LITERAL"]
      when "STRING" then
        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then
        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]];Fi[	@˝iÜI"        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then
        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then
        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]];Fi[	@˝iàI"        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then
        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then
        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]];Fi[	@˝iäI"        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then
        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then
        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]];Fi[	@˝iåI"        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then
        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then
        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]];Fi[	@˝iéI"ÿ        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then
        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then
        nulltok(var);Fi[	@`/I"H# : Notification will be sent, including the Exception which caused;Fi[[	@≤i*I"”      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[	@ü
iBI"”      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[	@¢
i|I"”      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[	@πi(I"”      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[	@¿i2I"”      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[	@«i&I"”      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[	@@ª.i[[	@≤i#I"”      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[	@ü
i;I"”      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[	@¢
izI"”      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[	@πi!I"”      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[	@¿i+I"”      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[	@«iI"”      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[	@ú/I"F# : the failure, the Exception's backtrace, a copy of the current;Fi[[	@≤i+I"      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[	@ü
iCI"      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[	@¢
i}I"      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[	@πi)I"      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[	@¿i3I"      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[	@«i'I"      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[	@@é.i[[	@≤iI"±      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[	@ü
i7I"±      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[	@¢
ivI"±      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[	@πiI"±      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[	@¿i'I"±      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[	@«iI"±      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[	@H@n
i[[	@i4I"¥      # Returns an array of arrays containing the field values.
      # Order is the same as that returned by +columns+.
      def function(var, var)
        # do nothing
      end;Fi[	@i;I"à      
      # Executes the SQL statement in the context of this connection.
      def function(var, var)
        # do nothing
      end;Fi[	@iI"Q      end
      
      def function(var, var)
        # do nothing
      end;Fi[	@ÿiMI"z      # XInclude end type
      # DOCB document node type
      def function(var, var)
        # do nothing
      end;Fi[	@'i I"”        # * +attrs+ are an assoc list of namespaces and attributes, e.g.:
        #     [ ["xmlns:foo", "http://sample.net"], ["size", "large"] ]
        def function(var, var)
          # do nothing
        end;Fi[	@'ilI"ß        # +name+ is the target of the instruction
        # +content+ is the value of the instruction
        def function(var, var)
          # do nothing
        end;Fi[	@|I"raise(Error, "STRING");Fi[[	@˝i%I"g      when "STRING" then
        arrparse(var)
      else
        raise(Error, "STRING")
      end;Fi[	@˝i6I"{      when "LITERAL", "LITERAL" then
        [var, var["LITERAL"]]
      else
        raise(Error, "STRING")
      end;Fi[	@˝iI"É              var = (var + ucharenc(var, var, var))
            end
          else
            raise(Error, "STRING")
          end;Fi[	@˝iKI"ú      when (("STRING" <= var) and (var <= "STRING")) then
        ((var.ord - "STRING".ord) + "LITERAL")
      else
        raise(Error, "STRING")
      end;Fi[	@˝i_I"b      when Array then
        arrenc(var)
      else
        raise(Error, "STRING")
      end;Fi[	@˝iÖI"c      when String then
        strenc(var)
      else
        raise(Error, "STRING")
      end;Fi[	@_@Ëi[[	@≤ipI"∂      #
      #   person.pets.find(2, 3)
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤i¿I"≈      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤i¯I"≈      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤iI"∏      #
      #   person.pets.delete(2, 3)
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤i0I"≈      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤i6I"Õ      #
      #   person.pets.destroy(Pet.find(2), Pet.find(3))
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	I"var = case var;F@i[[	@≤i0I"j      #
      def function(var)
        var = case var
        when "LITERAL" then
          "STRING";Fi[	@πi.I"j      #
      def function(var)
        var = case var
        when "LITERAL" then
          "STRING";Fi[	@¿i8I"j      #
      def function(var)
        var = case var
        when "LITERAL" then
          "STRING";Fi[	@«i,I"j      #
      def function(var)
        var = case var
        when "LITERAL" then
          "STRING";Fi[	@QiUI"õ      var = var["STRING"]
      var = (var["LITERAL"] or var.result)
      var = case var
      when "LITERAL" then
        var = (var.message or "STRING");Fi[	@›
iJI"^  
  def function(var)
    var = case var
    when "LITERAL" then
      (self / "STRING");Fi[	I"var.putc(var);F@0i[[	@˝iÕI"z            raise(Utf8Error)
          end
          var.putc(var)
          var.putc(var)
          return "LITERAL";Fi[	@˝i◊I"÷          var = (var.&(Umask3) << "LITERAL").|((var.&(Umaskx) << "LITERAL")).|(var.&(Umaskx))
          raise(Utf8Error) if (var <= Uchar2max)
          var.putc(var)
          var.putc(var)
          var.putc(var);Fi[	@˝iÿI"ì          raise(Utf8Error) if (var <= Uchar2max)
          var.putc(var)
          var.putc(var)
          var.putc(var)
          return "LITERAL";Fi[	@˝i‚I"ˆ          var = (var.&(Umask4) << "LITERAL").|((var.&(Umaskx) << "LITERAL")).|((var.&(Umaskx) << "LITERAL")).|(var.&(Umaskx))
          raise(Utf8Error) if (var <= Uchar3max)
          var.putc(var)
          var.putc(var)
          var.putc(var);Fi[	@˝i„I"ê          raise(Utf8Error) if (var <= Uchar3max)
          var.putc(var)
          var.putc(var)
          var.putc(var)
          var.putc(var);Fi[	@˝i‰I"          var.putc(var)
          var.putc(var)
          var.putc(var)
          var.putc(var)
          return "LITERAL";Fi[	@π/I"K# : backup log and other information if `on_failure` was set to `true`;Fi[[	@≤i,I"      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[	@ü
iDI"      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[	@¢
i~I"      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[	@πi*I"      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[	@¿i4I"      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[	@«i(I"      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[	I"$var = "LITERAL".match(var.to_s);F@¿"i[[	@zioI"Õ      "LITERAL".match(var.to_s) ? (Pathname.new(var.dirname).stem) : (var.stem)
    end
    var = "LITERAL".match(var.to_s)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var.to_s);Fi[	@ziqI"«    var = "LITERAL".match(var.to_s)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var.to_s)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var.to_s);Fi[	@zisI"«    var = "LITERAL".match(var.to_s)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var.to_s)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var.to_s);Fi[	@ziuI"«    var = "LITERAL".match(var.to_s)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var.to_s)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var.to_s);Fi[	@ziwI"¬    var = "LITERAL".match(var.to_s)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var.to_s)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var);Fi[	@ziäI"§    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var.to_s)
    return var.captures.first unless var.nil?
  end;Fi[	@Ô+@îi[[	@˝iíI"á        case var[var]
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING");Fi[	@˝iîI"è          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING");Fi[	@˝iñI"è          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING");Fi[	@˝iòI"è          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING");Fi[	@˝iöI"è          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING");Fi[	@˝iúI"è          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING");Fi[	@H@;i[[	@Üi>I"|      #
      #   distinct("posts.id", "posts.created_at desc")
      def function(var, var)
        "STRING"
      end;Fi[	@∏i!I"9  end
  
  def function(var, var)
    "STRING"
  end;Fi[	@Ôi8I"ò    # @param str [String] The string to add before the Haml
    # @yield A block of Haml to prepend to
    def function(var, var)
      "STRING"
    end;Fi[	@ÔiKI"ñ    # @param str [String] The string to add after the Haml
    # @yield A block of Haml to append to
    def function(var, var)
      "STRING"
    end;Fi[	@iÎI"≠    # @param vars [Array<Boolean>] The static variable assignment
    # @return [String] The real name of the static method
    def function(var, var)
      "STRING"
    end;Fi[	I"3projects//jekyll_proj/jekyll/tags/highlight.rb;Ti2I"C    end
    
    def function(var, var)
      "STRING"
    end;Fi[	@0@i[[	@≤i-I"˛      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(var);Fi[	@ü
iEI"˛      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(var);Fi[	@¢
iI"˛      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(var);Fi[	@πi+I"˛      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(var);Fi[	@¿i5I"˛      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(var);Fi[	@«i)I"˛      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(var);Fi[	@@Hi[[	@iI"v    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(var, var)
      begin;Fi[	@i>I"≈    # layouts - A Hash of {"name" => "layout"}.
    #
    # Returns nothing.
    def function(var, var)
      var = { "LITERAL" => ([Jekyll::Filters]), "LITERAL" => ({ "LITERAL" => (self.site) }) };Fi[	@i%I"{    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(var, var)
      super(var, var);Fi[	@ihI"ø    # site_payload - The site payload Hash.
    #
    # Returns nothing.
    def function(var, var)
      var = { "STRING" => (self.to_liquid), "STRING" => (pager.to_liquid) }.deep_merge(var);Fi[	@
iCI"{    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(var, var)
      super(var, var);Fi[	@
iªI"Ë    # site_payload - The site payload hash.
    #
    # Returns nothing.
    def function(var, var)
      var = { "STRING" => ({ "STRING" => (related_posts(var["STRING"]["STRING"])) }), "STRING" => (self.to_liquid) }.deep_merge(var);Fi[	@I"# Options:;Fi[[	@òi#I"Ö      #     end
      #   end
      #
      # Options:
      # * <tt>:on</tt> - Specifies the context where this validation is active;Fi[	@òi]I"Ö      #     end
      #   end
      #
      # Options:
      # * <tt>:on</tt> - Specifies the context where this validation is active;Fi[	@ñi@I"á      #
      # See load_and_authorize_resource to automatically authorize the resource too.
      #
      # Options:
      # [:+only+];Fi[	@ñiéI"Ç      #
      # See load_and_authorize_resource to automatically load the resource too.
      #
      # Options:
      # [:+only+];Fi[	@ñiÂI"å      #
      # See skip_authorization_check to bypass this check on specific controller actions.
      #
      # Options:
      # [:+only+];Fi[	@i\I"¶    # and can instead point to an action in your app, for example for fine grained
    # security; this has a serious performance tradeoff.
    #
    # Options:
    #;Fi[	I"!@var = var.delete("LITERAL");F@Ö0i[[	@iI"ù      @var = var
      if var.is_a?(Hash) then
        @var = var.delete("LITERAL")
        @var = var.delete("LITERAL")
        @var = var.delete("LITERAL");Fi[	@iI"±      if var.is_a?(Hash) then
        @var = var.delete("LITERAL")
        @var = var.delete("LITERAL")
        @var = var.delete("LITERAL")
        @var = var.delete("LITERAL");Fi[	@iI"∏        @var = var.delete("LITERAL")
        @var = var.delete("LITERAL")
        @var = var.delete("LITERAL")
        @var = var.delete("LITERAL")
        @var = var.delete("LITERAL");Fi[	@iI"¶        @var = var.delete("LITERAL")
        @var = var.delete("LITERAL")
        @var = var.delete("LITERAL")
        @var = var.delete("LITERAL")
        @var = var;Fi[	@i#I"¨    # Creates a new branch
    def function(var)
      @var = var.delete("LITERAL")
      @var = var.delete("LITERAL")
      @var = build_matcher(var, "LITERAL", "LITERAL");Fi[	@wiI"ù    def function(var)
      @var = var
      @var = var.delete("LITERAL")
      @var = var.delete("LITERAL")
      @var = (var.delete("LITERAL") or "STRING");Fi[	@Ÿ@ÿi[[	@´iI"Ω      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(var, var, var)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop);Fi[	@´i&I"ã      end
      
      def function(var, var, var)
        var = Twitter::API::Arguments.new(var)
        merge_user!(var.options, var.pop);Fi[	@´i0I"|      end
      
      def function(var, var, var)
        var = Twitter::API::Arguments.new(var)
        var = var.pop;Fi[	@iI"æ      # @param args [Array]
      # @return [Array<Twitter::Tweet>]
      def function(var, var, var)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |var|;Fi[	@iI"Ω      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(var, var, var)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |var|;Fi[	@iI"⁄      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(var, var, var)
        var = Twitter::API::Arguments.new(var)
        unless (var.options["LITERAL"] or var.options["LITERAL"]) then;Fi[	@Æ@**i[[	@iiI"∏      # Creates a new instance of the Riak adapter object
      def function(var, var)
        super(var)
        instance_eval(&var) if block_given?
        @var ||= utility("STRING");Fi[	@≤iI"à      # Campfire account's room id
      def function(var, var)
        super(var)
        instance_eval(&var) if block_given?
      end;Fi[	@¢
imI"à      # Example: '/tmp/test-mails'
      def function(var, var)
        super(var)
        instance_eval(&var) if block_given?
      end;Fi[	@πiI"¨      # Create a Prowl account and request an API key on prowlapp.com.
      def function(var, var)
        super(var)
        instance_eval(&var) if block_given?
      end;Fi[	@¿iI"é      # The priority of the notification
      def function(var, var)
        super(var)
        instance_eval(&var) if block_given?
      end;Fi[	@«iI"      # OAuth credentials
      def function(var, var)
        super(var)
        instance_eval(&var) if block_given?
      end;Fi[	@4I"when Hash then;Fi[[	@v
iHI"g      
      def function(var)
        case var
        when Hash then
          preload_hash(var);Fi[	@ÜiVI"œ      def function(var, var, var)
        if var.is_a?(Hash) and var = var["LITERAL"] then
          case var
          when Hash then
            var.each { |var| var[var] += "STRING" if var.has_key?(var) };Fi[	@Ui:I"§      def function(var, var, var)
        if var.is_a?(Hash) and var = var["LITERAL"] then
          case var
          when Hash then
            var.each do |var|;Fi[	@˝iZI"    # Strings contained in x must be valid UTF-8.
    def function(var)
      case var
      when Hash then
        objenc(var);Fi[	@˝ieI"W    
    def function(var)
      case var
      when Hash then
        objenc(var);Fi[	@i0I"¢        var = Nokogiri::XML::Element.new(var, self, &var)
        var.each do |var|
          case var
          when Hash then
            var.each do |var, var|;Fi[	@|I"var.pos -= "LITERAL";Fi[[	I"Bprojects//rescue_proj/resque/vendor/utf8_util/utf8_util_18.rb;Ti I"v      if check_next_sequence(var) then
        return "LITERAL"
      else
        var.pos -= "LITERAL"
      end;Fi[	@¬0i(I"Ö          if check_next_sequence(var) then
            return "LITERAL"
          else
            var.pos -= "LITERAL"
          end;Fi[	@¬0i+I"k            var.pos -= "LITERAL"
          end
        else
          var.pos -= "LITERAL"
        end;Fi[	@¬0i4I"ô              if check_next_sequence(var) then
                return "LITERAL"
              else
                var.pos -= "LITERAL"
              end;Fi[	@¬0i7I"                var.pos -= "LITERAL"
              end
            else
              var.pos -= "LITERAL"
            end;Fi[	@¬0i:I"u              var.pos -= "LITERAL"
            end
          else
            var.pos -= "LITERAL"
          end;Fi[	@n@Œ+i[[	@Œi!I"ﬁ      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.;Fi[	@Œi4I"ﬁ      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.;Fi[	@ŒiNI"ﬁ      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.;Fi[	@ŒicI"2      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [String] :name The name a place is known as.;Fi[	@˙i(I"      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @return [Array<Twitter::Place>];Fi[	@˙i8I"Í      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat If provided with a :long option the available trend locations will be sorted by distance, nearest to furthest, to the co-ordinate pair. The valid ranges for latitude are -90.0 to +90.0 (North is positive) inclusive.;Fi[	I"# @param klass [Class];F@Ò!i[[	@i&I"v      end
      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String];Fi[	@i1I"v      end
      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String];Fi[	@iBI"v      end
      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String];Fi[	@iNI"v      end
      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String];Fi[	@iYI"è      
      # @param collection_name [Symbol]
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String];Fi[	@ihI"è      
      # @param collection_name [Symbol]
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String];Fi[	I"O# * <tt>:if</tt> - Specifies a method, proc or string to call to determine;FI"M#   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,;Fi[[	@ÇiPI"e      #   validation contexts by default (+nil+), other options are <tt>:create</tt>
      #   and <tt>:update</tt>.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,;Fi[	@ãi=I"W      # * <tt>:on</tt> - Specifies when this validation is active
      #   (<tt>:create</tt> or <tt>:update</tt>.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>).;Fi[	@òi)I"Ä      # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.
      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,;Fi[	@òicI"Ä      # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.
      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,;Fi[	@ki)I"e      #   validation contexts by default (+nil+), other options are <tt>:create</tt>
      #   and <tt>:update</tt>.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,;Fi[	@qiÑI"t      # * <tt>:allow_blank</tt> - If set to +true+, skips this validation if the
      #   attribute is blank (default is +false+).
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,;Fi[	@:I"@var = "LITERAL";Fi[[	@ûiI"©        # collects image sizes and input parameters for each sprite
        # Calculates the height
        def function
          @var = "LITERAL"
          init_images;Fi[	@w!iI"}  
  # 410 GONE
  def function
    @var = "LITERAL"
    var = params["LITERAL"] ? (params["LITERAL"].to_i) : ("LITERAL");Fi[	@w!i6I"o  end
  
  def function
    @var = "LITERAL"
    @var = Person.where("LITERAL" => (search_query.downcase));Fi[	@“i
I"{  respond_to("LITERAL", "LITERAL")
  
  def function
    @var = "LITERAL"
    @var = Person.find_by_guid(params["LITERAL"]);Fi[	@Å!iI"[  respond_to("LITERAL")
  
  def function
    @var = "LITERAL"
    @var = current_user;Fi[	@Å!iwI"I  end
  
  def function
    @var = "LITERAL"
    @var = current_user;Fi[	@:I"synchronize do;Fi[[	@giµI"’      
      # Is there an open connection that is being used for the current thread?
      def function
        synchronize do
          @reserved_connections.fetch(current_connection_id) { return false }.in_use?;Fi[	@giÿI"ú      
      # Disconnects all connections in the pool, and clears the pool.
      def function
        synchronize do
          @reserved_connections.clear;Fi[	@giÂI"É      
      # Clears the cache which maps classes.
      def function
        synchronize do
          @reserved_connections.clear;Fi[	@giI"´      # Raises:
      # - ConnectionTimeoutError: no connection can be obtained from the pool.
      def function
        synchronize do
          var = acquire_connection;Fi[	@gi)I"”      # if a programmer forgets to close a connection at the end of a thread
      # or a thread dies unexpectedly.
      def function
        synchronize do
          var = (Time.now - @dead_connection_timeout);Fi[	@PiRI"\      end
      
      def function
        synchronize do
          unless in_use then;Fi[	I"module Paperclip;FI"module Shoulda;Fi[[	@Ci I":module Paperclip
  module Shoulda
    module Matchers;Fi [	@Ji I":module Paperclip
  module Shoulda
    module Matchers;Fi [	@Oi I":module Paperclip
  module Shoulda
    module Matchers;Fi [	@Vi I":module Paperclip
  module Shoulda
    module Matchers;Fi [	I"3projects//paperclip_proj/paperclip/matchers.rb;Ti	I"ªrequire("paperclip/matchers/validate_attachment_content_type_matcher")
require("paperclip/matchers/validate_attachment_size_matcher")
module Paperclip
  module Shoulda
    module Matchers;Fi[	I"*projects//paperclip_proj/paperclip.rb;TiI"Zrequire("paperclip/matchers")
module Paperclip
  module Shoulda
    include(Matchers);Fi[	@Ÿ@ˆi[[	@∫iwI"    
    class RealTransaction < OpenTransaction
      def function(var, var, var)
        super
        if var["LITERAL"] then;Fi[	@Ji
I"å      attr_accessor("LITERAL")
      
      def function(var, var, var)
        super
        @var = Manifest.new(manifest_file, var) if var;Fi[	@W0iI"u    # 1. name
    # 2. name=value
    def function(var, var, var)
      super
      if var.strip.=~(SYNTAX) then;Fi[	@–iI"vmodule Jekyll
  class IncludeTag < Liquid::Tag
    def function(var, var, var)
      super
      @var = var.strip;Fi[	I"2projects//jekyll_proj/jekyll/tags/post_url.rb;TiI"h  
  class PostUrl < Liquid::Tag
    def function(var, var, var)
      super
      @var = var.strip;Fi[	@b
iI"Ã    #   +format+ - the desired filename extension
    #   +animated+ - whether to merge all the layers in the image. Defaults to true
    def function(var, var, var)
      super
      var = var["LITERAL"];Fi[	@π$@b.i[[	@≤iI"á      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	@ü
i4I"á      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	@¢
isI"á      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	@πiI"á      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	@¿i$I"á      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	@«iI"á      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	I"@var = "STRING";F@I1i[[	@ iBI"Î          @var, @var = var.fetch("LITERAL", "STRING"), var.fetch("LITERAL", "STRING")
          @var = /^(?:#{Regexp.escape(@prefix)}STRING#{Regexp.escape(@suffix)}STRING/
          @var = "STRING"
          @var = "STRING"
        end;Fi[	@-*iI"|        @var ||= false
        instance_eval(&var) if block_given?
        @var = "STRING"
        @var = "STRING"
      end;Fi[	@0*iI"|        @var ||= false
        instance_eval(&var) if block_given?
        @var = "STRING"
        @var = "STRING"
      end;Fi[	@3*iI"|        @var ||= false
        instance_eval(&var) if block_given?
        @var = "STRING"
        @var = "STRING"
      end;Fi[	@6*iI"|        @var ||= false
        instance_eval(&var) if block_given?
        @var = "STRING"
        @var = "STRING"
      end;Fi[	@Ì,iI"H  
  def function
    @var = "STRING"
    @var = "STRING"
    super;Fi[	@I"# @example;Fi[[	@iI"ó    # Computes the powerset of the given array.
    # This is the set of all subsets of the array.
    #
    # @example
    #   powerset([1, 2, 3]) #=>;Fi[	@€i@I"Õ      # @param name [Symbol] The key of the default option in your configuration hash.
      # @param value [Object] The value your object defaults to. Nil if not provided.
      #
      # @example
      #;Fi[	@€i}I"†    # Direct access to the OmniAuth logger, automatically prefixed
    # with this strategy's name.
    #
    # @example
    #   log :warn, "This is a warning.";Fi[	@€i=I"ú    # to true or by setting `:skip_info` to a Proc that takes a uid and
    # evaluates to true when you would like to skip info.
    #
    # @example
    #;Fi[	@)1i6I"â    
    # Stubs the HTTP PUT for an attachment using S3 storage.
    #
    # @example
    #   stub_paperclip_s3('user', 'avatar', 'png');Fi[	@)1iLI"•    #
    #     When I attach a "demo_tape" "mp3" file to a "band" on S3
    #
    # @example
    #   Factory.define :band_with_demo_tape, :parent => :band do |band|;Fi[	@:I"'if (action_hook == "LITERAL") then;Fi[[	@ÃigI"          (::ActiveRecord::VERSION::MAJOR == "LITERAL") and (::ActiveRecord::VERSION::MINOR == "LITERAL")
        end
        def function
          if (action_hook == "LITERAL") then
            owner_class.set_callback("LITERAL", "LITERAL", "STRING", "LITERAL" => (true));Fi[	@)i;I"‚      
      # Uses around callbacks to run state events if using the :save hook
      def function
        if (action_hook == "LITERAL") then
          owner_class.set_callback("LITERAL", "LITERAL", self, "LITERAL" => (true));Fi[	@”iOI"˘          defined? ::MongoMapper::Version and ::MongoMapper::Version =~ "LITERAL"
        end
        def function
          if (action_hook == "LITERAL") then
            owner_class.set_callback("LITERAL", "LITERAL", "STRING", "LITERAL" => (true));Fi[	@,i4I"‚      
      # Uses around callbacks to run state events if using the :save hook
      def function
        if (action_hook == "LITERAL") then
          owner_class.set_callback("LITERAL", "LITERAL", self, "LITERAL" => (true));Fi[	@ÃiI"˜          define_helper("LITERAL", "STRING", "STRING", ("LITERAL" + "LITERAL"))
        end
        def function
          if (action_hook == "LITERAL") then
            owner_class.set_callback("LITERAL", "LITERAL", "STRING", "LITERAL" => (true));Fi[	@/i8I"‚      
      # Uses around callbacks to run state events if using the :save hook
      def function
        if (action_hook == "LITERAL") then
          owner_class.set_callback("LITERAL", "LITERAL", self, "LITERAL" => (true));Fi[	@£I"+var = Devise::Mapping.find_scope!(var);Fi[[	@≥iI"ﬂ      #   redirect_to stored_location_for(:user) || root_path
      #
      def function(var)
        var = Devise::Mapping.find_scope!(var)
        is_navigational_format? ? (session.delete("STRING")) : (session["STRING"]);Fi[	@≥iÅI"˙      # The scope root url to be used when he's signed in. By default, it first
      # tries to find a resource_root_path, otherwise it uses the root_path.
      def function(var)
        var = Devise::Mapping.find_scope!(var)
        var = "STRING";Fi[	@≥i≈I"ÿ      # Sign out a user and tries to redirect to the url specified by
      # after_sign_out_path_for.
      def function(var)
        var = Devise::Mapping.find_scope!(var)
        var = after_sign_out_path_for(var);Fi[	@ﬂiI"æ      
      # Remembers the given resource by setting up a cookie
      def function(var)
        var = Devise::Mapping.find_scope!(var)
        var.remember_me!(var.extend_remember_period);Fi[	@ﬂiI"ú      
      # Forgets the given resource by deleting a cookie
      def function(var)
        var = Devise::Mapping.find_scope!(var)
        var.forget_me!;Fi[	@Qi4I"π    #   sign_out @user     # sign_out(resource)
    #
    def function(var)
      var = Devise::Mapping.find_scope!(var)
      @controller.instance_variable_set(:"@current_#{var}", nil);Fi[	@H@¢%i[[	@liMI"´        #   person.valid? # => true
        #   person.status # => true
        def function(var, var)
          var = var.extract_options!
          var["LITERAL"] = true;Fi[	@ãiXI"|      #     end
      #   end
      def function(var, var)
        var = var.extract_options!
        var.each do |var|;Fi[	@ãiÜI"œ    # to the class and available as +options+, please refer to the
    # class version of this method for more information.
    def function(var, var)
      var = var.extract_options!
      var.each do |var|;Fi[	@òilI"∆      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(var, var)
        var = var.extract_options!
        if var.key?("LITERAL") then;Fi[	@≥iEI"«      #   sign_in @user, :bypass => true            # sign_in(resource, options)
      #
      def function(var, var)
        var = var.extract_options!
        var = Devise::Mapping.find_scope!(var);Fi[	@≥i∑I"È      # then to the url specified by after_sign_in_path_for. It accepts the same
      # parameters as the sign_in method.
      def function(var, var)
        var = var.extract_options!
        var = Devise::Mapping.find_scope!(var);Fi[	I"#   </firm>;F@i[[	@hiMI"∑    #       <credit-limit type="integer">50</credit-limit>
    #     </account>
    #   </firm>
    #
    # Additionally, the record being serialized will be passed to a Proc's second;Fi[	@hi\I"¡    #     # ... normal attributes as shown above ...
    #     <name-reverse>slangis73</name-reverse>
    #   </firm>
    #
    # To include deeper levels of associations pass a hash like this:;Fi[	@hizI"≥    #       <credit-limit type="integer">50</credit-limit>
    #     </account>
    #   </firm>
    #
    # To include any methods on the model being called use <tt>:methods</tt>:;Fi[	@hiI"◊    #     <calculated-earnings>100000000000000000</calculated-earnings>
    #     <real-earnings>5</real-earnings>
    #   </firm>
    #
    # To call any additional Procs use <tt>:procs</tt>. The Procs are passed a;Fi[	@hiäI"∑    #     # ... normal attributes as shown above ...
    #     <abc>def</abc>
    #   </firm>
    #
    # Alternatively, you can yield the builder object as part of the +to_xml+ call:;Fi[	@hiõI"´    #       <last_name>Heinemeier Hansson</last_name>
    #     </creator>
    #   </firm>
    #
    # As noted above, you may override +to_xml+ in your ActiveRecord::Base;Fi[	@Ä#I"module Installers;Fi[[	@
i I"6module Compass
  module Installers
    class Base;Fi [	@
i I"Fmodule Compass
  module Installers
    class BareInstaller < Base;Fi [	@õi I"6module Compass
  module Installers
    class Base;Fi [	@®i I":module Compass
  module Installers
    class Manifest;Fi [	@Ji I"Jmodule Compass
  module Installers
    class ManifestInstaller < Base;Fi [	@´i I"Amodule Compass
  module Installers
    class TemplateContext;Fi [	I""var.gsub!("STRING", "STRING");F@±1i[[	@pigI"‡      var.force_encoding("STRING") if var.respond_to?("LITERAL")
      var = HTMLEntities.new.encode(var, "LITERAL")
      var.gsub!("STRING", "STRING")
      var.gsub!("STRING", "STRING")
      var.gsub!("STRING", "STRING");Fi[	@pihI"√      var = HTMLEntities.new.encode(var, "LITERAL")
      var.gsub!("STRING", "STRING")
      var.gsub!("STRING", "STRING")
      var.gsub!("STRING", "STRING")
      var.gsub!("STRING", "STRING");Fi[	@piiI"≥      var.gsub!("STRING", "STRING")
      var.gsub!("STRING", "STRING")
      var.gsub!("STRING", "STRING")
      var.gsub!("STRING", "STRING")
      var.gsub!("STRING", "STRING");Fi[	@pijI"≥      var.gsub!("STRING", "STRING")
      var.gsub!("STRING", "STRING")
      var.gsub!("STRING", "STRING")
      var.gsub!("STRING", "STRING")
      var.gsub!("STRING", "STRING");Fi[	@pikI"ô      var.gsub!("STRING", "STRING")
      var.gsub!("STRING", "STRING")
      var.gsub!("STRING", "STRING")
      var.gsub!("STRING", "STRING")
      var;Fi[	I"Tprojects//state_machine_proj/state_machine/integrations/active_record/locale.rb;TiI"œif (defined? I18n::VERSION.! or (I18n::VERSION < "STRING")) then
  var["LITERAL"]["LITERAL"]["LITERAL"]["LITERAL"].each do |var, var|
    var.gsub!("STRING", "STRING")
    var.gsub!("STRING", "STRING")
  end;Fi[	I"5# dest - The String path to the destination dir.;F@i[[	@iwI"è    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #
    # Returns the destination file path String.;Fi[	@i}I"ô    # Write the generated page file to the destination directory.
    #
    # dest - The String path to the destination dir.
    #
    # Returns nothing.;Fi[	@
i√I"ã    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #
    # Returns destination file path String.;Fi[	@
iŒI"ô    # Write the generated post file to the destination directory.
    #
    # dest - The String path to the destination dir.
    #
    # Returns nothing.;Fi[	@ÌiI"Ñ    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #
    # Returns destination file path.;Fi[	@Ìi3I"“    # Write the static file to the destination directory (if modified).
    #
    # dest - The String path to the destination dir.
    #
    # Returns false if the file was not modified since last time (no-op).;Fi[	@ÎI"module Compressor;Fi[[	I"4projects//backup_proj/backup/compressor/base.rb;Ti I"5module Backup
  module Compressor
    class Base;Fi [	@-*i I"=module Backup
  module Compressor
    class Bzip2 < Base;Fi [	I"6projects//backup_proj/backup/compressor/custom.rb;Ti I">module Backup
  module Compressor
    class Custom < Base;Fi [	@0*i I"<module Backup
  module Compressor
    class Gzip < Base;Fi [	@3*i I"<module Backup
  module Compressor
    class Lzma < Base;Fi [	@6*i I">module Backup
  module Compressor
    class Pbzip2 < Base;Fi [	@:+I"module Handlers;Fi[[	@S!iI"jmodule StateMachine
  module YARD
    module Handlers
      class Base < ::YARD::Handlers::Ruby::Base;Fi[	@?+iI"Smodule StateMachine
  module YARD
    module Handlers
      class Event < Base;Fi[	@›iI"irequire("tempfile")
module StateMachine
  module YARD
    module Handlers
      class Machine < Base;Fi[	@D+iI"Smodule StateMachine
  module YARD
    module Handlers
      class State < Base;Fi[	@˚
iI"Xmodule StateMachine
  module YARD
    module Handlers
      class Transition < Base;Fi[	@I+iI"Bmodule StateMachine
  module YARD
    module Handlers
    end;Fi[	@ÎI"module Database;Fi[[	@Ÿi I"3module Backup
  module Database
    class Base;Fi [	@ci I"=module Backup
  module Database
    class MongoDB < Base;Fi [	@i I";module Backup
  module Database
    class MySQL < Base;Fi [	@i I"@module Backup
  module Database
    class PostgreSQL < Base;Fi [	@fi I";module Backup
  module Database
    class Redis < Base;Fi [	@ii I":module Backup
  module Database
    class Riak < Base;Fi [	@Ù@Ùi[[	@biI"Ö      return if var.blank?
      var = var.stringify_keys
      var = []
      var = []
      var = sanitize_for_mass_assignment(var);Fi[	@.!iLI"H  
  def function(var)
    var = []
    var = []
    var = "STRING";Fi[	@7i&I"ù        if var then
          $found = var.length
          var = []
          var = []
          (var << Thread.new { search_tap("STRING", "STRING", var) });Fi[	@—iCI"ñ    end
    unless ignore_deps then
      var = []
      var = []
      if f.recursive_deps.any? { |var| (var.name == "STRING") } and ARGV.debug? then;Fi[	@pi7I"i        end
      end
      var = []
      var = []
      if (var["LITERAL"] or var["LITERAL"]) then;Fi[	@;ivI"i    def function
      return if @jobs.empty?
      var = []
      var = []
      var = roles.empty?;Fi[	I"respond_to do |var|;FI"var.json do;Fi[[	@M#iI"⁄    @var = current_user.comment!(var, params["LITERAL"]) if var
    if @comment then
      respond_to do |var|
        var.json do
          render("LITERAL" => (CommentPresenter.new(@comment)), "LITERAL" => "LITERAL");Fi[	I"Dprojects//diaspora_proj/controllers/notifications_controller.rb;TiI"Ã    if var then
      var.set_read_state(params["LITERAL"].!=("STRING"))
      respond_to do |var|
        var.json do
          render("LITERAL" => ({ "LITERAL" => (var.id), "LITERAL" => (var.unread) }));Fi[	@w!i#I"≈    var = params["LITERAL"] ? (params["LITERAL"].to_i) : ("LITERAL")
    @var = Person.search(search_query, current_user)
    respond_to do |var|
      var.json do
        @var = @people.limit(var);Fi[	@“i-I"        @var = current_user.build_post("LITERAL", params["LITERAL"])
        if @photo.save then
          respond_to do |var|
            var.json do
              render("LITERAL" => ({ "STRING" => (true), "STRING" => (@photo.as_api_response("LITERAL")) }));Fi[	@“i®I"Ã        current_user.update_profile(var)
      end
      respond_to do |var|
        var.json do
          render("LITERAL" => (false), "LITERAL" => ({ "STRING" => (true), "STRING" => (@photo) }.to_json));Fi[	@µiI"µ  def function
    @var = Person.find_by_guid!(params["LITERAL"])
    respond_to do |var|
      var.json do
        render("LITERAL" => (PersonPresenter.new(@person, current_user)));Fi[	@%@|i[[	@^iÏI"         if (var["LITERAL"] == "STRING") then
          var = ["STRING", "STRING", "STRING", "STRING"]
          var = Node.new("LITERAL", var)
        else
          if (var["LITERAL"] == "STRING") then;Fi[	@^iI"π          if (var["LITERAL"] == "STRING") then
            var = ["STRING", "STRING", "STRING", "STRING"]
            var = Node.new("LITERAL", var)
          else
            var = var;Fi[	@^i˙I"∞      def function(var, var, var)
        if (var["LITERAL"] == "STRING") then
          var = Node.new("LITERAL", var)
        else
          raise(Racc::ParseError, "STRING");Fi[	@^iI"±        if (var["LITERAL"] == "STRING") then
          var.unshift("STRING")
          var = Node.new("LITERAL", var)
        else
          if (var["LITERAL"] == "STRING") then;Fi[	@^i	I"Ø            var["LITERAL"] = "STRING"
            var.unshift("STRING")
            var = Node.new("LITERAL", var)
          else
            raise(Racc::ParseError, "STRING");Fi[	@^iI"ô          (var << "STRING")
          (var << "STRING")
          var = Node.new("LITERAL", var)
        else
          raise(Racc::ParseError, "STRING");Fi[	@I"# Examples;Fi[[	@@i3I"F    #
    # date - The Time to format.
    #
    # Examples
    #;Fi[	@@iBI"I    #
    # input - The String to escape.
    #
    # Examples
    #;Fi[	@@iQI"I    #
    # input - The String to escape.
    #
    # Examples
    #;Fi[	@@imI"Q    #
    # array - The Array of Strings to join.
    #
    # Examples
    #;Fi[	@Z
iÕI"®    
    # Private: creates a regular expression from the keep_files array
    # 
    # Examples
    #   ['.git','.svn'] creates the following regex: /\/(\.git|\/.svn)/;Fi[	@Z
i‰I"^    #
    # post_attr - The String name of the Post attribute.
    #
    # Examples
    #;Fi[	I"var = var["STRING"];F@;2i[[	@~!iI"˙    var = var["STRING"]["STRING"]
    var = var["STRING"]["STRING"]
    var = var["STRING"]
    var = var["STRING"]
    var = "STRING".constantize.new("LITERAL" => (var["STRING"]), "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => (var["STRING"]));Fi[	@}i	I"µ    def self.process(var)
      var = Jekyll::Site.new(var)
      var = var["STRING"]
      var = var["STRING"]
      var["STRING"] ? (self.watch(var, var)) : (self.build(var, var));Fi[	@}iI"o    
    def self.build(var, var)
      var = var["STRING"]
      var = var["STRING"]
      puts("STRING");Fi[	@}i I"à    def self.watch(var, var)
      require("directory_watcher")
      var = var["STRING"]
      var = var["STRING"]
      puts("STRING");Fi[	@
i6I"Ç      case var["STRING"]
      when "STRING" then
        var = var["STRING"]
        var = var["STRING"]
      when "STRING" then;Fi[	@
iWI"∞        (var << "STRING")
      when "STRING" then
        var = var["STRING"]
        var = var["STRING"]
        (var << ("STRING" + var["STRING"])) unless var["STRING"].nil?;Fi[	@@¡1i[[	@ivI"i    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #;Fi[	@i|I"á    
    # Write the generated page file to the destination directory.
    #
    # dest - The String path to the destination dir.
    #;Fi[	@
i¬I"i    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #;Fi[	@
iÕI"á    
    # Write the generated post file to the destination directory.
    #
    # dest - The String path to the destination dir.
    #;Fi[	@ÌiI"i    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #;Fi[	@Ìi2I"ç    
    # Write the static file to the destination directory (if modified).
    #
    # dest - The String path to the destination dir.
    #;Fi[	@I"+#   class Article < ActiveRecord::Base;Fi[[	@Ti6I"ÿ        # Use this macro in your model to set a default scope for all operations on
        # the model.
        #
        #   class Article < ActiveRecord::Base
        #     default_scope { where(published: true) };Fi[	@TiII"Â        # If you use multiple +default_scope+ declarations in your model then
        # they will be merged together:
        #
        #   class Article < ActiveRecord::Base
        #     default_scope { where(published: true) };Fi[	@TiWI"‡        # If you need to do more complex things with a default scope, you can
        # alternatively define it as a class method:
        #
        #   class Article < ActiveRecord::Base
        #     def self.default_scope;Fi[	@[ixI"ƒ        #
        # Scopes can also be used while creating/building a record.
        #
        #   class Article < ActiveRecord::Base
        #     scope :published, -> { where(published: true) };Fi[	@[i}I"Ï        # \Class methods on your model are automatically available
        # on scopes. Assuming the following setup:
        #
        #   class Article < ActiveRecord::Base
        #     scope :published, -> { where(published: true) };Fi[	@qipI"˜      # are not being taken into consideration when validating uniqueness
      # of the title attribute:
      #
      #   class Article < ActiveRecord::Base
      #     validates_uniqueness_of :title, conditions: where('status != ?', 'archived');Fi[	@'@:i[[	@Z-iI"Õ      # A collection containing the favorited tweet
      #
      # @return [Array<Twitter::Tweet>]
      def function
        @var = Array(@attrs["LITERAL"]).map { |var| Twitter::Tweet.fetch_or_new(var) };Fi[	@y'iI"Ã      # A collection of tweets that mention a user
      #
      # @return [Array<Twitter::Tweet>]
      def function
        @var = Array(@attrs["LITERAL"]).map { |var| Twitter::Tweet.fetch_or_new(var) };Fi[	@c-iI"Õ      # A collection of tweets that reply to a user
      #
      # @return [Array<Twitter::Tweet>]
      def function
        @var = Array(@attrs["LITERAL"]).map { |var| Twitter::Tweet.fetch_or_new(var) };Fi[	@c-iI"“      # A collection that contains the replied-to tweets
      #
      # @return [Array<Twitter::Tweet>]
      def function
        @var = Array(@attrs["LITERAL"]).map { |var| Twitter::Tweet.fetch_or_new(var) };Fi[	@~'iI"∫      # A collection of retweets
      #
      # @return [Array<Twitter::Tweet>]
      def function
        @var = Array(@attrs["LITERAL"]).map { |var| Twitter::Tweet.fetch_or_new(var) };Fi[	@¿iI"¬module Twitter
  class SearchResults < Twitter::Base
    # @return [Array<Twitter::Tweet>]
    def function
      @var ||= Array(@attrs["LITERAL"]).map { |var| Twitter::Tweet.fetch_or_new(var) };Fi[	@¯-@¯-i
[
[	@Í
i"I"ï          end)
        rescue LoadError
          STDERR.puts("STRING")
          STDERR.puts("STRING")
          raise(FatalException.new("STRING"));Fi[	@Í
i*I"§          require("kramdown")
        rescue LoadError
          STDERR.puts("STRING")
          STDERR.puts("STRING")
          raise(FatalException.new("STRING"));Fi[	@Í
i3I"Õ          @var = @config["STRING"]["STRING"].map { |var| var.to_sym })
        rescue LoadError
          STDERR.puts("STRING")
          STDERR.puts("STRING")
          raise(FatalException.new("STRING"));Fi[	@Í
iII"ï          end)
        rescue LoadError
          STDERR.puts("STRING")
          STDERR.puts("STRING")
          raise(FatalException.new("STRING"));Fi[	@W
iI"ì        @var = true)
      rescue LoadError
        STDERR.puts("STRING")
        STDERR.puts("STRING")
        raise(FatalException.new("STRING"));Fi[	@:I"$if ARGV.include?("STRING") then;Fi
[
[	@iI"  
  # Create a formula from a tarball URL
  def function
    if ARGV.include?("STRING") then
      exec_browser("STRING");Fi[	@
iI"u  extend(self)
  
  def function
    if ARGV.include?("STRING") then
      Formula.each { |var| puts("STRING") };Fi[	@IiI"^  extend(self)
  
  def function
    if ARGV.include?("STRING") then
      puts("STRING");Fi[	I"+projects//homebrew_proj/cmd/options.rb;TiI"jrequire("formula")
require("cmd/outdated")
def function
  if ARGV.include?("STRING") then
    Formula;Fi[	@7i
I"f  extend(self)
  
  def function
    if ARGV.include?("STRING") then
      exec_browser("STRING");Fi[	@ÑI".class PostgreSQLAdapter < AbstractAdapter;Fi
[
[	@Ç
iI"}module ActiveRecord
  module ConnectionAdapters
    class PostgreSQLAdapter < AbstractAdapter
      module DatabaseStatements;Fi[	@siI"¨require("active_record/connection_adapters/abstract_adapter")
module ActiveRecord
  module ConnectionAdapters
    class PostgreSQLAdapter < AbstractAdapter
      module OID;Fi[	@ñiI"wmodule ActiveRecord
  module ConnectionAdapters
    class PostgreSQLAdapter < AbstractAdapter
      module Quoting;Fi[	@—	iI"module ActiveRecord
  module ConnectionAdapters
    class PostgreSQLAdapter < AbstractAdapter
      module ReferentialIntegrity;Fi[	@õiI"{module ActiveRecord
  module ConnectionAdapters
    class PostgreSQLAdapter < AbstractAdapter
      module SchemaStatements;Fi[	@'@Œ+i
[
[	@ÎiI"}      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;Fi[	@Îi]I"}      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;Fi[	@ÎirI"}      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;Fi[	@ÎiÑI"}      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;Fi[	@ÎiôI"t      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[	I""def self.required_fields(var);F@A*i
[
[	@∏iI"N      end
      
      def self.required_fields(var)
        []
      end;Fi[	@iI"i      extend(ActiveSupport::Concern)
      
      def self.required_fields(var)
        []
      end;Fi[	@i
I"i      extend(ActiveSupport::Concern)
      
      def self.required_fields(var)
        []
      end;Fi[	@ iI"i      extend(ActiveSupport::Concern)
      
      def self.required_fields(var)
        []
      end;Fi[	@´i
I"í      VALIDATIONS = ["LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL"].freeze
      
      def self.required_fields(var)
        []
      end;Fi[	@
I"module Strategies;Fi
[
[	@≠
iI"irequire("devise/strategies/base")
module Devise
  module Strategies
    class Authenticatable < Base;Fi[	I"4projects//devise_proj/devise/strategies/base.rb;Ti I"Rmodule Devise
  module Strategies
    class Base < ::Warden::Strategies::Base;Fi [	I"Hprojects//devise_proj/devise/strategies/database_authenticatable.rb;TiI"Çrequire("devise/strategies/authenticatable")
module Devise
  module Strategies
    class DatabaseAuthenticatable < Authenticatable;Fi[	@ÆiI"|require("devise/strategies/authenticatable")
module Devise
  module Strategies
    class Rememberable < Authenticatable;Fi[	@±iI"yrequire("devise/strategies/base")
module Devise
  module Strategies
    class TokenAuthenticatable < Authenticatable;Fi[	I"require("twitter/error");F@i
[
[	@	i I":require("twitter/error")
module Twitter
  class Error;Fi [	@i I":require("twitter/error")
module Twitter
  class Error;Fi [	@i I":require("twitter/error")
module Twitter
  class Error;Fi [	@i I":require("twitter/error")
module Twitter
  class Error;Fi [	@+i I":require("twitter/error")
module Twitter
  class Error;Fi [	I" Rails.logger.info("STRING");FI"return;Fi
[
[	@Ωi/I"r  def function(var, var)
    if self.target.nil? then
      Rails.logger.info("STRING")
      return
    else;Fi[	@Ωi:I"p          self.perform(var)
        else
          Rails.logger.info("STRING")
          return
        end;Fi[	I"1projects//diaspora_proj/models/retraction.rb;Ti8I"°    if (self.type == "STRING") then
      unless (self.person.guid.to_s == self.post_guid.to_s) then
        Rails.logger.info("STRING")
        return
      end;Fi[	@ÓiUI"r  def function(var, var)
    if self.target.nil? then
      Rails.logger.info("STRING")
      return
    else;Fi[	@Ói[I"f        self.perform(var)
      else
        Rails.logger.info("STRING")
        return
      end;Fi[	@I"Ü# Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).;Fi
[
[	@ÿiÒI"G      # Add +node_or_tags+ as a child of this Node.
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
      #;Fi[	@ÿiI"R      # Insert +node_or_tags+ before this Node (as a sibling).
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
      #;Fi[	@ÿiI"Q      # Insert +node_or_tags+ after this Node (as a sibling).
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
      #;Fi[	@ÿiLI"K      # Set the inner html for this Node +node_or_tags+
      # +node_or_tags+ can be a Nokogiri::XML::Node, a Nokogiri::XML::DocumentFragment, or a string containing markup.
      #
      # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
      #;Fi[	@ÿi^I"B      # Replace this Node with +node_or_tags+.
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
      #;Fi[	I"var = true;F@|i
[
[	@
i;I"ê                  var = true
                when "STRING" then
                  var = true
                else
                  (var << var);Fi[	@_$i,I"ì        if (var == var) then
          log_action("LITERAL", basename(var), var)
          var = true
        else
          if var["LITERAL"] then;Fi[	@äiI"ó      end
      if FONT_TYPES.key?(var) then
        var = true
      else
        var = var.to_s.split("STRING").last.gsub("LITERAL", "STRING").to_sym;Fi[	@iNI"†        if around_hooks.empty? then
          var.perform(*var)
          var = true
        else
          var = around_hooks.reverse.inject(nil) do |var, var|;Fi[	@iÇI"£        var = var["LITERAL"].filter(var)
        if var["LITERAL"].values.empty? then
          var = true
        else
          var = var["LITERAL"].values.first;Fi[	@I",# Call with a block to register a hook.;Fi
[
[	@`i]I"≥  # changes you make will be permanent for the lifespan of the
  # worker.
  #
  # Call with a block to register a hook.
  # Call with no arguments to return all registered hooks.;Fi[	@`ilI"ÿ  # before every job, so be careful- any changes you make will be
  # permanent for the lifespan of the worker.
  #
  # Call with a block to register a hook.
  # Call with no arguments to return all registered hooks.;Fi[	@`i{I"ﬂ  # the current job. Any changes you make, therefore, will only live as
  # long as the job currently being processed.
  #
  # Call with a block to register a hook.
  # Call with no arguments to return all registered hooks.;Fi[	@`iõI"¬  # the job code is performed. This hook will run before any
  # Job.before_perform hook.
  #
  # Call with a block to register a hook.
  # Call with no arguments to return all registered hooks.;Fi[	@`i™I"¡  # the job code has performed. This hook will run after any
  # Job.after_perform hook.
  #
  # Call with a block to register a hook.
  # Call with no arguments to return all registered hooks.;Fi[	I"var["LITERAL"];F@|i
[
[	@*iVI"§        if var["LITERAL"] then
          if absolute_path?(var["LITERAL"]) then
            var["LITERAL"]
          else
            File.join(var, var["LITERAL"]);Fi[	@“i}I"Ç  def function(var)
    if request.params["LITERAL"].is_a?(String).! then
      var["LITERAL"]
    else
      var = var["LITERAL"];Fi[	@Ïi§I"æ        else
          ("STRING" + (if (if var["LITERAL"] and @options.html? then
            var["LITERAL"]
          else
            (block_given?.! or (var["LITERAL"] or var["LITERAL"]));Fi[	@	iI"        else
          if var["LITERAL"] then
            var["LITERAL"]
          else
            if var["LITERAL"] then;Fi[	@;iI"ì      var = File.read(var)
      var = if var["LITERAL"] then
        var["LITERAL"]
      else
        File.read(var["LITERAL"]) if var["LITERAL"];Fi[	@¢-@ÿ!i
[
[	@iŸI"v    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end;Fi[	@iÁI"v    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end;Fi[	@i¯I"v    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end;Fi[	@iI"v    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end;Fi[	@i\I"ó    #     attr_accessor :state
    #     
    #     state_machine :state, :initial => :parked do
    #       ...
    #       state :parked, :value => 0;Fi[	@:@	i
[
[	@Ë	i—I"{      # [Version]
      # Returns the current version of the Backup gem
      def function
        puts("STRING")
      end;Fi[	@Æi3I"w        end
        
        def function
          puts("STRING")
          @images.each { |var| puts(var.file) };Fi[	@ŸiII"Pend
module NoiseyPathname
  def function
    puts("STRING")
    orig_unlink;Fi[	@¯ifI"^  
  # we try to keep output minimal
  def function
    puts("STRING")
    puts("STRING");Fi[	@¯iI"B  end
  
  def function
    puts("STRING")
    puts("STRING");Fi[	@‡2@i
[
[	@ÿiÚI"9      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
      #
      # Also see related method +<<+.;Fi[	@ÿiI"=      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
      #
      # Also see related method +before+.;Fi[	@ÿiI"<      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
      #
      # Also see related method +after+.;Fi[	@ÿiMI"A      # +node_or_tags+ can be a Nokogiri::XML::Node, a Nokogiri::XML::DocumentFragment, or a string containing markup.
      #
      # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
      #
      # Also see related method +inner_html=+;Fi[	@ÿi_I";      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
      #
      # Also see related method +swap+.;Fi[	I"var = nil;F@|i
[
[	@Ω%iVI"¯        if var = column_for_attribute(var) then
          if var.number? and (changes_from_nil_to_empty_string?(var, var, var) or changes_from_zero_to_string?(var, var)) then
            var = nil
          else
            var = var.type_cast(var);Fi[	@È(iPI"≈          var = var.config.active_record.delete("LITERAL")
          if respond_to?("LITERAL") then
            var = nil
          else
            var = var.config.active_record.delete("LITERAL");Fi[	@¶iÛI"~      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then;Fi[	@¶i˝I"~      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then;Fi[	@¶iI"~      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then;Fi[	@ôI"module CSS;Fi
[
[	@Ùi I"0module Nokogiri
  module CSS
    class Node;Fi [	@^iI"|require("racc/parser.rb")
require("nokogiri/css/parser_extras")
module Nokogiri
  module CSS
    class Parser < Racc::Parser;Fi[	I"9projects//nokogiri_proj/nokogiri/css/syntax_error.rb;TiI"rrequire("nokogiri/syntax_error")
module Nokogiri
  module CSS
    class SyntaxError < ::Nokogiri::SyntaxError;Fi[	@ i I"5module Nokogiri
  module CSS
    class Tokenizer;Fi [	@Ki I"8module Nokogiri
  module CSS
    class XPathVisitor;Fi [	I"module CanCan;FI"module ModelAdapters;Fi
[
[	@£i I"Cmodule CanCan
  module ModelAdapters
    class AbstractAdapter;Fi [	@—i I"Ymodule CanCan
  module ModelAdapters
    class ActiveRecordAdapter < AbstractAdapter;Fi [	I"Gprojects//cancan_proj/cancan/model_adapters/data_mapper_adapter.rb;Ti I"Wmodule CanCan
  module ModelAdapters
    class DataMapperAdapter < AbstractAdapter;Fi [	I"Cprojects//cancan_proj/cancan/model_adapters/default_adapter.rb;Ti I"Tmodule CanCan
  module ModelAdapters
    class DefaultAdapter < AbstractAdapter;Fi [	I"Cprojects//cancan_proj/cancan/model_adapters/mongoid_adapter.rb;Ti I"Tmodule CanCan
  module ModelAdapters
    class MongoidAdapter < AbstractAdapter;Fi [	I"# @return [Twitter::User];F@:i
[
[	@y'iI"}      # The user who mentioned a user
      #
      # @return [Twitter::User]
      def function
        @var = sources.first;Fi[	@˘*iI"é    alias "LITERAL" "LITERAL"
    
    # @return [Twitter::User]
    def function
      @var ||= Twitter::User.fetch_or_new(@attrs["LITERAL"]);Fi[	@˘*iI"}    end
    
    # @return [Twitter::User]
    def function
      @var ||= Twitter::User.fetch_or_new(@attrs["LITERAL"]);Fi[	@¸*iI"„    attr_reader("LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL")
    
    # @return [Twitter::User]
    def function
      @var ||= Twitter::User.fetch_or_new(@attrs["LITERAL"]);Fi[	@…iÉI"ë    end
    
    # @return [Twitter::User]
    def function
      @var ||= fetch_or_new_without_self(Twitter::User, @attrs, "LITERAL", "LITERAL");Fi[	I"J# Creates a scope for finding records *without* a particular state or;F@3#i
[
[	@)iNI"ï      end
      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(var);Fi[	@	i|I"ï      end
      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(var);Fi[	@,iGI"ï      end
      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(var);Fi[	@/iKI"ï      end
      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(var);Fi[	@JixI"ï      end
      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(var);Fi[	@I"3#   person.errors.add(:name, "can't be blank");Fi
[
[	@9ieI"    # Yields the attribute and the error for that attribute. If the attribute
    # has more than one error message, yields once for each error message.
    #
    #   person.errors.add(:name, "can't be blank")
    #   person.errors.each do |attribute, error|;Fi[	@9iuI"ã    
    # Returns the number of error messages.
    #
    #   person.errors.add(:name, "can't be blank")
    #   person.errors.size # => 1;Fi[	@9iäI"ø    
    # Returns an array of error messages, with the attribute name included.
    #
    #   person.errors.add(:name, "can't be blank")
    #   person.errors.add(:name, "must be specified");Fi[	@9iìI"å    
    # Returns the number of error messages.
    #
    #   person.errors.add(:name, "can't be blank")
    #   person.errors.count # => 1;Fi[	@9i©I"≈    # aliases empty?
    # Returns an xml formatted representation of the Errors hash.
    #
    #   person.errors.add(:name, "can't be blank")
    #   person.errors.add(:name, "must be specified");Fi[	@:@Yi
[
[	@\'i[I"R    end
    
    def function
      var = "LITERAL"
      if new_config? then;Fi[	@iI"M  extend(self)
  
  def function
    var = "LITERAL"
    var = "LITERAL";Fi[	@ÊiCI"P  end
  
  def function
    var = "LITERAL"
    Dir["STRING"].each do |var|;Fi[	@ÈiI"L  end
  
  def function
    var = "LITERAL"
    if var.match(@url) then;Fi[	@]i∆I"º    # Reconnect to Redis to avoid sharing a connection with the parent,
    # retry up to 3 times with increasing delay before giving up.
    def function
      var = "LITERAL"
      begin;Fi[	I"G# Creates a scope for finding records *with* a particular state or;F@3#i
[
[	@)iHI"í      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(var);Fi[	@	ivI"í      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(var);Fi[	@,iAI"í      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(var);Fi[	@/iEI"í      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(var);Fi[	@JirI"í      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(var);Fi[	@:@(i
[
[	@úiI"Wmodule ActiveRecord
  module NullRelation
    def function
      @var = []
    end;Fi[	@ı	iI"`    attr_reader("LITERAL", "LITERAL")
    
    def function
      @var = []
      @var = [];Fi[	@XiI"E  attr_accessor("LITERAL")
  
  def function
    @var = []
  end;Fi[	I"?projects//paperclip_proj/paperclip/io_adapters/registry.rb;TiI"M    attr_reader("LITERAL")
    
    def function
      @var = []
    end;Fi[	@i≠I"†    # where you either are re-using an existing state machine implementation
    # or are subclassing machines.
    def function
      @var = []
      @var = [];Fi[	@(@(i
[
[	@ı	iI"P    
    def function
      @var = []
      @var = []
      @var = "STRING";Fi[	@ ioI"I  def function(var)
    @var = var
    @var = []
    @var = []
  end;Fi[	@JiI"g        def function(var)
          @var = var
          @var = []
          @var = []
        end;Fi[	@iÆI"`    # or are subclassing machines.
    def function
      @var = []
      @var = []
    end;Fi[	@ji,I"|      var = @nodes
      var = @contexts
      @var = []
      @var = []
      @var = @indices.inject({}) do |var, var|;Fi[	@:@…i
[
[	@si£I"^        
        class TypeMap
          def function
            @var = {}
          end;Fi[	@¿iRI"¶      
      # List available parameters
      def function
        @var = {}
        ["LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL"].each do |var|;Fi[	@ãiÆI"s    
    # Removes previously aliased actions including the defaults.
    def function
      @var = {}
    end;Fi[	I"Fprojects//paperclip_proj/paperclip/interpolations/plural_cache.rb;TiI"a  module Interpolations
    class PluralCache
      def function
        @var = {}
      end;Fi[	@k
ifI"è    # Resets any information tracked from previous attempts to perform the
    # collection
    def function
      @var = {}
      @var = false;Fi[	I"# object;F@:i
[
[	@)i*I"·      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function
        define_static_state_initializer;Fi[	@	iTI"      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function
        define_helper("LITERAL", "STRING", "STRING", ("LITERAL" + "LITERAL"));Fi[	@,i(I"      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function
        define_helper("LITERAL", "STRING", "STRING", ("LITERAL" + "LITERAL"));Fi[	@/i,I"      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function
        define_helper("LITERAL", "STRING", "STRING", ("LITERAL" + "LITERAL"));Fi[	@JiHI"      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function
        define_helper("LITERAL", "STRING", "STRING", ("LITERAL" + "LITERAL"));Fi[	I"J# initial state of the machine *before* any attributes are set on the;F@ 3i
[
[	@)i)I"¿      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function;Fi[	@	iSI"¿      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function;Fi[	@,i'I"¿      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function;Fi[	@/i+I"¿      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function;Fi[	@JiGI"¿      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function;Fi[	I"J# Defines an initialization hook into the owner class for setting the;F@◊3i
[
[	@)i(I"∑      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object;Fi[	@	iRI"∑      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object;Fi[	@,i&I"∑      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object;Fi[	@/i*I"∑      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object;Fi[	@JiFI"∑      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object;Fi[	@:@™,i
[
[	@®iI"ã      
      # Resets the \loaded flag to +false+ and sets the \target to +nil+.
      def function
        @var = false
        @var = nil;Fi[	@Pi`I"G      end
      
      def function
        @var = false
      end;Fi[	@&ióI"Ü      
      #:nodoc:
      def function
        @var = false
        @var = connection.default_sequence_name(table_name, primary_key);Fi[	@®ilI"M      protected
      
      def function
        @var = false
      end;Fi[	@®ipI"G      end
      
      def function
        @var = false
      end;Fi[	@∫ @|i
[
[	@Ui˝I"í      def function(var, var)
        if var["LITERAL"] then
          (var << "STRING")
        else
          (var << "STRING") if var["LITERAL"];Fi[	@äiI"|      end
      if FONT_TYPES.key?(var) then
        (var << "STRING")
      else
        raise(Sass::SyntaxError, "STRING");Fi[	@i:I"	        (var << var.matched[("LITERAL"...("LITERAL" - var))])
        if ((var % "LITERAL") == "LITERAL") then
          (var << "STRING")
        else
          var = eval((("STRING" + balance(var, "STRING", "STRING", "LITERAL")["LITERAL"]["LITERAL"]) + "STRING"));Fi[	@i7I"í          (var << "STRING")
          (var << "STRING") unless var.directory?
          (var << "STRING")
        else
          (var << "STRING");Fi[	@iII"Ü            (var << "STRING")
            (var << "STRING")
            (var << "STRING")
          else
            (var << "STRING");Fi[	I"# Server credentials;F@π$i
[
[	@‡"iI"_      
      ##
      # Server credentials
      ##
      # Server IP Address and FTP port;Fi[	@uiI"_      
      ##
      # Server credentials
      ##
      # Server IP Address and SSH port;Fi[	@iI"_      
      ##
      # Server credentials
      ##
      # Server IP Address and SCP port;Fi[	@iI"`      
      ##
      # Server credentials
      ##
      # Server IP Address and SFTP port;Fi[	@ÜiI"i        
        ##
        # Server credentials
        ##
        # Server IP Address and SSH port;Fi[	I"-transferred_files_for(var) do |var, var|;FI"*Logger.message(("STRING" + "STRING"));Fi
[
[	@oi?I"ﬁ      def function(var)
        var = remote_path_for(var)
        transferred_files_for(var) do |var, var|
          Logger.message(("STRING" + "STRING"))
          connection.delete_object(container, File.join(var, var));Fi[	@‡"iJI"œ        var = remote_path_for(var)
        connection do |var|
          transferred_files_for(var) do |var, var|
            Logger.message(("STRING" + "STRING"))
            var.delete(File.join(var, var));Fi[	@riII"Õ        if var = directory_for(var) then
          var = []
          transferred_files_for(var) do |var, var|
            Logger.message(("STRING" + "STRING"))
            if var = var.files.get(var) then;Fi[	@ziCI"·        var = remote_path_for(var)
        connection.sync_clock
        transferred_files_for(var) do |var, var|
          Logger.message(("STRING" + "STRING"))
          connection.delete_object(bucket, File.join(var, var));Fi[	@i>I"–        var = remote_path_for(var)
        connection do |var|
          transferred_files_for(var) do |var, var|
            Logger.message(("STRING" + "STRING"))
            var.remove!(File.join(var, var));Fi[	@4I"when String then;Fi
[
[	@Ji‰I"    def function(var, var)
      var = var.group_by do |var|
        case var
        when String then
          "LITERAL";Fi[	@…i0I"»      @connection.tables.sort.each do |var|
        if (["STRING", ignore_tables].flatten.any? do |var|
          case var
          when String then
            (remove_prefix_and_suffix(var) == var);Fi[	@˝iÇI"Y    
    def function(var)
      case var
      when String then
        strenc(var);Fi[	@$iI"ê    def function(var, var)
      if RUBY_PLATFORM =~ "LITERAL" then
        case var
        when String then
          var, var = var, "STRING";Fi[	@`i#I"v  #      or `Redis::Namespace`.
  def function(var)
    case var
    when String then
      if var["STRING"] then;Fi[	@:I"3assert(model.respond_to?("LITERAL"), "STRING");Fi
[
[	I"4projects//activemodel_proj/active_model/lint.rb;TiI"Ì      # or nil if <tt>model.persisted?</tt> is false. This is used by
      # <tt>dom_id</tt> to generate unique ids for the object.
      def function
        assert(model.respond_to?("LITERAL"), "STRING")
        def (model).persisted?;Fi[	@44i I"”      # However, if the resource is not persisted?, then <tt>to_param</tt>
      # should always return +nil+.
      def function
        assert(model.respond_to?("LITERAL"), "STRING")
        def (model).to_key;Fi[	@44i/I"       # Returns a string giving a relative path. This is used for looking up
      # partials. For example, a BlogPost model might return "blog_posts/blog_post"
      def function
        assert(model.respond_to?("LITERAL"), "STRING")
        assert_kind_of(String, model.to_partial_path);Fi[	@44i;I"Î      # the create action. If it is persisted, a form for the object will routes
      # to the update action.
      def function
        assert(model.respond_to?("LITERAL"), "STRING")
        assert_boolean(model.persisted?, "STRING");Fi[	@44iTI"+      # If localization is used, the Strings should be localized for the current
      # locale. If no error is present, this method should return an empty Array.
      def function
        assert(model.respond_to?("LITERAL"), "STRING")
        assert(model.errors["LITERAL"].is_a?(Array), "STRING");Fi[	@π$@	4i
[
[	@‡"iI"W      attr_accessor("LITERAL")
      
      ##
      # Server credentials
      ##;Fi[	@uiI"W      attr_accessor("LITERAL")
      
      ##
      # Server credentials
      ##;Fi[	@iI"W      attr_accessor("LITERAL")
      
      ##
      # Server credentials
      ##;Fi[	@iI"W      attr_accessor("LITERAL")
      
      ##
      # Server credentials
      ##;Fi[	@ÜiI"a        attr_accessor("LITERAL")
        
        ##
        # Server credentials
        ##;Fi[	@1I"module Matchers;Fi
[
[	@CiI"Åmodule Paperclip
  module Shoulda
    module Matchers
      # Ensures that the given instance or class has an attachment with the;Fi[	@JiI"Ñmodule Paperclip
  module Shoulda
    module Matchers
      # Ensures that the given instance or class validates the content type of;Fi[	@OiI"Ñmodule Paperclip
  module Shoulda
    module Matchers
      # Ensures that the given instance or class validates the presence of the;Fi[	@ViI"Ämodule Paperclip
  module Shoulda
    module Matchers
      # Ensures that the given instance or class validates the size of the;Fi[	@&1i
I"|require("paperclip/matchers/validate_attachment_size_matcher")
module Paperclip
  module Shoulda
    module Matchers
    end;Fi[	I"6# Gets the db default for the machine's attribute;F@:i
[
[	@)i!I"’      end
      
      # Gets the db default for the machine's attribute
      def function
        if owner_class.connected? and (owner_class.table_exists? and var = owner_class.columns_hash[attribute.to_s]) then;Fi[	@	iCI"ï      end
      
      # Gets the db default for the machine's attribute
      def function
        attribute_property and attribute_property.default;Fi[	@,iI"ë      end
      
      # Gets the db default for the machine's attribute
      def function
        attribute_key and attribute_key.default_value;Fi[	@/i I"è      end
      
      # Gets the db default for the machine's attribute
      def function
        attribute_field and attribute_field.default;Fi[	@JifI"“      end
      
      # Gets the db default for the machine's attribute
      def function
        if owner_class.db.table_exists?(owner_class.table_name) and var = owner_class.db_schema[attribute.to_sym] then;Fi[	I"# @note Undocumented;F@(	i
[
[	@iI"å      # Returns activity about me
      #
      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	@i"I"é      # Returns activity by friends
      #
      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	@i0I"x      end
      
      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	@iNI"ó      # Returns activity summary for a Tweet
      #
      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	@iaI"ñ      # Returns activity summary for Tweets
      #
      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	@@'i
[
[	@Z-iI"}      
      # A collection containing the favorited tweet
      #
      # @return [Array<Twitter::Tweet>]
      def function;Fi[	@y'iI"|      
      # A collection of tweets that mention a user
      #
      # @return [Array<Twitter::Tweet>]
      def function;Fi[	@c-i
I"ü    class Reply < Twitter::Action::Tweet
      # A collection of tweets that reply to a user
      #
      # @return [Array<Twitter::Tweet>]
      def function;Fi[	@c-iI"Ç      
      # A collection that contains the replied-to tweets
      #
      # @return [Array<Twitter::Tweet>]
      def function;Fi[	@~'i
I"é    class Retweet < Twitter::Action::Tweet
      # A collection of retweets
      #
      # @return [Array<Twitter::Tweet>]
      def function;Fi[	I"eager_autoload do;F@Si
[
[	@˘i4I"w    extend(ActiveSupport::Autoload)
    
    eager_autoload do
      autoload("LITERAL")
      autoload("LITERAL");Fi[	@nifI"w    extend(ActiveSupport::Autoload)
    
    eager_autoload do
      autoload("LITERAL")
      autoload("LITERAL");Fi[	@niuI"w    extend(ActiveSupport::Autoload)
    
    eager_autoload do
      autoload("LITERAL")
      autoload("LITERAL");Fi[	@ni~I"|    extend(ActiveSupport::Autoload)
    
    eager_autoload do
      autoload("LITERAL")
      autoload("LITERAL", "STRING");Fi[	@niÇI"w    extend(ActiveSupport::Autoload)
    
    eager_autoload do
      autoload("LITERAL")
      autoload("LITERAL");Fi[	@Ø'@ ,i
[
[	@NiI"Orequire("rubygems")
require("sequel")
require("fileutils")
require("yaml");Fi[	@UiI"Orequire("rubygems")
require("sequel")
require("fileutils")
require("yaml");Fi[	@	iI"Orequire("rubygems")
require("sequel")
require("fileutils")
require("yaml");Fi[	@iiI"Orequire("rubygems")
require("sequel")
require("fileutils")
require("yaml");Fi[	@piI"Orequire("rubygems")
require("sequel")
require("fileutils")
require("yaml");Fi[	@@å"i
[
[	@zisI"j      #
      # The given path will be expanded before use.
      #
      # @return [String]
      ##;Fi[	@ziI"~      #
      # Use of this option will override the use of {#passphrase_file}.
      #
      # @return [String]
      ##;Fi[	@ziI"L      #     end
      #   end
      #
      # @return [String]
      ##;Fi[	@ÈiI"Œ    # The string that holds the compiled HTML. This is aliased as
    # `_erbout` for compatibility with ERB-specific code.
    #
    # @return [String]
    # The options hash passed in from {Haml::Engine}.;Fi[	@i$I"«    # or `nil` if the indentation is ambiguous
    # (for example, for a single-level document).
    #
    # @return [String]
    # Tilt currently depends on these moved methods, provide a stable API;Fi[	@£I"load_defaults!;Fi
[
[	@-*iI"ä      ##
      # Creates a new instance of Backup::Compressor::Bzip2
      def function(var)
        load_defaults!
        @var ||= false;Fi[	@ÿ1iI"ê      ##
      # Initializes a new custom compressor.
      def function(var)
        load_defaults!
        instance_eval(&var) if block_given?;Fi[	@0*iI"â      ##
      # Creates a new instance of Backup::Compressor::Gzip
      def function(var)
        load_defaults!
        @var ||= false;Fi[	@3*iI"â      ##
      # Creates a new instance of Backup::Compressor::Lzma
      def function(var)
        load_defaults!
        @var ||= false;Fi[	@6*iI"ã      ##
      # Creates a new instance of Backup::Compressor::Pbzip2
      def function(var)
        load_defaults!
        @var ||= false;Fi[	I"@(var << Thread.new { search_tap("STRING", "STRING", var) });F@∞4i
[
[	@7i(I"˜          var = []
          var = []
          (var << Thread.new { search_tap("STRING", "STRING", var) })
          (var << Thread.new { search_tap("STRING", "STRING", var) })
          (var << Thread.new { search_tap("STRING", "STRING", var) });Fi[	@7i)I"*          var = []
          (var << Thread.new { search_tap("STRING", "STRING", var) })
          (var << Thread.new { search_tap("STRING", "STRING", var) })
          (var << Thread.new { search_tap("STRING", "STRING", var) })
          (var << Thread.new { search_tap("STRING", "STRING", var) });Fi[	@7i*I"]          (var << Thread.new { search_tap("STRING", "STRING", var) })
          (var << Thread.new { search_tap("STRING", "STRING", var) })
          (var << Thread.new { search_tap("STRING", "STRING", var) })
          (var << Thread.new { search_tap("STRING", "STRING", var) })
          (var << Thread.new { search_tap("STRING", "STRING", var) });Fi[	@7i+I"]          (var << Thread.new { search_tap("STRING", "STRING", var) })
          (var << Thread.new { search_tap("STRING", "STRING", var) })
          (var << Thread.new { search_tap("STRING", "STRING", var) })
          (var << Thread.new { search_tap("STRING", "STRING", var) })
          (var << Thread.new { search_tap("STRING", "STRING", var) });Fi[	@7i,I"G          (var << Thread.new { search_tap("STRING", "STRING", var) })
          (var << Thread.new { search_tap("STRING", "STRING", var) })
          (var << Thread.new { search_tap("STRING", "STRING", var) })
          (var << Thread.new { search_tap("STRING", "STRING", var) })
          var.each { |var| (var << var.value) };Fi[	@Æ@|i
[
[	@õiI"î            case var
            when nil, "LITERAL" then
              super(var)
            else
              raise(ActiveRecordError, "STRING");Fi[	@õi&I"î            case var
            when nil, "LITERAL" then
              super(var)
            else
              raise(ActiveRecordError, "STRING");Fi[	@_'ioI"ô    return image_url if (var == "STRING")
    if (var.nil? or var.match("LITERAL")) then
      super(var)
    else
      super(absolutify_local_url(var));Fi[	@_'ixI"ô    return image_url if (var == "STRING")
    if (var.nil? or var.match("LITERAL")) then
      super(var)
    else
      super(absolutify_local_url(var));Fi[	@_'i|I"ô    return image_url if (var == "STRING")
    if (var.nil? or var.match("LITERAL")) then
      super(var)
    else
      super(absolutify_local_url(var));Fi[	@,2@i
[
[	@@i4I"d    # date - The Time to format.
    #
    # Examples
    #
    #   date_to_xmlschema(Time.now);Fi[	@@iCI"i    # input - The String to escape.
    #
    # Examples
    #
    #   xml_escape('foo "bar" <baz>');Fi[	@@iRI"f    # input - The String to escape.
    #
    # Examples
    #
    #   cgi_escape('foo,bar;baz?');Fi[	@@inI"à    # array - The Array of Strings to join.
    #
    # Examples
    #
    #   array_to_sentence_string(["apples", "oranges", "grapes"]);Fi[	@Z
iÂI"}    # post_attr - The String name of the Post attribute.
    #
    # Examples
    #
    #   post_attr_hash('categories');Fi[	@K&@ø	i
[
[	@~iXI"Ì      def function(var)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |var|
          begin
            object_from_response(Twitter::Tweet, "LITERAL", "STRING", var.options.merge("LITERAL" => (var)));Fi[	@~izI"Ì      def function(var)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |var|
          begin
            object_from_response(Twitter::Tweet, "LITERAL", "STRING", var.options.merge("LITERAL" => (var)));Fi[	@ÖiúI"        var = Twitter::API::Arguments.new(var)
        var.options["LITERAL"] = true if var.options.delete("LITERAL").!.!
        var.flatten.threaded_map do |var|
          begin
            object_from_response(Twitter::User, "LITERAL", "STRING", merge_user(var.options, var));Fi[	@iêI"´      def function(var)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |var|
          begin
            post_retweet(var, var.options);Fi[	@i´I"´      def function(var)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |var|
          begin
            post_retweet(var, var.options);Fi[	@Æ@Hi
[
[	@∫i0I"e      
      def function(var, var, var)
        super(var)
        @var = var
        @var = [];Fi[	@yi.I"N    
    def function(var, var)
      super(var)
      @var = var
    end;Fi[	@yiYI"\    
    def function(var, var, var)
      super(var)
      @var = var
      @var = var;Fi[	@ÃiI"q    # @param line [Fixnum] See \{#line}
    def function(var, var)
      super(var)
      @var = var
    end;Fi[	@˛i3I"N    
    def function(var, var)
      super(var)
      @var = var
    end;Fi[	I"L# Skips defining reader/writer methods since this is done automatically;F@:i
[
[	@ÛiäI"â      end
      
      # Skips defining reader/writer methods since this is done automatically
      def function
        var = self.name;Fi[	@	iYI"ª      end
      
      # Skips defining reader/writer methods since this is done automatically
      def function
        owner_class.property(attribute, String) unless attribute_property;Fi[	@,i-I"±      end
      
      # Skips defining reader/writer methods since this is done automatically
      def function
        owner_class.key(attribute, String) unless attribute_key;Fi[	@/i1I"ƒ      end
      
      # Skips defining reader/writer methods since this is done automatically
      def function
        owner_class.field(attribute, "LITERAL" => (String)) unless attribute_field;Fi[	@JiMI"â      end
      
      # Skips defining reader/writer methods since this is done automatically
      def function
        var = self.name;Fi[	@w,@|i
[
[	@Xi¸I"®            var = var.to_a
            var.close
            var = var
          else
            var = @statements[var] ||= { "LITERAL" => (@connection.prepare(var)) };Fi[	@4i¢I"ä    missing_image!(var, var) unless var
    if (var.unit_str == "STRING") then
      var = var
    else
      var = (var.value - var.left);Fi[	@˚imI"q    if (var.nil? or var.kind_of?(Hash)) then
      @var = "STRING"
      var = var
    else
      @var = var;Ti[	@
iáI"i          var = true
          var = "STRING"
          var = var
        else
          if var then;Fi[	@∫"i%I"n    def function(var, var, var)
      if var.is_a?(Class) then
        var = var
      else
        begin;Fi[	@£I"@var ||= {};Fi
[
[	@a"iXI"›      # The block will be passed the root-relative url of the asset.
      # When called without a block, returns the block that was previously set.
      def function(var)
        @var ||= {}
        if block_given? then;Fi[	@»i}I"g        end
        
        def function(var)
          @var ||= {}
          send("STRING", nil);Fi[	@»iI"h        end
        
        def function(var)
          @var ||= {}
          @set_attributes[var];Fi[	I";projects//paperclip_proj/paperclip/instance_methods.rb;TiI"Ømodule Paperclip
  module InstanceMethods
    def function(var)
      @var ||= {}
      @_paperclip_attachments[var] ||= Attachment.new(var, self, attachment_definitions[var]);Fi[	@i%I"s  
  module ProcessorHelpers
    def function(var)
      @var ||= {}
      if @known_processors[var.to_s] then;Fi[	@ô,@i
[
[	@ÈiI"ë      MercurialDownloadStrategy
    when "LITERAL" then
      SubversionDownloadStrategy
    when "LITERAL" then
      SubversionDownloadStrategy;Fi[	@ÈiI"é      SubversionDownloadStrategy
    when "LITERAL" then
      SubversionDownloadStrategy
    when "LITERAL" then
      FossilDownloadStrategy;Fi[	@Èi
I"ë      MercurialDownloadStrategy
    when "LITERAL" then
      SubversionDownloadStrategy
    when "LITERAL" then
      SubversionDownloadStrategy;Fi[	@ÈiI"í      SubversionDownloadStrategy
    when "LITERAL" then
      SubversionDownloadStrategy
    when "LITERAL" then
      SubversionDownloadStrategy;Fi[	@ÈiI"ò      SubversionDownloadStrategy
    when "LITERAL" then
      SubversionDownloadStrategy
    when "LITERAL" then
      CurlApacheMirrorDownloadStrategy;Fi[	@:I"8raise(FormulaUnspecifiedError) if ARGV.named.empty?;Fi
[
[	I"'projects//homebrew_proj/cmd/cat.rb;TiI"y  extend(self)
  
  def function
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    cd(HOMEBREW_REPOSITORY);Fi[	@Bi	I"|  extend(self)
  
  def function
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    if ARGV.include?("STRING") then;Fi[	@»
iI"á  extend(self)
  
  def function
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    raise("STRING") if ARGV.include?("STRING");Fi[	I"(projects//homebrew_proj/cmd/test.rb;TiI"}  extend(self)
  
  def function
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    ENV.extend(HomebrewEnvExtension);Fi[	@ß+i	I"  extend(self)
  
  def function
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    var = Formula.select do |var|;Fi[	@î@4i
[
[	@UiœI"à      def function(var, var, var, var)
        case var.to_s
        when "STRING" then
          case var
          when "LITERAL" then;Fi[	@Ui⁄I"à            raise(ActiveRecordError, "STRING")
          end
        when "STRING" then
          case var
          when "LITERAL" then;Fi[	@UiÈI"à            raise(ActiveRecordError, "STRING")
          end
        when "STRING" then
          case var
          when "LITERAL" then;Fi[	@õiI"ó        def function(var, var, var, var)
          case var.to_s
          when "STRING" then
            case var
            when nil, "LITERAL" then;Fi[	@õi#I"ó              raise(ActiveRecordError, "STRING")
            end
          when "STRING" then
            case var
            when nil, "LITERAL" then;Fi[	@|@2i
[
[	I">projects//diaspora_proj/controllers/aspects_controller.rb;TiI"ã        end
      end
    else
      respond_to do |var|
        var.js { render("LITERAL" => (I18n.t("STRING")), "LITERAL" => "LITERAL") };Fi[	@M#i+I"å        var.mobile { redirect_to(@comment.post) }
      end
    else
      respond_to do |var|
        var.mobile { redirect_to("LITERAL") };Fi[	I"Fprojects//diaspora_proj/controllers/status_messages_controller.rb;Ti<I"i        end
      end
    else
      respond_to do |var|
        var.html { redirect_to("LITERAL") };Fi[	@b#i%I"f        end
      end
    else
      respond_to do |var|
        var.any("LITERAL", "LITERAL") do;Fi[	I";projects//diaspora_proj/controllers/tags_controller.rb;TiI"«        var.json { render("LITERAL" => (@tags.to_json), "LITERAL" => "LITERAL") }
      end
    else
      respond_to do |var|
        var.json { render("LITERAL" => (true), "LITERAL" => "LITERAL") };Fi[	@Ì0I"O#   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,;Fi
[
[	@ÇiQI"a      #   and <tt>:update</tt>.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.;Fi[	@òi*I"ä      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.;Fi[	@òidI"ä      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.;Fi[	@ki*I"a      #   and <tt>:update</tt>.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.;Fi[	@qiÖI"t      #   attribute is blank (default is +false+).
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.;Fi[	@	@A'i
[
[	@Ë	i™I"m          puts
          puts("STRING")
          puts("STRING")
          puts
          puts("STRING");Fi[	@Ë	i≠I"m          puts
          puts("STRING")
          puts("STRING")
          puts
          puts("STRING");Fi[	@7iI"p          unless var.empty? then
            puts
            puts("STRING")
            puts
          end;Fi[	@Êi&I"c      puts("STRING")
      puts("STRING")
      puts("STRING")
      puts
      puts("STRING");Fi[	@Êi)I"J      puts
      puts("STRING")
      puts("STRING")
      puts
  end;Fi[	@î@Ì2i
[
[	@
i:I"è                  var = false
                  var = true
                when "STRING" then
                  var = true
                else;Fi[	@
iAI"é              else
                case var
                when "STRING" then
                  var = true
                when "STRING" then;Fi[	@
iGI"°                  var = "STRING"
                  var = false
                when "STRING" then
                  var = true
                when "STRING" then;Fi[	@3
iII"°      var = ((var == "STRING") or (var.!=("STRING") and @options["LITERAL"]))
      case var
      when "STRING" then
        var = true
      when "STRING" then;Fi[	@3
iMI"ä      when "STRING" then
        var = var = true
      when "STRING" then
        var = true
        if (var["LITERAL"] == "STRING") then;Fi[	@J5I"O#   proc or string should return or evaluate to a +true+ or +false+ value.;Fi
[
[	@ÇiRI"ñ      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to determine;Fi[	@òi+I"å      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to;Fi[	@òieI"å      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to;Fi[	@ki+I"å      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to;Fi[	@qiÜI"å      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to;Fi[	@¿"@.0i
[
[	@zipI"´    end
    var = "LITERAL".match(var.to_s)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var.to_s)
    return var.captures.first unless var.nil?;Fi[	@zirI"—    return var.captures.first unless var.nil?
    var = "LITERAL".match(var.to_s)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var.to_s)
    return var.captures.first unless var.nil?;Fi[	@zitI"—    return var.captures.first unless var.nil?
    var = "LITERAL".match(var.to_s)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var.to_s)
    return var.captures.first unless var.nil?;Fi[	@zivI"—    return var.captures.first unless var.nil?
    var = "LITERAL".match(var.to_s)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var.to_s)
    return var.captures.first unless var.nil?;Fi[	@ziâI"Ã    return var.captures.first unless var.nil?
    var = "LITERAL".match(var)
    return var.captures.first unless var.nil?
    var = "LITERAL".match(var.to_s)
    return var.captures.first unless var.nil?;Fi[	@|I"@options["LITERAL"];Fi
[
[	@
iõI"t      when String then
        @options["LITERAL"].constantize
      else
        @options["LITERAL"]
      end;Fi[	@i6I"ê      if @options["LITERAL"].respond_to?("LITERAL") then
        @options["LITERAL"].call(self)
      else
        @options["LITERAL"]
      end;Fi[	@	i1I"ƒ          if @options["LITERAL"].respond_to?("LITERAL") and @options["LITERAL"].has_key?(var) then
            @options["LITERAL"][var]
          else
            @options["LITERAL"]
          end;Fi[	@	iÇI"∞          if @options["LITERAL"] =~ "LITERAL" then
            (@options["LITERAL"] % (path(var).hash % "LITERAL"))
          else
            @options["LITERAL"]
          end;Fi[	@	i®I"†        var = if @options["LITERAL"].respond_to?("LITERAL") then
          @options["LITERAL"].call(self)
        else
          @options["LITERAL"]
        end;Fi[	I"%#         transition all => :off;F@i
[
[	@ÌiQI"r    #       
    #       event :disable do
    #         transition all => :off
    #       end
    #     end;Fi[	@Ìi~I"r    #       
    #       event :disable do
    #         transition all => :off
    #       end
    #     end;Fi[	@iïI"ù    #     state_machine :alarm_state, :initial => :active do
    #       event :disable do
    #         transition all => :off
    #       end
    #     end;Fi[	@i∆I"s    #       
    #       event :turn_off do
    #         transition all => :off
    #       end
    #     end;Fi[	@i–I"s    #       
    #       event :turn_off do
    #         transition all => :off
    #       end
    #     end;Fi[	@î@;2i
[
[	@
i5I"ç    def self.post_to_hash(var, var)
      case var["STRING"]
      when "STRING" then
        var = var["STRING"]
        var = var["STRING"];Fi[	@
i<I"‹        var = "STRING"
        (var << ("STRING" + var["STRING"])) unless var["STRING"].nil?
      when "STRING" then
        var = var["STRING"]
        var = var.keys.map { |var| var.gsub("STRING", "STRING").to_i }.max;Fi[	@
iMI"}          var = var.at["STRING"]
        end
      when "STRING" then
        var = var["STRING"]
        var = "STRING";Fi[	@
iQI"®        var = "STRING"
        (var << ("STRING" + var["STRING"])) unless var["STRING"].nil?
      when "STRING" then
        var = var["STRING"]
        var = "STRING";Fi[	@
iVI"´        var["STRING"]["STRING"].each { |var| (var << "STRING") }
        (var << "STRING")
      when "STRING" then
        var = var["STRING"]
        var = var["STRING"];Fi[	@üI"#   person.name = 'Bob';Fi
[
[	@ i2I"{      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name          # => "Bob";Fi[	@ iVI"{      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name          # => "Bob";Fi[	@ iíI"}      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name            # => "Bob";Fi[	@ i÷I"~      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name        # => "Bob";Fi[	@ i˘I"}      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name_short? # => true;Fi[	@T,I"¥# @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi
[
[	@ÎiI"®      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @example Return the 20 most recent mentions (statuses containing @username) for the authenticating user;Fi[	@ÎiJI"í      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.;Fi[	@ÎiaI"í      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.;Fi[	@ÎivI"í      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.;Fi[	@ÎiàI"í      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.;Fi[	I",#         transition :idling => :parked;F@i
[
[	@ÊiI"í    #     state_machine :initial => :parked do
    #       event :park do
    #         transition :idling => :parked
    #       end
    #       ;Fi[	@ÊiAI"í    #     state_machine :initial => :parked do
    #       event :park do
    #         transition :idling => :parked
    #       end
    #       ;Fi[	@ÌiGI"v    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end;Fi[	@ÌiyI"v    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end;Fi[	@i§I"v    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end;Fi[	@£@0i
[
[	@≤i/I"ü      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(var)
        var = case var
        when "LITERAL" then;Fi[	@πi-I"ü      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(var)
        var = case var
        when "LITERAL" then;Fi[	@¿i7I"ü      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(var)
        var = case var
        when "LITERAL" then;Fi[	@«i+I"ü      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(var)
        var = case var
        when "LITERAL" then;Fi[	@›
iII"L  end
  
  def function(var)
    var = case var
    when "LITERAL" then;Fi[	@I"# Option examples:;Fi
[
[	@i*I"˙      #   not an instance of <tt>:class_name</tt>. If <tt>:allow_nil</tt> is set to true, the converter
      #   can return nil to skip the assignment.
      #
      # Option examples:
      #   composed_of :temperature, mapping: %w(reading celsius);Fi[	@ÒiRI"      #   with <tt>:through</tt> or <tt>:as</tt> options.
      #   See ActiveRecord::Associations::ClassMethods's overview on Bi-directional associations for more detail.
      #
      # Option examples:
      #   has_many :comments, -> { order "posted_on" };Fi[	@Òi∏I"'      #   with <tt>:through</tt> or <tt>:as</tt> options.
      #   See ActiveRecord::Associations::ClassMethods's overview on Bi-directional associations for more detail.
      #
      # Option examples:
      #   has_one :credit_card, dependent: :destroy  # destroys the associated credit card;Fi[	@Òi'I"      #   combination with the <tt>:polymorphic</tt> options.
      #   See ActiveRecord::Associations::ClassMethods's overview on Bi-directional associations for more detail.
      #
      # Option examples:
      #   belongs_to :firm, foreign_key: "client_of";Fi[	@Òi≥I"π      #
      #   Note that <tt>accepts_nested_attributes_for</tt> sets <tt>:autosave</tt> to <tt>true</tt>.
      #
      # Option examples:
      #   has_and_belongs_to_many :projects;Fi[	@˙2I"=# Call with no arguments to return all registered hooks.;Fi
[
[	@`i^I"à  # worker.
  #
  # Call with a block to register a hook.
  # Call with no arguments to return all registered hooks.
  def function(var);Fi[	@`imI"™  # permanent for the lifespan of the worker.
  #
  # Call with a block to register a hook.
  # Call with no arguments to return all registered hooks.
  def function(var);Fi[	@`i|I"´  # long as the job currently being processed.
  #
  # Call with a block to register a hook.
  # Call with no arguments to return all registered hooks.
  def function(var);Fi[	@`iúI"ô  # Job.before_perform hook.
  #
  # Call with a block to register a hook.
  # Call with no arguments to return all registered hooks.
  def function(var);Fi[	@`i´I"ò  # Job.after_perform hook.
  #
  # Call with a block to register a hook.
  # Call with no arguments to return all registered hooks.
  def function(var);Fi[	I"#       event :park do;F@»5i
[
[	@ÊiI"õ    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :park do
    #         transition :idling => :parked
    #       end;Fi[	@Êi@I"õ    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :park do
    #         transition :idling => :parked
    #       end;Fi[	@ÌiFI"x    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end;Fi[	@ÌixI"x    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end;Fi[	@i£I"x    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end;Fi[	@|I"(var << var);Fi
[
[	@
i<I"á                when "STRING" then
                  var = true
                else
                  (var << var)
                end;Fi[	@
iPI"û                  add_item_to_array(var, var, var)
                  return [var, var]
                else
                  (var << var)
                end;Fi[	@riMI"Ç            if var = var.files.get(var) then
              var.destroy
            else
              (var << var)
            end;Fi[	@&iI"∏          if var.is_a?(String) then
            (var << [var, File.join((css_path or (css_dir or "STRING")), File.basename(var))])
          else
            (var << var)
          end;Fi[	@·iGI"™          if ["LITERAL", "LITERAL"].include?(var) then
            var = (var["LITERAL", (var - "LITERAL")] + [var])
          else
            (var << var)
          end;Fi[	@Ó5@£i
[
[	@`i_I"ª  #
  # Call with a block to register a hook.
  # Call with no arguments to return all registered hooks.
  def function(var)
    var ? (register_hook("LITERAL", var)) : (hooks("LITERAL"));Fi[	@`inI"ª  #
  # Call with a block to register a hook.
  # Call with no arguments to return all registered hooks.
  def function(var)
    var ? (register_hook("LITERAL", var)) : (hooks("LITERAL"));Fi[	@`i}I"ª  #
  # Call with a block to register a hook.
  # Call with no arguments to return all registered hooks.
  def function(var)
    var ? (register_hook("LITERAL", var)) : (hooks("LITERAL"));Fi[	@`iùI"ª  #
  # Call with a block to register a hook.
  # Call with no arguments to return all registered hooks.
  def function(var)
    var ? (register_hook("LITERAL", var)) : (hooks("LITERAL"));Fi[	@`i¨I"ª  #
  # Call with a block to register a hook.
  # Call with no arguments to return all registered hooks.
  def function(var)
    var ? (register_hook("LITERAL", var)) : (hooks("LITERAL"));Fi[	@£I"var.each do |var|;Fi
[
[	@XiëI"p      end
      
      def function(var)
        var.each do |var|
          var = through_records_for(var);Fi[	@XiI"‘      end
      
      def function(var)
        var.each do |var|
          (join_associations.detect { |var| (var == var) } or build(var.reflection.name, (var.find_parent_in(self) or join_base), var.join_type));Fi[	@»iI"Ä      
      module ClassMethods
        def function(var)
          var.each do |var|
            var = ("LITERAL" + "LITERAL");Fi[	@»iI"        # value when not set. The inherited reader calls to a raw reader that acts like a normal attribute
        # reader but prefixes the attribute name with "raw_".
        def function(var)
          var.each do |var|
            var = ("LITERAL" + "LITERAL");Fi[	I":projects//compass_proj/compass/configuration/paths.rb;TiI"õ  TRAILING_SEPARATOR = /.(\/|#{Regexp.escape(File::SEPARATOR)}STRING/
  
  def function(var)
    var.each do |var|
      alias_method("STRING".to_sym, var);Fi[	@£I"var.flatten!;Fi
[
[	@JiãI"Ñ    end
    
    def function(var)
      var.flatten!
      self.references_values = (references_values + var.map!(&"LITERAL")).uniq;Fi[	@JiÃI"Y    end
    
    def function(var)
      var.flatten!
      self.group_values += var;Fi[	@JiÈI"Y    end
    
    def function(var)
      var.flatten!
      validate_order_args(var);Fi[	@Ji I"Y    end
    
    def function(var)
      var.flatten!
      validate_order_args(var);Fi[	@ iOI"k  env { x11 }
  
  def function(var)
    var.flatten!
    @var = var.shift if "LITERAL".===(var.first);Fi[	@£@ói
[
[	@úiI"?    end
    
    def function(var)
      "LITERAL"
    end;Fi[	@úiI"?    end
    
    def function(var)
      "LITERAL"
    end;Fi[	@úi3I"?    end
    
    def function(var)
      "LITERAL"
    end;Fi[	@úi7I"?    end
    
    def function(var)
      "LITERAL"
    end;Fi[	@Ãi8I"Y          true
        end
        def function(var)
          "LITERAL"
        end;Fi[	@|@ø	i
[
[	@|i9I"i        when "LITERAL" then
          nil
        else
          begin
            Kernel.Float(var);Fi[	@ÈiAI"h      if @tarball_path.exist? then
        puts("STRING")
      else
        begin
          _fetch;Fi[	I"#projects//homebrew_proj/tab.rb;TiI"Ç    if var.exist? then
      self.from_file(var)
    else
      begin
        self.dummy_tab(Formula.factory(var.parent.basename));Fi[	@’i(I"R  if ARGV.verbose? then
    yield
  else
    begin
      (var = $stderr.clone;Fi[	@∫"i&I"Ç      if var.is_a?(Class) then
        var = var
      else
        begin
          var = OmniAuth::Strategies.const_get("STRING");Fi[	@î@#-i
[
[	@„iI"  when "STRING", "STRING" then
    "STRING".undent
  when "STRING" then
    "STRING".undent
  when "STRING", "STRING" then;Fi[	@„iI"Ñ  when "STRING", "STRING" then
    "STRING".undent
  when "STRING" then
    "STRING".undent
  when "STRING", "STRING", "STRING" then;Fi[	@„iI"  when "STRING", "STRING", "STRING" then
    "STRING".undent
  when "STRING" then
    "STRING".undent
  when "STRING" then;Fi[	@„iI"l  when "STRING" then
    "STRING".undent
  when "STRING" then
    "STRING".undent
  when "LITERAL" then;Fi[	@„iI"W  when "LITERAL" then
    "STRING"
  when "STRING" then
    "STRING".undent
  else;Fi[	@£I"var = var.to_s;Fi
[
[	@$iII"˙      # it has been typecast (for example, "2004-12-12" in a data column is cast
      # to a date object, like Date.new(2004, 12, 12)).
      def function(var)
        var = var.to_s
        (@attributes_cache[var] or @attributes_cache.fetch(var) do;Fi[	I"Eprojects//compass_proj/compass/sass_extensions/functions/urls.rb;Ti§I"ô  
  # Emits a path, taking off any leading "./"
  def function(var)
    var = var.to_s
    var = (var["LITERAL"] == "STRING") ? (var["LITERAL"]) : (var);Fi[	@;iI"•      # Don't escape text that's already safe,
      # output is always HTML safe
      def function(var)
        var = var.to_s
        return var if var.html_safe?;Fi[	@$iI"ù    #               mollit anim id est laborum.
    #               EOS
    def function(var)
      var = var.to_s
      (self["LITERAL", var.length] == var);Fi[	I")projects//homebrew_proj/metafiles.rb;TiI"O  private
  
  def function(var)
    var = var.to_s
    var = var.downcase;Fi[	I"warn("STRING");FI"exit("LITERAL");Fi
[
[	@uiI"ù      @options["LITERAL"] ||= default_identifier
      unless File.exists?(@options["LITERAL"]) then
        warn("STRING")
        exit("LITERAL")
      end;Fi[	@uiI"≠      end
      if ([@options["LITERAL"], @options["LITERAL"], @options["LITERAL"]].compact.length > "LITERAL") then
        warn("STRING")
        exit("LITERAL")
      end;Fi[	@uiI"      end
      unless @options["LITERAL"].to_s =~ "LITERAL" then
        warn("STRING")
        exit("LITERAL")
      end;Fi[	@uiYI"≠    def function
      if read_crontab.=~(Regexp.new("STRING")) and read_crontab.=~(Regexp.new("STRING")).nil? then
        warn("STRING")
        exit("LITERAL")
      else;Fi[	@ui]I"Æ      else
        if read_crontab.=~(Regexp.new("STRING")).nil? and read_crontab.=~(Regexp.new("STRING")) then
          warn("STRING")
          exit("LITERAL")
        end;Fi[	@ë-I"-var.change_make_var!("STRING", "STRING");Fi
[
[	@\i
I"ó  def function
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var);Fi[	@\iI"ó  def function
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var);Fi[	@\iI"ó  def function
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var);Fi[	@\iI"ó  def function
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var);Fi[	@\i&I"ó  def function
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var);Fi[	@ø	I"(log("STRING");Fi
[
[	@^i&I"ô      def function
        @queued_for_delete.each do |var|
          begin
            (log("STRING")
            FileUtils.rm(var) if File.exist?(var));Fi[	@	isI"}      
      def function(var, var)
        begin
          (log("STRING")
          ::File.open(var, "STRING") do |var|;Fi[	@ciøI"±      def function
        @queued_for_write.each do |var, var|
          begin
            (log("STRING")
            var = (@s3_permissions[var] or @s3_permissions["LITERAL"]);Fi[	@ci›I"™      def function
        @queued_for_delete.each do |var|
          begin
            (log("STRING")
            s3_bucket.objects[var.sub("LITERAL", "STRING")].delete);Fi[	@ciËI"z      
      def function(var, var)
        begin
          (log("STRING")
          var = ::File.open(var, "STRING");Fi[	I"class_attribute("LITERAL");F@ò6i
[
[	@[iI"ì      setup("LITERAL")
      teardown("LITERAL")
      class_attribute("LITERAL")
      class_attribute("LITERAL")
      class_attribute("LITERAL");Fi[	@[iI"ù      teardown("LITERAL")
      class_attribute("LITERAL")
      class_attribute("LITERAL")
      class_attribute("LITERAL")
      class_attribute("LITERAL");Fi[	@[iI"§      class_attribute("LITERAL")
      class_attribute("LITERAL")
      class_attribute("LITERAL")
      class_attribute("LITERAL")
      class_attribute("LITERAL");Fi[	@[i I"§      class_attribute("LITERAL")
      class_attribute("LITERAL")
      class_attribute("LITERAL")
      class_attribute("LITERAL")
      class_attribute("LITERAL");Fi[	@[i!I"ß      class_attribute("LITERAL")
      class_attribute("LITERAL")
      class_attribute("LITERAL")
      class_attribute("LITERAL")
      self.fixture_table_names = [];Fi[	I"class << self;FI"attr_accessor("LITERAL");Fi
[
[	@Vi	I"e    extend(ActiveSupport::Concern)
    
    class << self
      attr_accessor("LITERAL")
    end;Fi[	@NiI"|module ActiveRecord::Associations::Builder
  class Association
    class << self
      attr_accessor("LITERAL")
    end;Fi[	@
iI"[    include(Convertible)
    
    class << self
      attr_accessor("LITERAL")
    end;Fi[	@GiI"J    end
    
    class << self
      attr_accessor("LITERAL")
    end;Fi[	@PiI"n  module Failure
    class Multiple < Base
      class << self
        attr_accessor("LITERAL")
      end;Fi[	@~6I" assert_equal("STRING", var);Fi
[
[	@\iI"é    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end;Fi[	@\iI"é    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end;Fi[	@\iI"é    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end;Fi[	@\i I"é    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end;Fi[	@\i'I"é    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end;Fi[	@¯(@À.i
[
[	@u"iI"j  
  def function
    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?);Fi[	@u"i'I"l  
  def function
    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!);Fi[	@u"iQI"j  
  def function
    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?);Fi[	@u"i_I"l  
  def function
    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!);Fi[	@u"imI"l  
  def function
    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!);Fi[	@<I""add_column_options!(var, var);Fi
[
[	@Üi8I"√      # See TableDefinition#column for details of the options you can use.
      def function(var, var, var, var)
        var = "STRING"
        add_column_options!(var, var)
        execute(var);Fi[	@Ui[I"ë      
      def function(var, var, var, var)
        var = "STRING"
        add_column_options!(var, var)
        add_column_position!(var, var);Fi[	@UieI"Ó        var["LITERAL"] = var.default unless options_include_default?(var)
        var["LITERAL"] = var.null unless var.has_key?("LITERAL")
        var = "STRING"
        add_column_options!(var, var)
        add_column_position!(var, var);Fi[	@UitI"ã        end
        var = select_one("STRING", "STRING")["STRING"]
        var = "STRING"
        add_column_options!(var, var)
        var;Fi[	@õiÈI"ó        def function(var, var, var, var)
          clear_cache!
          var = "STRING"
          add_column_options!(var, var)
          execute(var);Fi[	@<I")ActiveSupport::Deprecation.warn(var);Fi
[
[	@ i=I"ƒ        def function(var)
          if ((var["LITERAL"] == "STRING") or (var["LITERAL"] == "STRING")) then
            var = "STRING"
            ActiveSupport::Deprecation.warn(var)
          end;Fi[	@∞i.I"ç      
      def function
        var = "STRING"
        ActiveSupport::Deprecation.warn(var)
        if defined? @serialized_attributes then;Fi[	@Pi˜I"Ü      
      def function(var)
        var = "STRING"
        ActiveSupport::Deprecation.warn(var)
        @transaction.joinable = var;Fi[	@Ç
iÆI"®        
        def function
          var = "STRING"
          ActiveSupport::Deprecation.warn(var)
          (@connection.transaction_status == PGconn::PQTRANS_IDLE);Fi[	@EiI"¶    
    def function
      var = "STRING"
      ActiveSupport::Deprecation.warn(var)
      defined? @_attr_readonly ? (@_attr_readonly) : (self.class._attr_readonly);Fi[	@£@(i
[
[	@i,I"©      # An array of ColumnDefinition objects, representing the column changes
      # that have been defined.
      def function(var)
        @var = []
        @var = {};Fi[	@Ÿ	iI"}      attr_accessor("LITERAL", "LITERAL", "LITERAL")
      
      def function(var)
        @var = []
        @var = var;Fi[	@è#iI"ô        def_delegators("LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL")
        
        def function(var)
          @var = []
          @var = var;Fi[	@Ÿi
I"|  
  # The patches defined in a formula and the DATA from that file
  def function(var)
    @var = []
    return if var.nil?;Fi[	@iI"é      
      # A list of Nokogiri::XML::SyntaxError found when parsing a document
      def function(var)
        @var = []
        @var = nil;Fi[	@£@1i
[
[	@gi#I"ç        
        # Add +element+ to the queue.  Never blocks.
        def function(var)
          synchronize do
            @queue.push(var);Fi[	@gi§I"©      
      # Hack for tests to be able to add connections.  Do not call outside of tests
      def function(var)
        synchronize do
          (@connections << var);Fi[	@giæI"◊      # #release_connection releases the connection-thread association
      # and returns the connection to the pool.
      def function(var)
        synchronize do
          var = @reserved_connections.delete(var);Fi[	@giI"Ÿ      # +conn+: an AbstractAdapter object, which was obtained by earlier by
      # calling +checkout+ on this pool.
      def function(var)
        synchronize do
          var.run_callbacks("LITERAL") { var.expire };Fi[	@giI"Á      # Remove a connection from the connection pool.  The connection will
      # remain open and active but will no longer be managed by this pool.
      def function(var)
        synchronize do
          @connections.delete(var);Fi[	I"8assert((TARGET_FOLDER + "STRING").exist?, "STRING");F@˛6i
[
[	@æ,i%I"≈    with_temp_folder do
      TARGET_FOLDER.install(["STRING", "STRING"])
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
    end;Fi[	@æ,i-I"æ    with_temp_folder do
      TARGET_FOLDER.install(Dir["STRING"])
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
    end;Fi[	@æ,i7I"∏      system("STRING")
      TARGET_FOLDER.install("STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
    end;Fi[	@æ,iHI"    with_temp_folder do
      TARGET_FOLDER.install("STRING" => "STRING", "STRING" => "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?.!, "STRING");Fi[	@æ,iUI"È      TARGET_FOLDER.install("STRING" => "STRING")
      assert((TARGET_FOLDER + "STRING").exist?.!, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
    end;Fi[	I"@var ||= Array.new;F@7i
[
[	@ci2I"|      def function(var, var)
        super(var)
        @var ||= Array.new
        @var ||= Array.new
        @var ||= false;Fi[	@i+I"Ä      def function(var, var)
        super(var)
        @var ||= Array.new
        @var ||= Array.new
        @var ||= Array.new;Fi[	@i,I"è        super(var)
        @var ||= Array.new
        @var ||= Array.new
        @var ||= Array.new
        instance_eval(&var) if block_given?;Fi[	@i,I"Ä      def function(var, var)
        super(var)
        @var ||= Array.new
        @var ||= Array.new
        @var ||= Array.new;Fi[	@i-I"è        super(var)
        @var ||= Array.new
        @var ||= Array.new
        @var ||= Array.new
        instance_eval(&var) if block_given?;Fi[	I"!var = var.patches["LITERAL"];FI")assert_equal("LITERAL", var.patch_p);Fi
[
[	@¸'iI"ü    var = Patches.new("STRING")
    assert_equal("LITERAL", var.patches.length)
    var = var.patches["LITERAL"]
    assert_equal("LITERAL", var.patch_p)
  end;Fi[	@¸'iI"∆    var = Patches.new(["STRING", "STRING"])
    assert_equal("LITERAL", var.patches.length)
    var = var.patches["LITERAL"]
    assert_equal("LITERAL", var.patch_p)
    var = var.patches["LITERAL"];Fi[	@¸'iI"ô    var = var.patches["LITERAL"]
    assert_equal("LITERAL", var.patch_p)
    var = var.patches["LITERAL"]
    assert_equal("LITERAL", var.patch_p)
  end;Fi[	@¸'i$I"¨    var = Patches.new("LITERAL" => "STRING")
    assert_equal("LITERAL", var.patches.length)
    var = var.patches["LITERAL"]
    assert_equal("LITERAL", var.patch_p)
  end;Fi[	@¸'i+I"¨    var = Patches.new("LITERAL" => "STRING")
    assert_equal("LITERAL", var.patches.length)
    var = var.patches["LITERAL"]
    assert_equal("LITERAL", var.patch_p)
  end;Fi[	@:@Ÿ-i	[	[	@ki4I"B    end
    
    def function
      @var ||= "STRING"
    end;Fi[	@úi+I"B    end
    
    def function
      @var ||= "STRING"
    end;Fi[	@™i%I"L      end
      
      def function
        @var ||= "STRING"
      end;Fi[	@]iÌI"¶    # The string representation is the same as the id for this worker
    # instance. Can be used with `Worker.find`.
    def function
      @var ||= "STRING"
    end;Fi[	I"var = read_file("STRING");FI"/assert(var.include?("STRING").!, "STRING");Fi	[	[	@i#I"¿    shutup do
      DefaultPatchBall.new("STRING").brew do
        var = read_file("STRING")
        assert(var.include?("STRING").!, "STRING")
        assert(var.include?("STRING"), "STRING");Fi[	@i-I"Ω    shutup do
      ListPatchBall.new("STRING").brew do
        var = read_file("STRING")
        assert(var.include?("STRING").!, "STRING")
        assert(var.include?("STRING"), "STRING");Fi[	@i7I"ª    shutup do
      P0PatchBall.new("STRING").brew do
        var = read_file("STRING")
        assert(var.include?("STRING").!, "STRING")
        assert(var.include?("STRING"), "STRING");Fi[	@iAI"ª    shutup do
      P1PatchBall.new("STRING").brew do
        var = read_file("STRING")
        assert(var.include?("STRING").!, "STRING")
        assert(var.include?("STRING"), "STRING");Fi[	I"# Connectivity options;F@π$i	[	[	@ci!I"à      # Credentials for the specified database
      ##
      # Connectivity options
      ##
      # IPv6 support (disabled by default);Fi[	@iI"è      # Credentials for the specified database
      ##
      # Connectivity options
      ##
      # Tables to skip while dumping the database;Fi[	@iI"è      # Credentials for the specified database
      ##
      # Connectivity options
      ##
      # Tables to skip while dumping the database;Fi[	@fiI"¶      # Credentials for the specified database
      ##
      # Connectivity options
      ##
      # Determines whether Backup should invoke the SAVE command through;Fi[	I"# example:;F@i	[	[	@i}I"—    # Initialize an empty model object from +coder+. +coder+ must contain
    # the attributes necessary for initializing an empty model object. For
    # example:
    #
    #   class Post < ActiveRecord::Base;Fi[	@JiII"É    
    # Specify relationships to be included in the result set. For
    # example:
    #
    #   users = User.includes(:address);Fi[	@i\I"«    # Since this transition is being defined within an event context, you do
    # *not* need to specify the <tt>:on</tt> option for the transition.  For
    # example:
    # 
    #  state_machine do;Fi[	@0i!I"…    # Since this transition is being defined within a state context, you do
    # *not* need to specify the <tt>:from</tt> option for the transition.  For
    # example:
    # 
    #   state_machine do;Fi[	@H@…i	[	[	@9iI"O    #   end
    def function(var)
      @var = var
      @var = {}
    end;Fi[	@AiI"e        
        def function(var)
          @var = var
          @var = {}
          @var = nil;Fi[	@øiI"Z      
      def function(var)
        @var = var
        @var = {}
        @var = {};Fi[	@^%iI"_    def function(var, var)
      super()
      @var = var
      @var = {}
      @var = var;Fi[	@I"+# Pre-configured defaults specified in;Fi	[	[	@}i I"≠        ##
        # Instantiates a new Cloud::CloudFiles Syncer.
        #
        # Pre-configured defaults specified in
        # Configuration::Syncer::Cloud::CloudFiles;Fi[	@ÄiI"ù        ##
        # Instantiates a new Cloud::S3 Syncer.
        #
        # Pre-configured defaults specified in
        # Configuration::Syncer::Cloud::S3;Fi[	@8iI"£        ##
        # Instantiates a new RSync::Local Syncer.
        #
        # Pre-configured defaults specified in
        # Configuration::Syncer::RSync::Local;Fi[	@ÜiI"≥        ##
        # Instantiates a new RSync::Push or RSync::Pull Syncer.
        #
        # Pre-configured defaults specified in
        # Configuration::Syncer::RSync::Push or;Fi[	I"	self;F@|i	[	[	@iSI"Æ      def function
        @var ||= if ((Base == self) or connection_handler.retrieve_connection_pool(self)) then
          self
        else
          superclass.arel_engine;Fi[	@ i@I"¿        raise(ActiveRecordError, "STRING") unless (self < Base)
        if ((superclass == Base) or superclass.abstract_class?) then
          self
        else
          superclass.base_class;Fi[	@kitI"ñ      when "STRING" then
        if (var.width >= self.width) and (var.height >= self.height) then
          self
        else
          scale_to(var);Fi[	@kizI"ó      when "STRING" then
        if ((var.width <= self.width) or (var.height <= self.height)) then
          self
        else
          scale_to(var);Fi[	I""next if send(var).to_s.empty?;F@;i	[	[	@ciâI"ö      def function
        ["STRING", "STRING"].map do |var|
          next if send(var).to_s.empty?
          "STRING"
        end.compact.join("STRING");Fi[	@ciìI"ö      def function
        ["STRING", "STRING"].map do |var|
          next if send(var).to_s.empty?
          "STRING"
        end.compact.join("STRING");Fi[	@igI"§      def function
        ["STRING", "STRING", "STRING"].map do |var|
          next if send(var).to_s.empty?
          "STRING"
        end.compact.join("STRING");Fi[	@figI"§      def function
        ["STRING", "STRING", "STRING"].map do |var|
          next if send(var).to_s.empty?
          "STRING"
        end.compact.join("STRING");Fi[	@ö(I"!assert(var.mach_o_bundle?.!);Fi	[	[	@u"i!I"¶    assert(var.dylib?)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?.!)
    assert_match("LITERAL", file(var));Fi[	@u"i/I"¶    assert(var.dylib?)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?.!)
    assert_match("LITERAL", file(var));Fi[	@u"i=I"¶    assert(var.dylib?.!)
    assert(var.mach_o_executable?)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?.!)
    assert_match("LITERAL", file(var));Fi[	@u"iuI"•    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?.!)
    assert((var.arch == "LITERAL"));Fi[	I"J# * <tt>:guard</tt> - Whether to guard transitions with the if/unless;FI"=#   conditionals defined for each one.  Default is true.;Fi	[	[	@iÄI"%    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.
    def function(var, var);Fi[	@ÊiI"    # * <tt>:on</tt> - One or more events that fire the transition.  If none
    #   are specified, then this will match any event.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.
    # ;Fi[	@Êi9I"    # * <tt>:on</tt> - One or more events that fire the transition.  If none
    #   are specified, then this will match any event.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.
    # ;Fi[	@iòI"	    # * <tt>:on</tt> - One or more events to transition on.  If none are
    #   specified, then this will match any event.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.
    # ;Fi[	I"}#   @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;FI"~#   @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;Fi	[	[	@qiOI"
      #   @see https://dev.twitter.com/docs/api/1.1/get/direct_messages
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      #   @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      #   @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[	@´i6I"      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      #   @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      #   @option options [Integer] :count The number of results to retrieve.;Fi[	@´i@I"      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      #   @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      #   @option options [Integer] :count The number of results to retrieve.;Fi[	@Îi1I"$      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      #   @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      #   @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[	I"-# Credentials for the specified database;F@π$i	[	[	@ciI"ì      # Name of the database that needs to get dumped
      ##
      # Credentials for the specified database
      ##
      # Connectivity options;Fi[	@iI"ü      # To dump all databases, set this to `:all` or leave blank.
      ##
      # Credentials for the specified database
      ##
      # Connectivity options;Fi[	@iI"ì      # Name of the database that needs to get dumped
      ##
      # Credentials for the specified database
      ##
      # Connectivity options;Fi[	@fiI"ü      # Name of and path to the database that needs to get dumped
      ##
      # Credentials for the specified database
      ##
      # Connectivity options;Fi[	I"@var ||= "LITERAL";F@Ÿ-i	[	[	@‡"iI"Ö      def function(var, var, var)
        super(var, var)
        @var ||= "LITERAL"
        @var ||= "STRING"
        @var ||= false;Fi[	@uiI"Ö      def function(var, var, var)
        super(var, var)
        @var ||= "LITERAL"
        @var ||= "STRING"
        @var ||= false;Fi[	@iI"ö      def function(var, var, var)
        super(var, var)
        @var ||= "LITERAL"
        @var ||= "STRING"
        instance_eval(&var) if block_given?;Fi[	@iI"ö      def function(var, var, var)
        super(var, var)
        @var ||= "LITERAL"
        @var ||= "STRING"
        instance_eval(&var) if block_given?;Fi[	I"
#   );F@i	[	[	I"Eprojects//activerecord_proj/active_record/connection_handling.rb;TiI"x    #     password: "mypass",
    #     database: "somedatabase"
    #   )
    #
    # Example for SQLite database:;Fi[	@π7iI"ö    #     adapter: "sqlite",
    #     database:  "path/to/dbfile"
    #   )
    #
    # Also accepts keys as strings (for parsing from YAML for example):;Fi[	@π7iI"o    #     "adapter" => "sqlite",
    #     "database"  => "path/to/dbfile"
    #   )
    #
    # Or a URL:;Fi[	@π7i%I"»    #   ActiveRecord::Base.establish_connection(
    #     "postgres://myuser:mypass@localhost/somedatabase"
    #   )
    #
    # The exceptions AdapterNotSpecified, AdapterNotFound and ArgumentError;Fi[	@<I"(var << "STRING") if var;Fi	[	[	@÷iI"l      
      def function(var, var)
        var = "STRING"
        (var << "STRING") if var
        var;Fi[	@UirI"Å      
      def function(var, var, var)
        var = "STRING"
        (var << "STRING") if var
        (var << "STRING") if var;Fi[	@XiII"’      # SCHEMA STATEMENTS ========================================
      def function(var, var)
        var = "STRING"
        (var << "STRING") if var
        exec_query(var, "STRING").map { |var| var["STRING"] };Fi[	@_$i;I"•        FileUtils.touch(var) unless var["LITERAL"]
      else
        var = "STRING"
        (var << "STRING") if var
        open(var, var) { |var| var.write(var) };Fi[	I"((var << "STRING") if var["LITERAL"];F@∫ i	[	[	@iúI"‘        (var["LITERAL"] == "LITERAL") ? (var = "STRING") : (var = "STRING")
        var = "STRING"
        (var << "STRING") if var["LITERAL"]
        (var << "STRING")
        (var << "STRING") if var["LITERAL"];Fi[	@iûI"ó        (var << "STRING") if var["LITERAL"]
        (var << "STRING")
        (var << "STRING") if var["LITERAL"]
        (var << "STRING")
        var;Fi[	@i¨I"‘        (var["LITERAL"] == "LITERAL") ? (var = "STRING") : (var = "STRING")
        var = "STRING"
        (var << "STRING") if var["LITERAL"]
        (var << "STRING")
        (var << "STRING") if var["LITERAL"];Fi[	@iÆI"ó        (var << "STRING") if var["LITERAL"]
        (var << "STRING")
        (var << "STRING") if var["LITERAL"]
        (var << "STRING")
        var;Fi[	@£I"var = var.first;Fi	[	[	@mi\I"{      end
      
      def function(var)
        var = var.first
        class_for_adapter(var["STRING"]).new(*var).charset;Fi[	@mieI"}      end
      
      def function(var)
        var = var.first
        class_for_adapter(var["STRING"]).new(*var).collation;Fi[	@minI"l      end
      
      def function(var)
        var = var.first
        var = var.delete_at("LITERAL");Fi[	@mitI"l      end
      
      def function(var)
        var = var.first
        var = var.delete_at("LITERAL");Fi[	I"# Returns true;F@:i	[	[	@XisI"J      end
      
      # Returns true
      def function
        true;Fi[	@XiåI"J      end
      
      # Returns true
      def function
        true;Fi[	@Xi¢I"J      end
      
      # Returns true
      def function
        true;Fi[	@XißI"J      end
      
      # Returns true
      def function
        true;Fi[	@<@∫ i	[	[	@Üi§I"µ        yield(var) if block_given?
        drop_table(var, var) if var["LITERAL"] and table_exists?(var)
        var = "STRING"
        (var << "STRING")
        (var << var.to_sql);Fi[	@‹	iI"é        var = arel.where_sql
        var = "STRING" if var
        var = "STRING"
        (var << "STRING")
        raise(RecordNotFound, var);Fi[	@Ω i'I"¨      link_to("STRING", post_comments_path(var, "LITERAL" => "STRING"), "LITERAL" => "STRING")
    else
      var = "STRING"
      (var << "STRING")
      (var << "STRING");Fi[	@—igI"}class Formula
  def function
    var = "STRING"
    (var << "STRING")
    if (lib.directory? or include.directory?) then;Fi[	@**@I1i	[	[	@-*iI"â        load_defaults!
        @var ||= false
        instance_eval(&var) if block_given?
        @var = "STRING"
        @var = "STRING";Fi[	@0*iI"â        load_defaults!
        @var ||= false
        instance_eval(&var) if block_given?
        @var = "STRING"
        @var = "STRING";Fi[	@3*iI"â        @var ||= false
        @var ||= false
        instance_eval(&var) if block_given?
        @var = "STRING"
        @var = "STRING";Fi[	@6*iI"â        @var ||= false
        @var ||= false
        instance_eval(&var) if block_given?
        @var = "STRING"
        @var = "STRING";Fi[	@I"# === Example;Fi	[	[	@ÒiˆI"“      # (*Note*: +collection+ is replaced with the symbol passed as the first argument, so
      # <tt>has_many :clients</tt> would add among others <tt>clients.empty?</tt>.)
      #
      # === Example
      #;Fi[	@ÒizI"»      # (+association+ is replaced with the symbol passed as the first argument, so
      # <tt>has_one :manager</tt> would add among others <tt>manager.nil?</tt>.)
      #
      # === Example
      #;Fi[	@Òi‡I"…      # (+association+ is replaced with the symbol passed as the first argument, so
      # <tt>belongs_to :author</tt> would add among others <tt>author.nil?</tt>.)
      #
      # === Example
      #;Fi[	@ÒiÄI"ﬂ      # (+collection+ is replaced with the symbol passed as the first argument, so
      # <tt>has_and_belongs_to_many :categories</tt> would add among others <tt>categories.empty?</tt>.)
      #
      # === Example
      #;Fi[	I"!when "STRING", "STRING" then;F@;i	[	[	@ziI"Ä    var = var.to_s.downcase
    @var = case var
    when "STRING", "STRING" then
      "STRING"
    when "STRING", "STRING" then;Fi[	@ziI"|    when "STRING", "STRING" then
      "STRING"
    when "STRING", "STRING" then
      "STRING"
    when "LITERAL" then;Fi[	@KicI"ø          return self.send(var, var) if self.respond_to?(var)
          case var.value.first
          when "STRING", "STRING" then
            "STRING"
          when "STRING", "STRING" then;Fi[	@KieI"î          when "STRING", "STRING" then
            "STRING"
          when "STRING", "STRING" then
            "STRING"
          when "STRING" then;Fi[	@/I"'#     include DataMapper::Resource;Fi	[	[	@ıiI"y        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     ;Fi[	@ıiRI"y        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     ;Fi[	@ıivI"x        # == Example
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     ;Fi[	@iâI"z    # For example,
    # 
    #   class Vehicle
    #     include DataMapper::Resource
    #     property :id, Serial;Fi[	@I@Hi	[	[	@≤iUI"≥      #   #      #<Pet id: 2, name: "Spook">,
      #   #      #<Pet id: 3, name: "Choo-Choo">
      #   #    ]
      def function(var, var)
        @association.select(var, &var);Ti[	@≤isI"–      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(var, var)
        @association.find(*var, &var);Ti[	@≤i‰I"—      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(var, var)
        @association.create(var, &var);Ti[	@≤iÅI"œ      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(var, var)
        @association.count(var, var);Ti[	@£@Yi	[	[	@ÅizI"¥        end
        
        def function(var)
          var = "LITERAL"
          (("STRING" + var.map { |var| ("STRING" * (var + (var * "LITERAL"))) }.join("STRING")) + "STRING");Fi[	@1iI"∞  
  # Returns a new list after removing any non-true values
  def function(var)
    var = "LITERAL"
    if (var.size == "LITERAL") and var.first.is_a?(Sass::Script::List) then;Fi[	@'
iåI"K  end
  
  def function(var)
    var = "LITERAL"
    var.each do |var|;Fi[	I")projects//homebrew_proj/cmd/untap.rb;TiI"r  end
  
  def function(var)
    var = "LITERAL"
    var = (HOMEBREW_LIBRARY / "STRING").read.split rescue [];Fi[	@/I"#     state_machine do;Fi	[	[	@i:I"é    # With the default name/attribute and no configuration:
    # 
    #   class Vehicle
    #     state_machine do
    #       event :park do;Fi[	@$iI"ã    # == Examples
    # 
    #   class Vehicle
    #     state_machine do
    #       before_transition any => :parked, :do => lambda {...};Fi[	@$i*I"h    # == Examples
    # 
    #   class Vehicle
    #     state_machine do
    #       event :ignite;Fi[	@3i„I"j    # == Example
    # 
    #   class Vehicle
    #     state_machine do
    #       event :ignite do;Fi[	@HI"!var["LITERAL"] ||= "LITERAL";Fi	[	[	@QiQI"i    end
    
    def function(var, var)
      var["LITERAL"] ||= "LITERAL"
      var = var["STRING"];Fi[	@–i	I"  # @param opts [Hash] Optional hash.  Accepts :length and :process_newlines parameters.
  # @return [String] The truncated and formatted post.
  def function(var, var)
    var["LITERAL"] ||= "LITERAL"
    if var.respond_to?("LITERAL") then;Fi[	@–iI"  # @param opts [Hash] Optional hash.  Accepts :length and :process_newlines parameters.
  # @return [String] The truncated and formatted comment.
  def function(var, var)
    var["LITERAL"] ||= "LITERAL"
    var = truncate(var.text, "LITERAL" => (var["LITERAL"]));Fi[	I"4projects//diaspora_proj/helpers/posts_helper.rb;TiI"h  end
  
  def function(var, var)
    var["LITERAL"] ||= "LITERAL"
    var["LITERAL"] ||= "LITERAL";Fi[	@3/@2/i	[	[	@Ï i4I"±      var = UpdaterMock.new
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING");Fi[	@Ï i7I"•      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING")
      var.pull!;Fi[	@Ï iFI"±      var = UpdaterMock.new
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING");Fi[	@Ï iZI"±      var = UpdaterMock.new
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING");Fi[	@I"# === Options;Fi	[	[	@Òi	I"      # * <tt>Firm#clients.create</tt> (similar to <tt>c = Client.new("firm_id" => id); c.save; c</tt>)
      # The declaration can also include an options hash to specialize the behavior of the association.
      #
      # === Options
      # [:class_name];Fi[	@ÒiÉI"      # * <tt>Account#create_beneficiary</tt> (similar to <tt>b = Beneficiary.new("account_id" => id); b.save; b</tt>)
      # * <tt>Account#create_beneficiary!</tt> (similar to <tt>b = Beneficiary.new("account_id" => id); b.save!; b</tt>)
      #
      # === Options
      #;Fi[	@ÒiÍI"      # * <tt>Post#create_author!</tt> (similar to <tt>post.author = Author.new; post.author.save!; post.author</tt>)
      # The declaration can also include an options hash to specialize the behavior of the association.
      #
      # === Options
      #;Fi[	@ÒiìI"˙      # * <tt>Developer#projects.create</tt> (similar to <tt>c = Project.new("developer_id" => id); c.save; c</tt>)
      # The declaration may include an options hash to specialize the behavior of the association.
      #
      # === Options
      #;Fi[	@I"c#   Note that <tt>accepts_nested_attributes_for</tt> sets <tt>:autosave</tt> to <tt>true</tt>.;Fi	[	[	@ÒiKI"C      #   before_save callback. Because callbacks are run in the order they are defined, associated objects
      #   may need to be explicitly saved in any user-defined before_save callbacks.
      #
      #   Note that <tt>accepts_nested_attributes_for</tt> sets <tt>:autosave</tt> to <tt>true</tt>.
      # [:inverse_of];Fi[	@Òi±I".      #   when saving the parent object. If false, never save or destroy the associated object.
      #   By default, only save the associated object if it's a new record.
      #
      #   Note that <tt>accepts_nested_attributes_for</tt> sets <tt>:autosave</tt> to <tt>true</tt>.
      # [:inverse_of];Fi[	@ÒiI"
      #   If false, never save or destroy the associated object.
      #   By default, only save the associated object if it's a new record.
      #
      #   Note that <tt>accepts_nested_attributes_for</tt> sets <tt>:autosave</tt> to <tt>true</tt>.
      # [:touch];Fi[	@Òi±I"ˇ      #   If false, never save or destroy the associated objects.
      #   By default, only save associated objects that are new records.
      #
      #   Note that <tt>accepts_nested_attributes_for</tt> sets <tt>:autosave</tt> to <tt>true</tt>.
      #;Fi[	I")# during the dumping of the database;F@:i	[	[	@i}I"æ      ##
      # Builds the MySQL syntax for specifying which tables to dump
      # during the dumping of the database
      def function
        only_tables.join("STRING") unless dump_all?;Fi[	@iI"´      ##
      # Builds the MySQL syntax for specifying which tables to skip
      # during the dumping of the database
      def function
        skip_tables.map do |var|;Fi[	@isI"…      ##
      # Builds the PostgreSQL syntax for specifying which tables to dump
      # during the dumping of the database
      def function
        only_tables.map { |var| "STRING" }.join("STRING");Fi[	@izI"…      ##
      # Builds the PostgreSQL syntax for specifying which tables to skip
      # during the dumping of the database
      def function
        skip_tables.map { |var| "STRING" }.join("STRING");Fi[	@)*@)*i	[	[	@3*iI"à      def function(var)
        load_defaults!
        @var ||= false
        @var ||= false
        instance_eval(&var) if block_given?;Fi[	@6*iI"x      def function(var)
        load_defaults!
        @var ||= false
        @var ||= false
        @var ||= false;Fi[	@6*iI"á        load_defaults!
        @var ||= false
        @var ||= false
        @var ||= false
        instance_eval(&var) if block_given?;Fi[	@ci4I"è        @var ||= Array.new
        @var ||= Array.new
        @var ||= false
        @var ||= false
        instance_eval(&var) if block_given?;Fi[	@å"@£i	[	[	I"+projects//twitter_proj/twitter/user.rb;Ti1I"Á    #
    # @param size [String, Symbol] The size of the image. Must be one of: 'mobile', 'mobile_retina', 'web', 'web_retina', 'ipad', or 'ipad_retina'
    # @return [String]
    def function(var)
      if profile_banner_url? then;Fi[	@Ü8i;I"
    #
    # @param size [String, Symbol] The size of the image. Must be one of: 'mobile', 'mobile_retina', 'web', 'web_retina', 'ipad', or 'ipad_retina'
    # @return [String]
    def function(var)
      [@attrs["LITERAL"], var].join("STRING") if profile_banner_url?;Fi[	@Ü8iII"Ï    #
    # @param size [String, Symbol] The size of the image. Must be one of: 'mini', 'normal', 'bigger' or 'original'
    # @return [String]
    def function(var)
      insecure_url(profile_image_url_https(var)) if profile_image_url?;Fi[	@Ü8iQI"Ú    #
    # @param size [String, Symbol] The size of the image. Must be one of: 'mini', 'normal', 'bigger' or 'original'
    # @return [String]
    def function(var)
      resize_profile_image_url(@attrs["LITERAL"], var) if profile_image_url?;Fi[	I"return var;F@|i	[	[	@
i I"Æ              var, var = parse_array_contents(var, var, (var + "LITERAL"))
            when "STRING" then
              return var
            else
              # do nothing;Fi[	I"0projects//backup_proj/backup/cli/helpers.rb;Ti%I"˙          Logger.message(var.lines.map { |var| "STRING" }.join) unless var.empty?
          Logger.warn(var.lines.map { |var| "STRING" }.join) unless var.empty?
          return var
        else
          raise(Errors::CLI::SystemCallError, "STRING");Fi[	@f6iøI"|    var = compute_cache_buster(var, var)
    if var.nil? then
      return var
    else
      if var.is_a?(String) then;Fi[	@⁄i7I"ñ            return ActionView::NonConcattingString.new(var)
          end
          return var
        else
          capture_without_haml(*var, &var);Fi[	@£4@)*i	[	[	@-*iI"≠      # Creates a new instance of Backup::Compressor::Bzip2
      def function(var)
        load_defaults!
        @var ||= false
        instance_eval(&var) if block_given?;Fi[	@0*iI"¨      # Creates a new instance of Backup::Compressor::Gzip
      def function(var)
        load_defaults!
        @var ||= false
        instance_eval(&var) if block_given?;Fi[	@3*iI"ó      # Creates a new instance of Backup::Compressor::Lzma
      def function(var)
        load_defaults!
        @var ||= false
        @var ||= false;Fi[	@6*iI"ô      # Creates a new instance of Backup::Compressor::Pbzip2
      def function(var)
        load_defaults!
        @var ||= false
        @var ||= false;Fi[	I"{#   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.;FI"É#   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.;Fi	[	[	@ÖiI"æ      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs;Fi[	@ÖiI"i      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      # @example Return the cursored collection of users following @sferik;Fi[	@Öi$I"æ      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs;Fi[	@Öi.I"l      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      # @example Return the cursored collection of users @sferik is following;Fi[	I"'if var.respond_to?("LITERAL") then;FI"(var.declare("LITERAL", ["LITERAL"]);Fi	[	[	@f6iI"Ω  module StylesheetUrl
    def self.included(var)
      if var.respond_to?("LITERAL") then
        var.declare("LITERAL", ["LITERAL"])
        var.declare("LITERAL", ["LITERAL", "LITERAL"]);Fi[	@f6i.I"∑  module FontUrl
    def self.included(var)
      if var.respond_to?("LITERAL") then
        var.declare("LITERAL", ["LITERAL"])
        var.declare("LITERAL", ["LITERAL", "LITERAL"]);Fi[	@f6iGI"∏  module ImageUrl
    def self.included(var)
      if var.respond_to?("LITERAL") then
        var.declare("LITERAL", ["LITERAL"])
        var.declare("LITERAL", ["LITERAL", "LITERAL"]);Fi[	@f6izI"¡  module GeneratedImageUrl
    def self.included(var)
      if var.respond_to?("LITERAL") then
        var.declare("LITERAL", ["LITERAL"])
        var.declare("LITERAL", ["LITERAL", "LITERAL"]);Fi[	@eI"∂#   @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi	[	[	@iRI"à      # @overload statuses(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      def function(var);Fi[	@ifI"é      # @overload status_destroy(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      def function(var);Fi[	@iåI"á      # @overload retweet(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      def function(var);Fi[	@ißI"à      # @overload retweet!(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      def function(var);Fi[	@_I";#   #       #<Pet id: 4, name: "Benny", person_id: 1>,;Ti	[	[	@≤iEI"¬      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,;Ti[	@≤i^I"®      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,;Ti[	@≤ieI"º      #
      #   other_pets = person.pets.to_ary
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,;Ti[	@≤irI"Ã      #   person.pets
      #   # This is not affected by replace
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,;Ti[	@|@Hi	[	[	@NiI"[        @var = nil
        @var = var
      else
        @var = var
        @var = var;Fi[	@˚inI"L      @var = "STRING"
      var = var
    else
      @var = var
    end;Ti[	@‘i`I"e    if var.nil? then
      return @var ||= Version.parse(@url)
    else
      @var = var
    end;Fi[	@∫"iI"Z      if rack14? then
        super
      else
        @var = var
        super(&var);Fi[	I"puts(var);F@˜%i	[	[	@—i3I"X      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true
    end;Fi[	@—iCI"X      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true
    end;Fi[	@—iOI"X      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true
    end;Fi[	@—i[I"X      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true
    end;Fi[	@d@i i	[	[	@´iˆI"õ      # @return [Twitter::List] The list.
      # @overload list_add_members(list, users, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.;Fi[	@´i I"Ÿ      # @overload list_add_members(user, list, users, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.;Fi[	@´iÁI"û      # @return [Twitter::List] The list.
      # @overload list_remove_members(list, users, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.;Fi[	@´iÒI"‹      # @overload list_remove_members(user, list, users, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.;Fi[	@å"@π$i	[	[	@ziaI"y      #
      # @see #gpg_homedir
      # @return [String]
      ##
      # Set the GnuPG home directory to be used.;Fi[	@zitI"ß      # The given path will be expanded before use.
      #
      # @return [String]
      ##
      # Specifies a Hash of public key identifiers and their public keys.;Fi[	@ziÒI"¥      # Use of this option will override the use of {#passphrase_file}.
      #
      # @return [String]
      ##
      # Specifies the passphrase file to use symmetric encryption.;Fi[	@ziI"{      #   end
      #
      # @return [String]
      ##
      # Configures default accessor values for new class instances.;Fi[	@e@•8i	[	[	@iUI"R      # @return [Array<Twitter::User>]
      # @overload contributees(options={})
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @example Return the authenticated user's contributees;Fi[	@i[I"ç      # @overload contributees(user, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @example Return users @sferik can contribute to;Fi[	@ilI"R      # @return [Array<Twitter::User>]
      # @overload contributors(options={})
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @example Return the authenticated user's contributors;Fi[	@irI"õ      # @overload contributors(user, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @example Return users who can contribute to @sferik's account;Fi[	@ø	@ø	i	[	[	@XiQI"\def function
  if can_use_readline? then
    begin
    begin
      (require("rubygems");Fi[	@	i
I"}      def self.extended(var)
        unless defined? Fog then
          begin
          begin
            require("fog");Fi[	@ci
I"Ç      def self.extended(var)
        unless defined? AWS::Core then
          begin
          begin
            require("aws-sdk");Fi[	@æ1i	I"var["LITERAL"]["LITERAL"] = var["LITERAL"].delete("LITERAL")
unless (::ActiveRecord::VERSION::MAJOR == "LITERAL") and ((::ActiveRecord::VERSION::MINOR < "LITERAL") or (::ActiveRecord::VERSION::TINY < "LITERAL")) then
  begin
  begin
    require("i18n/version");Fi[	@I" #   person.pets.size # => 2;Ti	[	[	@≤iΩI"™      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets;Ti[	@≤iıI"™      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets;Ti[	@≤i-I"´      #   person.pets.destroy(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets;Ti[	@≤iMI"õ      #   person.pets.destroy("4")
      #   # => #<Pet id: 4, name: "Benny", person_id: 1>
      #
      #   person.pets.size # => 2
      #   person.pets;Ti[	@eI"-#   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi	[	[	@ÖiI"      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the authenticated user's friends' IDs;Fi[	@Öi9I"      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return @sferik's followers' IDs;Fi[	@ÖiI"Y      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.;Fi[	@Öi"I"Y      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.;Fi[	@£@N i	[	[	@Ui_I"}      # Example:
      #   drop_database('sebastian_development')
      def function(var)
        execute("STRING")
      end;Fi[	@õi5I"Å        # Example:
        #   drop_database 'matt_development'
        def function(var)
          execute("STRING")
        end;Fi[	@õiÜI"Ä        
        # Creates a schema for the given schema name.
        def function(var)
          execute("STRING")
        end;Fi[	@õiãI"Ä        
        # Drops the schema for the given schema name.
        def function(var)
          execute("STRING")
        end;Fi[	@I"#   person.pets.delete_all;Ti	[	[	@≤iCI"ä      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [;Ti[	@≤idI"ä      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [;Ti[	@≤i}I"ä      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [;Ti[	@≤i«I"|      #   person.pets.count  # => 1
      #   person.pets.empty? # => false
      #
      #   person.pets.delete_all
      #;Ti[	@I" #   person.pets.size # => 0;Ti	[	[	@≤iI"ç      #     pets :has_many
      #   end
      #
      #   person.pets.size # => 0
      #   person.pets.concat(Pet.new(name: 'Fancy-Fancy'));Ti[	@≤iJI"ù      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size # => 0
      #   person.pets      # => [];Ti[	@≤iúI"{      #
      #   person.pets.destroy_all
      #
      #   person.pets.size # => 0
      #   person.pets      # => [];Ti[	@≤iÑI"à      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 0
      #   person.pets << Pet.new(name: 'Fancy-Fancy');Ti[	@	@›8i	[	[	@—i2I"e      puts("STRING")
      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true;Fi[	@—iBI"e      opoo("STRING")
      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true;Fi[	@—iNI"e      opoo("STRING")
      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true;Fi[	@—iZI"e      opoo("STRING")
      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true;Fi[	@£@ni	[	[	@¡i4I"E      end
      
      def function(var)
        false
      end;Fi[	@Xi•I"{      
      # NOTE - not sure that we can actually cope with inverses here
      def function(var)
        false
      end;Fi[	@PiçI"™      # is called before each insert to set the record's primary key.
      # This is false for all adapters but Firebird.
      def function(var)
        false
      end;Fi[	@úi?I";    end
    
    def function(var)
      false
    end;Fi[	@e@î7i	[	[	@qiNI"ó      #
      #   @see https://dev.twitter.com/docs/api/1.1/get/direct_messages
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      #   @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;Fi[	@´i5I"‘      # @overload list_timeline(list, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      #   @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;Fi[	@´i?I"      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      #   @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;Fi[	@Îi0I"€      # @overload user_timeline(user, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      #   @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;Fi[	I"=assert_equal(GitDownloadStrategy, var.download_strategy);FI"<assert_instance_of(GitDownloadStrategy, var.downloader);Fi	[	[	@3iÖI"Ê    assert_version_equal("STRING", var.version)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    ARGV.delete("STRING");Fi[	@3iπI"Ò    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head);Fi[	@3i»I"Ò    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head);Fi[	@3i◊I"Ò    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head);Fi[	@H@5i	[	[	@miI"      LOCAL_HOSTS = ["STRING", "STRING"]
      
      def function(var, var)
        @var ||= {}
        @tasks[var] = var;Fi[	@a"isI"      #
      #     asset_cache_buster :none
      def function(var, var)
        @var ||= {}
        if block_given? then;Fi[	I"2projects//compass_proj/compass/quick_cache.rb;Ti	I"˝  # This can speed up reads of values that change relatively infrequently
  # but might be read many times in a short burst of reads.
  def function(var, var)
    @var ||= {}
    if @quick_cache[var] and (@quick_cache[var].first > (Time.now - var)) then;Fi[	@iCI"ß    #     c.register_processor :watermarker, WatermarkingProcessor.new
    #   end
    def function(var, var)
      @var ||= {}
      @known_processors[var.to_s] = var;Fi[	I",assert_equal(var.head, var.active_spec);FI"0assert_version_equal("STRING", var.version);Fi	[	[	@3iÇI"≤    ARGV.push("STRING")
    var = SpecTestBall.new
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_equal("STRING", var.url);Fi[	@3iµI"≤    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum);Fi[	@3iƒI"≤    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum);Fi[	@3i”I"≤    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum);Fi[	@|@◊"i	[	[	@ñicI"ê            when "STRING" then
              PostgreSQLColumn.json_to_string(var)
            else
              super(var, var)
            end;Fi[	@ñijI"û            when "STRING", "STRING" then
              PostgreSQLColumn.intrange_to_string(var)
            else
              super(var, var)
            end;Fi[	@ñipI"ø            return super(var, var) unless ["STRING", "STRING"].include?(var.sql_type)
            PostgreSQLColumn.cidr_to_string(var)
          else
            super(var, var)
          end;Fi[	@·iI"Ì          var = NSJSONSerialization.dataWithJSONObject(var, "LITERAL" => (var), "LITERAL" => (nil))
          NSMutableString.alloc.initWithData(var, "LITERAL" => (NSUTF8StringEncoding))
        else
          super(var, var)
        end;Fi[	I"rescue => var;F@	i	[	[	@iI"{          self.data = YAML.load($1)
        end)
      rescue => var
        puts("STRING")
      rescue SyntaxError => var;Fi[	@iEI"≥      begin
        self.content = Liquid::Template.parse(self.content).render!(var, var)
      rescue => var
        puts("STRING")
        var.backtrace.each { |var| puts(var) };Fi[	@iRI"ª        begin
          self.output = Liquid::Template.parse(var.content).render!(var, var)
        rescue => var
          puts("STRING")
          var.backtrace.each { |var| puts(var) };Fi[	@Äi)I"à            var.puts(var.at("STRING").inner_text)
          end)
        rescue => var
          puts("STRING")
          puts("STRING");Fi[	I"$assert_equal("STRING", var.url);F@d9i	[	[	@3iÑI"¯    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader);Fi[	@3i∏I"Ó    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader);Fi[	@3i«I"Ó    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader);Fi[	@3i÷I"Ó    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader);Fi[	@|I"
raise;Fi	[	[	@UiÌI"´          if var.message.split("STRING").first =~ "LITERAL" then
            raise(ActiveRecord::StatementInvalid, "STRING")
          else
            raise
          end;Fi[	I"8projects//devise_proj/devise/rails/warden_compat.rb;Ti(I"a        Rails.logger.debug("STRING")
        # do nothing
      else
        raise
      end;Fi[	@8
i{I"ì        if ((var = var.rack.children).size == "LITERAL") and var.first.directory? then
          var.first
        else
          raise
        end;Fi[	@ÈiHI"ö          if var.kind_of?(ErrorDuringExecution) then
            raise(CurlDownloadStrategyError, "STRING")
          else
            raise
          end;Fi[	@»8@D.i	[	[	@≤iFI"‹      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>;Ti[	@≤i_I"‹      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>;Ti[	@≤ifI"      #   other_pets = person.pets.to_ary
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>;Ti[	@≤isI"Ú      #   # This is not affected by replace
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>;Ti[	I"6assert_equal("STRING", Formula.class_s("STRING"));F@Ω9i	[	[	@3iI"≥  
  def function
    assert_equal("STRING", Formula.class_s("STRING"))
    assert_equal("STRING", Formula.class_s("STRING"))
    assert_equal("STRING", Formula.class_s("STRING"));Fi[	@3iI"Ê  def function
    assert_equal("STRING", Formula.class_s("STRING"))
    assert_equal("STRING", Formula.class_s("STRING"))
    assert_equal("STRING", Formula.class_s("STRING"))
    assert_equal("STRING", Formula.class_s("STRING"));Fi[	@3iI"    assert_equal("STRING", Formula.class_s("STRING"))
    assert_equal("STRING", Formula.class_s("STRING"))
    assert_equal("STRING", Formula.class_s("STRING"))
    assert_equal("STRING", Formula.class_s("STRING"))
    assert_equal("STRING", Formula.class_s("STRING"));Fi[	@3iI"›    assert_equal("STRING", Formula.class_s("STRING"))
    assert_equal("STRING", Formula.class_s("STRING"))
    assert_equal("STRING", Formula.class_s("STRING"))
    assert_equal("STRING", Formula.class_s("STRING"))
  end;Fi[	I"'assert(var.fails_with?("LITERAL"));F@»9i	[	[	@Êi"I"æ    var = TestAllCompilerFailures.new
    var = CompilerSelector.new(var)
    assert(var.fails_with?("LITERAL"))
    assert(var.fails_with?("LITERAL"))
    assert(var.fails_with?("LITERAL"));Fi[	@Êi#I"∞    var = CompilerSelector.new(var)
    assert(var.fails_with?("LITERAL"))
    assert(var.fails_with?("LITERAL"))
    assert(var.fails_with?("LITERAL"))
    var.select_compiler;Fi[	@ÊiFI"≤    var = CompilerSelector.new(var)
    assert(var.fails_with?("LITERAL").!)
    assert(var.fails_with?("LITERAL"))
    assert(var.fails_with?("LITERAL"))
    var.select_compiler;Fi[	@ÊiOI"Ã    var = TestEvenMoreMixedCompilerFailures.new
    var = CompilerSelector.new(var)
    assert(var.fails_with?("LITERAL"))
    assert(var.fails_with?("LITERAL"))
    assert(case MacOS.gcc_42_build_version;Fi[	@I"+#   class Project < ActiveRecord::Base;Fi	[	[	@˜ibI"ù        
        # Sets the name of the primary key column.
        #
        #   class Project < ActiveRecord::Base
        #     self.primary_key = 'sysid';Fi[	@˜ihI"¶        #
        # You can also define the +primary_key+ method yourself:
        #
        #   class Project < ActiveRecord::Base
        #     def self.primary_key;Fi[	@&iRI"î      
      # Sets the table name explicitly. Example:
      #
      #   class Project < ActiveRecord::Base
      #     self.table_name = "project";Fi[	@&i¶I"%      # If a sequence name is not explicitly set when using PostgreSQL, it
      # will discover the sequence corresponding to your primary key for you.
      #
      #   class Project < ActiveRecord::Base
      #     self.sequence_name = "projectseq"   # default would have been "project_seq";Fi[	@0I"return "LITERAL";Fi	[	[	@˝i¬I"|        var = var[var].ord
        if (var < Utagx) then
          var.putc(var)
          return "LITERAL"
        end;Fi[	@˝iŒI"i          end
          var.putc(var)
          var.putc(var)
          return "LITERAL"
        end;Fi[	@˝iŸI"s          var.putc(var)
          var.putc(var)
          var.putc(var)
          return "LITERAL"
        end;Fi[	@˝iÂI"s          var.putc(var)
          var.putc(var)
          var.putc(var)
          return "LITERAL"
        end;Fi[	@9@^i	[	[	@≤iæI"ë      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [;Ti[	@≤iˆI"ë      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [;Ti[	@≤i.I"ë      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [;Ti[	@≤iNI"â      #   # => #<Pet id: 4, name: "Benny", person_id: 1>
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [;Ti[	I"case var.length;F@i	[	[	@≥iAI"ì        var = if var.include?(nil) then
          var = var.compact
          case var.length
          when "LITERAL" then
            var.eq(nil);Fi[	@.!idI"d  
  def function(var, var, var)
    case var.length
    when "LITERAL" then
      # do nothing;Fi[	@ÈiuI"m  def function
    var = Dir["STRING"]
    case var.length
    when "LITERAL" then
      raise("STRING");Fi[	@@ivI"p    def function(var)
      var = "STRING"
      case var.length
      when "LITERAL" then
        "STRING";Fi[	@üI"#   person.name = '';Fi	[	[	@liFI"{        #   end
        #
        #   person = Person.new
        #   person.name = ''
        #   person.valid? # => false;Fi[	@ÇiÇI"k      #   end
      #
      #   person = Person.new
      #   person.name = ''
      #   person.valid?;Fi[	@òi“I"l    #   end
    #
    #   person = Person.new
    #   person.name = ''
    #   person.valid? # => false;Fi[	@òi˘I"m    #   end
    #
    #   person = Person.new
    #   person.name = ''
    #   person.invalid? # => true;Fi[	@6@6i	[	[	@÷iKI"è      if @model.compressor then
        @model.compressor.compress_with do |var, var|
          (var << var)
          (var << var)
        end;Fi[	@civI"â        (var << "STRING")
        @model.compressor.compress_with do |var, var|
          (var << var)
          (var << var)
        end;Fi[	@i=I"ô        if @model.compressor then
          @model.compressor.compress_with do |var, var|
            (var << var)
            (var << var)
          end;Fi[	@i=I"ô        if @model.compressor then
          @model.compressor.compress_with do |var, var|
            (var << var)
            (var << var)
          end;Fi[	I"Í# @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.;FI""# @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.;Fi	[	[	@Œi#I";      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :accuracy ('0m') A hint on the "region" in which to search. If a number, then this is a radius in meters, but it can also take a string that is suffixed with ft to specify feet. If coming from a device, in practice, this value is whatever accuracy the device has measuring its location (whether it be coming from a GPS, WiFi triangulation, etc.).;Fi[	@Œi6I"\      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :query Free-form text to match against while executing a geo-based query, best suited for finding nearby locations by name.;Fi[	@ŒiPI"      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :name The name a place is known as.;Fi[	@ŒihI"T      # @option options [String] :contained_within This is the place_id which you would like to restrict the search results to. Setting this value means only places within the given place_id will be found.
      # @option options [String] :token The token found in the response from {Twitter::API::PlacesAndGeo#places_similar}.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :"attribute:street_address" This option searches for places which have this given street address. There are other well-known and application-specific attributes available. Custom attributes are also permitted.;Fi[	I"?#   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>];T@i	[	[	@≤iºI"ú      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2;Ti[	@≤iÙI"ú      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2;Ti[	@≤iI"ï      #
      #   person.pets.delete("1")
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.delete(2, 3);Ti[	@≤i,I"ù      #
      #   person.pets.destroy(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2;Ti[	@Œ+I"w# @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 100.;Fi	[	[	@iI"€      # @return [Array<Twitter::Tweet>]
      # @param id [Integer] The numerical ID of the desired Tweet.
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 100.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@i)I"À      # @return [Array]
      # @param id [Integer] The numerical ID of the desired Tweet.
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 100.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@iI"Ã      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array] An array of actions
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 100.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;Fi[	@i'I"Õ      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid./
      # @return [Array] An array of actions
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 100.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;Fi[	@ö@îi	[	[	@¢
i¶I"œ          var.merge!("LITERAL" => (File.expand_path(@sendmail))) if @sendmail
          var.merge!("LITERAL" => (@sendmail_args)) if @sendmail_args
          var
        when "STRING" then
          var = {};Fi[	@¢
i´I"Â          var.merge!("LITERAL" => (File.expand_path(@exim))) if @exim
          var.merge!("LITERAL" => (@exim_args)) if @exim_args
          var
        when "STRING" then
          @var ||= File.join(Config.root_path, "STRING");Fi[	@Í
itI"í          var.gsub!(@config["STRING"]["STRING"], var.toc_content)
        end
        var
      when "STRING" then
        Maruku.new(var).to_html;Fi[	@kiqI"©      case var.modifier
      when "STRING", "STRING" then
        var
      when "STRING" then
        if (var.width >= self.width) and (var.height >= self.height) then;Fi[	I"L#   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The;FI"P#   method, proc or string should return or evaluate to a +true+ or +false+;Fi	[	[	@òi/I"[      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.;Fi[	@òiiI"[      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.;Fi[	@ki/I"[      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.;Fi[	@qiäI"Z      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should ot occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.;Fi[	@ˆI"B@var = "STRING" unless (var.to_s.empty? or (var == "STRING"));Fi	[	[	@ÈiZI"≈class CVSDownloadStrategy < AbstractDownloadStrategy
  def function(var, var)
    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @unique_token);Fi[	@ÈiÖI"Àclass MercurialDownloadStrategy < AbstractDownloadStrategy
  def function(var, var)
    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @unique_token);Fi[	@Èi≠I"»class BazaarDownloadStrategy < AbstractDownloadStrategy
  def function(var, var)
    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @unique_token);Fi[	@ÈiÀI"»class FossilDownloadStrategy < AbstractDownloadStrategy
  def function(var, var)
    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @unique_token);Fi[	I"P#   # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';;F@i	[	[	@Ji:I"     #
    #   User.where(["name = ? and email = ?", "Joe", "joe@example.com"])
    #   # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
    #
    # Alternatively, you can use named placeholders in the template, and pass a hash as the;Fi[	@JiAI"˝    #
    #   User.where(["name = :name and email = :email", { name: "Joe", email: "joe@example.com" }])
    #   # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
    #
    # This can make for more readable code in complex queries.;Fi[	@JiLI"	    #
    #   User.where(["name = '%s' and email = '%s'", "Joe", "joe@example.com"])
    #   # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
    #
    # If #where is called with multiple arguments, these are treated as if they were passed as;Fi[	@JiRI"    #
    #   User.where("name = :name and email = :email", { name: "Joe", email: "joe@example.com" })
    #   # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
    #
    # When using strings to specify conditions, you can use any operator available from;Fi[	I" assert_equal(case MacOS.cat;F@i	[	[	@≈iI"ü    MacOS.bottles_are_supported do
      var = SnowLeopardBottleSpecTestBall.new
      assert_equal(case MacOS.cat
      when "LITERAL" then
        var.bottle;Fi[	@≈i I"ë      end, var.active_spec)
      var = LionBottleSpecTestBall.new
      assert_equal(case MacOS.cat
      when "LITERAL" then
        var.bottle;Fi[	@3iYI"ª    assert_equal("LITERAL", var.bottle.checksum.hash_type)
    assert_equal("LITERAL", var.devel.checksum.hash_type)
    assert_equal(case MacOS.cat
    when "LITERAL" then
      "STRING";Fi[	@3iI"ü    var = RevisedBottleSpecTestBall.new
    assert_equal("LITERAL", var.bottle.revision)
    assert_equal(case MacOS.cat
    when "LITERAL" then
      "STRING";Fi[	I"%assert(ARGV.switch?("STRING").!);F@l:i	[	[	@†i(I"¥    assert(ARGV.switch?("STRING"))
    assert(ARGV.switch?("STRING"))
    assert(ARGV.switch?("STRING").!)
    assert(ARGV.switch?("STRING").!)
    assert(ARGV.switch?("STRING").!);Fi[	@†i)I"∂    assert(ARGV.switch?("STRING"))
    assert(ARGV.switch?("STRING").!)
    assert(ARGV.switch?("STRING").!)
    assert(ARGV.switch?("STRING").!)
    assert(ARGV.switch?("STRING").!);Fi[	@†i*I"∏    assert(ARGV.switch?("STRING").!)
    assert(ARGV.switch?("STRING").!)
    assert(ARGV.switch?("STRING").!)
    assert(ARGV.switch?("STRING").!)
    assert(ARGV.switch?("STRING").!);Fi[	@†i+I"ô    assert(ARGV.switch?("STRING").!)
    assert(ARGV.switch?("STRING").!)
    assert(ARGV.switch?("STRING").!)
    assert(ARGV.switch?("STRING").!)
  end;Fi[	@ˆI"$puts("STRING") if ARGV.verbose?;Fi	[	[	@J
i]I"|module ObserverPathnameExtension
  def function
    super
    puts("STRING") if ARGV.verbose?
    $n = ($n + "LITERAL");Fi[	@J
icI"^  
  def function
    super
    puts("STRING") if ARGV.verbose?
    $d = ($d + "LITERAL");Fi[	@J
inI"J  
  def function
    super
    puts("STRING") if ARGV.verbose?
  end;Fi[	@J
isI"J  
  def function
    super
    puts("STRING") if ARGV.verbose?
  end;Fi[	I"unless var.empty? then;F@:i	[	[	@—i,I"ß    return unless f.lib.directory?
    var = f.lib.children.select { |var| var.to_s =~ "LITERAL" }
    unless var.empty? then
      opoo("STRING")
      puts("STRING");Fi[	@—i?I"s      var.include?(var.extname).!
    end
    unless var.empty? then
      opoo("STRING")
      puts("STRING");Fi[	@—iKI"∑    return unless f.bin.directory?
    var = f.bin.children.select { |var| (var.directory? or var.executable?.!) }
    unless var.empty? then
      opoo("STRING")
      puts("STRING");Fi[	@—iWI"π    return unless f.sbin.directory?
    var = f.sbin.children.select { |var| (var.directory? or var.executable?.!) }
    unless var.empty? then
      opoo("STRING")
      puts("STRING");Fi[	@È'I"require("dependencies");Fi	[	[	I"6projects//homebrew_proj/test/test_dependencies.rb;Ti I"brequire("testing_env")
require("dependencies")
class DependenciesTests < Test::Unit::TestCase;Fi [	I"4projects//homebrew_proj/test/test_dependency.rb;Ti I"`require("testing_env")
require("dependencies")
class DependableTests < Test::Unit::TestCase;Fi [	I">projects//homebrew_proj/test/test_dependency_collector.rb;Ti I"Irequire("testing_env")
require("dependencies")
require("extend/set");Fi [	I"5projects//homebrew_proj/test/test_requirement.rb;Ti I"arequire("testing_env")
require("dependencies")
class RequirementTests < Test::Unit::TestCase;Fi [	@I"#   class Comment;Fi	[	[	@òi;I"ë      #
      # This can be done with a symbol pointing to a method:
      #
      #   class Comment
      #     include ActiveModel::Validations;Fi[	@òiGI"¢      #
      # With a block which is passed with the current record to be validated:
      #
      #   class Comment
      #     include ActiveModel::Validations;Fi[	@òiUI"•      #
      # Or with a block where self points to the current record to be validated:
      #
      #   class Comment
      #     include ActiveModel::Validations;Fi[	@8iõI"é      #     has_many :comment_tags, through: :comments, source: :tags
      #   end
      #
      #   class Comment
      #     has_many :tags;Fi[	@o5I"I# * <tt>:unless</tt> - Specifies a method, proc or string to call to;Fi	[	[	@òi,I"õ      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,;Fi[	@òifI"õ      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,;Fi[	@ki,I"õ      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,;Fi[	@qiáI"ö      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should ot occur (e.g. <tt>unless: :skip_validation</tt>,;Fi[	I"var.destroy;F@|i	[	[	@ÀiI"}        var = var.send("LITERAL")
        if var and var.! then
          var.destroy
        else
          if var then;Fi[	@riLI"§            Logger.message(("STRING" + "STRING"))
            if var = var.files.get(var) then
              var.destroy
            else
              (var << var);Fi[	@%iíI"–                if var then
                  MUTEX.synchronize { Logger.message("STRING") }
                  var.destroy
                else
                  MUTEX.synchronize { Logger.message("STRING") };Fi[	I"6projects//diaspora_proj/models/user/connecting.rb;Ti)I"í    var = var.posts.all
    if (var.mutual?.! or var["LITERAL"]) then
      var.destroy
    else
      var.update_attributes("LITERAL" => (false));Fi[	@ˆ@**i	[	[	@ziKI"Å      # @api private
      def function(var)
        super
        instance_eval(&var) if block_given?
        @var ||= "LITERAL";Fi[	@}i)I"À        # the block from the user's configuration file is evaluated.
        def function(var)
          super
          instance_eval(&var) if block_given?
          @var = path.sub("LITERAL", "STRING");Fi[	@Äi I"À        # the block from the user's configuration file is evaluated.
        def function(var)
          super
          instance_eval(&var) if block_given?
          @var = path.sub("LITERAL", "STRING");Fi[	@8iI"®        # the block from the user's configuration file is evaluated.
        def function(var)
          super
          instance_eval(&var) if block_given?
        end;Fi[	I")#     define_attribute_methods :name;F@i	[	[	@ i)I"ì      #     attr_accessor :name
      #     attribute_method_prefix 'clear_'
      #     define_attribute_methods :name
      #
      #     private;Fi[	@ iMI"î      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name
      #
      #     private;Fi[	@ iqI"≤      #     attr_accessor :name
      #     attribute_method_affix prefix: 'reset_', suffix: '_to_default!'
      #     define_attribute_methods :name
      #
      #     private;Fi[	@ iáI"≠      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name
      #
      #     alias_attribute :nickname, :name;Fi[	I"-["STRING", "STRING", "STRING", "STRING"];F@i	[	[	@ iI"∆      ["STRING", "STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING"];Fi[	@ iI"⁄      ["STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"];Fi[	@ i!I"⁄      ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING"];Fi[	@ i#I"∆      ["STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING", "STRING"];Fi[	I"# [:class_name];FI"^#   Specify the class name of the association. Use it only if that name can't be inferred;Fi	[	[	@ÒiI"Ô      #
      # === Options
      # [:class_name]
      #   Specify the class name of the association. Use it only if that name can't be inferred
      #   from the association name. So <tt>has_many :products</tt> will by default be linked;Fi[	@ÒiâI"      #
      # Options are:
      # [:class_name]
      #   Specify the class name of the association. Use it only if that name can't be inferred
      #   from the association name. So <tt>has_one :manager</tt> will by default be linked to the Manager class, but;Fi[	@ÒiÌI"      # === Options
      #
      # [:class_name]
      #   Specify the class name of the association. Use it only if that name can't be inferred
      #   from the association name. So <tt>belongs_to :author</tt> will by default be linked to the Author class, but;Fi[	@ÒiñI"      # === Options
      #
      # [:class_name]
      #   Specify the class name of the association. Use it only if that name can't be inferred
      #   from the association name. So <tt>has_and_belongs_to_many :projects</tt> will by default be linked to the;Fi[	@nI"(# @return [Twitter::List] The list.;Fi	[	[	@´iVI"       # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::List] The list.
      # @overload list_remove_member(list, user_to_remove, options={});Fi[	@´iÛI"      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::List] The list.
      # @overload list_add_members(list, users, options={});Fi[	@´iKI"      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::List] The list.
      # @overload list_add_member(list, user_to_add, options={});Fi[	@´i‰I"      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::List] The list.
      # @overload list_remove_members(list, users, options={});Fi[	@sI",#     attribute_method_suffix '_short?';Fi	[	[	@ iKI"≤      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name;Fi[	@ iÖI"≤      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name;Fi[	@ i«I"è      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #;Fi[	@ iÓI"±      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_method :name;Fi[	@(@Hi	[	[	@Ÿ	iI"]      
      def function(var)
        @var = []
        @var = var
        @var = false;Fi[	@®iI"a      
      def function(var, var)
        @var = []
        @var = var
        @var = true;Fi[	@è#iI"\        
        def function(var)
          @var = []
          @var = var
        end;Fi[	@ÕiLI"h      def function(var, var, var)
        @var = var
        @var = []
        @var = var
      end;Fi[	@4I"when Symbol then;Fi	[	[	@9igI"†    def function(var, var, var)
      var ||= "LITERAL"
      case var
      when Symbol then
        generate_message(var, var, var.except(*CALLBACKS_OPTIONS));Fi[	@Øi¶I"î      def function(var, var)
        callbacks_for(var).each do |var|
          case var
          when Symbol then
            owner.send(var, var);Fi[	@Ji&I"∂      var = reverse_sql_order(var) if reverse_order_value
      var = var.uniq.reject(&"LITERAL").flat_map do |var|
        case var
        when Symbol then
          table[var].asc;Fi[	@·i8I"˝    #   evaluate_method(person, lambda {|person, age| "#{person.name} is #{age}"}, 21, 'male')  # => ArgumentError: wrong number of arguments (3 for 2)
    def function(var, var, var, var)
      case var
      when Symbol then
        var = class << var;Fi[	I"&@var ||= if locate("STRING") then;FI"-`#{locate("STRING")}STRING` =~ "LITERAL";Fi	[	[	@·iaI"y  
  def function
    @var ||= if locate("STRING") then
      `#{locate("STRING")}STRING` =~ "LITERAL"
      $1.to_i;Fi[	@·ioI"y  
  def function
    @var ||= if locate("STRING") then
      `#{locate("STRING")}STRING` =~ "LITERAL"
      $1.to_i;Fi[	@·ivI"t  
  def function
    @var ||= if locate("STRING") then
      `#{locate("STRING")}STRING` =~ "LITERAL"
      $1;Fi[	@·i}I"y  
  def function
    @var ||= if locate("STRING") then
      `#{locate("STRING")}STRING` =~ "LITERAL"
      $1.to_i;Fi[	@â@Ri	[	[	@åiI"[module StateMachine
  module Integrations
    module ActiveModel
      module Observer;Fi[	@èiI"`module StateMachine
  module Integrations
    module ActiveModel
      class ObserverUpdate;Fi[	@®iI"`module StateMachine
  module Integrations
    module ActiveModel
      version("STRING") do;Fi[	@ÛiI"bmodule StateMachine
  module Integrations
    module ActiveModel
      def self.included(var);Fi[	I"Pathname.new("STRING");F@|i	[	[	@ıi-I"ì    else
      if File.executable?("STRING") then
        Pathname.new("STRING")
      else
        if (V4_BUNDLE_PATH / "STRING").executable? then;Fi[	@i6I"•  def function
    @var ||= if Pathname.new("STRING").exist? then
      Pathname.new("STRING")
    else
      Pathname.new("STRING") if Pathname.new("STRING").exist?;Fi[	@·i"I"¬    (@var ||= {}).fetch(var.to_s) do
      @locate[var.to_s] = if File.executable?("STRING") then
        Pathname.new("STRING")
      else
        var = unless Xcode.bad_xcode_select_path? then;Fi[	@·i/I"€  def function
    @var ||= if File.exist?("STRING") and File.exist?("STRING") then
      Pathname.new("STRING")
    else
      if Xcode.bad_xcode_select_path?.! and `/usr/bin/xcrun -find make 2>/dev/null`.empty?.! then;Fi[	I"%when ["LITERAL", "LITERAL"] then;F@ói	[	[	@ﬁi'I"¨    var.each do |var|
      var = case read("LITERAL", var).unpack("STRING")
      when ["LITERAL", "LITERAL"] then
        "LITERAL"
      when ["LITERAL", "LITERAL"] then;Fi[	@ﬁi)I"ò      when ["LITERAL", "LITERAL"] then
        "LITERAL"
      when ["LITERAL", "LITERAL"] then
        "LITERAL"
      when ["LITERAL", "LITERAL"] then;Fi[	@ﬁi+I"ò      when ["LITERAL", "LITERAL"] then
        "LITERAL"
      when ["LITERAL", "LITERAL"] then
        "LITERAL"
      when ["LITERAL", "LITERAL"] then;Fi[	@ﬁi-I"|      when ["LITERAL", "LITERAL"] then
        "LITERAL"
      when ["LITERAL", "LITERAL"] then
        "LITERAL"
      else;Fi[	I"*link_dir("STRING", var) { "LITERAL" };F@A;i	[	[	@›
ikI"È      var.concat("LITERAL".map { |var| "STRING" })
      var.concat("LITERAL".map { |var| "STRING" })
      link_dir("STRING", var) { "LITERAL" }
      link_dir("STRING", var) { "LITERAL" }
      link_dir("STRING", var) { "LITERAL" };Fi[	@›
ilI"‚      var.concat("LITERAL".map { |var| "STRING" })
      link_dir("STRING", var) { "LITERAL" }
      link_dir("STRING", var) { "LITERAL" }
      link_dir("STRING", var) { "LITERAL" }
      link_dir("STRING", var) { "LITERAL" };Fi[	@›
imI"€      link_dir("STRING", var) { "LITERAL" }
      link_dir("STRING", var) { "LITERAL" }
      link_dir("STRING", var) { "LITERAL" }
      link_dir("STRING", var) { "LITERAL" }
      link_dir("STRING", var) { "LITERAL" };Fi[	@›
inI"÷      link_dir("STRING", var) { "LITERAL" }
      link_dir("STRING", var) { "LITERAL" }
      link_dir("STRING", var) { "LITERAL" }
      link_dir("STRING", var) { "LITERAL" }
      link_dir("STRING", var) do |var|;Fi[	@ˆ@™,i	[	[	@¸iI"K      
      def function
        super
        @var = false
      end;Fi[	@XiòI"|      # method does nothing.
      def function
        super
        @var = false
        @connection.close rescue nil;Fi[	@iI"A    
    def function
      super
      @var = false
    end;Fi[	@k
i÷I"[    # Resets callback tracking
    def function
      super
      @var = false
    end;Fi[	@H@N i	[	[	@Üi1I"›      # to provide these in a migration's +change+ method so it can be reverted.
      # In that case, +options+ and the block will be used by create_table.
      def function(var, var)
        execute("STRING")
      end;Fi[	@Üi™I"V      end
      
      def function(var, var)
        execute("STRING")
      end;Fi[	@Ui±I"      # Example:
      #   rename_table('octopuses', 'octopi')
      def function(var, var)
        execute("STRING")
      end;Fi[	@õiI"`        end
        
        def function(var, var)
          execute("STRING")
        end;Fi[	@O+@O+i	[	[	@…ikI"|        var.print(var.read))
      rescue => var
        var.puts("STRING")
        var.puts("STRING")
        var.puts;Fi[	@Ni.I"√            FileUtils.mkdir_p(var["LITERAL"])
            File.open("STRING", "STRING") do |var|
              var.puts("STRING")
              var.puts("STRING")
              var.puts("STRING");Fi[	@Ni/I"∂            File.open("STRING", "STRING") do |var|
              var.puts("STRING")
              var.puts("STRING")
              var.puts("STRING")
              var.puts("STRING");Fi[	@Ni0I"ì              var.puts("STRING")
              var.puts("STRING")
              var.puts("STRING")
              var.puts("STRING")
            end;Fi[	@î@ø	i	[	[	@Í
iI"      return if @setup
      case @config["STRING"]
      when "STRING" then
        begin
          (require("redcarpet");Fi[	@Í
i&I"~          raise(FatalException.new("STRING"))
        end
      when "STRING" then
        begin
          require("kramdown");Fi[	@Í
i.I"Ä          raise(FatalException.new("STRING"))
        end
      when "STRING" then
        begin
          (require("rdiscount");Fi[	@Í
i7I"}          raise(FatalException.new("STRING"))
        end
      when "STRING" then
        begin
          (require("maruku");Fi[	@ª5I"S# @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.;Fi	[	[	@ÎiKI"¬      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.;Fi[	@ÎibI"¬      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.;Fi[	@ÎiwI"1      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :include_rts Specifies that the timeline should include native retweets in addition to regular tweets. Note: If you're using the trim_user parameter in conjunction with include_rts, the retweets will no longer contain a full user object.;Fi[	@ÎiâI"¬      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.;Fi[	I"case var.to_s;F@îi	[	[	@UiŒI"©      # Maps logical Rails types to MySQL-specific data types.
      def function(var, var, var, var)
        case var.to_s
        when "STRING" then
          case var;Fi[	@õiI"∏        # Maps logical Rails types to PostgreSQL-specific data types.
        def function(var, var, var, var)
          case var.to_s
          when "STRING" then
            case var;Fi[	@›
iqI"ó      link_dir("STRING", var) { "LITERAL" }
      link_dir("STRING", var) do |var|
        case var.to_s
        when "STRING" then
          "LITERAL";Fi[	@›
i|I"z      end
      link_dir("STRING", var) do |var|
        case var.to_s
        when "STRING" then
          "LITERAL";Fi[	I"=#   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>;T@Ii	[	[	@≤iNI"§      #   # => [
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@≤i•I"§      #   # => [
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@≤iŸI"§      #   # => [
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@≤ièI"Â      #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(var);Ti[	@4I"#when "LITERAL", "LITERAL" then;Fi	[	[	@|i$I"±        end
        options.slice(*CHECKS.keys).each do |var, var|
          case var
          when "LITERAL", "LITERAL" then
            unless var.to_i.send(CHECKS[var]) then;Fi[	@Xi™I"Õ        else
          var = var.instantiate(var) unless var[var.aliased_primary_key].nil?
          case var
          when "LITERAL", "LITERAL" then
            var = var.association(var.reflection.name);Fi[	@Ui6I"|            return "LITERAL"
          end
          case var
          when "LITERAL", "LITERAL" then
            "LITERAL";Fi[	@õi,I"ö          when "STRING" then
            return "STRING" unless var
            case var
            when "LITERAL", "LITERAL" then
              "STRING";Fi[	@π$I"A# Transfers the archived file to the specified remote server;Fi	[	[	@‡"i6I"t      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function;Fi[	@ui8I"t      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function;Fi[	@i,I"t      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function;Fi[	@i*I"t      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function;Fi[	@H@◊"i	[	[	@*iI"≠      attr_accessor("LITERAL", "LITERAL", "LITERAL")
      
      def function(var, var)
        super(var, var)
        self.project_name = determine_project_name(var, var);Fi[	I"3projects//homebrew_proj/formula_specialties.rb;TiI"®end
class GithubGistFormula < ScriptFileFormula
  def function(var, var)
    super(var, var)
    @stable.version(File.basename(File.dirname(url))["LITERAL", "LITERAL"]);Fi[	@i&I"ñ    #
    # Returns nothing.
    def function(var, var)
      super(var, var)
      self.data["STRING"] = "STRING" unless self.data.has_key?("STRING");Fi[	@
iDI"ñ    #
    # Returns nothing.
    def function(var, var)
      super(var, var)
      self.data["STRING"] = "STRING" unless self.data.has_key?("STRING");Fi[	@ŸI"Ivar = Node.new("LITERAL", [var.first.strip, var["LITERAL"]].flatten);Fi	[	[	@^iƒI"ã      end
      
      def function(var, var, var)
        var = Node.new("LITERAL", [var.first.strip, var["LITERAL"]].flatten)
        var;Fi[	@^i…I"ã      end
      
      def function(var, var, var)
        var = Node.new("LITERAL", [var.first.strip, var["LITERAL"]].flatten)
        var;Fi[	@^iŒI"ã      end
      
      def function(var, var, var)
        var = Node.new("LITERAL", [var.first.strip, var["LITERAL"]].flatten)
        var;Fi[	@^i”I"ã      end
      
      def function(var, var, var)
        var = Node.new("LITERAL", [var.first.strip, var["LITERAL"]].flatten)
        var;Fi[	I"2files_to_transfer_for(@package) do |var, var|;FI"Logger.message("STRING");Fi	[	[	@oi1I"÷      def function
        var = remote_path_for(@package)
        files_to_transfer_for(@package) do |var, var|
          Logger.message("STRING")
          File.open(File.join(local_path, var), "STRING") do |var|;Fi[	@¯	iSI"÷      def function
        var = remote_path_for(@package)
        files_to_transfer_for(@package) do |var, var|
          Logger.message("STRING")
          File.open(File.join(local_path, var), "STRING") do |var|;Fi[	@„"iI"         var = remote_path_for(@package)
        FileUtils.mkdir_p(var)
        files_to_transfer_for(@package) do |var, var|
          Logger.message("STRING")
          var = File.join(local_path, var);Fi[	@ri9I"Í        var = remote_path_for(@package)
        var = directory_for(var, true)
        files_to_transfer_for(@package) do |var, var|
          Logger.message("STRING")
          File.open(File.join(local_path, var), "STRING") do |var|;Fi[	I"if @clone.exist? then;F@	i	[	[	@ÈiI"`      end
    end
    if @clone.exist? then
      puts("STRING")
      Dir.chdir(@clone) do;Fi[	@ÈiìI"~    raise("STRING") unless hgpath
    ohai("STRING")
    if @clone.exist? then
      puts("STRING")
      Dir.chdir(@clone) do;Fi[	@ÈiªI"ü    raise("STRING") unless bzrpath
    ohai("STRING")
    if @clone.exist? then
      puts("STRING")
      Dir.chdir(@clone) { safe_system(bzrpath, "STRING") };Fi[	@ÈiŸI"°    raise("STRING") unless fossilpath
    ohai("STRING")
    if @clone.exist? then
      puts("STRING")
      safe_system(fossilpath, "STRING", "STRING", @clone);Fi[	@¡;@4i	[	[	@‡"i<I"Ò        connection do |var|
          create_remote_path(var, var)
          files_to_transfer_for(@package) do |var, var|
            Logger.message(("STRING" + "STRING"))
            var.put(File.join(local_path, var), File.join(var, var));Fi[	@zi4I"Ó        var = remote_path_for(@package)
        connection.sync_clock
        files_to_transfer_for(@package) do |var, var|
          Logger.message(("STRING" + "STRING"))
          File.open(File.join(local_path, var), "STRING") do |var|;Fi[	@i2I"        connection do |var|
          var.exec!("STRING")
          files_to_transfer_for(@package) do |var, var|
            Logger.message(("STRING" + "STRING"))
            var.scp.upload!(File.join(local_path, var), File.join(var, var));Fi[	@i0I"ı        connection do |var|
          create_remote_path(var, var)
          files_to_transfer_for(@package) do |var, var|
            Logger.message(("STRING" + "STRING"))
            var.upload!(File.join(local_path, var), File.join(var, var));Fi[	@|@:i	[	[	@Ïi.I"o                rm_rf(var)
              end
            else
              opoo("STRING")
            end;Fi[	@Ïi1I"i              opoo("STRING")
            end
          else
            opoo("STRING")
          end;Fi[	@˚i{I"_        opoo("STRING")
        ENV.gcc
      else
        opoo("STRING")
        ENV.clang;Ti[	@iI"æ                if var and var.exist? then
                  system(MacOS.locate("STRING"), "STRING", var, var, var)
                else
                  opoo("STRING")
                end;Fi[	@ŸI"0var = Node.new("LITERAL", [var["LITERAL"]]);Fi	[	[	@^iäI"Ç      
      # reduce 20 omitted
      def function(var, var, var)
        var = Node.new("LITERAL", [var["LITERAL"]])
        var;Fi[	@^iI"w      end
      
      def function(var, var, var)
        var = Node.new("LITERAL", [var["LITERAL"]])
        var;Fi[	@^i!I"w      end
      
      def function(var, var, var)
        var = Node.new("LITERAL", [var["LITERAL"]])
        var;Fi[	@^isI"w      end
      
      def function(var, var, var)
        var = Node.new("LITERAL", [var["LITERAL"]])
        var;Fi[	@@e4i	[	[	@iI"j      
      # Returns activity about me
      #
      # @note Undocumented
      # @rate_limited Yes;Fi[	@i!I"l      
      # Returns activity by friends
      #
      # @note Undocumented
      # @rate_limited Yes;Fi[	@iMI"u      
      # Returns activity summary for a Tweet
      #
      # @note Undocumented
      # @rate_limited Yes;Fi[	@i`I"t      
      # Returns activity summary for Tweets
      #
      # @note Undocumented
      # @rate_limited Yes;Fi[	@ŸI")if (var["LITERAL"] == "STRING") then;Fi	[	[	@^iÈI"ª      # reduce 41 omitted
      # reduce 42 omitted
      def function(var, var, var)
        if (var["LITERAL"] == "STRING") then
          var = ["STRING", "STRING", "STRING", "STRING"];Fi[	@^i¯I"à      end
      
      def function(var, var, var)
        if (var["LITERAL"] == "STRING") then
          var = Node.new("LITERAL", var);Fi[	@^iI"      end
      
      def function(var, var, var)
        if (var["LITERAL"] == "STRING") then
          var.unshift("STRING");Fi[	@^iI"{      end
      
      def function(var, var, var)
        if (var["LITERAL"] == "STRING") then
          (var << "STRING");Fi[	I"rescue;F@n
i	[	[	@UiI"`        begin
          execute("STRING")
        rescue
          # do nothing
        end;Fi[	@UiI"s          (execute("STRING")
          begin_db_transaction)
        rescue
          # do nothing
        end;Fi[	@UiI"`        begin
          execute("STRING")
        rescue
          # do nothing
        end;Fi[	@UiI"`        begin
          execute("STRING")
        rescue
          # do nothing
        end;Fi[	@ŸI"%@var, @var, @var = var, var, var;Fi	[	[	@%i?I"          # Creates a new SyncContext object which handles a single directory
          # from the Syncer::Base @directories array.
          def function(var, var, var)
            @var, @var, @var = var, var, var
            @var = File.join(var, File.basename(var));Fi[	@á#iI"Æ        attr_accessor("LITERAL", "LITERAL", "LITERAL", "LITERAL")
        
        def function(var, var, var)
          @var, @var, @var = var, var, var
          @var = nil;Fi[	@çiI"•        attr_accessor("LITERAL", "LITERAL")
        
        def function(var, var, var)
          @var, @var, @var = var, var, var
          @var = @var = "LITERAL";Fi[	@èiI"•        # The object being transitioned
        # The transition being run
        def function(var, var, var)
          @var, @var, @var = var, var, var
        end;Fi[	I"onoe("STRING");F@	i	[	[	@ÈiÌI"«    var = var.split("STRING").collect { |var| Integer(var) }
    if (var["LITERAL"] == "LITERAL") and (var["LITERAL"] <= "LITERAL") then
      onoe("STRING")
      puts("STRING")
      puts("STRING");Fi[	@—iãI"|        Keg.new(f.prefix).optlink
      rescue Exception => var
        onoe("STRING")
        puts("STRING")
      end;Fi[	@—i—I"n      var.link
    rescue Exception => var
      onoe("STRING")
      puts("STRING")
      puts("STRING");Fi[	@—iÊI"Ñ      Keg.new(f.prefix).fix_install_names
    rescue Exception => var
      onoe("STRING")
      puts("STRING")
      puts("STRING");Fi[	I"desc("STRING");FI"task("LITERAL") do;Fi	[	[	I"*projects//rescue_proj/resque/tasks.rb;TiI"h    var.work((ENV["STRING"] or "LITERAL"))
  end
  desc("STRING")
  task("LITERAL") do
    var = [];Fi[	I"8projects//state_machine_proj/tasks/state_machine.rb;TiI"Onamespace("LITERAL") do
  desc("STRING")
  task("LITERAL") do
    var = {};Fi[	I";projects//whenever_proj/whenever/capistrano/recipes.rb;TiI"’  _cset("LITERAL") { "STRING" }
  namespace("LITERAL") do
    desc("STRING")
    task("LITERAL") do
      var = { "LITERAL" => (fetch("LITERAL")), "LITERAL" => (fetch("LITERAL")), "LITERAL" => (fetch("LITERAL")) };Fi[	@7<i!I"d      end
    end
    desc("STRING")
    task("LITERAL") do
      if whenever_servers.any? then;Fi[	@Æ@7i	[	[	@ci1I"£      # Creates a new instance of the MongoDB database object
      def function(var, var)
        super(var)
        @var ||= Array.new
        @var ||= Array.new;Fi[	@i*I"†      # Creates a new instance of the MySQL adapter object
      def function(var, var)
        super(var)
        @var ||= Array.new
        @var ||= Array.new;Fi[	@i+I"ö      # so it doesn't prompt and hang in the process
      def function(var, var)
        super(var)
        @var ||= Array.new
        @var ||= Array.new;Fi[	@fi'I"≤      # Creates a new instance of the Redis database object
      def function(var, var)
        super(var)
        @var ||= Array.new
        instance_eval(&var) if block_given?;Fi[	I"safe_system("STRING");F@F<i	[	[	@Êi3I"Ü    begin
      if Dir["STRING"].empty? then
        safe_system("STRING")
        safe_system("STRING")
        safe_system("STRING");Fi[	@Êi4I"ö      if Dir["STRING"].empty? then
        safe_system("STRING")
        safe_system("STRING")
        safe_system("STRING")
        safe_system("STRING");Fi[	@Êi5I"ï        safe_system("STRING")
        safe_system("STRING")
        safe_system("STRING")
        safe_system("STRING")
        safe_system("STRING");Fi[	@Êi6I"Å        safe_system("STRING")
        safe_system("STRING")
        safe_system("STRING")
        safe_system("STRING")
      end;Fi[	@HI"if (var == "LITERAL") then;Fi	[	[	@ƒi_I"∏      
      # Deletes the records according to the <tt>:dependent</tt> option.
      def function(var, var)
        if (var == "LITERAL") then
          var.each { |var| var.destroy };Fi[	@JiïI"»    # If the condition is any blank-ish object, then #where is a no-op and returns
    # the current relation.
    def function(var, var)
      if (var == "LITERAL") then
        WhereChain.new(spawn);Fi[	@JiüI"Â    # #where! is identical to #where, except that instead of returning a new relation, it adds
    # the condition to the existing relation.
    def function(var, var)
      if (var == "LITERAL") then
        WhereChain.new(self);Fi[	@i2I"‰    # Returns a list of objects in the queue.  This method is *not* available
    # on the stdlib Queue.
    def function(var, var)
      if (var == "LITERAL") then
        synchronize { decode(@redis.lindex(@redis_name, var)) };Fi[	@HI"if var.is_a?(Array) then;Fi	[	[	@ØiAI"      end
      
      def function(var, var)
        if var.is_a?(Array) then
          var.collect { |var| build(var, &var) };Fi[	@1i#I"ú      #     u.is_admin = false
      #   end
      def function(var, var)
        if var.is_a?(Array) then
          var.collect { |var| create(var, &var) };Fi[	@QiI"    #   people = { 1 => { "first_name" => "David" }, 2 => { "first_name" => "Jeremy" } }
    #   Person.update(people.keys, people.values)
    def function(var, var)
      if var.is_a?(Array) then
        var.map.with_index { |var, var| update(var, var[var]) };Ti[	@”iI"      # Creates an object just like Base.create but calls <tt>save!</tt> instead of +save+
      # so an exception is raised if the record is invalid.
      def function(var, var)
        if var.is_a?(Array) then
          var.collect { |var| create!(var, &var) };Fi[	@ŸI"exec_query(var, var, var);Fi	[	[	@iRI"∏      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(var, var, var)
        exec_query(var, var, var)
      end;Fi[	@iYI"∏      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(var, var, var)
        exec_query(var, var, var)
      end;Fi[	@XiI"u      end
      
      def function(var, var, var)
        exec_query(var, var, var)
        @connection.changes;Fi[	@Xi≠I"i      protected
      
      def function(var, var, var)
        exec_query(var, var, var)
      end;Fi[	I":#   #      #<Pet id: 2, name: "Spook", person_id: 1>,;T@ä;i	[	[	@≤iMI"‘      #   person.pets.select { |pet| pet.name =~ /oo/ }
      #   # => [
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤i§I"∫      #   person.pets.last(2)
      #   # => [
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤iÿI"·      #   person.pets.create([{name: 'Spook'}, {name: 'Choo-Choo'}])
      #   # => [
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@≤iéI"ﬁ      #   # => [
      #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@∫ I"var.run;Fi	[	[	@÷iOI"[        end
      end
      (var << "STRING")
      var.run
      if var.success? then;Fi[	@ciyI"n          (var << var)
        end
        (var << "STRING")
        var.run
        if var.success? then;Fi[	@iAI"e          end
        end
        (var << "STRING")
        var.run
        if var.success? then;Fi[	@iAI"e          end
        end
        (var << "STRING")
        var.run
        if var.success? then;Fi[	@π$I"4# Establishes a connection to the remote server;Fi	[	[	@‡"i&I"`      private
      
      ##
      # Establishes a connection to the remote server
      #;Fi[	@ui0I"g      end
      
      ##
      # Establishes a connection to the remote server
      def function;Fi[	@i"I"      private
      
      ##
      # Establishes a connection to the remote server
      # and yields the Net::SSH connection.;Fi[	@i"I"k      private
      
      ##
      # Establishes a connection to the remote server
      def function;Fi[	@Ω8@£i	[	[	@iSI"û      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      def function(var)
        threaded_tweets_from_response("LITERAL", "STRING", var);Fi[	@igI"û      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      def function(var)
        threaded_tweets_from_response("LITERAL", "STRING", var);Fi[	@içI"ç      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      def function(var)
        var = Twitter::API::Arguments.new(var);Fi[	@i®I"ç      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      def function(var)
        var = Twitter::API::Arguments.new(var);Fi[	I"ovar = Sequel.mysql(var, "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => "STRING");FI" FileUtils.mkdir_p("STRING");Fi	[	[	@UiI"Í  module Joomla
    def self.process(var, var, var, var, var, var)
      var = Sequel.mysql(var, "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => "STRING")
      FileUtils.mkdir_p("STRING")
      var = "STRING";Fi[	@\iI"ﬂ    
    def self.process(var, var, var, var)
      var = Sequel.mysql(var, "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => "STRING")
      FileUtils.mkdir_p("STRING")
      var[QUERY].each do |var|;Fi[	@	iI"ﬂ    
    def self.process(var, var, var, var)
      var = Sequel.mysql(var, "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => "STRING")
      FileUtils.mkdir_p("STRING")
      var[QUERY].each do |var|;Fi[	@iiI"ﬂ    
    def self.process(var, var, var, var)
      var = Sequel.mysql(var, "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => "STRING")
      FileUtils.mkdir_p("STRING")
      var[QUERY].each do |var|;Fi[	@4I"when Symbol, String then;Fi	[	[	@Xi?I"      
      def function(var, var, var)
        case var
        when Symbol, String then
          var = var.reflections[var];Fi[	@XifI"Õ      def function(var, var, var)
        var ||= join_parts.last
        case var
        when Symbol, String then
          (var = var.reflections[var.to_s.intern] or raise(ConfigurationError, "STRING"));Fi[	@XiäI"}      
      def function(var, var, var, var)
        case var
        when Symbol, String then
          var = var.to_s;Fi[	@≠
iI"Ê        ActiveSupport::Deprecation.warn("STRING", caller) unless var
        var = (var and var.valid_for_authentication?(&var))
        case var
        when Symbol, String then
          ActiveSupport::Deprecation.warn("STRING");Fi[	@π$I"# Path to store backups to;Fi	[	[	@‡"iI"g      ##
      # Server IP Address and FTP port
      ##
      # Path to store backups to
      ##;Fi[	@uiI"g      ##
      # Server IP Address and SSH port
      ##
      # Path to store backups to
      ##;Fi[	@iI"g      ##
      # Server IP Address and SCP port
      ##
      # Path to store backups to
      ##;Fi[	@iI"h      ##
      # Server IP Address and SFTP port
      ##
      # Path to store backups to
      ##;Fi[	I"var[QUERY].each do |var|;F@;i	[	[	@NiI"ª      FileUtils.mkdir_p("STRING")
      File.open("STRING", "STRING") { |var| var.puts("STRING") }
      var[QUERY].each do |var|
        var = var["LITERAL"]
        var = var["LITERAL"];Fi[	@\iI"Î      var = Sequel.mysql(var, "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => "STRING")
      FileUtils.mkdir_p("STRING")
      var[QUERY].each do |var|
        var = var["LITERAL"]
        var = var["LITERAL"];Fi[	@	iI"      var = Sequel.mysql(var, "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => "STRING")
      FileUtils.mkdir_p("STRING")
      var[QUERY].each do |var|
        var = var["LITERAL"]
        var = var["LITERAL"].gsub("LITERAL", "STRING");Fi[	@iiI"Î      var = Sequel.mysql(var, "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => "STRING")
      FileUtils.mkdir_p("STRING")
      var[QUERY].each do |var|
        var = var["LITERAL"]
        var = var["LITERAL"];Fi[	@1I"module Validators;Fi	[	[	I"Wprojects//paperclip_proj/paperclip/validators/attachment_content_type_validator.rb;Ti I"omodule Paperclip
  module Validators
    class AttachmentContentTypeValidator < ActiveModel::EachValidator;Fi [	I"Sprojects//paperclip_proj/paperclip/validators/attachment_presence_validator.rb;TiI"•require("active_model/validations/presence")
module Paperclip
  module Validators
    class AttachmentPresenceValidator < ActiveModel::Validations::PresenceValidator;Fi[	@EiI"©require("active_model/validations/numericality")
module Paperclip
  module Validators
    class AttachmentSizeValidator < ActiveModel::Validations::NumericalityValidator;Fi[	@Bi
I"ørequire("paperclip/validators/attachment_presence_validator")
require("paperclip/validators/attachment_size_validator")
module Paperclip
  module Validators
    extend(ActiveSupport::Concern);Fi[	I"# [:foreign_key];FI"d#   Specify the foreign key used for the association. By default this is guessed to be the name;Fi	[	[	@ÒiI"d      #   to the Product class, but if the real class name is SpecialProduct, you'll have to
      #   specify it with this option.
      # [:foreign_key]
      #   Specify the foreign key used for the association. By default this is guessed to be the name
      #   of this class in lower-case and "_id" suffixed. So a Person class that makes a +has_many+;Fi[	@ÒiñI"œ      #   * <tt>:restrict_with_exception</tt> causes an exception to be raised if there is an associated record
      #   * <tt>:restrict_with_error</tt> causes an error to be added to the owner if there is an associated object
      # [:foreign_key]
      #   Specify the foreign key used for the association. By default this is guessed to be the name
      #   of this class in lower-case and "_id" suffixed. So a Person class that makes a +has_one+ association;Fi[	@ÒiÒI"¥      #   from the association name. So <tt>belongs_to :author</tt> will by default be linked to the Author class, but
      #   if the real class name is Person, you'll have to specify it with this option.
      # [:foreign_key]
      #   Specify the foreign key used for the association. By default this is guessed to be the name
      #   of the association with an "_id" suffix. So a class that defines a <tt>belongs_to :person</tt>;Fi[	@ÒiûI"ù      #   <b>WARNING:</b> If you're overwriting the table name of either class, the +table_name+ method
      #   MUST be declared underneath any +has_and_belongs_to_many+ declaration in order to work.
      # [:foreign_key]
      #   Specify the foreign key used for the association. By default this is guessed to be the name
      #   of this class in lower-case and "_id" suffixed. So a Person class that makes;Fi[	@H@M%i	[	[	@iI"d    end
    
    def function(var, var)
      if var then
        var = "STRING" if var.binary?;Fi[	@®iPI"n      attr_reader("LITERAL")
      
      def function(var, var)
        if var then
          @var = var;Fi[	@J
i%I"U  end
  
  def function(var, var)
    if var then
      var = File.basename(var);Fi[	@ki]I"	    # overhanging image would be cropped. Useful for square thumbnail images. The cropping
    # is weighted at the center of the Geometry.
    def function(var, var)
      if var then
        var = Geometry.new((var.width / self.width), (var.height / self.height));Fi[	@I"1#   ActiveRecord::Base.establish_connection(;Fi	[	[	@π7i
I"˜    # the <tt>:adapter</tt> key must be specified with the name of a database adapter (in lower-case)
    # example for regular databases (MySQL, Postgresql, etc):
    #
    #   ActiveRecord::Base.establish_connection(
    #     adapter:  "mysql",;Fi[	@π7iI"|    #
    # Example for SQLite database:
    #
    #   ActiveRecord::Base.establish_connection(
    #     adapter: "sqlite",;Fi[	@π7iI"•    #
    # Also accepts keys as strings (for parsing from YAML for example):
    #
    #   ActiveRecord::Base.establish_connection(
    #     "adapter" => "sqlite",;Fi[	@π7i"I"à    #
    # Or a URL:
    #
    #   ActiveRecord::Base.establish_connection(
    #     "postgres://myuser:mypass@localhost/somedatabase";Fi[	@¥<@π$i	[	[	@‡"iI"x      # Server IP Address and FTP port
      ##
      # Path to store backups to
      ##
      # use passive mode?;Fi[	@uiI"{      # Server IP Address and SSH port
      ##
      # Path to store backups to
      ##
      # Flag to use local backups;Fi[	@iI"é      # Server IP Address and SCP port
      ##
      # Path to store backups to
      ##
      # Creates a new instance of the storage object;Fi[	@iI"è      # Server IP Address and SFTP port
      ##
      # Path to store backups to
      ##
      # Creates a new instance of the storage object;Fi[	I"(@html << "STRING");F@g7i	[	[	@.iI"Q    
    def function(var, var)
      (@html << "STRING")
      self
    end;Fi[	@.i!I"Q    
    def function(var, var)
      (@html << "STRING")
      self
    end;Fi[	@.i=I"j      (@html << "STRING")
      self.instance_eval(&var)
      (@html << "STRING")
      self
    end;Fi[	@.iBI"Q    
    def function(var, var)
      (@html << "STRING")
      self
    end;Fi[	I"#   <firm>;FI"5#     # ... normal attributes as shown above ...;Fi	[	[	@hiYI"û    #   firm.to_xml procs: [ proc ]
    #
    #   <firm>
    #     # ... normal attributes as shown above ...
    #     <name-reverse>slangis73</name-reverse>;Fi[	@hi{I"◊    #   firm.to_xml methods: [ :calculated_earnings, :real_earnings ]
    #
    #   <firm>
    #     # ... normal attributes as shown above ...
    #     <calculated-earnings>100000000000000000</calculated-earnings>;Fi[	@hiáI"Ü    #   firm.to_xml procs: [ proc ]
    #
    #   <firm>
    #     # ... normal attributes as shown above ...
    #     <abc>def</abc>;Fi[	@hiïI"n    #   end
    #
    #   <firm>
    #     # ... normal attributes as shown above ...
    #     <creator>;Fi[	@:I".ActiveSupport::Deprecation.warn("STRING");Fi	[	[	@®iGI"h      end
      
      def function
        ActiveSupport::Deprecation.warn("STRING")
        scope;Fi[	@giuI"ñ      end
      
      def function
        ActiveSupport::Deprecation.warn("STRING")
        Hash[connection_pool_list.map { |var| [var.spec, var] }];Fi[	@PiÓI"d      end
      
      def function
        ActiveSupport::Deprecation.warn("STRING")
      end;Fi[	@PiÚI"d      end
      
      def function
        ActiveSupport::Deprecation.warn("STRING")
      end;Fi[	@†;@:i	[	[	@‡"i7I"ç      
      ##
      # Transfers the archived file to the specified remote server
      def function
        var = remote_path_for(@package);Fi[	@ui9I"x      
      ##
      # Transfers the archived file to the specified remote server
      def function
        begin;Fi[	@i-I"ç      
      ##
      # Transfers the archived file to the specified remote server
      def function
        var = remote_path_for(@package);Fi[	@i+I"ç      
      ##
      # Transfers the archived file to the specified remote server
      def function
        var = remote_path_for(@package);Fi[	I"#       <client>;FI"0#         <rating type="integer">1</rating>;Fi	[	[	@hi@I"®    #     <name>37signals</name>
    #     <clients type="array">
    #       <client>
    #         <rating type="integer">1</rating>
    #         <name>Summit</name>;Fi[	@hiDI"°    #         <name>Summit</name>
    #       </client>
    #       <client>
    #         <rating type="integer">1</rating>
    #         <name>Microsoft</name>;Fi[	@higI"®    #     <name>37signals</name>
    #     <clients type="array">
    #       <client>
    #         <rating type="integer">1</rating>
    #         <name>Summit</name>;Fi[	@hinI"ò    #         </address>
    #       </client>
    #       <client>
    #         <rating type="integer">1</rating>
    #         <name>Microsoft</name>;Fi[	@I"#   user = User.find(1);Fi	[	[	@`iI"¨      # after the object's type. The default value for <tt>include_root_in_json</tt>
      # option is +false+.
      #
      #   user = User.find(1)
      #   user.as_json;Fi[	@`i(I"±      # This behavior can also be achieved by setting the <tt>:root</tt> option
      # to +true+ as in:
      #
      #   user = User.find(1)
      #   user.as_json(root: true);Fi[	@`i0I"û      # Without any +options+, the returned Hash will include all the model's
      # attributes.
      #
      #   user = User.find(1)
      #   user.as_json;Fi[	@ci®I"£      # Without any +options+, the returned XML string will include all the
      # model's attributes.
      #
      #   user = User.find(1)
      #   user.to_xml;Fi[	@	+@<i	[	[	@Üi7I"‹      # Adds a new column to the named table.
      # See TableDefinition#column for details of the options you can use.
      def function(var, var, var, var)
        var = "STRING"
        add_column_options!(var, var);Fi[	@UiZI"y      end
      
      def function(var, var, var, var)
        var = "STRING"
        add_column_options!(var, var);Fi[	@¶i I"Z    end
    
    def function(var, var, var, var)
      var = "STRING"
      svg(var);Fi[	@iI"Ú    #   and the rest of the string.
    #   `["Foo (Bar (Baz bang) bop)", " (Bang (bop bip))"]` in the example above.
    def function(var, var, var, var)
      var = "STRING"
      var = StringScanner.new(var) unless var.is_a?(StringScanner);Fi[	@¢)I"module RSync;Fi	[	[	@ÉiI"Smodule Backup
  module Syncer
    module RSync
      class Base < Syncer::Base;Fi[	@8iI"Lmodule Backup
  module Syncer
    module RSync
      class Local < Base;Fi[	@ˇ	iI"Kmodule Backup
  module Syncer
    module RSync
      class Pull < Push;Fi[	@ÜiI"Kmodule Backup
  module Syncer
    module RSync
      class Push < Base;Fi[	I"require("twitter/tweet");F@#i	[	[	@~i	I"çrequire("twitter/error/already_favorited")
require("twitter/error/forbidden")
require("twitter/tweet")
require("twitter/user")
module Twitter;Fi[	@´iI"require("twitter/error/not_found")
require("twitter/list")
require("twitter/tweet")
require("twitter/user")
module Twitter;Fi[	@ÎiI"arequire("twitter/api/utils")
require("twitter/tweet")
require("twitter/user")
module Twitter;Fi[	@i	I"{require("twitter/api/utils")
require("twitter/cursor")
require("twitter/tweet")
require("twitter/user")
module Twitter;Fi[	I".# which in turn will invoke Syncer::Base.;F@i	[	[	@}i$I"Ô        # Configuration::Syncer::Cloud::CloudFiles
        # are set via a super() call to Cloud::Base,
        # which in turn will invoke Syncer::Base.
        #
        # Once pre-configured defaults and Cloud specific defaults are set,;Fi[	@ÄiI"Á        # Configuration::Syncer::Cloud::S3
        # are set via a super() call to Cloud::Base,
        # which in turn will invoke Syncer::Base.
        #
        # Once pre-configured defaults and Cloud specific defaults are set,;Fi[	@8iI"Í        # Configuration::Syncer::RSync::Local
        # are set via a super() call to RSync::Base,
        # which in turn will invoke Syncer::Base.
        #
        # Once pre-configured defaults and RSync specific defaults are set,;Fi[	@Üi I"È        # Configuration::Syncer::RSync::Pull
        # are set via a super() call to RSync::Base,
        # which in turn will invoke Syncer::Base.
        #
        # Once pre-configured defaults and RSync specific defaults are set,;Fi[	@@:I"#   value.;Fi	[	[	@òi0I"-      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(var, var);Fi[	@òijI"-      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(var, var);Fi[	@ki0I"(      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(var);Fi[	@qiãI"      #   determine if the validation should ot occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      #;Fi[	I""#       send(attr).length < 5;F@>i	[	[	@ iRI"u      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end;Fi[	@ iéI"u      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end;Fi[	@ i“I"u      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end;Fi[	@ iıI"u      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end;Fi[	I"%#     def attribute_short?(attr);F@{=i	[	[	@ iQI"{      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end;Fi[	@ içI"{      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end;Fi[	@ i—I"{      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end;Fi[	@ iÙI"{      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end;Fi[	I"A# the block from the user's configuration file is evaluated.;F@£i	[	[	@}i'I"ƒ        #
        # Once pre-configured defaults and Cloud specific defaults are set,
        # the block from the user's configuration file is evaluated.
        def function(var)
          super;Fi[	@ÄiI"ƒ        #
        # Once pre-configured defaults and Cloud specific defaults are set,
        # the block from the user's configuration file is evaluated.
        def function(var)
          super;Fi[	@8iI"ƒ        #
        # Once pre-configured defaults and RSync specific defaults are set,
        # the block from the user's configuration file is evaluated.
        def function(var)
          super;Fi[	@Üi#I"ƒ        #
        # Once pre-configured defaults and RSync specific defaults are set,
        # the block from the user's configuration file is evaluated.
        def function(var)
          super;Fi[	@I"K#   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">;Fi	[	[	@i›I"õ    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked";Fi[	@iI"õ    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked";Fi[	@iI"õ    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked";Fi[	@i-I"õ    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked";Fi[	I"†# @note This method requires an access token with RWD (read, write & direct message) permissions. Consult The Application Permission Model for more information.;F@(	i	[	[	@qiI"<      #
      # @see https://dev.twitter.com/docs/api/1.1/get/direct_messages
      # @note This method requires an access token with RWD (read, write & direct message) permissions. Consult The Application Permission Model for more information.
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	@qi$I"A      #
      # @see https://dev.twitter.com/docs/api/1.1/get/direct_messages/sent
      # @note This method requires an access token with RWD (read, write & direct message) permissions. Consult The Application Permission Model for more information.
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	@qi7I"A      #
      # @see https://dev.twitter.com/docs/api/1.1/get/direct_messages/show
      # @note This method requires an access token with RWD (read, write & direct message) permissions. Consult The Application Permission Model for more information.
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	@qiEI"ˇ      end
      
      # @note This method requires an access token with RWD (read, write & direct message) permissions. Consult The Application Permission Model for more information.
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	I"when nil then;F@;i	[	[	@Ki!I"Ñ            var ? (quoted_true) : (quoted_false)
          end
        when nil then
          "STRING"
        when BigDecimal then;Fi[	@Ui”I"}          when "LITERAL" then
            "STRING"
          when nil then
            "STRING"
          when "LITERAL" then;Fi[	@7iI"y        var = ARGV.first
        var = case var
        when nil then
          "STRING"
        when "LITERAL" then;Fi[	@˝irI"[      when false then
        "STRING"
      when nil then
        "STRING"
      else;Fi[	@π$@<7i	[	[	@ci I"k      ##
      # Credentials for the specified database
      ##
      # Connectivity options
      ##;Fi[	@iI"k      ##
      # Credentials for the specified database
      ##
      # Connectivity options
      ##;Fi[	@iI"k      ##
      # Credentials for the specified database
      ##
      # Connectivity options
      ##;Fi[	@fiI"k      ##
      # Credentials for the specified database
      ##
      # Connectivity options
      ##;Fi[	@:I"
yield;Fi	[	[	@PiØI"¡      # REFERENTIAL INTEGRITY ====================================
      # Override to turn off referential integrity while executing <tt>&block</tt>.
      def function
        yield
      end;Fi[	@
iZI"6    end
    
    def function
      yield
    end;Fi[	@°iSI"å    # The hook which is called inside devise.
    # So your ORM can include devise compatibility stuff.
    def function
      yield
    end;Fi[	@ iI"@      end
      
      def function
        yield
      end;Fi[	@;I"end.compact.join("STRING");Fi	[	[	@ciäI"ë        ["STRING", "STRING"].map do |var|
          next if send(var).to_s.empty?
          "STRING"
        end.compact.join("STRING")
      end;Fi[	@ciîI"ë        ["STRING", "STRING"].map do |var|
          next if send(var).to_s.empty?
          "STRING"
        end.compact.join("STRING")
      end;Fi[	@ihI"õ        ["STRING", "STRING", "STRING"].map do |var|
          next if send(var).to_s.empty?
          "STRING"
        end.compact.join("STRING")
      end;Fi[	@fihI"õ        ["STRING", "STRING", "STRING"].map do |var|
          next if send(var).to_s.empty?
          "STRING"
        end.compact.join("STRING")
      end;Fi[	@ÆI"module ConnectionHandling;Fi	[	[	@ÅiI"≤gem("STRING", "STRING")
require("mysql2")
module ActiveRecord
  module ConnectionHandling
    # Establishes a connection to the database that's used by all Active Record objects.;Fi[	@Ã	iI"í  end
end
module ActiveRecord
  module ConnectionHandling
    # Establishes a connection to the database that's used by all Active Record objects.;Fi[	@Xi
I"ägem("STRING", "STRING")
require("sqlite3")
module ActiveRecord
  module ConnectionHandling
    # sqlite3 adapter reuses sqlite_connection.;Fi[	@π7i I"module ActiveRecord
  module ConnectionHandling
    # Establishes the connection to the database. Accepts a hash as input where;Fi [	@}<I"if var.success? then;Fi	[	[	@÷iPI"p      end
      (var << "STRING")
      var.run
      if var.success? then
        Logger.message("STRING");Fi[	@cizI"Ç        end
        (var << "STRING")
        var.run
        if var.success? then
          Logger.message(("STRING" + "STRING"));Fi[	@iBI"z        end
        (var << "STRING")
        var.run
        if var.success? then
          Logger.message("STRING");Fi[	@iBI"z        end
        (var << "STRING")
        var.run
        if var.success? then
          Logger.message("STRING");Fi[	@@Ÿi	[	[	@ÜiñI"ö      #
      # Note: only supported by PostgreSQL
      #
      def function(var, var, var)
        var, var, var, var = add_index_options(var, var, var);Fi[	@Üi⁄I"Î      # ====== Create a supplier_id, supplier_type columns and appropriate index
      #  add_reference(:products, :supplier, polymorphic: true, index: true)
      #
      def function(var, var, var)
        var = var.delete("LITERAL");Fi[	@ÜiÒI"Ω      # ====== Remove polymorphic reference
      #  remove_reference(:products, :supplier, polymorphic: true)
      #
      def function(var, var, var)
        remove_column(var, "STRING");Fi[	@i,I";      #   doc.create_element "div", "contents", :class => "container" # <div class='container'>contents</div>
      #   doc.create_element "div" { |node| node['class'] = "container" } # <div class='container'></div>
      #
      def function(var, var, var)
        var = Nokogiri::XML::Element.new(var, self, &var);Fi[	@ï;@ói	[	[	@Ui7I"}          end
          case var
          when "LITERAL", "LITERAL" then
            "LITERAL"
          when "LITERAL" then;Fi[	@ﬁi3I"µ      end
      var = case read("LITERAL", (var + "LITERAL")).unpack("STRING")["LITERAL"]
      when "LITERAL", "LITERAL" then
        "LITERAL"
      when "LITERAL", "LITERAL" then;Fi[	@ﬁi5I"í      when "LITERAL", "LITERAL" then
        "LITERAL"
      when "LITERAL", "LITERAL" then
        "LITERAL"
      when "LITERAL", "LITERAL" then;Fi[	@ﬁi7I"}      when "LITERAL", "LITERAL" then
        "LITERAL"
      when "LITERAL", "LITERAL" then
        "LITERAL"
      else;Fi[	@π$@†7i	[	[	@ciI"      ##
      # Name of the database that needs to get dumped
      ##
      # Credentials for the specified database
      ##;Fi[	@iI"∏      # Name of the database that needs to get dumped
      # To dump all databases, set this to `:all` or leave blank.
      ##
      # Credentials for the specified database
      ##;Fi[	@iI"      ##
      # Name of the database that needs to get dumped
      ##
      # Credentials for the specified database
      ##;Fi[	@fiI"ã      ##
      # Name of and path to the database that needs to get dumped
      ##
      # Credentials for the specified database
      ##;Fi[	I"class Formula;F@:i	[	[	@i#I"F  end
end
class Formula
  def function
    @head and @stable.nil?;Fi[	@ÏiTI"T  end
end
class Formula
  def function
    if (keg_only?.! or ARGV.force?) then;Fi[	@iI"8  end
end
class Formula
  def function
    var = [];Fi[	@—ieI">  end
end
class Formula
  def function
    var = "STRING";Fi[	@Ù@!6i	[	[	@XiII"∏            var = var.reflections[var]
            remove_uniq_by_reflection(var, var)
            var = []
            var.each do |var|
              if var = var.send(var.name) then;Fi[	@∏iI"v  
  def self.admin(var, var, var)
    var = []
    var.each do |var|
      var = single_admin(var, var, var.dup);Fi[	@J
iI"M  
  def function(var)
    var = []
    var.each do |var|
      case var;Fi[	@J
i<I"z  # Creates symlinks to sources in this folder.
  def function(var)
    var = []
    var.each do |var|
      case var;Fi[	@ò+I"require("keg");Fi	[	[	@Ïi I"9require("formula")
require("keg")
require("bottles");Fi [	@Ii I"5require("formula")
require("keg")
require("irb");Fi [	@’)i I"6require("formula")
require("keg")
module Homebrew;Fi [	@—iI"Krequire("exceptions")
require("formula")
require("keg")
require("tab");Fi[	@◊"@´7i	[	[	@‡"iI"£      # Creates a new instance of the storage object
      def function(var, var, var)
        super(var, var)
        @var ||= "LITERAL"
        @var ||= "STRING";Fi[	@uiI"£      # Creates a new instance of the storage object
      def function(var, var, var)
        super(var, var)
        @var ||= "LITERAL"
        @var ||= "STRING";Fi[	@iI"£      # Creates a new instance of the storage object
      def function(var, var, var)
        super(var, var)
        @var ||= "LITERAL"
        @var ||= "STRING";Fi[	@iI"£      # Creates a new instance of the storage object
      def function(var, var, var)
        super(var, var)
        @var ||= "LITERAL"
        @var ||= "STRING";Fi[	I"ohai("STRING");F@Õ;i	[	[	@ÈiI"Å  def function
    raise("STRING") unless which("STRING")
    ohai("STRING")
    if @clone.exist? then
      Dir.chdir(@clone) do;Fi[	@ÈiíI"w  def function
    raise("STRING") unless hgpath
    ohai("STRING")
    if @clone.exist? then
      puts("STRING");Fi[	@Èi∫I"x  def function
    raise("STRING") unless bzrpath
    ohai("STRING")
    if @clone.exist? then
      puts("STRING");Fi[	@ÈiÿI"{  def function
    raise("STRING") unless fossilpath
    ohai("STRING")
    if @clone.exist? then
      puts("STRING");Fi[	I"$var = CompilerSelector.new(var);F@»9i	[	[	@Êi!I"¶  def function
    var = TestAllCompilerFailures.new
    var = CompilerSelector.new(var)
    assert(var.fails_with?("LITERAL"))
    assert(var.fails_with?("LITERAL"));Fi[	@Êi:I"™  def function
    var = TestMixedCompilerFailures.new
    var = CompilerSelector.new(var)
    assert(var.fails_with?("LITERAL"))
    assert(var.fails_with?("LITERAL").!);Fi[	@ÊiNI"∞  def function
    var = TestEvenMoreMixedCompilerFailures.new
    var = CompilerSelector.new(var)
    assert(var.fails_with?("LITERAL"))
    assert(var.fails_with?("LITERAL"));Fi[	@ÊibI"µ  def function
    var = TestBlockWithoutBuildCompilerFailure.new
    var = CompilerSelector.new(var)
    assert(var.fails_with?("LITERAL"))
    assert(var.fails_with?("LITERAL").!);Fi[	@@—$i	[	[	@ıiI"¨        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do;Fi[	@ıiWI"¨        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do;Fi[	@ıi{I"¨        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do;Fi[	@iåI"ú    #     include DataMapper::Resource
    #     property :id, Serial
    #     
    #     state_machine :initial => :parked do
    #       event :ignite do;Fi[	I"!require("twitter/creatable");F@i	[	[	@o'iI"Xrequire("twitter/base")
require("twitter/creatable")
module Twitter
  module Action;Fi[	@t'iI"Xrequire("twitter/base")
require("twitter/creatable")
module Twitter
  module Action;Fi[	@y'iI"Xrequire("twitter/base")
require("twitter/creatable")
module Twitter
  module Action;Fi[	@Å'iI"Xrequire("twitter/base")
require("twitter/creatable")
module Twitter
  module Action;Fi[	I"2@model.compressor.compress_with do |var, var|;F@6i	[	[	@÷iJI"®      (var << ("STRING" + "STRING"))
      if @model.compressor then
        @model.compressor.compress_with do |var, var|
          (var << var)
          (var << var);Fi[	@ciuI"´        Logger.message(("STRING" + "STRING"))
        (var << "STRING")
        @model.compressor.compress_with do |var, var|
          (var << var)
          (var << var);Fi[	@i<I"¶        (var << mysqldump)
        if @model.compressor then
          @model.compressor.compress_with do |var, var|
            (var << var)
            (var << var);Fi[	@i<I"£        (var << pgdump)
        if @model.compressor then
          @model.compressor.compress_with do |var, var|
            (var << var)
            (var << var);Fi[	@π$I"1# Tells Backup::Compressor::Lzma to compress;Fi	[	[	@3*iI"ô      attr_accessor("LITERAL")
      
      ##
      # Tells Backup::Compressor::Lzma to compress
      # better (-9) rather than faster when set to true;Fi[	@3*iI"ﬁ      # Tells Backup::Compressor::Lzma to compress
      # better (-9) rather than faster when set to true
      ##
      # Tells Backup::Compressor::Lzma to compress
      # faster (-1) rather than better when set to true;Fi[	@6*iI"ô      attr_accessor("LITERAL")
      
      ##
      # Tells Backup::Compressor::Lzma to compress
      # better (-9) rather than faster when set to true;Fi[	@6*iI"ﬁ      # Tells Backup::Compressor::Lzma to compress
      # better (-9) rather than faster when set to true
      ##
      # Tells Backup::Compressor::Lzma to compress
      # faster (-1) rather than better when set to true;Fi[	@#-@îi	[	[	@„i
I"t    "STRING".undent
  when "STRING", "STRING" then
    "STRING".undent
  when "STRING" then
    "STRING".undent;Fi[	@„iI"t    "STRING".undent
  when "STRING", "STRING" then
    "STRING".undent
  when "STRING" then
    "STRING".undent;Fi[	@„iI"~    "STRING".undent
  when "STRING", "STRING", "STRING" then
    "STRING".undent
  when "STRING" then
    "STRING".undent;Fi[	@„iI"j    "STRING".undent
  when "STRING" then
    "STRING".undent
  when "STRING" then
    "STRING".undent;Fi[	@@Ü=i	[	[	@ iPI"s      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5;Fi[	@ iåI"s      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5;Fi[	@ i–I"s      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5;Fi[	@ iÛI"s      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5;Fi[	@Ì2@îi	[	[	@
i9I"ù                when "STRING" then
                  var = false
                  var = true
                when "STRING" then
                  var = true;Fi[	@
iBI"Æ                case var
                when "STRING" then
                  var = true
                when "STRING" then
                  add_item_to_array(var, var, var);Fi[	@
iHI"õ                  var = false
                when "STRING" then
                  var = true
                when "STRING" then
                  var = [];Fi[	@3
iJI"q      case var
      when "STRING" then
        var = true
      when "STRING" then
        var = var = true;Fi[	@:@¬;i	[	[	@Ÿi.I"±      # Logs a message to the console and log file to inform
      # the client that Backup is dumping the database
      def function
        Logger.message("STRING")
      end;Fi[	I"3projects//backup_proj/backup/encryptor/base.rb;TiI"≥      # Logs a message to the console and log file to inform
      # the client that Backup is encrypting the archive
      def function
        Logger.message("STRING")
      end;Fi[	@‹iMI"∏      # Logs a message to the console and log file to inform
      # the client that Backup is notifying about the process
      def function
        Logger.message("STRING")
      end;Fi[	@%inI"±          ##
          # Returns a String of file paths and their md5 hashes.
          def function
            Logger.message("STRING")
            `find '#{@directory}STRING`;Fi[	I"if @model.compressor then;F@f>i	[	[	@÷iII"™      var = Pipeline.new
      (var << ("STRING" + "STRING"))
      if @model.compressor then
        @model.compressor.compress_with do |var, var|
          (var << var);Fi[	@i;I"§        var = "STRING"
        (var << mysqldump)
        if @model.compressor then
          @model.compressor.compress_with do |var, var|
            (var << var);Fi[	@i;I"°        var = "STRING"
        (var << pgdump)
        if @model.compressor then
          @model.compressor.compress_with do |var, var|
            (var << var);Fi[	@ii*I"≥        var = File.join(@dump_path, name)
        run("STRING")
        if @model.compressor then
          @model.compressor.compress_with do |var, var|
            run("STRING");Fi[	@,@[>i	[	[	@o'i I"Hrequire("twitter/base")
require("twitter/creatable")
module Twitter;Fi [	@t'i I"Hrequire("twitter/base")
require("twitter/creatable")
module Twitter;Fi [	@y'i I"Hrequire("twitter/base")
require("twitter/creatable")
module Twitter;Fi [	@Å'i I"Hrequire("twitter/base")
require("twitter/creatable")
module Twitter;Fi [	I"!# Output is always HTML safe;F@Hi	[	[	@;iI"ù      end
      
      # Output is always HTML safe
      def function(var, var)
        Haml::Util.html_safe(find_and_preserve_without_haml_xss(*var, &var));Fi[	@;iI"î      end
      
      # Output is always HTML safe
      def function(var, var)
        Haml::Util.html_safe(preserve_without_haml_xss(*var, &var));Fi[	@;i!I"ì      end
      
      # Output is always HTML safe
      def function(var, var)
        Haml::Util.html_safe(list_of_without_haml_xss(*var, &var));Fi[	@;i5I"ò      end
      
      # Output is always HTML safe
      def function(var, var)
        Haml::Util.html_safe(capture_haml_without_haml_xss(*var, &var));Fi[	I"# @see Base#render;F@£i	[	[	@iéI"\      include(Base)
      
      # @see Base#render
      def function(var)
        var;Fi[	@i∑I"a      include(Base)
      
      # @see Base#render
      def function(var)
        "STRING";Fi[	@i¿I"w      include(Base)
      
      # @see Base#render
      def function(var)
        Haml::Helpers.html_escape(var);Fi[	@i◊I"t      include(Base)
      
      # @see Base#render
      def function(var)
        Haml::Helpers.preserve(var);Fi[	I"var.first;F@|i	[	[	@—i|I"        if defined? ActiveRecord::Relation and var.any? { |var| var.kind_of?(ActiveRecord::Relation) } then
          if (var.size == "LITERAL") then
            var.first
          else
            var = @rules.detect { |var| var.conditions.kind_of?(ActiveRecord::Relation) };Fi[	@É$iI"†      var = @commands.keys.select { |var| var.to_s.=~(var) }
      if (var.size == "LITERAL") then
        var.first
      else
        if var =~ "LITERAL" then;Fi[	@8
izI"í      else
        if ((var = var.rack.children).size == "LITERAL") and var.first.directory? then
          var.first
        else
          raise;Fi[	@^i^I"ß      def function(var, var, var)
        var = if var["LITERAL"].nil? then
          var.first
        else
          Node.new("LITERAL", [var.first, var["LITERAL"]]);Fi[	I"var = coerce(var);FI"$if var.is_a?(XML::NodeSet) then;Fi	[	[	@i≈I"≠      def function(var)
        raise("STRING") if root
        var = coerce(var)
        if var.is_a?(XML::NodeSet) then
          raise("STRING") if (var.size > "LITERAL");Fi[	@ÿiˆI"∞      # Also see related method +<<+.
      def function(var)
        var = coerce(var)
        if var.is_a?(XML::NodeSet) then
          var.each { |var| add_child_node(var) };Fi[	@ÿiiI"¶          return var.replace(var)
        end
        var = coerce(var)
        if var.is_a?(XML::NodeSet) then
          var.each { |var| add_previous_sibling(var) };Fi[	@ÿi3I"”        var = (var == "LITERAL") ? ("LITERAL") : ("LITERAL")
        var = (var == "LITERAL") ? ("LITERAL") : ("LITERAL")
        var = coerce(var)
        if var.is_a?(XML::NodeSet) then
          if text? then;Fi[	@Ä#I"module AppIntegration;Fi	[	[	I"<projects//compass_proj/compass/app_integration/rails.rb;Ti I"<module Compass
  module AppIntegration
    module Rails;Fi [	@âi I"Amodule Compass
  module AppIntegration
    module StandAlone;Fi [	I"Bprojects//compass_proj/compass/app_integration/stand_alone.rb;TiI"}  require("compass/app_integration/stand_alone/#{lib}")
end
module Compass
  module AppIntegration
    module StandAlone;Fi[	I"6projects//compass_proj/compass/app_integration.rb;TiI"mrequire("compass/app_integration/stand_alone")
module Compass
  module AppIntegration
    module Helpers;Fi[	I"0assert_equal("LITERAL", var.patches.length);F@7i	[	[	@¸'iI"®  def function
    var = Patches.new("STRING")
    assert_equal("LITERAL", var.patches.length)
    var = var.patches["LITERAL"]
    assert_equal("LITERAL", var.patch_p);Fi[	@¸'iI"¥  def function
    var = Patches.new(["STRING", "STRING"])
    assert_equal("LITERAL", var.patches.length)
    var = var.patches["LITERAL"]
    assert_equal("LITERAL", var.patch_p);Fi[	@¸'i#I"µ  def function
    var = Patches.new("LITERAL" => "STRING")
    assert_equal("LITERAL", var.patches.length)
    var = var.patches["LITERAL"]
    assert_equal("LITERAL", var.patch_p);Fi[	@¸'i*I"µ  def function
    var = Patches.new("LITERAL" => "STRING")
    assert_equal("LITERAL", var.patches.length)
    var = var.patches["LITERAL"]
    assert_equal("LITERAL", var.patch_p);Fi[	@ÆI"module Tasks;Fi	[	[	@mi I"Wmodule ActiveRecord
  module Tasks
    class DatabaseAlreadyExists < StandardError;Fi [	@`i I"Dmodule ActiveRecord
  module Tasks
    class MySQLDatabaseTasks;Fi [	@ŒiI"_require("shellwords")
module ActiveRecord
  module Tasks
    class PostgreSQLDatabaseTasks;Fi[	I"Mprojects//activerecord_proj/active_record/tasks/sqlite_database_tasks.rb;Ti I"Emodule ActiveRecord
  module Tasks
    class SQLiteDatabaseTasks;Fi [	@ÆI"module Generators;Fi	[	[	@ö
iI"zrequire("rails/generators/active_record")
module ActiveRecord
  module Generators
    class MigrationGenerator < Base;Fi[	I"Xprojects//activerecord_proj/rails/generators/active_record/model/model_generator.rb;TiI"vrequire("rails/generators/active_record")
module ActiveRecord
  module Generators
    class ModelGenerator < Base;Fi[	I"Bprojects//activerecord_proj/rails/generators/active_record.rb;Ti	I"órequire("rails/generators/active_model")
require("active_record")
module ActiveRecord
  module Generators
    class Base < Rails::Generators::NamedBase;Fi[	@§iI"µrequire("rails/generators/active_record")
require("generators/devise/orm_helpers")
module ActiveRecord
  module Generators
    class DeviseGenerator < ActiveRecord::Generators::Base;Fi[	@ú=I".#   vehicle.state           # => "parked";Fi	[	[	@iﬁI"î    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # ;Fi[	@iI"î    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # ;Fi[	@iI"î    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # ;Fi[	@i.I"î    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # ;Fi[	@I":# This method is considered part of the `stable` API.;Fi	[	[	@`i&I"∂  # Returns true if the job was queued, nil if the job was rejected by a
  # before_enqueue hook.
  #
  # This method is considered part of the `stable` API.
  def function(var, var);Fi[	@`i3I"ª  # Returns true if the job was queued, nil if the job was rejected by a
  # before_enqueue hook.
  #
  # This method is considered part of the `stable` API.
  def function(var, var, var);Fi[	@`iWI"Â  #   # Removes all jobs of class `UpdateNetworkGraph` with matching args.
  #   Resque.dequeue(GitHub::Jobs::UpdateNetworkGraph, 'repo:135325')
  #
  # This method is considered part of the `stable` API.
  def function(var, var);Fi[	@`ijI"¡  # depending on whether a job can be obtained. You should pass it the
  # precise name of a queue: case matters.
  #
  # This method is considered part of the `stable` API.
  def function(var);Fi[	@?@i	[	[	@iﬂI"’    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # In the above example, no +initialize+ method is defined.  As a result,;Fi[	@iI"—    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # Because of the way the inclusion of modules works in Ruby, calling;Fi[	@iI"ÿ    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # You may also need to call the +initialize_state_machines+ helper manually;Fi[	@i/I"ÿ    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # The above example is also noteworthy because it demonstrates how to avoid;Fi[	@ØI"class JoinDependency;Fi	[	[	@SiI"nmodule ActiveRecord
  module Associations
    class JoinDependency
      class JoinAssociation < JoinPart;Fi[	@>iI"gmodule ActiveRecord
  module Associations
    class JoinDependency
      class JoinBase < JoinPart;Fi[	@AiI"\module ActiveRecord
  module Associations
    class JoinDependency
      class JoinPart;Fi[	@XiI"kmodule ActiveRecord
  module Associations
    class JoinDependency
      autoload("LITERAL", "STRING");Fi[	I"*require("twitter/error/server_error");F@i	[	[	@i I"Grequire("twitter/error/server_error")
module Twitter
  class Error;Fi [	@i I"Grequire("twitter/error/server_error")
module Twitter
  class Error;Fi [	@"i I"Grequire("twitter/error/server_error")
module Twitter
  class Error;Fi [	@.i I"Grequire("twitter/error/server_error")
module Twitter
  class Error;Fi [	@π$I";# Logs a message to the console and log file to inform;Fi	[	[	@”1iI"ç      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is using the compressor;Fi[	@Ÿi+I"ç      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is dumping the database;Fi[	@û>iI"è      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is encrypting the archive;Fi[	@‹iJI"î      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is notifying about the process;Fi[	I"'api_accessible("LITERAL") do |var|;F@Ω!i	[	[	@¿!iI"h  acts_as_api
  
  api_accessible("LITERAL") do |var|
    var.add("LITERAL")
    var.add("LITERAL");Fi[	@«!iI"h  acts_as_api
  
  api_accessible("LITERAL") do |var|
    var.add("LITERAL")
    var.add("LITERAL");Fi[	@“iI"h  acts_as_api
  
  api_accessible("LITERAL") do |var|
    var.add("LITERAL")
    var.add("LITERAL");Fi[	@∫iI"h  acts_as_api
  
  api_accessible("LITERAL") do |var|
    var.add("LITERAL")
    var.add("LITERAL");Fi[	@«=@|i	[	[	@i∆I"Ó          if var["LITERAL"].! and current_transaction.joinable? then
            raise(ActiveRecord::TransactionIsolationError, "STRING") if var["LITERAL"]
            yield
          else
            within_new_transaction(var) { yield };Fi[	@0iïI"ô      def function
        if (confirmed?.! or pending_reconfirmation?) then
          yield
        else
          self.errors.add("LITERAL", "LITERAL");Fi[	@iI"~      def function
        if access_locked? then
          yield
        else
          self.errors.add("LITERAL", "LITERAL");Fi[	@’i'I"Ddef function
  if ARGV.verbose? then
    yield
  else
    begin;Fi[	@:I"setup_phase;Fi	[	[	@€i§I"ë    
    # Performs the steps necessary to run the request phase of a strategy.
    def function
      setup_phase
      log("LITERAL", "STRING");Fi[	@€iΩI"í    
    # Performs the steps necessary to run the callback phase of a strategy.
    def function
      setup_phase
      log("LITERAL", "STRING");Fi[	@€iÌI"]    end
    
    def function
      setup_phase
      session["STRING"] = request.params;Fi[	@€i˙I"b    end
    
    def function
      setup_phase
      var = OmniAuth.mock_auth_for(name.to_s);Fi[	I"Ivar.on("STRING", "STRING") { |var| set_dir_or_path("LITERAL", var) };F@z?i	[	[	@@iI"y    var.on("STRING", "STRING", "STRING") { |var| self.options["LITERAL"] = var }
    var.on("STRING", "STRING") { |var| self.options["LITERAL"] = var.to_sym }
    var.on("STRING", "STRING") { |var| set_dir_or_path("LITERAL", var) }
    var.on("STRING", "STRING") { |var| set_dir_or_path("LITERAL", var) }
    var.on("STRING", "STRING") { |var| set_dir_or_path("LITERAL", var) };Fi[	@@iI"q    var.on("STRING", "STRING") { |var| self.options["LITERAL"] = var.to_sym }
    var.on("STRING", "STRING") { |var| set_dir_or_path("LITERAL", var) }
    var.on("STRING", "STRING") { |var| set_dir_or_path("LITERAL", var) }
    var.on("STRING", "STRING") { |var| set_dir_or_path("LITERAL", var) }
    var.on("STRING", "STRING") { |var| set_dir_or_path("LITERAL", var) };Fi[	@@iI"l    var.on("STRING", "STRING") { |var| set_dir_or_path("LITERAL", var) }
    var.on("STRING", "STRING") { |var| set_dir_or_path("LITERAL", var) }
    var.on("STRING", "STRING") { |var| set_dir_or_path("LITERAL", var) }
    var.on("STRING", "STRING") { |var| set_dir_or_path("LITERAL", var) }
    var.on("STRING", "STRING") { |var| set_dir_or_path("LITERAL", var) };Fi[	@@iI"w    var.on("STRING", "STRING") { |var| set_dir_or_path("LITERAL", var) }
    var.on("STRING", "STRING") { |var| set_dir_or_path("LITERAL", var) }
    var.on("STRING", "STRING") { |var| set_dir_or_path("LITERAL", var) }
    var.on("STRING", "STRING") { |var| set_dir_or_path("LITERAL", var) }
    var.on("STRING", "STRING", ["LITERAL", "LITERAL"], "STRING", "STRING") do |var|;Fi[	I"var.separator("STRING");F@Ö?i	[	[	@
i:I"∞    def function(var)
      var.banner = "STRING"
      var.separator("STRING")
      var.separator("STRING")
      var.on("STRING", "STRING", "LITERAL", "STRING", "STRING") do;Fi[	@
iUI"ƒ        self.options["LITERAL"] = "LITERAL"
      end
      var.separator("STRING")
      var.separator("STRING")
      var.on("STRING", "STRING", "STRING") { |var| self.options["LITERAL"] = var };Fi[	@
i`I"Û      var.on("STRING", "STRING") { self.options["LITERAL"] = "LITERAL" }
      var.on("STRING", "STRING") { |var| self.options["LITERAL"] = var.to_sym }
      var.separator("STRING")
      var.separator("STRING")
      set_project_options(var);Fi[	@
icI"ñ      var.separator("STRING")
      set_project_options(var)
      var.separator("STRING")
      var.separator("STRING")
      set_global_options(var);Fi[	I"C# +binds+ as the bind substitutes. +name+ is logged along with;FI"$# the executed +sql+ statement.;Fi	[	[	@iBI"‹      
      # Executes +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(var, var, var);Fi[	@iII"Ì      
      # Executes insert +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(var, var, var, var, var);Fi[	@iPI"„      
      # Executes delete +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(var, var, var);Fi[	@iWI"„      
      # Executes update +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(var, var, var);Fi[	@öI"module SAX;Fi	[	[	@'iI"Emodule Nokogiri
  module XML
    module SAX
      class Document;Fi[	@˝iI"Cmodule Nokogiri
  module XML
    module SAX
      class Parser;Fi[	@◊iI"Jmodule Nokogiri
  module XML
    module SAX
      class ParserContext;Fi[	@ iI"Gmodule Nokogiri
  module XML
    module SAX
      class PushParser;Fi[	I"super();F@Hi	[	[	@giñI"§      # The default ConnectionPool maximum size is 5.
      def function(var)
        super()
        @var = var
        @var = (var.config["LITERAL"] or "LITERAL");Fi[	@PiEI"e      
      def function(var, var, var)
        super()
        @var = var
        @var = false;Fi[	@^%iI"ñ    # Create a new MultiQueue using the +queues+ from the +redis+ connection
    def function(var, var)
      super()
      @var = var
      @var = {};Fi[	@iI"¢    # the +coder+ for encoding and decoding objects that are stored in redis.
    def function(var, var, var)
      super()
      @var = var
      @var = "STRING";Fi[	I":namespace.attributes["LITERAL"][var]["LITERAL"] = var;FI")var.docstring = ["STRING", "STRING"];Fi	[	[	@›iÑI"U            namespace.attributes["LITERAL"][var] = {}
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, var)))
            namespace.attributes["LITERAL"][var]["LITERAL"] = var
            var.docstring = ["STRING", "STRING"]
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")));Fi[	@›iáI"$            var.docstring = ["STRING", "STRING"]
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")))
            namespace.attributes["LITERAL"][var]["LITERAL"] = var
            var.docstring = ["STRING", "STRING"]
            var.parameters = ["STRING"];Fi[	@›ièI"U            namespace.attributes["LITERAL"][var] = {}
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, var)))
            namespace.attributes["LITERAL"][var]["LITERAL"] = var
            var.docstring = ["STRING", "STRING"]
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")));Fi[	@›iíI"$            var.docstring = ["STRING", "STRING"]
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")))
            namespace.attributes["LITERAL"][var]["LITERAL"] = var
            var.docstring = ["STRING", "STRING"]
            var.parameters = ["STRING"];Fi[	@“2@|i	[	[	@Ωi0I"≠    if self.target.nil? then
      Rails.logger.info("STRING")
      return
    else
      if (self.parent.author == var.person) and self.target_author_signature_valid? then;Fi[	@ÓiVI"Ü    if self.target.nil? then
      Rails.logger.info("STRING")
      return
    else
      if self.target_author_signature_valid? then;Fi[	@›
i√I"Å      if var.dry_run and var.overwrite then
        puts(var) if var.exist?
        return
      else
        if var.dry_run then;Fi[	@›
i«I"Ç        if var.dry_run then
          puts(var)
          return
        else
          var.delete if var.overwrite and var.exist?;Fi[	@Ï;@öi	[	[	@^iãI"Ö      # reduce 20 omitted
      def function(var, var, var)
        var = Node.new("LITERAL", [var["LITERAL"]])
        var
      end;Fi[	@^iI"w      
      def function(var, var, var)
        var = Node.new("LITERAL", [var["LITERAL"]])
        var
      end;Fi[	@^i"I"w      
      def function(var, var, var)
        var = Node.new("LITERAL", [var["LITERAL"]])
        var
      end;Fi[	@^itI"w      
      def function(var, var, var)
        var = Node.new("LITERAL", [var["LITERAL"]])
        var
      end;Fi[	@I"7["STRING", "STRING", "STRING", "STRING", "STRING"];Fi	[	[	@ iI"ä  def function
    case @language
    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then;Fi[	@ iI"π    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then;Fi[	@ i$I"Ø    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then;Fi[	@ i&I"™    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING", "STRING"]
    else;Fi[	@:I"shutup do;Fi	[	[	@i I"W  end
  
  def function
    shutup do
      DefaultPatchBall.new("STRING").brew do;Fi[	@i*I"T  end
  
  def function
    shutup do
      ListPatchBall.new("STRING").brew do;Fi[	@i4I"R  end
  
  def function
    shutup do
      P0PatchBall.new("STRING").brew do;Fi[	@i>I"R  end
  
  def function
    shutup do
      P1PatchBall.new("STRING").brew do;Fi[	@I"0# See Node#write_to for a list of +options+;Fi	[	[	@ÿi∆I"í      #
      #   doc.to_xml(:indent => 5, :encoding => 'UTF-8')
      #
      # See Node#write_to for a list of +options+
      def function(var);Fi[	@ÿi—I"î      #
      #   doc.to_xhtml(:indent => 5, :encoding => 'UTF-8')
      #
      # See Node#write_to for a list of +options+
      def function(var);Fi[	@ÿi˙I"í      ###
      # Write Node as HTML to +io+ with +options+
      #
      # See Node#write_to for a list of +options+
      def function(var, var);Fi[	@ÿiI"ì      ###
      # Write Node as XHTML to +io+ with +options+
      #
      # See Node#write_to for a list of +options+
      def function(var, var);Fi[	@≤8I"3var.declare("LITERAL", ["LITERAL", "LITERAL"]);Fi	[	[	@f6iI"∞    def self.included(var)
      if var.respond_to?("LITERAL") then
        var.declare("LITERAL", ["LITERAL"])
        var.declare("LITERAL", ["LITERAL", "LITERAL"])
      end;Fi[	@f6i/I"∞    def self.included(var)
      if var.respond_to?("LITERAL") then
        var.declare("LITERAL", ["LITERAL"])
        var.declare("LITERAL", ["LITERAL", "LITERAL"])
      end;Fi[	@f6iHI"Ë    def self.included(var)
      if var.respond_to?("LITERAL") then
        var.declare("LITERAL", ["LITERAL"])
        var.declare("LITERAL", ["LITERAL", "LITERAL"])
        var.declare("LITERAL", ["LITERAL", "LITERAL", "LITERAL"]);Fi[	@f6i{I"∞    def self.included(var)
      if var.respond_to?("LITERAL") then
        var.declare("LITERAL", ["LITERAL"])
        var.declare("LITERAL", ["LITERAL", "LITERAL"])
      end;Fi[	@@”:i	[	[	@ iI"Ø    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then;Fi[	@ iI"•    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then;Fi[	@ i I"√    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then;Fi[	@ i"I"•    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then;Fi[	@5.@;!i	[	[	@ìiI"a        
        def function(var)
          if var.nil? then
            nil
          else;Fi[	@ìiSI"a        
        def function(var)
          if var.nil? then
            nil
          else;Fi[	@ìimI"a        
        def function(var)
          if var.nil? then
            nil
          else;Fi[	@ƒiI"a      
      def function(var, var, var)
        if var.nil? then
          nil
        else;Fi[	@∂;@öi	[	[	@^i≈I"ã      
      def function(var, var, var)
        var = Node.new("LITERAL", [var.first.strip, var["LITERAL"]].flatten)
        var
      end;Fi[	@^i I"ã      
      def function(var, var, var)
        var = Node.new("LITERAL", [var.first.strip, var["LITERAL"]].flatten)
        var
      end;Fi[	@^iœI"ã      
      def function(var, var, var)
        var = Node.new("LITERAL", [var.first.strip, var["LITERAL"]].flatten)
        var
      end;Fi[	@^i‘I"ã      
      def function(var, var, var)
        var = Node.new("LITERAL", [var.first.strip, var["LITERAL"]].flatten)
        var
      end;Fi[	I"if Nokogiri.jruby? then;FI"5var = var.first.is_a?(Hash) ? (var.shift) : ({});Fi	[	[	@˙iYI"Í      # Convert this Builder object to XML
      def function(var)
        if Nokogiri.jruby? then
          var = var.first.is_a?(Hash) ? (var.shift) : ({})
          var["LITERAL"] = Node::SaveOptions::AS_BUILDER if var["LITERAL"].!;Fi[	@i(I"¿      # See Nokogiri::XML::NodeSet#to_html
      def function(var)
        if Nokogiri.jruby? then
          var = var.first.is_a?(Hash) ? (var.shift) : ({})
          if var["LITERAL"].! then;Fi[	@i6I"¡      # See Nokogiri::XML::NodeSet#to_xhtml
      def function(var)
        if Nokogiri.jruby? then
          var = var.first.is_a?(Hash) ? (var.shift) : ({})
          if var["LITERAL"].! then;Fi[	@(iıI"∫      # Convert this NodeSet to HTML
      def function(var)
        if Nokogiri.jruby? then
          var = var.first.is_a?(Hash) ? (var.shift) : ({})
          if var["LITERAL"].! then;Fi[	@:@;i	[	[	@·i`I"q  end
  
  def function
    @var ||= if locate("STRING") then
      `#{locate("STRING")}STRING` =~ "LITERAL";Fi[	@·inI"q  end
  
  def function
    @var ||= if locate("STRING") then
      `#{locate("STRING")}STRING` =~ "LITERAL";Fi[	@·iuI"q  end
  
  def function
    @var ||= if locate("STRING") then
      `#{locate("STRING")}STRING` =~ "LITERAL";Fi[	@·i|I"q  end
  
  def function
    @var ||= if locate("STRING") then
      `#{locate("STRING")}STRING` =~ "LITERAL";Fi[	@¸0@(i	[	[	@giI"t          @var = var
          @var = @lock.new_cond
          @var = "LITERAL"
          @var = []
        end;Fi[	@w!i^I"k        else
          @var ||= Contact.new
          @var = "LITERAL"
          @var = []
        end;Fi[	@ÏiI"h    def function(var)
      @var = var
      @var = "LITERAL"
      @var = []
      @var = "STRING";Fi[	@3
iVI"f      @var = var
      @var = false
      @var = "LITERAL"
      @var = []
      @var = "LITERAL";Fi[	@
@?i	[	[	@Mi I"_module Devise
  module Generators
    class DeviseGenerator < Rails::Generators::NamedBase;Fi [	I"Aprojects//devise_proj/generators/devise/install_generator.rb;TiI"srequire("securerandom")
module Devise
  module Generators
    class InstallGenerator < Rails::Generators::Base;Fi[	@ßi I"<module Devise
  module Generators
    module OrmHelpers;Fi [	@™i I"Cmodule Devise
  module Generators
    module ViewPathTemplates;Fi [	@
I"module Controllers;Fi	[	[	@≥i I":module Devise
  module Controllers
    module Helpers;Fi [	@ﬂi I"?module Devise
  module Controllers
    module Rememberable;Fi [	@‚i I">module Devise
  module Controllers
    module ScopedViews;Fi [	I"<projects//devise_proj/devise/controllers/url_helpers.rb;Ti I"=module Devise
  module Controllers
    module UrlHelpers;Fi [	@£I"replace(var);Fi	[	[	@ØiI"ã      
      # Implements the writer method, e.g. foo.items= for Foo.has_many :items
      def function(var)
        replace(var)
      end;Fi[	@˜iI"â      
      # Implements the writer method, e.g. foo.bar= for Foo.belongs_to :bar
      def function(var)
        replace(var)
      end;Fi[	@˜i4I"L      end
      
      def function(var)
        replace(var)
      end;Fi[	@ÿizI"q      #
      # Also see related method +replace+.
      def function(var)
        replace(var)
        self;Fi[	I"4var["LITERAL"] = ENV["STRING"] if ENV["STRING"];F@^@i	[	[	@4<i	I"Ω  task("LITERAL") do
    var = {}
    var["LITERAL"] = ENV["STRING"] if ENV["STRING"]
    var["LITERAL"] = ENV["STRING"] if ENV["STRING"]
    var["LITERAL"] = ENV["STRING"] if ENV["STRING"];Fi[	@4<i
I"‹    var = {}
    var["LITERAL"] = ENV["STRING"] if ENV["STRING"]
    var["LITERAL"] = ENV["STRING"] if ENV["STRING"]
    var["LITERAL"] = ENV["STRING"] if ENV["STRING"]
    var["LITERAL"] = ENV["STRING"] if ENV["STRING"];Fi[	@4<iI"    var["LITERAL"] = ENV["STRING"] if ENV["STRING"]
    var["LITERAL"] = ENV["STRING"] if ENV["STRING"]
    var["LITERAL"] = ENV["STRING"] if ENV["STRING"]
    var["LITERAL"] = ENV["STRING"] if ENV["STRING"]
    var["LITERAL"] = ENV["STRING"] if ENV["STRING"];Fi[	@4<iI"    var["LITERAL"] = ENV["STRING"] if ENV["STRING"]
    var["LITERAL"] = ENV["STRING"] if ENV["STRING"]
    var["LITERAL"] = ENV["STRING"] if ENV["STRING"]
    var["LITERAL"] = ENV["STRING"] if ENV["STRING"]
    var["LITERAL"] = (ENV["STRING"] == "STRING") if ENV["STRING"];Fi[	@≥-@±8i	[	[	@f6iI"â  
  module StylesheetUrl
    def self.included(var)
      if var.respond_to?("LITERAL") then
        var.declare("LITERAL", ["LITERAL"]);Fi[	@f6i-I"É  
  module FontUrl
    def self.included(var)
      if var.respond_to?("LITERAL") then
        var.declare("LITERAL", ["LITERAL"]);Fi[	@f6iFI"Ñ  
  module ImageUrl
    def self.included(var)
      if var.respond_to?("LITERAL") then
        var.declare("LITERAL", ["LITERAL"]);Fi[	@f6iyI"ç  
  module GeneratedImageUrl
    def self.included(var)
      if var.respond_to?("LITERAL") then
        var.declare("LITERAL", ["LITERAL"]);Fi[	@8@i	[	[	@Òi˜I"       # <tt>has_many :clients</tt> would add among others <tt>clients.empty?</tt>.)
      #
      # === Example
      #
      # Example: A Firm class declares <tt>has_many :clients</tt>, which will add:;Fi[	@Òi{I"≈      # <tt>has_one :manager</tt> would add among others <tt>manager.nil?</tt>.)
      #
      # === Example
      #
      # An Account class declares <tt>has_one :beneficiary</tt>, which will add:;Fi[	@Òi·I"¿      # <tt>belongs_to :author</tt> would add among others <tt>author.nil?</tt>.)
      #
      # === Example
      #
      # A Post class declares <tt>belongs_to :author</tt>, which will add:;Fi[	@ÒiÅI"Î      # <tt>has_and_belongs_to_many :categories</tt> would add among others <tt>categories.empty?</tt>.)
      #
      # === Example
      #
      # A Developer class declares <tt>has_and_belongs_to_many :projects</tt>, which will add:;Fi[	@£@@i	[	[	@˙iXI"ß      ###
      # Convert this Builder object to XML
      def function(var)
        if Nokogiri.jruby? then
          var = var.first.is_a?(Hash) ? (var.shift) : ({});Fi[	@i'I"À      # Convert this DocumentFragment to html
      # See Nokogiri::XML::NodeSet#to_html
      def function(var)
        if Nokogiri.jruby? then
          var = var.first.is_a?(Hash) ? (var.shift) : ({});Fi[	@i5I"Õ      # Convert this DocumentFragment to xhtml
      # See Nokogiri::XML::NodeSet#to_xhtml
      def function(var)
        if Nokogiri.jruby? then
          var = var.first.is_a?(Hash) ? (var.shift) : ({});Fi[	@(iÙI"°      ###
      # Convert this NodeSet to HTML
      def function(var)
        if Nokogiri.jruby? then
          var = var.first.is_a?(Hash) ? (var.shift) : ({});Fi[	I"view_directory("LITERAL");F@á@i	[	[	@™iI"      
      def function
        view_directory("LITERAL")
        view_directory("LITERAL")
        view_directory("LITERAL");Fi[	@™iI"ö      def function
        view_directory("LITERAL")
        view_directory("LITERAL")
        view_directory("LITERAL")
        view_directory("LITERAL");Fi[	@™iI"©        view_directory("LITERAL")
        view_directory("LITERAL")
        view_directory("LITERAL")
        view_directory("LITERAL")
        view_directory("LITERAL");Fi[	@™iI"ë        view_directory("LITERAL")
        view_directory("LITERAL")
        view_directory("LITERAL")
        view_directory("LITERAL")
      end;Fi[	I"Bvar = Nokogiri::XML::ParseOptions.new(var) if Fixnum.===(var);FI"yield(var) if block_given?;Fi	[	[	@’iTI"È        # Nokogiri::XML::ParseOptions.
        def function(var, var, var, var)
          var = Nokogiri::XML::ParseOptions.new(var) if Fixnum.===(var)
          yield(var) if block_given?
          if var.respond_to?("LITERAL") then;Fi[	@iI"Œ      
      def self.parse(var, var, var, var, var)
        var = Nokogiri::XML::ParseOptions.new(var) if Fixnum.===(var)
        yield(var) if block_given?
        var = if var.respond_to?("LITERAL") then;Fi[	@ÿi‹I"      def function(var, var)
        var ||= document.html? ? (ParseOptions::DEFAULT_HTML) : (ParseOptions::DEFAULT_XML)
        var = Nokogiri::XML::ParseOptions.new(var) if Fixnum.===(var)
        yield(var) if block_given?
        var = var.respond_to?("LITERAL") ? (var.read) : (var);Fi[	@ÿi!I"¸      # passed to it, allowing more convenient modification of the parser options.
      def function(var, var)
        var = Nokogiri::XML::ParseOptions.new(var) if Fixnum.===(var)
        yield(var) if block_given?
        process_xincludes(var.to_i);Fi[	@I"# site - The Site.;Fi	[	[	@iI"ã    # This generator is safe from arbitrary code execution.
    # Generate paginated pages if necessary.
    #
    # site - The Site.
    #;Fi[	@iI"º    # directories, e.g.: page2/index.html, page3/index.html, etc and adds more
    # site-wide data.
    #
    # site - The Site.
    # page - The index.html Page that requires pagination.;Fi[	@‚iI"ì    # Gets/Sets the content of this layout.
    # Initialize a new Layout.
    #
    # site - The Site.
    # base - The String path to the source.;Fi[	@ÌiI"©    # The cache of last modification times [path] -> mtime.
    # Initialize a new StaticFile.
    #
    # site - The Site.
    # base - The String path to the <source>.;Fi[	@@=i	[	[	@hiXI"◊    #   proc = Proc.new { |options, record| options[:builder].tag!('name-reverse', record.name.reverse) }
    #   firm.to_xml procs: [ proc ]
    #
    #   <firm>
    #     # ... normal attributes as shown above ...;Fi[	@hiI"ï    #
    #   firm.to_xml methods: [ :calculated_earnings, :real_earnings ]
    #
    #   <firm>
    #     # ... normal attributes as shown above ...;Fi[	@hiÜI"∏    #   proc = Proc.new { |options| options[:builder].tag!('abc', 'def') }
    #   firm.to_xml procs: [ proc ]
    #
    #   <firm>
    #     # ... normal attributes as shown above ...;Fi[	@hiîI"h    #     end
    #   end
    #
    #   <firm>
    #     # ... normal attributes as shown above ...;Fi[	@™,@ri	[	[	@®iI"ó      # Resets the \loaded flag to +false+ and sets the \target to +nil+.
      def function
        @var = false
        @var = nil
        @var = nil;Fi[	@3
i_I"|      begin
        (@var = @var = ParseNode.new("LITERAL")
        @var = false
        @var = nil
        @var = next_line;Fi[	@3
iµI"T    
    def function(var)
      @var = false
      @var = nil
      @var = nil;Fi[	@3iUI"l      @var = var
      @var = []
      @var = false
      @var = nil
      @var = var.events.fetch(var);Fi[	I"module OmniAuth;FI"module Test;Fi[[	I"9projects//omni_proj/omniauth/test/strategy_macros.rb;Ti I"<module OmniAuth
  module Test
    module StrategyMacros;Fi [	@,iI"grequire("rack")
require("omniauth/test")
module OmniAuth
  module Test
    module StrategyTestCase;Fi[	I")projects//omni_proj/omniauth/test.rb;Ti I"Dmodule OmniAuth
  module Test
    autoload("LITERAL", "STRING");Fi [	I"O# Generate a token checking if one does not already exist in the database.;F@:i[[	@0i‘I"†        end
        
        # Generate a token checking if one does not already exist in the database.
        def function
          generate_token("LITERAL");Fi[	@i`I"†        end
        
        # Generate a token checking if one does not already exist in the database.
        def function
          generate_token("LITERAL");Fi[	@i2I"†        end
        
        # Generate a token checking if one does not already exist in the database.
        def function
          generate_token("LITERAL");Fi[	I"#         end;F@i[[	@∏iXI"ï      #         pending_notifications.each do |n|
      #           devise_mailer.send(n, self).deliver
      #         end
      #       end
      #;Fi[	@Ôi£I"z    #         haml_tag :td do
    #           haml_concat "more_data"
    #         end
    #       end
    #     end;Fi[	@ÚiAI"|        #             # Override here...
        #           end
        #         end
        #       end
        #     end;Fi[	I"respond_with do |var|;F@2i[[	@B!iI"Í      @var = var.aspect
      flash.now["LITERAL"] = I18n.t("STRING")
      respond_with do |var|
        var.json do
          render("LITERAL" => ({ "LITERAL" => (@person_id), "LITERAL" => (@contact.aspects.map { |var| var.id }) }));Fi[	@M#i=I"Ï    raise(ActiveRecord::RecordNotFound.new) unless @post
    @var = @post.comments.for_a_stream
    respond_with do |var|
      var.json do
        render("LITERAL" => (CommentPresenter.as_collection(@comments)), "LITERAL" => "LITERAL");Fi[	@G5i&I"    gon.tagFollowings = tags if user_signed_in?
    @var = Stream::Tag.new(current_user, params["LITERAL"], "LITERAL" => (max_time), "LITERAL" => (params["LITERAL"]))
    respond_with do |var|
      var.json do
        render("LITERAL" => (@stream.stream_posts.map do |var|;Fi[	@2I";render("LITERAL" => (@stream.stream_posts.map do |var|;Fi[[	@w!ieI"
    respond_to do |var|
      var.all { respond_with(@person, "LITERAL" => ({ "LITERAL" => "LITERAL" })) }
      var.json do
        render("LITERAL" => (@stream.stream_posts.map do |var|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user));Fi[	I">projects//diaspora_proj/controllers/streams_controller.rb;Ti?I"È      var.html { render("STRING") }
      var.mobile { render("STRING") }
      var.json do
        render("LITERAL" => (@stream.stream_posts.map do |var|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user));Fi[	@G5i'I"0    @var = Stream::Tag.new(current_user, params["LITERAL"], "LITERAL" => (max_time), "LITERAL" => (params["LITERAL"]))
    respond_with do |var|
      var.json do
        render("LITERAL" => (@stream.stream_posts.map do |var|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user));Fi[	@
@Ω@i[[	@µi I"Kmodule Devise
  module OmniAuth
    class StrategyNotFound < NameError;Fi [	I"9projects//devise_proj/devise/omniauth/url_helpers.rb;Ti I":module Devise
  module OmniAuth
    module UrlHelpers;Fi [	I"-projects//devise_proj/devise/omniauth.rb;TiI"l  var.action("LITERAL").call(var)
end
module Devise
  module OmniAuth
    autoload("LITERAL", "STRING");Fi[	@:I"require("version");Fi[[	@J
iòI"K  end
  
  def function
    require("version")
    Version.parse(self);Fi[	@›
iZI"R  end
  
  def function
    require("version")
    Version.new(basename.to_s);Fi[	@·i
I"∏  # This can be compared to numerics, strings, or symbols
  # using the standard Ruby Comparable methods.
  def function
    require("version")
    MacOSVersion.new(MACOS_VERSION.to_s);Fi[	@2I"Cvar.js { render("LITERAL" => (true), "LITERAL" => "LITERAL") };Fi[[	@M#i&I"     if (current_user.owns?(@comment) or current_user.owns?(@comment.parent)) then
      current_user.retract(@comment)
      respond_to do |var|
        var.js { render("LITERAL" => (true), "LITERAL" => "LITERAL") }
        var.json { render("LITERAL" => (true), "LITERAL" => "LITERAL") };Fi[	@µi/I"ü      flash["LITERAL"] = I18n.t("STRING")
    end
    respond_to do |var|
      var.js { render("LITERAL" => (true), "LITERAL" => "LITERAL") }
      var.any do;Fi[	@Å!iUI"¿      end
    end
    respond_to do |var|
      var.js { render("LITERAL" => (true), "LITERAL" => "LITERAL") }
      var.all { redirect_to((var ? (new_user_session_path) : (edit_user_path))) };Fi[	@:I"'if params["LITERAL"].present? then;Fi[[	@3i/I"à  end
  
  def function
    if params["LITERAL"].present? then
      @var ||= InvitationCode.find_by_token(params["LITERAL"]["LITERAL"]);Fi[	@I*iI"¨  
  ##### These methods need to go away once we pass publisher object into the partial ######
  def function
    if params["LITERAL"].present? then
      params["LITERAL"];Fi[	@I*iI"[  end
  
  def function
    if params["LITERAL"].present? then
      params["LITERAL"];Fi[	@2I"Evar.json { render("LITERAL" => (true), "LITERAL" => "LITERAL") };Fi[[	@P#iI"€    @var = Like.find_by_id_and_author_id!(params["LITERAL"], current_user.person.id)
    current_user.retract(@like)
    respond_to do |var|
      var.json { render("LITERAL" => (true), "LITERAL" => "LITERAL") }
    end;Fi[	@“iRI"¶    if var then
      current_user.retract(var)
      respond_to do |var|
        var.json { render("LITERAL" => (true), "LITERAL" => "LITERAL") }
        var.html do;Fi[	@G5iI"™      end
    else
      respond_to do |var|
        var.json { render("LITERAL" => (true), "LITERAL" => "LITERAL") }
        var.html { redirect_to(tag_path("STRING")) };Fi[	I"%var.any("LITERAL", "LITERAL") do;F@J#i[[	@M#i.I"∫      respond_to do |var|
        var.mobile { redirect_to("LITERAL") }
        var.any("LITERAL", "LITERAL") do
          render("LITERAL" => (true), "LITERAL" => "LITERAL")
        end;Fi[	@b#i!I"¨    if var and var.destroy then
      respond_to do |var|
        var.any("LITERAL", "LITERAL") do
          render("LITERAL" => (true), "LITERAL" => "LITERAL")
        end;Fi[	@b#i'I"ï    else
      respond_to do |var|
        var.any("LITERAL", "LITERAL") do
          render("LITERAL" => (true), "LITERAL" => "LITERAL")
        end;Fi[	I"=(@version["LITERAL"] << "STRING") if @version["LITERAL"];F@%Ai[[	I".projects//compass_proj/compass/version.rb;TiI"      @version["LITERAL"] = @version["LITERAL"]
      @version["LITERAL"] = "STRING"
      (@version["LITERAL"] << "STRING") if @version["LITERAL"]
      (@version["LITERAL"] << "STRING") if @version["LITERAL"]
      (@version["LITERAL"] << "STRING") if @version["LITERAL"];Fi[	@(AiI"       @version["LITERAL"] = "STRING"
      (@version["LITERAL"] << "STRING") if @version["LITERAL"]
      (@version["LITERAL"] << "STRING") if @version["LITERAL"]
      (@version["LITERAL"] << "STRING") if @version["LITERAL"]
      (@version["LITERAL"] << "STRING") if @version["LITERAL"];Fi[	@(AiI"I      (@version["LITERAL"] << "STRING") if @version["LITERAL"]
      (@version["LITERAL"] << "STRING") if @version["LITERAL"]
      (@version["LITERAL"] << "STRING") if @version["LITERAL"]
      (@version["LITERAL"] << "STRING") if @version["LITERAL"]
      (@version["LITERAL"] << "STRING") if ENV["STRING"].! and var = revision;Fi[	@‰@I"ILastThreeCommentsDecorator.new(PostPresenter.new(var, current_user));Fi[[	@w!ifI"       var.all { respond_with(@person, "LITERAL" => ({ "LITERAL" => "LITERAL" })) }
      var.json do
        render("LITERAL" => (@stream.stream_posts.map do |var|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end));Fi[	@È@i@I"”      var.mobile { render("STRING") }
      var.json do
        render("LITERAL" => (@stream.stream_posts.map do |var|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end));Fi[	@G5i(I"«    respond_with do |var|
      var.json do
        render("LITERAL" => (@stream.stream_posts.map do |var|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end));Fi[	@:I"(@env << "LITERAL");Fi[[	I";projects//homebrew_proj/test/test_build_environment.rb;TiI"J  end
  
  def function
    (@env << "LITERAL")
    assert(@env.std?);Fi[	@;AiI"P  end
  
  def function
    (@env << "LITERAL")
    assert(@env.userpaths?);Fi[	@;AiI"Y  end
  
  def function
    (@env << "LITERAL")
    (@env << Proc.new { "LITERAL" });Fi[	@:I"N@var = current_user.aspects.where("LITERAL" => (params["LITERAL"])).first;Fi[[	@=5i*I"t  end
  
  def function
    @var = current_user.aspects.where("LITERAL" => (params["LITERAL"])).first
    begin;Fi[	@=5iZI"ü  end
  
  def function
    @var = current_user.aspects.where("LITERAL" => (params["LITERAL"])).first
    if @aspect.update_attributes!(params["LITERAL"]) then;Fi[	@=5idI"ã  end
  
  def function
    @var = current_user.aspects.where("LITERAL" => (params["LITERAL"])).first
    if @aspect.contacts_visible? then;Fi[	@:I" (@set << X11Dependency.new);Fi[[	I"7projects//homebrew_proj/test/test_comparableset.rb;TiI"\  end
  
  def function
    (@set << X11Dependency.new)
    (@set << X11Dependency.new);Fi[	@NAiI"f  end
  
  def function
    (@set << X11Dependency.new)
    (@set << X11Dependency.new("STRING"));Fi[	@NAi#I"Z  end
  
  def function
    (@set << X11Dependency.new)
    (@set << Requirement.new);Fi[	@/AI"
end));Fi[[	@w!igI"∑      var.json do
        render("LITERAL" => (@stream.stream_posts.map do |var|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end;Fi[	@È@iAI"∑      var.json do
        render("LITERAL" => (@stream.stream_posts.map do |var|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end;Fi[	@G5i)I"∑      var.json do
        render("LITERAL" => (@stream.stream_posts.map do |var|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end;Fi[	I".Sass::Script::String.new(clean_path(var));F@|i[[	@f6i%I"Ç      var = "STRING"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var);Fi[	@f6i>I"Ç      var = "STRING"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var);Fi[	@f6iqI"â      var = "STRING" if var
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var);Fi[	I"if var.to_bool then;F@^Ai[[	@f6i$I"z      end
      var = "STRING"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else;Fi[	@f6i=I"z      end
      var = "STRING"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else;Fi[	@f6ipI"|      end
      var = "STRING" if var
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else;Fi[	@:I"if params["LITERAL"] then;Fi[[	I"Bprojects//diaspora_proj/controllers/application_controller.rb;TiI"`  end
  
  def function
    if params["LITERAL"] then
      Time.at(params["LITERAL"].to_i);Fi[	@w!i{I"{  end
  
  def function
    if params["LITERAL"] then
      Webfinger.in_background(params["LITERAL"], "LITERAL" => (true));Fi[	@\#i,I"}  end
  
  def function
    if params["LITERAL"] then
      @var = Person.local_by_account_identifier(params["LITERAL"]);Fi[	I"#var = convert_sprite_name(var);FI"verify_map(var);Fi[[	@4iDI"  #     background: url('/images/icons.png?12345678') 0 -24px no-repeat;
  def function(var, var, var, var)
    var = convert_sprite_name(var)
    verify_map(var)
    raise(Sass::SyntaxError, "STRING") unless var.is_a?(Sass::Script::String);Fi[	@4ikI"ë  # Returns boolean if sprite has a parent
  def function(var, var)
    var = convert_sprite_name(var)
    verify_map(var)
    verify_sprite(var);Fi[	@4iuI"ö  # Returns boolean if sprite has the selector
  def function(var, var, var)
    var = convert_sprite_name(var)
    verify_map(var)
    verify_sprite(var);Fi[	I"var = (var.value + var);F@83i[[	@¶iˆI"{      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end;Fi[	@¶i I"{      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end;Fi[	@¶iI"{      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end;Fi[	@:I"2FileUtils.touch((HOMEBREW_PREFIX / "STRING"));Fi[[	@˘'i-I"{  end
  
  def function
    FileUtils.touch((HOMEBREW_PREFIX / "STRING"))
    assert_raise(RuntimeError) { @keg.link };Fi[	@˘'i2I"g  end
  
  def function
    FileUtils.touch((HOMEBREW_PREFIX / "STRING"))
    var = OpenStruct.new;Fi[	@˘'i9I"g  end
  
  def function
    FileUtils.touch((HOMEBREW_PREFIX / "STRING"))
    var = OpenStruct.new;Fi[	@:I"if user_signed_in? then;Fi[[	@sAiII"b  end
  
  def function
    if user_signed_in? then
      I18n.locale = current_user.language;Fi[	@M#iGI"á  private
  
  def function
    if user_signed_in? then
      @var = current_user.find_visible_shareable_by_id(Post, params["LITERAL"]);Fi[	I";projects//diaspora_proj/controllers/home_controller.rb;TiI"{class HomeController < ApplicationController
  def function
    if user_signed_in? then
      redirect_to(stream_path);Fi[	@:I"'var = (HOMEBREW_PREFIX / "STRING");Fi[[	@u"iäI"[  end
  
  def function
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING");Fi[	@u"iöI"[  end
  
  def function
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING");Fi[	@u"i™I"[  end
  
  def function
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING");Fi[	I"&if list_of_color_stops?(var) then;F@ÑAi[[	@¶iıI"|        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil;Fi[	@¶iˇI"|        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil;Fi[	@¶iI"|        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil;Fi[	I"var = I18n.t("STRING");FI"Irespond_with(@photo, "LITERAL" => (photos_path), "LITERAL" => (var));Fi[[	@“iπI"Ø      yield
    rescue TypeError
      var = I18n.t("STRING")
      respond_with(@photo, "LITERAL" => (photos_path), "LITERAL" => (var))
    rescue CarrierWave::IntegrityError;Fi[	@“iºI"¯      respond_with(@photo, "LITERAL" => (photos_path), "LITERAL" => (var))
    rescue CarrierWave::IntegrityError
      var = I18n.t("STRING")
      respond_with(@photo, "LITERAL" => (photos_path), "LITERAL" => (var))
    rescue RuntimeError => var;Fi[	@“iøI"‚      respond_with(@photo, "LITERAL" => (photos_path), "LITERAL" => (var))
    rescue RuntimeError => var
      var = I18n.t("STRING")
      respond_with(@photo, "LITERAL" => (photos_path), "LITERAL" => (var))
      raise(var);Fi[	@:@á@i[[	@™iI"l      end
      
      def function
        view_directory("LITERAL")
        view_directory("LITERAL");Fi[	@™i4I"Å      
      # Override copy_views to just copy mailer and shared.
      def function
        view_directory("LITERAL")
      end;Fi[	@™iVI"V      hide!
      
      def function
        view_directory("LITERAL")
      end;Fi[	I"var.unshift(var);F@83i[[	@¶iÚI"y    def function(var, var, var)
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else;Fi[	@¶i¸I"}      var = nil if var and var.to_bool.!
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else;Fi[	@¶iI"t    def function(var, var)
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else;Fi[	I"if color_stop?(var) then;F@ƒAi[[	@¶iÒI"s    
    def function(var, var, var)
      if color_stop?(var) then
        var.unshift(var)
        var = nil;Fi[	@¶i˚I"|      end
      var = nil if var and var.to_bool.!
      if color_stop?(var) then
        var.unshift(var)
        var = nil;Fi[	@¶iI"n    
    def function(var, var)
      if color_stop?(var) then
        var.unshift(var)
        var = nil;Fi[	@J#@“2i[[	@\#i1I"å    end
    if (@person.nil? or @person.closed_account?) then
      render("LITERAL" => (true), "LITERAL" => "LITERAL")
      return
    end;Fi[	@\#iFI"ù    if (var.nil? or var.owner_id.nil?) then
      Rails.logger.error("STRING")
      render("LITERAL" => (true), "LITERAL" => "LITERAL")
      return
    end;Fi[	@\#iSI"Ä  def function
    if params["LITERAL"].nil? then
      render("LITERAL" => (true), "LITERAL" => "LITERAL")
      return
    end;Fi[	I"9Sass::Script::List.new(var.value.dup, var.separator);F@|i[[	@ÀiI"¿    def function(var)
      var = if var.is_a?(Sass::Script::List) then
        Sass::Script::List.new(var.value.dup, var.separator)
      else
        Sass::Script::List.new([var], "LITERAL");Fi[	@¶i∫I"∫      var = var
      var = if var.is_a?(Sass::Script::List) then
        Sass::Script::List.new(var.value.dup, var.separator)
      else
        Sass::Script::List.new([var], "LITERAL");Fi[	@1i2I"∞  def function(var)
    if var.is_a?(Sass::Script::List) then
      Sass::Script::List.new(var.value.dup, var.separator)
    else
      Sass::Script::List.new([var], "LITERAL");Fi[	I"+class Generator < Federated::Generator;FI"def self.federated_class;Fi[[	@Ói[I"a  end
  
  class Generator < Federated::Generator
    def self.federated_class
      Comment;Fi[	@¿!iI"wclass Like < Federated::Relayable
  class Generator < Federated::Generator
    def self.federated_class
      Like;Fi[	@«!iI"Ñclass Participation < Federated::Relayable
  class Generator < Federated::Generator
    def self.federated_class
      Participation;Fi[	I""if var.delete("LITERAL") then;FI"Fvar = TemplateContext.ctx("LITERAL" => (var), "LITERAL" => (var));Fi[[	@õiPI"◊          else
            var = File.new(var).read
            if var.delete("LITERAL") then
              var = TemplateContext.ctx("LITERAL" => (var), "LITERAL" => (var))
              var = process_erb(var, var);Fi[	@õi_I"˚        var = targetize(install_location_for_stylesheet(var, var))
        var = File.new(var).read
        if var.delete("LITERAL") then
          var = TemplateContext.ctx("LITERAL" => (var), "LITERAL" => (var))
          var = process_erb(var, var);Fi[	@õiáI"          var = install_location_for_html(var, var) if respond_to?("LITERAL")
          var = File.read(templatize(var))
          if var.delete("LITERAL") then
            var = TemplateContext.ctx("LITERAL" => (var), "LITERAL" => (var))
            var = process_erb(var, var);Fi[	I" # @return [Invitation] self;F@:i[[	@≥
i>I"f  # invitation.
  #
  # @return [Invitation] self
  def function
    if email_like_identifer then;Fi[	@≥
iJI"ï  # converts a personal invitation to an admin invite
  # used in account deletion
  # @return [Invitation] self
  def function
    self.admin = true;Fi[	@≥
iSI"I  end
  
  # @return [Invitation] self
  def function
    self.send!;Fi[	@:I")Compass::Util.compass_warn("STRING");Fi[[	@Í>i
I"h      extend(self)
      
      def function
        Compass::Util.compass_warn("STRING")
      end;Fi[	@Í>iI"j      end
      
      def function
        Compass::Util.compass_warn("STRING")
        ::Rails.root;Fi[	@Í>iI"i      end
      
      def function
        Compass::Util.compass_warn("STRING")
        ::Rails.env;Fi[	I"# @note Validation;F@:i[[	@≥
iuI"  end
  
  # @note Validation
  def function
    (errors["LITERAL"] << "STRING") if (self.identifier == self.sender.email);Fi[	@≥
izI"  end
  
  # @note Validation
  def function
    (errors["LITERAL"] << "STRING") if self.sender_id.!=(self.aspect.user_id);Fi[	@≥
iI"Y  end
  
  # @note Validation
  def function
    return false unless self.identifier;Fi[	I"2var.on("STRING", "STRING", "STRING") do |var|;FI"require("pathname");Fi[[	@=iI"¡      ::Compass.configuration.require(library)
    end
    var.on("STRING", "STRING", "STRING") do |var|
      require("pathname")
      ::Compass.configuration.load(Pathname.new(var).realpath);Fi[	@=iI"’      ::Compass.configuration.load(Pathname.new(var).realpath)
    end
    var.on("STRING", "STRING", "STRING") do |var|
      require("pathname")
      ::Compass.configuration.discover(Pathname.new(var).realpath);Fi[	@=iI"‡      ::Compass.configuration.discover(Pathname.new(var).realpath)
    end
    var.on("STRING", "STRING", "STRING") do |var|
      require("pathname")
      ::Compass.configuration.add_import_path(Pathname.new(var).realpath);Fi[	@:I" if @options["LITERAL"] then;Fi[[	@
iÑI"i    end
    
    def function
      if @options["LITERAL"] then
        @params[@options["LITERAL"]];Fi[	@
iºI"    # If the :shallow option is passed it will use the resource_class if there's no parent
    # If the :singleton option is passed it won't use the association because it needs to be handled later.
    def function
      if @options["LITERAL"] then
        if parent_resource then;Fi[	@
iÈI"s    end
    
    def function
      if @options["LITERAL"] then
        var = extract_key(@options["LITERAL"]);Fi[	@:I")@queued_for_write.each do |var, var|;Fi[[	@i©I"√    
    # called by storage after the writes are flushed and before @queued_for_writes is cleared
    def function
      @queued_for_write.each do |var, var|
        var.close unless var.closed?;Fi[	@^iI"ä      
      #:nodoc:
      def function
        @queued_for_write.each do |var, var|
          FileUtils.mkdir_p(File.dirname(path(var)));Fi[	@ciΩI"j      
      #:nodoc:
      def function
        @queued_for_write.each do |var, var|
          begin;Fi[	@:I"Paperclip.log("STRING");Fi[[	@5iI"y    end
    
    def function
      Paperclip.log("STRING")
      each_attachment { |var, var| var.send("LITERAL") };Fi[	@5iI"y    end
    
    def function
      Paperclip.log("STRING")
      each_attachment { |var, var| var.send("LITERAL") };Fi[	@5iI"y    end
    
    def function
      Paperclip.log("STRING")
      each_attachment { |var, var| var.send("LITERAL") };Fi[	@:I"@var ||= (var = {};Fi[[	@%idI"$          # The keys are the filesystem paths, relative to @directory.
          # The values are the LocalFile objects for that given file.
          def function
            @var ||= (var = {}
            local_hashes.lines.map { |var| LocalFile.new(@directory, var) }.compact.each do |var|;Fi[	@%iwI"          # The keys are the remote paths, relative to @remote_base
          # The values are the Fog file objects for that given file
          def function
            @var ||= (var = {}
            @bucket.files.all("LITERAL" => (@remote_base)).each do |var|;Fi[	@›i8I"Ÿ        # Extracts the machine options.  Note that this will only extract a
        # subset of the options supported.
        def function
          @var ||= (var = {}
          var = statement.parameters(false).last;Fi[	@Á>I"module StandAlone;Fi[[	@âiI"dmodule Compass
  module AppIntegration
    module StandAlone
      module ConfigurationDefaults;Fi[	@
iI"z  end
  
  module AppIntegration
    module StandAlone
      class Installer < Compass::Installers::ManifestInstaller;Fi[	@Ô>i	I"Xend
module Compass
  module AppIntegration
    module StandAlone
      extend(self);Fi[	I"*return image_url if (var == "STRING");FI"/if (var.nil? or var.match("LITERAL")) then;Fi[[	@_'imI"Ä  
  def function(var)
    return image_url if (var == "STRING")
    if (var.nil? or var.match("LITERAL")) then
      super(var);Fi[	@_'ivI"Ä  
  def function(var)
    return image_url if (var == "STRING")
    if (var.nil? or var.match("LITERAL")) then
      super(var);Fi[	@_'iI"Ä  
  def function(var)
    return image_url if (var == "STRING")
    if (var.nil? or var.match("LITERAL")) then
      super(var);Fi[	@:@A*i[[	@’iBI")  end
  
  def function
    []
  end;Fi[	@’iFI")  end
  
  def function
    []
  end;Fi[	@ÚiI"É        
        # The list of ancestor names that cause this integration to matched.
        def function
          []
        end;Fi[	@Ä#I"module Commands;Fi[[	@&i I"4module Compass
  module Commands
    class Base;Fi [	I"Aprojects//compass_proj/compass/commands/installer_command.rb;TiI"_require("compass/installers")
module Compass
  module Commands
    module InstallerCommand;Fi[	@*i	I"årequire("compass/commands/base")
require("compass/commands/installer_command")
module Compass
  module Commands
    class ProjectBase < Base;Fi[	@NB@Æi[[	@_'inI"Ü  def function(var)
    return image_url if (var == "STRING")
    if (var.nil? or var.match("LITERAL")) then
      super(var)
    else;Fi[	@_'iwI"Ü  def function(var)
    return image_url if (var == "STRING")
    if (var.nil? or var.match("LITERAL")) then
      super(var)
    else;Fi[	@_'i{I"Ü  def function(var)
    return image_url if (var == "STRING")
    if (var.nil? or var.match("LITERAL")) then
      super(var)
    else;Fi[	I"self.perform(var);F@|i[[	@Ωi5I"Ÿ        self.parent_author_signature = self.sign_with_key(var.encryption_key)
        Postzord::Dispatcher.build(var, self).post
        self.perform(var)
      else
        if self.parent_author_signature_valid? then;Fi[	@Ωi8I"ç      else
        if self.parent_author_signature_valid? then
          self.perform(var)
        else
          Rails.logger.info("STRING");Fi[	@ÓiYI"É    else
      if self.target_author_signature_valid? then
        self.perform(var)
      else
        Rails.logger.info("STRING");Fi[	I"version("LITERAL") do;FI"3process("LITERAL" => (["LITERAL", "LITERAL"]));Fi[[	@„iI"o  end
  
  version("LITERAL") do
    process("LITERAL" => (["LITERAL", "LITERAL"]))
    process("LITERAL");Fi[	@„iI"o  end
  
  version("LITERAL") do
    process("LITERAL" => (["LITERAL", "LITERAL"]))
    process("LITERAL");Fi[	@„iI"o  end
  
  version("LITERAL") do
    process("LITERAL" => (["LITERAL", "LITERAL"]))
    process("LITERAL");Fi[	@:I"0["STRING", "STRING", "STRING"].map do |var|;Fi[[	@ieI"Á      # Builds the MySQL connectivity options syntax to connect the user
      # to perform the database dumping process
      def function
        ["STRING", "STRING", "STRING"].map do |var|
          next if send(var).to_s.empty?;Fi[	@icI"!      # that's the option PostgreSQL takes for socket connections as well. In case
      # both the host and the socket are specified, the socket will take priority over the host
      def function
        ["STRING", "STRING", "STRING"].map do |var|
          next if send(var).to_s.empty?;Fi[	@fieI"Á      # Builds the Redis connectivity options syntax to connect the user
      # to perform the database dumping process
      def function
        ["STRING", "STRING", "STRING"].map do |var|
          next if send(var).to_s.empty?;Fi[	@:I"?@var ||= Array(@attrs["LITERAL"]).inject({}) do |var, var|;Fi[[	@/iI"Ø    #
    # @return [Array<Twitter::Size>]
    def function
      @var ||= Array(@attrs["LITERAL"]).inject({}) do |var, var|
        var[var] = Twitter::Size.fetch_or_new(var);Fi[	@ˇ*iI"π      #
      # @return [Array<Twitter::Size>]
      def function
        @var ||= Array(@attrs["LITERAL"]).inject({}) do |var, var|
          var[var] = Twitter::Size.fetch_or_new(var);Fi[	@AiI"Ø    #
    # @return [Array<Twitter::Size>]
    def function
      @var ||= Array(@attrs["LITERAL"]).inject({}) do |var, var|
        var[var] = Twitter::Size.fetch_or_new(var);Fi[	@:I"var = @attrs["STRING"];Fi[[	@riI"e    
    # @return [Integer]
    def function
      var = @attrs["STRING"]
      var.to_i if var;Fi[	@riI"e    
    # @return [Integer]
    def function
      var = @attrs["STRING"]
      var.to_i if var;Fi[	@riI"k    
    # @return [Time]
    def function
      var = @attrs["STRING"]
      Time.at(var.to_i) if var;Fi[	I"module Haml;FI"module Helpers;Fi[[	@,
i I"Bmodule Haml
  module Helpers
    @@action_view_defined = true;Fi [	@;i I"4module Haml
  module Helpers
    module XssMods;Fi [	@Ôi I"7module Haml
  module Helpers
    class ErrorReturn;Fi [	@:I"&["STRING", "STRING"].map do |var|;Fi[[	@ciáI"€      # Builds the MongoDB credentials syntax to authenticate the user
      # to perform the database dumping process
      def function
        ["STRING", "STRING"].map do |var|
          next if send(var).to_s.empty?;Fi[	@ciëI"ﬂ      # Builds the MongoDB connectivity options syntax to connect the user
      # to perform the database dumping process
      def function
        ["STRING", "STRING"].map do |var|
          next if send(var).to_s.empty?;Fi[	@i[I"Ÿ      # Builds the credentials MySQL syntax to authenticate the user
      # to perform the database dumping process
      def function
        ["STRING", "STRING"].map do |var|
          next if send(var).to_s.empty?;Fi[	I"#     </li>;FI"&#     <li class='nav' role='nav'>;Fi[[	@ÔiüI"û    #     <li class='nav' role='nav'>
    #       <a href='#'>Home</a>
    #     </li>
    #     <li class='nav' role='nav'>
    #       <a href='#'>About</a>;Fi[	@Ôi¢I"°    #     <li class='nav' role='nav'>
    #       <a href='#'>About</a>
    #     </li>
    #     <li class='nav' role='nav'>
    #       <a href='#'>Contact</a>;Fi[	@Ôi•I"ü    #     <li class='nav' role='nav'>
    #       <a href='#'>Contact</a>
    #     </li>
    #     <li class='nav' role='nav'>
    #       <a href='#'>FAQ</a>;Fi[	@&>@ô+i[[	@’)iI"Erequire("formula")
require("keg")
module Homebrew
  extend(self);Fi[	I")projects//homebrew_proj/cmd/prune.rb;Ti I"2require("keg")
module Homebrew
  extend(self);Fi [	@*5iI"\require("extend/ENV")
require("hardware")
require("keg")
module Homebrew
  extend(self);Fi[	I"W# You can also pass the resource name as the first argument to skip that resource.;F@£i[[	@ñi∂I"ß      #   end
      #
      # You can also pass the resource name as the first argument to skip that resource.
      def function(var)
        skip_load_resource(*var);Fi[	@ñi≈I"©      #   end
      #
      # You can also pass the resource name as the first argument to skip that resource.
      def function(var)
        var = var.extract_options!;Fi[	@ñi’I"©      #   end
      #
      # You can also pass the resource name as the first argument to skip that resource.
      def function(var)
        var = var.extract_options!;Fi[	I"*def function(var, var, var, var, var);F@Hi[[	@8idI"ë      # <tt>has_many :clients</tt> returns +{}+
      # :nodoc:
      def function(var, var, var, var, var)
        @var = var
        @var = var;Fi[	@Æi#I"q        end
        
        def function(var, var, var, var, var)
          @var = var
          @var = var;Fi[	@∏i%I"S  end
  
  def function(var, var, var, var, var)
    @var = var
    @var = var;Fi[	I")ENV.prepend_path("STRING", "STRING");F@◊Bi[[	@8
iII"±    var.each do |var|
      var = var.opt_prefix
      ENV.prepend_path("STRING", "STRING")
      ENV.prepend_path("STRING", "STRING")
      ENV.prepend_path("STRING", "STRING");Fi[	@8
iJI"∆      var = var.opt_prefix
      ENV.prepend_path("STRING", "STRING")
      ENV.prepend_path("STRING", "STRING")
      ENV.prepend_path("STRING", "STRING")
      ENV.prepend_path("STRING", "STRING");Fi[	@8
iKI"—      ENV.prepend_path("STRING", "STRING")
      ENV.prepend_path("STRING", "STRING")
      ENV.prepend_path("STRING", "STRING")
      ENV.prepend_path("STRING", "STRING")
      ENV.prepend_path("STRING", var);Fi[	@:I"var = self;Fi[[	@IiI"u    # Set the lookup ancestors for ActiveModel.
    #:nodoc:
    def function
      var = self
      var = [var];Fi[	I".projects//diaspora_proj/models/reshare.rb;TiHI"K  end
  
  def function
    var = self
    while var.is_a?(Reshare) do;Fi[	@3
iÜI"m      
      # @private
      def function
        var = self
        @var ||= compiler.instance_eval do;Fi[	@F>I")assert(var.fails_with?("LITERAL").!);Fi[[	@ÊiI"†  def function
    var = TestLLVMFailure.new
    var = CompilerSelector.new(var)
    assert(var.fails_with?("LITERAL").!)
    assert(var.fails_with?("LITERAL"));Fi[	@Êi+I"©  def function
    var = TestNoCompilerFailures.new
    var = CompilerSelector.new(var)
    assert(var.fails_with?("LITERAL").!)
    assert(var.fails_with?("LITERAL").!);Fi[	@ÊiDI"Æ  def function
    var = TestMoreMixedCompilerFailures.new
    var = CompilerSelector.new(var)
    assert(var.fails_with?("LITERAL").!)
    assert(var.fails_with?("LITERAL"));Fi[	I"var.install;FI"var.caveats;Fi[[	@»
iVI"k    begin
      (var = FormulaInstaller.new(var)
      var.install
      var.caveats
      var.finish);Fi[	@âi=I"f      oh1("STRING")
      var.unlink if var
      var.install
      var.caveats
      var.finish);Fi[	@—isI"f      oh1("STRING")
      var.unlink if var
      var.install
      var.caveats
      var.finish);Fi[	I"problem("STRING");F@|i[[	@iÜI"°      next if var.nil?
      if var.version.to_s.empty? then
        problem("STRING")
      else
        var = var.version unless var.version.detected_from_url?;Fi[	@iöI"¥      problem("STRING") if (var.hash_type == "LITERAL")
      if var.empty? then
        problem("STRING")
      else
        problem("STRING") unless (var.hexdigest.length == var);Fi[	@i™I"â        problem("STRING") unless var.url =~ "LITERAL"
      when "LITERAL" then
        problem("STRING")
      else
        # do nothing;Fi[	I"*problem("STRING") if var =~ "LITERAL";F@Ci[[	@i}I"≈      next if var =~ "LITERAL"
      next unless var =~ "LITERAL"
      problem("STRING") if var =~ "LITERAL"
      problem("STRING") if var =~ "LITERAL"
      problem("STRING") if var =~ "LITERAL";Fi[	@i~I"“      next unless var =~ "LITERAL"
      problem("STRING") if var =~ "LITERAL"
      problem("STRING") if var =~ "LITERAL"
      problem("STRING") if var =~ "LITERAL"
      problem("STRING") if var =~ "LITERAL";Fi[	@iI"∑      problem("STRING") if var =~ "LITERAL"
      problem("STRING") if var =~ "LITERAL"
      problem("STRING") if var =~ "LITERAL"
      problem("STRING") if var =~ "LITERAL"
    end;Fi[	I"require("blacklist");F@ô+i[[	@iI"Krequire("formula")
require("blacklist")
module Homebrew
  extend(self);Fi[	@»
iI"irequire("formula_installer")
require("hardware")
require("blacklist")
module Homebrew
  extend(self);Fi[	@7iI"Krequire("formula")
require("blacklist")
module Homebrew
  extend(self);Fi[	I"# debug options: -vhP;F@:i[[	@8iI"Æ        ##
        # Performs the RSync::Local operation
        # debug options: -vhP
        def function
          Logger.message(("STRING" + @directories.join("STRING")));Fi[	@ˇ	iI"        ##
        # Performs the RSync::Pull operation
        # debug options: -vhP
        def function
          begin;Fi[	@Üi-I"~        ##
        # Performs the RSync:Push operation
        # debug options: -vhP
        def function
          begin;Fi[	@Å2I"exec_browser("STRING");Fi[[	@iI"Ä  # Create a formula from a tarball URL
  def function
    if ARGV.include?("STRING") then
      exec_browser("STRING")
    else;Fi[	@7iI"`  
  def function
    if ARGV.include?("STRING") then
      exec_browser("STRING")
    else;Fi[	@7iI"z      exec_browser("STRING")
    else
      if ARGV.include?("STRING") then
        exec_browser("STRING")
      else;Fi[	@Ÿ@4i[[	@Xi>I"i      end
      
      def function(var, var, var)
        case var
        when Symbol, String then;Fi[	@∏i1I"Y    end
    
    def function(var, var, var)
      case var
      when "STRING" then;Fi[	@iâI"√      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen_name, or object.
      # @return [Hash]
      def function(var, var, var)
        case var
        when Integer then;Fi[	@!C@|i[[	@iI"ê  def function
    if ARGV.include?("STRING") then
      exec_browser("STRING")
    else
      exec_browser("STRING") if ARGV.include?("STRING");Fi[	@7iI"~  def function
    if ARGV.include?("STRING") then
      exec_browser("STRING")
    else
      if ARGV.include?("STRING") then;Fi[	@7iI"v    else
      if ARGV.include?("STRING") then
        exec_browser("STRING")
      else
        var = ARGV.first;Fi[	@ÙBI"var.finish);Fi[[	@»
iWI"ê      (var = FormulaInstaller.new(var)
      var.install
      var.caveats
      var.finish)
    rescue FormulaInstallationAlreadyAttemptedError;Fi[	@âi>I"Å      var.unlink if var
      var.install
      var.caveats
      var.finish)
    rescue FormulaInstallationAlreadyAttemptedError;Fi[	@—itI"]      var.unlink if var
      var.install
      var.caveats
      var.finish)
    ensure;Fi[	@:I"var = self.name;Fi[[	@iI"ó    end
    
    def function
      var = self.name
      model.send("LITERAL", Module.new { class_eval("STRING", "STRING", ("LITERAL" + "LITERAL")) });Fi[	@ÛiãI"•      
      # Skips defining reader/writer methods since this is done automatically
      def function
        var = self.name
        if supports_validations? then;Fi[	@JiNI"¿      
      # Skips defining reader/writer methods since this is done automatically
      def function
        var = self.name
        owner_class.validates_each(attribute) do |var, var, var|;Fi[	@:I"Bmixin.class_eval("STRING", "STRING", ("LITERAL" + "LITERAL"));Fi[[	@NiHI"n    end
    
    def function
      mixin.class_eval("STRING", "STRING", ("LITERAL" + "LITERAL"))
    end;Fi[	@NiLI"n    end
    
    def function
      mixin.class_eval("STRING", "STRING", ("LITERAL" + "LITERAL"))
    end;Fi[	@niI"n    end
    
    def function
      mixin.class_eval("STRING", "STRING", ("LITERAL" + "LITERAL"))
    end;Fi[	@¢)I"module Cloud;Fi[[	@%iI"uBackup::Dependency.load("STRING")
module Backup
  module Syncer
    module Cloud
      class Base < Syncer::Base;Fi[	@}iI"Qmodule Backup
  module Syncer
    module Cloud
      class CloudFiles < Base;Fi[	@ÄiI"Imodule Backup
  module Syncer
    module Cloud
      class S3 < Base;Fi[	I"$n = "LITERAL";FI"$d = "LITERAL";Fi[[	@¿BiI"f  # certain filesystem actions.
  def function
    $n = "LITERAL"
    $d = "LITERAL"
    var = [];Fi[	@J
iwI",  end
end
$n = "LITERAL"
$d = "LITERAL";Fi[	@›
ifI"©    begin
      (raise("STRING") if linked_keg_record.directory?
      $n = "LITERAL"
      $d = "LITERAL"
      var = ["STRING", "STRING", "STRING", "STRING", "STRING"];Fi[	@:I"
reset;Fi[[	@®i$I"{      
      # Reloads the \target and returns +self+ on success.
      def function
        reset
        reset_scope;Fi[	@QiûI"U    
    # Forces reloading of relation.
    def function
      reset
      load;Ti[	@3iI"ï    #   transition.rollback
    #   vehicle.state             # => "parked"
    def function
      reset
      machine.write(object, "LITERAL", from);Fi[	@:I"{};Fi[[	@ÜiI"ï      # database types. See TableDefinition#column for details on the recognized
      # abstract data types.
      def function
        {}
      end;Fi[	@úi/I"3    end
    
    def function
      {}
    end;Fi[	@€i©I"3    end
    
    def function
      {}
    end;Fi[	I"if var.symlink? then;F@ø	i[[	@G
i'I"Ø        File.utime(var.atime, var.mtime, var) if var.symlink?.!
        begin
          if var.symlink? then
            begin
              File.lchown(var.uid, var.gid, var);Fi[	@G
i1I"ê          end
        rescue Errno::EPERM
          if var.symlink? then
            begin
              File.lchmod(var.mode.&("LITERAL"), var);Fi[	@G
i;I"y          end
        else
          if var.symlink? then
            begin
              File.lchmod(var.mode, var);Fi[	@W)@Ùi[[	@¯	i`I"‡      # and a warning will be logged, containing the error message.
      def function(var)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) { |var, var| (var << ("STRING" + "STRING")) };Fi[	@„"i)I"”      # and a warning will be logged, containing the error message.
      def function(var)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) { |var, var| (var << "STRING") };Fi[	@i>I"‡      # and a warning will be logged, containing the error message.
      def function(var)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) { |var, var| (var << ("STRING" + "STRING")) };Fi[	I"var = Report.new;FI"var.merge!(var.report);Fi[[	@Ï i:I"ä      var.in_repo_expect("STRING")
      var.pull!
      var = Report.new
      var.merge!(var.report)
      assert(var.expectations_met?);Fi[	@Ï iLI"è      var.in_repo_expect("STRING", var)
      var.pull!
      var = Report.new
      var.merge!(var.report)
      assert(var.expectations_met?);Fi[	@Ï i`I"è      var.in_repo_expect("STRING", var)
      var.pull!
      var = Report.new
      var.merge!(var.report)
      assert(var.expectations_met?);Fi[	@ŸI"log(var, var, var) do;Fi[[	@Ç
ieI"™        end
        
        def function(var, var, var)
          log(var, var, var) do
            var = var.empty? ? (exec_no_cache(var, var)) : (exec_cache(var, var));Fi[	@Ç
iwI"™        end
        
        def function(var, var, var)
          log(var, var, var) do
            var = var.empty? ? (exec_no_cache(var, var)) : (exec_cache(var, var));Fi[	@XiıI"r      end
      
      def function(var, var, var)
        log(var, var, var) do
          if var.empty? then;Fi[	I"var.pull!;F@ãCi[[	@Ï i9I"ì      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING")
      var.pull!
      var = Report.new
      var.merge!(var.report);Fi[	@Ï iKI"ò      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING", var)
      var.pull!
      var = Report.new
      var.merge!(var.report);Fi[	@Ï i_I"ò      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING", var)
      var.pull!
      var = Report.new
      var.merge!(var.report);Fi[	@Ÿ@Œi[[	@ÒiI"å  
  class HasManyThroughAssociationPolymorphicSourceError < ActiveRecordError
    def function(var, var, var)
      super("STRING")
    end;Fi[	@Òi#I"é  
  class HasManyThroughAssociationPointlessSourceTypeError < ActiveRecordError
    def function(var, var, var)
      super("STRING")
    end;Fi[	@Òi)I"à  
  class HasOneThroughCantAssociateThroughCollection < ActiveRecordError
    def function(var, var, var)
      super("STRING")
    end;Fi[	@åCI""assert(var.expectations_met?);Fi[[	@Ï i;I"Ä      var.pull!
      var = Report.new
      var.merge!(var.report)
      assert(var.expectations_met?)
      assert(var.empty?);Fi[	@Ï iMI"ö      var.pull!
      var = Report.new
      var.merge!(var.report)
      assert(var.expectations_met?)
      assert(var.select_formula("LITERAL").empty?);Fi[	@Ï iaI"Ø      var.pull!
      var = Report.new
      var.merge!(var.report)
      assert(var.expectations_met?)
      assert_equal(["STRING", "STRING"], var.select_formula("LITERAL"));Fi[	I"-dump_formula_report("LITERAL", "STRING");F@∏Ci[[	@ÊivI"©class Report < Hash
  def function
    dump_formula_report("LITERAL", "STRING")
    dump_formula_report("LITERAL", "STRING")
    dump_formula_report("LITERAL", "STRING");Fi[	@ÊiwI"¬  def function
    dump_formula_report("LITERAL", "STRING")
    dump_formula_report("LITERAL", "STRING")
    dump_formula_report("LITERAL", "STRING")
    dump_formula_report("LITERAL", "STRING");Fi[	@ÊixI"π    dump_formula_report("LITERAL", "STRING")
    dump_formula_report("LITERAL", "STRING")
    dump_formula_report("LITERAL", "STRING")
    dump_formula_report("LITERAL", "STRING")
  end;Fi[	I"HOMEBREW_REPOSITORY.cd do;FI"var = UpdaterMock.new;Fi[[	@Ï i1I"s  
  def function
    HOMEBREW_REPOSITORY.cd do
      var = UpdaterMock.new
      var.in_repo_expect("STRING");Fi[	@Ï iCI"á  def function
    var = fixture("STRING")
    HOMEBREW_REPOSITORY.cd do
      var = UpdaterMock.new
      var.in_repo_expect("STRING");Fi[	@Ï iWI"á  def function
    var = fixture("STRING")
    HOMEBREW_REPOSITORY.cd do
      var = UpdaterMock.new
      var.in_repo_expect("STRING");Fi[	I"+if @compilers.include?("LITERAL") then;F@ói[[	@iiI"Ä    ENV.send(case ENV.compiler
    when "LITERAL" then
      if @compilers.include?("LITERAL") then
        "LITERAL"
      else;Fi[	@irI"q        "LITERAL"
      else
        if @compilers.include?("LITERAL") then
          "LITERAL"
        else;Fi[	@i|I"q        "LITERAL"
      else
        if @compilers.include?("LITERAL") then
          "LITERAL"
        else;Fi[	@|I"(var = @url.sub("LITERAL", "STRING");Fi[[	@ÈiôI"ì        safe_system(hgpath, "STRING")
      end
    else
      var = @url.sub("LITERAL", "STRING")
      safe_system(hgpath, "STRING", var, @clone);Fi[	@ÈiæI"æ      puts("STRING")
      Dir.chdir(@clone) { safe_system(bzrpath, "STRING") }
    else
      var = @url.sub("LITERAL", "STRING")
      safe_system(bzrpath, "STRING", "STRING", var, @clone);Fi[	@Èi‹I"∂      puts("STRING")
      safe_system(fossilpath, "STRING", "STRING", @clone)
    else
      var = @url.sub("LITERAL", "STRING")
      safe_system(fossilpath, "STRING", var, @clone);Fi[	I"var.choice("LITERAL") do;F@	i[[	@XijI"Ç      end
      if has_debugger? then
        var.choice("LITERAL") do
          puts("STRING")
          var.restart { debugger };Fi[	@XipI"|      end
      if can_use_readline? then
        var.choice("LITERAL") do
          puts("STRING")
          var.restart do;Fi[	@Xi|I"o        end
      end
      var.choice("LITERAL") do
        puts("STRING")
        interactive_shell(var);Fi[	I"
chdir;F@i[[	@Èi^I"æ    when "LITERAL", "LITERAL", "LITERAL", "LITERAL" then
      safe_system("STRING", "STRING", @tarball_path)
      chdir
    when "LITERAL" then
      raise("STRING") unless which("STRING");Fi[	@ÈibI"∂      raise("STRING") unless which("STRING")
      safe_system("STRING")
      chdir
    when "LITERAL" then
      safe_system("STRING", "STRING", @tarball_path, File.basename(@url));Fi[	@ÈieI"≤    when "LITERAL" then
      safe_system("STRING", "STRING", @tarball_path, File.basename(@url))
      chdir
    when "LITERAL" then
      raise("STRING") unless which("STRING");Fi[	@|@Å2i[[	@
iI"∫    if ARGV.include?("STRING") then
      Formula.each { |var| puts("STRING") }
    else
      if ARGV.include?("STRING") then
        raise(FormulaUnspecifiedError) if ARGV.named.empty?;Fi[	@ä2i
I"ó  if ARGV.include?("STRING") then
    Formula
  else
    if ARGV.include?("STRING") then
      var = Homebrew.outdated_brews.collect { |var| var.name };Fi[	@7iI"é    if ARGV.include?("STRING") then
      exec_browser("STRING")
    else
      if ARGV.include?("STRING") then
        exec_browser("STRING");Fi[	I"if @spec and @ref then;F@;>i[[	@Èi=I"x    var = Dir.getwd
    Dir.chdir(@clone) do
      if @spec and @ref then
        ohai("STRING")
        case @spec;Fi[	@Èi¢I"√    var = Dir.getwd
    Dir.chdir(@clone) do
      if @spec and @ref then
        ohai("STRING")
        safe_system(hgpath, "STRING", "STRING", "STRING", "STRING", @ref, "STRING", "STRING", var);Fi[	@Èi‰I"ö  def function
    safe_system(fossilpath, "STRING", @clone)
    if @spec and @ref then
      ohai("STRING")
      safe_system(fossilpath, "STRING", @ref);Fi[	I"GitDownloadStrategy;F@i[[	@Èi¸I"Ä      BazaarDownloadStrategy
    when "LITERAL" then
      GitDownloadStrategy
    when "LITERAL" then
      GitDownloadStrategy;Fi[	@Èi˛I"É      GitDownloadStrategy
    when "LITERAL" then
      GitDownloadStrategy
    when "LITERAL" then
      MercurialDownloadStrategy;Fi[	@Èi#I"É      CVSDownloadStrategy
    when "LITERAL" then
      GitDownloadStrategy
    when "LITERAL" then
      MercurialDownloadStrategy;Fi[	@ŸI" var = [var.first, var.last];Fi[[	@^iÿI"g      end
      
      def function(var, var, var)
        var = [var.first, var.last]
        var;Fi[	@^i›I"g      end
      
      def function(var, var, var)
        var = [var.first, var.last]
        var;Fi[	@^i‚I"g      end
      
      def function(var, var, var)
        var = [var.first, var.last]
        var;Fi[	@t(I"connection do |var|;Fi[[	@‡"i9I"¿      # Transfers the archived file to the specified remote server
      def function
        var = remote_path_for(@package)
        connection do |var|
          create_remote_path(var, var);Fi[	@i/I"∑      # Transfers the archived file to the specified remote server
      def function
        var = remote_path_for(@package)
        connection do |var|
          var.exec!("STRING");Fi[	@i-I"¿      # Transfers the archived file to the specified remote server
      def function
        var = remote_path_for(@package)
        connection do |var|
          create_remote_path(var, var);Fi[	I"MercurialDownloadStrategy;F@i[[	@Èi I"ä      GitDownloadStrategy
    when "LITERAL" then
      MercurialDownloadStrategy
    when "LITERAL" then
      SubversionDownloadStrategy;Fi[	@ÈiI"ç      FossilDownloadStrategy
    when "LITERAL" then
      MercurialDownloadStrategy
    when "LITERAL" then
      SubversionDownloadStrategy;Fi[	@Èi%I"ã      GitDownloadStrategy
    when "LITERAL" then
      MercurialDownloadStrategy
    when "LITERAL" then
      NoUnzipCurlDownloadStrategy;Fi[	@|@—2i[[	I"6projects//diaspora_proj/models/jobs/http_multi.rb;TiI"¡        if (var < MAX_RETRIES) then
          Resque.enqueue(Jobs::HttpMulti, var, var, var.failed_people, var, (var + "LITERAL"))
        else
          Rails.logger.info("STRING")
        end;Fi[	@Ωi9I"ì        if self.parent_author_signature_valid? then
          self.perform(var)
        else
          Rails.logger.info("STRING")
          return;Fi[	@ÓiZI"â      if self.target_author_signature_valid? then
        self.perform(var)
      else
        Rails.logger.info("STRING")
        return;Fi[	I",ohai(var, var.backtrace) if ARGV.debug?;F@˜%i[[	@—i‘I"ê      puts("STRING")
      puts("STRING")
      ohai(var, var.backtrace) if ARGV.debug?
      @var = true
      ignore_interrupts { var.unlink };Fi[	@—iÈI"v      puts("STRING")
      puts("STRING")
      ohai(var, var.backtrace) if ARGV.debug?
      @var = true
    end;Fi[	@—i˛I"v      opoo("STRING")
      puts("STRING")
      ohai(var, var.backtrace) if ARGV.debug?
      @var = true
    end;Fi[	@ˆ@ri[[	@âi
I"M    
    def function(var)
      super
      @var = nil
      @var = nil;Fi[	@-iI"@  end
    def function
      super
      @var = nil
    end;Fi[	@$i I"D    
    def function(var)
      super
      @var = nil
    end;Fi[	@|I",flash.now["LITERAL"] = I18n.t("STRING");Fi[[	@B!iI"©        var.html { redirect_to("LITERAL") }
      end
    else
      flash.now["LITERAL"] = I18n.t("STRING")
      var = var ? (var.errors.full_messages) : (t("STRING"));Fi[	@B!i-I"      flash.now["LITERAL"] = I18n.t("STRING")
      respond_with(AspectMembership.where("LITERAL" => (@contact.id), "LITERAL" => (@aspect.id)).first)
    else
      flash.now["LITERAL"] = I18n.t("STRING")
      render("LITERAL" => (true), "LITERAL" => "LITERAL");Fi[	@“irI"™          var.js { render("LITERAL" => (var), "LITERAL" => "LITERAL") }
        end
      else
        flash.now["LITERAL"] = I18n.t("STRING")
        respond_to do |var|;Fi[	I"#if (version == "LITERAL") then;F@ói[[	@·iI"R  
  def function
    if (version == "LITERAL") then
      "LITERAL"
    else;Fi[	@·iI"_      "LITERAL"
    else
      if (version == "LITERAL") then
        "LITERAL"
      else;Fi[	@·iI"i        "LITERAL"
      else
        if (version == "LITERAL") then
          "LITERAL"
        else;Fi[	@|@©Ai[[	@¶iÙI"Å        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var);Fi[	@¶i˛I"Å        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var);Fi[	@¶iI"Å        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var);Fi[	@|I"if var.is_a?(String) then;Fi[[	@ƒi)I"Ë              if var.is_a?(Hash) then
                Compass::Configuration::Data.new(var, var)
              else
                if var.is_a?(String) then
                  Compass::Configuration::FileData.new_from_file(var, var);Fi[	@f6i¿I"x    if var.nil? then
      return var
    else
      if var.is_a?(String) then
        var = { "LITERAL" => (var) };Fi[	@iI"~        @var = var.delete("LITERAL")
        @var = var
      else
        if var.is_a?(String) then
          @var = var;Fi[	@“?@i[[	@ iI"¥    case @language
    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING", "STRING"];Fi[	@ iI"–      ["STRING", "STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING"];Fi[	@ i%I"–      ["STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING", "STRING"]
    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING", "STRING"];Fi[	@È'@ò+i[[	@Ì,i I"Grequire("testing_env")
require("formula")
require("test/testball");Fi [	@Ï iI"eabort if ARGV.include?("STRING")
require("testing_env")
require("formula")
require("cmd/update");Fi[	@>i I"Grequire("testing_env")
require("formula")
require("test/testball");Fi [	@|@ Bi[[	@
itI"œ      if @options["LITERAL"] and parent_resource.respond_to?(name) then
        parent_resource.send(name)
      else
        if @options["LITERAL"] then
          if resource_base.respond_to?("STRING") then;Fi[	@
iƒI"™            parent_resource.send((@options["LITERAL"] or name.to_s.pluralize))
          end
        else
          if @options["LITERAL"] then
            resource_class;Fi[	@ui$I"∑      if (@options["LITERAL"] or @options["LITERAL"]) then
        write_crontab(updated_crontab)
      else
        if @options["LITERAL"] then
          write_crontab(whenever_cron);Fi[	@|I"$stderr.puts("STRING");Fi[[	@`i"I"Ô            connection.execute(grant_statement.gsub("LITERAL", "STRING").strip)
            establish_connection(configuration)
          else
            $stderr.puts("STRING")
            $stderr.puts("STRING") if configuration["STRING"];Fi[	I"3projects//compass_proj/compass/exec/helpers.rb;TiI"ó      if var["LITERAL"] then
        var.backtrace["LITERAL"].each { |var| $stderr.puts("STRING") }
      else
        $stderr.puts("STRING")
      end;Fi[	@f6iŸI"r    if File.readable?(var) then
      File.mtime(var).to_i.to_s
    else
      $stderr.puts("STRING")
    end;Fi[	@ﬁ,I"7var.instance_eval { @var = Version.new("STRING") };Fi[[	@Ô'iMI"∫  def function
    require("cmd/cleanup")
    var = TestBall.new
    var.instance_eval { @var = Version.new("STRING") }
    var.active_spec.instance_eval { @var = Version.new("STRING") };Fi[	@Ô'iPI"
    var.instance_eval { @var = Version.new("STRING") }
    var.active_spec.instance_eval { @var = Version.new("STRING") }
    var = TestBall.new
    var.instance_eval { @var = Version.new("STRING") }
    var.active_spec.instance_eval { @var = Version.new("STRING") };Fi[	@Ô'iSI"
    var.instance_eval { @var = Version.new("STRING") }
    var.active_spec.instance_eval { @var = Version.new("STRING") }
    var = TestBall.new
    var.instance_eval { @var = Version.new("STRING") }
    var.active_spec.instance_eval { @var = Version.new("STRING") };Fi[	@ÉDI"Cvar.active_spec.instance_eval { @var = Version.new("STRING") };Fi[[	@Ô'iNI"¬    require("cmd/cleanup")
    var = TestBall.new
    var.instance_eval { @var = Version.new("STRING") }
    var.active_spec.instance_eval { @var = Version.new("STRING") }
    var = TestBall.new;Fi[	@Ô'iQI"Í    var.active_spec.instance_eval { @var = Version.new("STRING") }
    var = TestBall.new
    var.instance_eval { @var = Version.new("STRING") }
    var.active_spec.instance_eval { @var = Version.new("STRING") }
    var = TestBall.new;Fi[	@Ô'iTI"„    var.active_spec.instance_eval { @var = Version.new("STRING") }
    var = TestBall.new
    var.instance_eval { @var = Version.new("STRING") }
    var.active_spec.instance_eval { @var = Version.new("STRING") }
    nostdout do;Fi[	I"var.write("STRING");F@À.i[[	@u"iåI"Ç  def function
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!);Fi[	@u"iúI"Ç  def function
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!);Fi[	@u"i¨I"Ç  def function
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!);Fi[	@|@p6i[[	@È(iAI"ƒ              if (var.version == ActiveRecord::Migrator.current_version) then
                self.connection.schema_cache = var
              else
                warn("STRING")
              end;Fi[	@…iôI"ï      if entities? then
        Array(@attrs["LITERAL"][var.to_sym]).map { |var| var.fetch_or_new(var) }
      else
        warn("STRING")
        [];Fi[	@uiPI"d        var.close!
        exit("LITERAL")
      else
        warn("STRING")
        var.close!;Fi[	@|9I""assert_nil(var.head.checksum);Fi[[	@3i∂I"ª    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url);Fi[	@3i≈I"ª    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url);Fi[	@3i‘I"ª    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url);Fi[	@ÍB@»9i[[	@ÊiI"∫    var = TestLLVMFailure.new
    var = CompilerSelector.new(var)
    assert(var.fails_with?("LITERAL").!)
    assert(var.fails_with?("LITERAL"))
    assert(var.fails_with?("LITERAL").!);Fi[	@Êi<I"≤    var = CompilerSelector.new(var)
    assert(var.fails_with?("LITERAL"))
    assert(var.fails_with?("LITERAL").!)
    assert(var.fails_with?("LITERAL"))
    var.select_compiler;Fi[	@ÊiEI"∆    var = TestMoreMixedCompilerFailures.new
    var = CompilerSelector.new(var)
    assert(var.fails_with?("LITERAL").!)
    assert(var.fails_with?("LITERAL"))
    assert(var.fails_with?("LITERAL"));Fi[	@»9I"var.select_compiler;Fi[[	@Êi$I"√    assert(var.fails_with?("LITERAL"))
    assert(var.fails_with?("LITERAL"))
    assert(var.fails_with?("LITERAL"))
    var.select_compiler
    assert_equal(MacOS.default_compiler, ENV.compiler);Fi[	@Êi=I"∏    assert(var.fails_with?("LITERAL"))
    assert(var.fails_with?("LITERAL").!)
    assert(var.fails_with?("LITERAL"))
    var.select_compiler
    assert_equal("LITERAL", ENV.compiler);Fi[	@ÊiGI"∏    assert(var.fails_with?("LITERAL").!)
    assert(var.fails_with?("LITERAL"))
    assert(var.fails_with?("LITERAL"))
    var.select_compiler
    assert_equal("LITERAL", ENV.compiler);Fi[	@»9@ÍBi[[	@ÊiI"¥    var = CompilerSelector.new(var)
    assert(var.fails_with?("LITERAL").!)
    assert(var.fails_with?("LITERAL"))
    assert(var.fails_with?("LITERAL").!)
    var.select_compiler;Fi[	@Êi;I"¬    var = TestMixedCompilerFailures.new
    var = CompilerSelector.new(var)
    assert(var.fails_with?("LITERAL"))
    assert(var.fails_with?("LITERAL").!)
    assert(var.fails_with?("LITERAL"));Fi[	@ÊicI"œ    var = TestBlockWithoutBuildCompilerFailure.new
    var = CompilerSelector.new(var)
    assert(var.fails_with?("LITERAL"))
    assert(var.fails_with?("LITERAL").!)
    assert(var.fails_with?("LITERAL").!);Fi[	@¢%@ÿ7i[[	@ñi«I"ÿ      # You can also pass the resource name as the first argument to skip that resource.
      def function(var)
        var = var.extract_options!
        var = var.first
        cancan_skipper["LITERAL"][var] = var;Fi[	@ñi◊I"ÿ      # You can also pass the resource name as the first argument to skip that resource.
      def function(var)
        var = var.extract_options!
        var = var.first
        cancan_skipper["LITERAL"][var] = var;Fi[	@
iI"Ω  class ControllerResource
    def self.add_before_filter(var, var, var)
      var = var.extract_options!
      var = var.first
      var = var.delete("LITERAL") ? ("LITERAL") : ("LITERAL");Fi[	@|@∫ i[[	@i8I"®          (var << "STRING") unless var.directory?
          (var << "STRING")
        else
          (var << "STRING")
          (var << "STRING") unless var.directory?;Fi[	@iJI"Ü            (var << "STRING")
            (var << "STRING")
          else
            (var << "STRING")
            (var << "STRING");Fi[	@iNI"ö            (var << "STRING")
          end
        else
          (var << "STRING")
          f.plist_startup ? ((var << "STRING")) : ((var << "STRING"));Fi[	@!6@4i[[	@J
iI"`  def function(var)
    var = []
    var.each do |var|
      case var
      when Array then;Fi[	@J
i=I"`  def function(var)
    var = []
    var.each do |var|
      case var
      when Array then;Fi[	@i/I"°      def function(var, var, var)
        var = Nokogiri::XML::Element.new(var, self, &var)
        var.each do |var|
          case var
          when Hash then;Fi[	@¶D@ú9i[[	@3i∑I"ﬁ    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy);Fi[	@3i∆I"ﬁ    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy);Fi[	@3i’I"ﬁ    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy);Fi[	@|@Ùi[[	@9iRI"‹          [:"#{@base.class.i18n_scope}STRING#{var.model_name.i18n_key}STRING#{var}STRING#{var}", :"#{@base.class.i18n_scope}STRING#{var.model_name.i18n_key}STRING#{var}"]
        end
      else
        var = []
      end;Fi[	@ igI"¥        if var.match("LITERAL") then
          ActiveSupport::Dependencies.constantize(var)
        else
          var = []
          name.scan("LITERAL") { var.unshift("STRING") };Fi[	@	i#I"ß        if var.errors.empty? then
          "STRING"
        else
          var = []
          var.errors.each_pair { |var, var| var.each { |var| (var << "STRING") } };Fi[	@e9I"3assert_instance_of(HeadSoftwareSpec, var.head);Fi[[	@3i∫I"’    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end;Fi[	@3i…I"’    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end;Fi[	@3iÿI"’    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end;Fi[	@!6I""var = ("LITERAL" + "LITERAL");Fi[[	@»iI"©      module ClassMethods
        def function(var)
          var.each do |var|
            var = ("LITERAL" + "LITERAL")
            class_eval("STRING", "STRING", var);Fi[	@»iI"Õ        # reader but prefixes the attribute name with "raw_".
        def function(var)
          var.each do |var|
            var = ("LITERAL" + "LITERAL")
            class_eval("STRING", "STRING", var);Fi[	@»iRI"∑          inherited_reader(*var)
          inherited_writer(*var)
          var.each do |var|
            var = ("LITERAL" + "LITERAL")
            class_eval("STRING", "STRING", var);Fi[	@Í@Íi[[	@i I"VBackup::Dependency.load("STRING")
Backup::Dependency.load("STRING")
module Backup;Fi [	@i I"VBackup::Dependency.load("STRING")
Backup::Dependency.load("STRING")
module Backup;Fi [	@%i I"VBackup::Dependency.load("STRING")
Backup::Dependency.load("STRING")
module Backup;Fi [	I"assert_not_nil(var.head);FI"assert_nil(var.stable);Fi[[	@3i±I"Ñ  def function
    var = HeadOnlySpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle);Fi[	@3i¿I"å  def function
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle);Fi[	@3iœI"å  def function
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle);Fi[	@|I"if var.empty? then;Fi[[	I"Bprojects//diaspora_proj/controllers/invitations_controller.rb;Ti4I"ß    if var.empty? then
      flash["LITERAL"] = t("STRING")
    else
      if var.empty? then
        flash["LITERAL"] = t("STRING", "LITERAL" => (var.join("STRING")));Fi[	@Ei7I"»      if var.empty? then
        flash["LITERAL"] = t("STRING", "LITERAL" => (var.join("STRING")))
      else
        if var.empty? then
          flash["LITERAL"] = (t("STRING") + var.join("STRING"));Fi[	@ÏiòI"l        @var = var
        return if var
      else
        if var.empty? then
          var = "STRING";Fi[	@EI"assert_nil(var.bottle);Fi[[	@3i≤I"è    var = HeadOnlySpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel);Fi[	@3i¡I"ó    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel);Fi[	@3i–I"ó    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel);Fi[	@n
@‰(i[[	@¨9i"I"o      else
        Rails.logger.warn("STRING")
        # do nothing
      end)
    rescue NameError => var;Fi[	@i~I"9      end
    else
      # do nothing
    end)
  end;Fi[	@’i™I"›            catch("LITERAL") do
              Nokogiri::HTML::SAX::Parser.new(JumpSAXHandler.new("LITERAL".to_s)).parse(var)
              # do nothing
            end)
          rescue Nokogiri::SyntaxError, RuntimeError;Fi[	@n
@|i[[	@ziI"∑        if user_recipients.empty? then
          Logger.warn("STRING")
          # do nothing
        else
          ("STRING" + user_recipients.map { |var| "STRING" }.join("STRING"));Fi[	@¨9i'I"~      if var.message =~ "LITERAL" then
        Rails.logger.debug("STRING")
        # do nothing
      else
        raise;Fi[	@"
iI"◊      var = OEmbed::Providers.get(self.url, "LITERAL" => "LITERAL", "LITERAL" => "LITERAL", "LITERAL" => "LITERAL", "LITERAL" => "LITERAL")
    rescue => var
      # do nothing
    else
      (self.data = var.fields;Fi[	@|@a6i[[	@≥iI"q            end
          end
        else
          var = var.to_s
          if var.include?("STRING") then;Fi[	@≥i1I"ò        if var.is_a?(Hash) then
          var
        else
          var = var.to_s
          var.split("STRING").first.to_sym if var.include?("STRING");Fi[	@kibI"{        var, var = scaling(var, var)
        var = cropping(var, var, var)
      else
        var = var.to_s
      end;Fi[	I"Logger.warn("STRING");F@n
i[[	@ziÊI"g          "STRING"
        else
          Logger.warn("STRING")
          # do nothing
        end;Fi[	@ziI"}      def function
        if user_recipients.empty? then
          Logger.warn("STRING")
          # do nothing
        else;Fi[	@zi"I"Ç              import_key(var, var)
            else
              Logger.warn("STRING")
              # do nothing
            end;Fi[	@ø	@«=i[[	@“i∂I"A  
  def function
    begin
      yield
    rescue TypeError;Fi[	I"0projects//diaspora_proj/models/jobs/base.rb;TiI"b    
    def self.suppress_annoying_errors(var)
      begin
        yield
      rescue => var;Fi[	@k
iõI"s    # that were made to the object involved.
    def function
      begin
        yield
      rescue Exception;Fi[	@ø	@N i[[	@Ui I"W      
      def function
        begin
          execute("STRING")
        rescue;Fi[	@UiI"_      #:nodoc:
      def function
        begin
          execute("STRING")
        rescue;Fi[	@UiI"_      #:nodoc:
      def function
        begin
          execute("STRING")
        rescue;Fi[	@|@±8i[[	@Ai‡I"ù      if var.respond_to?("LITERAL") then
        var.model_name
      else
        if var.respond_to?("LITERAL") then
          var.to_model.class.model_name;Fi[	@ƒi"I"Ω          if var.is_a?(Compass::Configuration::Data) then
            var
          else
            if var.respond_to?("LITERAL") then
              var ||= var.to_s if var.is_a?(Pathname);Fi[	@	iòI"~        when Hash then
          var
        else
          if var.respond_to?("LITERAL") then
            var.call(self);Fi[	I"/#       Version: GnuPG v1.4.12 (GNU/Linux);F@i[[	@zi|I"Î      #     enc.keys['joe@example.com'] = <<-EOS
      #       -----BEGIN PGP PUBLIC KEY BLOCK-----
      #       Version: GnuPG v1.4.12 (GNU/Linux)
      #
      #       mQMqBEd5F8MRCACfArHCJFR6nkmxNiW+UE4PAW3bQla9JWFqCwu4VqLkPI/lHb5p;Fi[	@ziàI"Ï      #     enc.keys['mary@example.com'] = <<-EOS
      #       -----BEGIN PGP PUBLIC KEY BLOCK-----
      #       Version: GnuPG v1.4.12 (GNU/Linux)
      #
      #       2SlVmAGHOCJhShx1vfNGVYNxHff8Fzy2O89BxD/6in9kGvD0+mhXSDxsJn2oNK50;Fi[	@ziI"Ò      #     encryptor.keys['joe@example.com'] = <<-EOS
      #       -----BEGIN PGP PUBLIC KEY BLOCK-----
      #       Version: GnuPG v1.4.12 (GNU/Linux)
      #
      #       mI0EUBR6CwEEAMVSlFtAXO4jXYnVFAWy6chyaMw+gXOFKlWojNXOOKmE3SujdLKh;Fi[	I"1#       -----BEGIN PGP PUBLIC KEY BLOCK-----;F@aEi[[	@zi{I"§      #
      #     enc.keys['joe@example.com'] = <<-EOS
      #       -----BEGIN PGP PUBLIC KEY BLOCK-----
      #       Version: GnuPG v1.4.12 (GNU/Linux)
      #;Fi[	@ziáI"•      #
      #     enc.keys['mary@example.com'] = <<-EOS
      #       -----BEGIN PGP PUBLIC KEY BLOCK-----
      #       Version: GnuPG v1.4.12 (GNU/Linux)
      #;Fi[	@ziI"¬      #     encryptor.keys = {}
      #     encryptor.keys['joe@example.com'] = <<-EOS
      #       -----BEGIN PGP PUBLIC KEY BLOCK-----
      #       Version: GnuPG v1.4.12 (GNU/Linux)
      #;Fi[	@EI"assert_nil(var.devel);Fi[[	@3i≥I"ò    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec);Fi[	@3i¬I"ò    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec);Fi[	@3i—I"ò    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec);Fi[	@|@:i[[	@± i6I"á    if method_defined?("LITERAL") then
      alias "LITERAL" "LITERAL"
    else
      def function
        Script::String.new("STRING");Fi[	@Èi¶I"v        "STRING"
      end
    else
      def function
        "STRING".encode(Encoding.find(options["LITERAL"]));Fi[	@Ïi#I"é    if (RUBY_VERSION < "STRING") then
      attr_reader :function
    else
      def function
        var = Encoding.find(@options["LITERAL"]);Fi[	@|@£i[[	@i’I"\        # do nothing
      end
    else
      def function(var)
        unless var then;Fi[	@x/i–I"}    if (RUBY_VERSION < "STRING") then
      attr_writer("LITERAL")
    else
      def function(var)
        return unless var;Fi[	@ijI"y        var.gsub("LITERAL", "STRING")
      end
    else
      def function(var)
        if var.valid_encoding? then;Fi[	@sE@{9i[[	@3i¥I"´    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version);Fi[	@3i√I"´    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version);Fi[	@3i“I"´    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version);Fi[	@ø	I"(require("rubygems");Fi[[	I"0projects//compass_proj/compass/validator.rb;Ti I"Abegin
  (require("rubygems")
  require("compass-validator"));Fi [	@XiRI"k  if can_use_readline? then
    begin
    begin
      (require("rubygems")
      require("ruby-debug");Fi[	@’i>I"ARGV.extend(HomebrewArgvExtension)
ENV.extend(HomebrewEnvExtension)
begin
  (require("rubygems")
  require("mocha/setup"));Fi[	@Ÿ-@)*i[[	@‡"iI"è        super(var, var)
        @var ||= "LITERAL"
        @var ||= "STRING"
        @var ||= false
        instance_eval(&var) if block_given?;Fi[	@ui I"è        super(var, var)
        @var ||= "LITERAL"
        @var ||= "STRING"
        @var ||= false
        instance_eval(&var) if block_given?;Fi[	@•)iI"x      def function
        load_defaults!
        @var ||= "STRING"
        @var ||= false
        @var = Array.new;Fi[	@<I"+var = eval(IO.read(var), binding, var);Fi[[	@æ1i I"wvar = "STRING"
var = eval(IO.read(var), binding, var)
var["LITERAL"]["LITERAL"] = var["LITERAL"].delete("LITERAL");Fi [	I"Sprojects//state_machine_proj/state_machine/integrations/mongo_mapper/locale.rb;Ti I"wvar = "STRING"
var = eval(IO.read(var), binding, var)
var["LITERAL"]["LITERAL"] = var["LITERAL"].delete("LITERAL");Fi [	I"Nprojects//state_machine_proj/state_machine/integrations/mongoid/locale.rb;Ti I"wvar = "STRING"
var = eval(IO.read(var), binding, var)
var["LITERAL"]["LITERAL"] = var["LITERAL"].delete("LITERAL");Fi [	@<I"var[var].each do |var|;Fi[[	@UiI"·      var = Sequel.mysql(var, "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => "STRING")
      FileUtils.mkdir_p("STRING")
      var = "STRING"
      var[var].each do |var|
        var = var["LITERAL"];Fi[	@pi:I"∑      var = []
      if (var["LITERAL"] or var["LITERAL"]) then
        var = "STRING"
        var[var].each do |var|
          if var["LITERAL"] and (var["LITERAL"] == "STRING") then;Fi[	@piOI"´      var = []
      if var["LITERAL"] and (var["LITERAL"].to_i > "LITERAL") then
        var = "STRING"
        var[var].each do |var|
          var = var["LITERAL"].to_s;Fi[	@ÑB@r7i[[	@ifI"±      # to perform the database dumping process
      def function
        ["STRING", "STRING", "STRING"].map do |var|
          next if send(var).to_s.empty?
          "STRING";Fi[	@idI"˙      # both the host and the socket are specified, the socket will take priority over the host
      def function
        ["STRING", "STRING", "STRING"].map do |var|
          next if send(var).to_s.empty?
          "STRING".gsub("STRING", "STRING");Fi[	@fifI"±      # to perform the database dumping process
      def function
        ["STRING", "STRING", "STRING"].map do |var|
          next if send(var).to_s.empty?
          "STRING";Fi[	I"8# data to the specified path based on the 'trigger';F@:i[[	@i5I"ö      ##
      # Performs the mysqldump command and outputs the
      # data to the specified path based on the 'trigger'
      def function
        super;Fi[	@i5I"ó      ##
      # Performs the pgdump command and outputs the
      # data to the specified path based on the 'trigger'
      def function
        super;Fi[	@ii$I"õ      ##
      # Performs the riak-admin command and outputs the
      # data to the specified path based on the 'trigger'
      def function
        super;Fi[	@¯(I"assert(var.universal?);Fi[[	@u"iI"íclass MachOPathnameTests < Test::Unit::TestCase
  def function
    var = Pathname.new("STRING")
    assert(var.universal?)
    assert(var.i386?.!);Fi[	@u"i5I"j  
  def function
    var = Pathname.new("STRING")
    assert(var.universal?)
    assert(var.i386?.!);Fi[	@u"iCI"j  
  def function
    var = Pathname.new("STRING")
    assert(var.universal?)
    assert(var.i386?.!);Fi[	@ÀE@-i[[	@u"iI"|  def function
    var = Pathname.new("STRING")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!);Fi[	@u"i6I"|  def function
    var = Pathname.new("STRING")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!);Fi[	@u"iDI"|  def function
    var = Pathname.new("STRING")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!);Fi[	@r"I"assert(var.dylib?);Fi[[	@u"iI"â    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?)
    assert(var.mach_o_executable?.!);Fi[	@u"iI"â    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?)
    assert(var.mach_o_executable?.!);Fi[	@u"i,I"á    assert(var.x86_64?)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?)
    assert(var.mach_o_executable?.!);Fi[	@<@Yi[[	@iI"j    end
    if (var.length <= var) and var.! then
      var = "STRING"
      var = "LITERAL"
    else;Fi[	@Ïi4I"Ñ    def function
      return if @to_merge.empty?
      var = "STRING"
      var = "LITERAL"
      @to_merge.each do |var, var, var|;Fi[	@i*I"|    def self.destroy(var, var, var)
      var = var.to_s
      var = "STRING"
      var = "LITERAL"
      if var.empty? then;Fi[	@‹E@ô(i[[	@u"iI"í    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!);Fi[	@u"iI"í    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!);Fi[	@u"i-I"í    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!);Fi[	@ö(I"assert(var.mach_o_bundle?);Fi[[	@u"iKI"¶    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match("LITERAL", file(var));Fi[	@u"iYI"¶    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match("LITERAL", file(var));Fi[	@u"igI"¶    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match("LITERAL", file(var));Fi[	I"(assert_equal("LITERAL", var.length);FI"$assert(var.include?("LITERAL"));Fi[[	I"/projects//homebrew_proj/test/test_utils.rb;TiI"Ã    var = archs_for_command("STRING")
    if `sw_vers -productVersion` =~ "LITERAL" and ($1.to_i >= "LITERAL") then
      assert_equal("LITERAL", var.length)
      assert(var.include?("LITERAL"))
    else;Fi[	@FiI"‘    else
      if `sw_vers -productVersion` =~ "LITERAL" and ($1.to_i == "LITERAL") then
        assert_equal("LITERAL", var.length)
        assert(var.include?("LITERAL"))
        assert(var.include?("LITERAL"));Fi[	@FiI"ê        assert(var.include?("LITERAL"))
      else
        assert_equal("LITERAL", var.length)
        assert(var.include?("LITERAL"))
      end;Fi[	@†A@ïDi[[	@u"iãI"r  
  def function
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!);Fi[	@u"iõI"r  
  def function
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!);Fi[	@u"i´I"r  
  def function
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!);Fi[	@©B@r7i[[	@ciàI"ß      # to perform the database dumping process
      def function
        ["STRING", "STRING"].map do |var|
          next if send(var).to_s.empty?
          "STRING";Fi[	@ciíI"ß      # to perform the database dumping process
      def function
        ["STRING", "STRING"].map do |var|
          next if send(var).to_s.empty?
          "STRING";Fi[	@i\I"¿      # to perform the database dumping process
      def function
        ["STRING", "STRING"].map do |var|
          next if send(var).to_s.empty?
          "STRING".gsub("STRING", "STRING");Fi[	@H@=i[[	@.iI"Q    end
    
    def function(var, var)
      (@html << "STRING")
      self;Fi[	@.i I"Q    end
    
    def function(var, var)
      (@html << "STRING")
      self;Fi[	@.iAI"Q    end
    
    def function(var, var)
      (@html << "STRING")
      self;Fi[	@H@Œi[[	@µi	I"x    class StrategyNotFound < NameError
      def function(var)
        @var = var
        super("STRING")
      end;Fi[	@˛iI"D  
  def function(var)
    @var = var
    super("STRING")
  end;Fi[	@˛iI"D  
  def function(var)
    @var = var
    super("STRING")
  end;Fi[	I" assert_equal([], var.archs);FI"$assert((var.arch == "LITERAL"));Fi[[	@u"iïI"∞    assert(var.mach_o_executable?.!)
    assert(var.text_executable?)
    assert_equal([], var.archs)
    assert((var.arch == "LITERAL"))
    assert_match("LITERAL", file(var));Fi[	@u"i•I"∞    assert(var.mach_o_executable?.!)
    assert(var.text_executable?)
    assert_equal([], var.archs)
    assert((var.arch == "LITERAL"))
    assert_match("LITERAL", file(var));Fi[	@u"iµI"µ    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert_equal([], var.archs)
    assert((var.arch == "LITERAL"))
    assert_no_match("LITERAL", file(var));Fi[	@7@**i[[	@i-I"ó        @var ||= Array.new
        @var ||= Array.new
        @var ||= Array.new
        instance_eval(&var) if block_given?
        @var ||= "LITERAL";Fi[	@i.I"†        @var ||= Array.new
        @var ||= Array.new
        @var ||= Array.new
        instance_eval(&var) if block_given?
        @var ||= utility("LITERAL");Fi[	@fi(I"ê      def function(var, var)
        super(var)
        @var ||= Array.new
        instance_eval(&var) if block_given?
        @var ||= "STRING";Fi[	@HI"var = prep_opts(var, var);Fi[[	@H-iI"n  end
  
  def function(var, var)
    var = prep_opts(var, var)
    var = visible_shareable_ids(var, var);Fi[	@H-iI"g  end
  
  def function(var, var)
    var = prep_opts(var, var)
    visible_ids_from_sql(var, var);Fi[	@H-iI"t  
  # @return [Array<Integer>]
  def function(var, var)
    var = prep_opts(var, var)
    var["LITERAL"] = var;Fi[	@HI"cache_current_values;Fi[[	@AiI"t  class FileAdapter < AbstractAdapter
    def function(var)
      @var = var
      cache_current_values
    end;Fi[	@DiI"í  class StringioAdapter < AbstractAdapter
    def function(var)
      @var = var
      cache_current_values
      @var = copy_to_tempfile(@target);Fi[	@GiI"ú  class UploadedFileAdapter < AbstractAdapter
    def function(var)
      @var = var
      cache_current_values
      if @target.respond_to?("LITERAL") then;Fi[	@˛6I":assert((TARGET_FOLDER + "STRING").exist?.!, "STRING");Fi[[	@æ,iI"ª    with_temp_folder do
      TARGET_FOLDER.install("STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?.!, "STRING")
    end;Fi[	@æ,i?I"˚    with_temp_folder do
      TARGET_FOLDER.install("STRING" => "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?.!, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?.!, "STRING");Fi[	@æ,iII"3      TARGET_FOLDER.install("STRING" => "STRING", "STRING" => "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?.!, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?.!, "STRING");Fi[	@û<@ø<i[[	@\iI"˜    def self.process(var, var, var, var)
      var = Sequel.mysql(var, "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => "STRING")
      FileUtils.mkdir_p("STRING")
      var[QUERY].each do |var|
        var = var["LITERAL"];Fi[	@	iI"˜    def self.process(var, var, var, var)
      var = Sequel.mysql(var, "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => "STRING")
      FileUtils.mkdir_p("STRING")
      var[QUERY].each do |var|
        var = var["LITERAL"];Fi[	@iiI"˜    def self.process(var, var, var, var)
      var = Sequel.mysql(var, "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => "STRING")
      FileUtils.mkdir_p("STRING")
      var[QUERY].each do |var|
        var = var["LITERAL"];Fi[	@¬C@2/i[[	@Ï i2I"ò  def function
    HOMEBREW_REPOSITORY.cd do
      var = UpdaterMock.new
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING");Fi[	@Ï iDI"•    var = fixture("STRING")
    HOMEBREW_REPOSITORY.cd do
      var = UpdaterMock.new
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING");Fi[	@Ï iXI"•    var = fixture("STRING")
    HOMEBREW_REPOSITORY.cd do
      var = UpdaterMock.new
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING");Fi[	@2/@2/i[[	@Ï i5I"¬      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING");Fi[	@Ï iGI"¬      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING");Fi[	@Ï i[I"¬      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING");Fi[	I"url("STRING");FI"sha1("STRING");Fi[[	@€iÇI"M  
  devel do
    url("STRING")
    sha1("STRING")
    version("STRING");Fi[	@€iâI"Q  bottle do
    version("STRING")
    url("STRING")
    sha1("STRING")
  end;Fi[	@€iôI">  
  bottle do
    url("STRING")
    sha1("STRING")
  end;Fi[	@HI"var = var.value;Fi[[	@ŒiI"ümodule Compass::SassExtensions::Functions::InlineImage
  def function(var, var)
    var = var.value
    var = File.join(Compass.configuration.images_path, var);Fi[	@f6i4I"Ñ    end
    
    def function(var, var)
      var = var.value
      return Sass::Script::String.new("STRING") if absolute_path?(var);Fi[	@f6i{I"û    end
    
    def function(var, var)
      var = var.value
      if var =~ /^#{Regexp.escape(Compass.configuration.http_generated_images_path)}STRING/ then;Fi[	I"I# Yields to the block the compressor command and filename extension.;F@:i[[	@”1iI"      
      ##
      # Yields to the block the compressor command and filename extension.
      def function
        log!;Fi[	@3*iI"∫      
      ##
      # Yields to the block the compressor command and filename extension.
      def function
        Backup::Logger.warn(((("STRING" + "STRING") + "STRING") + "STRING"));Fi[	@6*i$I"∫      
      ##
      # Yields to the block the compressor command and filename extension.
      def function
        Backup::Logger.warn(((("STRING" + "STRING") + "STRING") + "STRING"));Fi[	I"8# Returns the parsed value and any trailing tokens.;F@£i[[	@˝i+I"º    
    # Parses a "value" in the sense of RFC 4627.
    # Returns the parsed value and any trailing tokens.
    def function(var)
      raise(Error, "STRING") if (var.length < "LITERAL");Fi[	@˝i<I"§    
    # Parses an "object" in the sense of RFC 4627.
    # Returns the parsed value and any trailing tokens.
    def function(var)
      var = eat("STRING", var);Fi[	@˝iWI"£    
    # Parses an "array" in the sense of RFC 4627.
    # Returns the parsed value and any trailing tokens.
    def function(var)
      var = eat("STRING", var);Fi[	@	@-Di[[	@—i”I"~      onoe("STRING")
      puts("STRING")
      puts("STRING")
      ohai(var, var.backtrace) if ARGV.debug?
      @var = true;Fi[	@—iËI"~      onoe("STRING")
      puts("STRING")
      puts("STRING")
      ohai(var, var.backtrace) if ARGV.debug?
      @var = true;Fi[	@—i˝I"Ö    rescue Exception => var
      opoo("STRING")
      puts("STRING")
      ohai(var, var.backtrace) if ARGV.debug?
      @var = true;Fi[	I"F["LITERAL", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]];F@îi[[	@˝iòI"‘        strtok(var)
      when Spc then
        ["LITERAL", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then
        ["LITERAL", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]];Fi[	@˝iöI"        ["LITERAL", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then
        ["LITERAL", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then
        ["LITERAL", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]];Fi[	@˝iúI"        ["LITERAL", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then
        ["LITERAL", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then
        ["LITERAL", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]];Fi[	@<"@!6i[[	@biOI"n    
    def function(var)
      var = {}
      var.each do |var|
        var = var.split("STRING").first;Fi[	@1iaI"ê      unless var.empty? then
        var = current_time_from_proper_timezone
        var = {}
        var.each do |var|
          var = var.to_s;Fi[	@iI"r  
  def function(var)
    var = {}
    var.each do |var|
      var = var.recursive_deps.uniq.reject do |var|;Fi[	@H@‡Bi[[	@ixI"¬      # @raise [Haml::Error] if none of \{#compile}, \{#render}, and
      #   \{#render_with_options} are overridden
      def function(var, var)
        var = self
        var.instance_eval do;Fi[	@Ì
iI"c  #
  # Returns an array
  def function(var, var)
    var = self
    if var.has_key?(var) then;Fi[	@JiI"°      
      # Creates a new named scope with the given name
      def function(var, var)
        var = self
        owner_class.def_dataset_method(var) do |var|;Fi[	I"*raise(Utf8Error) if (var < "LITERAL");FI"%var = var[(var + "LITERAL")].ord;Fi[[	@˝i∆I"         end
        raise(Utf8Error) if (var < Utag2)
        raise(Utf8Error) if (var < "LITERAL")
        var = var[(var + "LITERAL")].ord
        raise(Utf8Error) if ((var < Utagx) or (Utag2 <= var));Fi[	@˝i—I"ª          return "LITERAL"
        end
        raise(Utf8Error) if (var < "LITERAL")
        var = var[(var + "LITERAL")].ord
        raise(Utf8Error) if ((var < Utagx) or (Utag2 <= var));Fi[	@˝i‹I"ª          return "LITERAL"
        end
        raise(Utf8Error) if (var < "LITERAL")
        var = var[(var + "LITERAL")].ord
        raise(Utf8Error) if ((var < Utagx) or (Utag2 <= var));Fi[	@µFI":raise(Utf8Error) if ((var < Utagx) or (Utag2 <= var));Fi[[	@˝i«I"‹        raise(Utf8Error) if (var < Utag2)
        raise(Utf8Error) if (var < "LITERAL")
        var = var[(var + "LITERAL")].ord
        raise(Utf8Error) if ((var < Utagx) or (Utag2 <= var))
        if (var < Utag3) then;Fi[	@˝i“I"æ        end
        raise(Utf8Error) if (var < "LITERAL")
        var = var[(var + "LITERAL")].ord
        raise(Utf8Error) if ((var < Utagx) or (Utag2 <= var))
        if (var < Utag4) then;Fi[	@˝i›I"æ        end
        raise(Utf8Error) if (var < "LITERAL")
        var = var[(var + "LITERAL")].ord
        raise(Utf8Error) if ((var < Utagx) or (Utag2 <= var))
        if (var < Utag5) then;Fi[	I"!# Read the YAML frontmatter.;F@i[[	@iI"u    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.;Fi[	@i I"u    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.;Fi[	@
i>I"u    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.;Fi[	@	@˜%i[[	@—iI"Ñ        unless ORIGINAL_PATHS.include?(var) then
          opoo("STRING")
          puts("STRING")
          @var = true
        end;Fi[	@—iI"]      opoo("STRING")
      puts("STRING")
      puts("STRING")
      @var = true
    end;Fi[	@—i$I"]      opoo("STRING")
      puts("STRING")
      puts("STRING")
      @var = true
    end;Fi[	@	@ø	i[[	@BiI"z      puts("STRING")
      puts("STRING")
      puts("STRING")
      begin
        var.verify_download_integrity(var);Fi[	@Xi^I"Udef function(var, var)
  puts("STRING")
  puts("STRING")
  begin
    var = false;Fi[	@}iI"m      var = var["STRING"]
      var = var["STRING"]
      puts("STRING")
      begin
        var.process;Fi[	I"=# base - The String path to the dir containing the file.;FI".# name - The String filename of the file.;Fi[[	@iI"ó    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #;Fi[	@i"I"ó    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #;Fi[	@
i@I"ó    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #;Fi[	@·F@i[[	@iI"ç    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.;Fi[	@i#I"ç    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.;Fi[	@
iAI"ç    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.;Fi[	I"$# Returns the formatted String.;F@£i[[	@@i+I"}    # date - The Time to format.
    #
    # Returns the formatted String.
    def function(var)
      var.strftime("STRING");Fi[	@@i9I"|    #   # => "2011-04-24T20:34:46+08:00"
    #
    # Returns the formatted String.
    def function(var)
      var.xmlschema;Fi[	@@isI"    #   # => "apples, oranges, and grapes"
    #
    # Returns the formatted String.
    def function(var)
      var = "STRING";Fi[	@¨*I"var.puts(var.to_yaml);Fi[[	I"5projects//jekyll_proj/jekyll/migrators/marley.rb;TiI"“        var = File.dirname(var).split("LITERAL").last.gsub("LITERAL", "STRING")
        var = "STRING"
        File.open("STRING", "STRING") do |var|
          var.puts(var.to_yaml)
          var.puts("STRING");Fi[	@
,iI"¬        var = "STRING"
        var = { "STRING" => "STRING", "STRING" => (var.title) }
        File.open("STRING", "STRING") do |var|
          var.puts(var.to_yaml)
          var.puts("STRING");Fi[	@Äi$I"¶        begin
          (FileUtils.mkdir_p("STRING")
          File.open("STRING", "STRING") do |var|
            var.puts(var.to_yaml)
            var.puts("STRING");Fi[	@H@\$i[[	@Ui˚I"m      end
      
      def function(var, var)
        if var["LITERAL"] then
          (var << "STRING");Fi[	@*iKI"í      private
      
      def function(var, var)
        if var["LITERAL"] then
          File.basename(strip_trailing_separator(var["LITERAL"]));Fi[	@*iSI"}      end
      
      def function(var, var)
        if var["LITERAL"] then
          if absolute_path?(var["LITERAL"]) then;Fi[	@H@a6i[[	@Ω%i9I"•      
      # Wrap write_attribute to remember original attribute value.
      def function(var, var)
        var = var.to_s
        if attribute_changed?(var) then;Fi[	@ %iI"’      # specified +value+. Empty strings for fixnum and float columns are
      # turned into +nil+.
      def function(var, var)
        var = var.to_s
        if (var == "STRING") and self.class.primary_key then;Fi[	@1i…I"ú    # * Updates all the attributes that are dirty in this object.
    #
    def function(var, var)
      var = var.to_s
      verify_readonly_attribute(var);Fi[	@HI"@var, @var = var, var;Fi[[	@piI"x      attr_reader("LITERAL", "LITERAL")
      
      def function(var, var)
        @var, @var = var, var
      end;Fi[	@	?i
I"ì      delegate("LITERAL", "LITERAL", "LITERAL" => (ActiveRecord::Base))
      
      def function(var, var)
        @var, @var = var, var
      end;Fi[	@»i&I"w        
        class ArrayProxy
          def function(var, var)
            @var, @var = var, var
          end;Fi[	I")def self.process(var, var, var, var);F@ù<i[[	@\iI"’    QUERY = "STRING"
    
    def self.process(var, var, var, var)
      var = Sequel.mysql(var, "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => "STRING")
      FileUtils.mkdir_p("STRING");Fi[	@	iI"’    QUERY = "STRING"
    
    def self.process(var, var, var, var)
      var = Sequel.mysql(var, "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => "STRING")
      FileUtils.mkdir_p("STRING");Fi[	@iiI"’    QUERY = "STRING"
    
    def self.process(var, var, var, var)
      var = Sequel.mysql(var, "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => "STRING")
      FileUtils.mkdir_p("STRING");Fi[	@H@<"i[[	@ÅiI"µ      # extended datatypes (Example: Adding an array option in the
      # PostgreSQLAdapter)
      def function(var, var)
        var = {}
        var["LITERAL"] = var.name.inspect;Fi[	@ãiÃI"g    end
    
    def function(var, var)
      var = {}
      relevant_rules(var, var).map do |var|;Fi[	@ÎiπI"î      # @param count [Integer]
      # @return [Array]
      def function(var, var)
        var = {}
        var["LITERAL"] = MAX_TWEETS_PER_REQUEST;Fi[	@˚F@O+i[[	@˛Fi I"¶        var = "STRING"
        File.open("STRING", "STRING") do |var|
          var.puts(var.to_yaml)
          var.puts("STRING")
          var.puts("STRING") if var;Fi[	@
,iI"œ        var = { "STRING" => "STRING", "STRING" => (var.title) }
        File.open("STRING", "STRING") do |var|
          var.puts(var.to_yaml)
          var.puts("STRING")
          var.puts(var.description);Fi[	@Äi%I"           (FileUtils.mkdir_p("STRING")
          File.open("STRING", "STRING") do |var|
            var.puts(var.to_yaml)
            var.puts("STRING")
            var.puts(var.at("STRING").inner_text);Fi[	@¬;I"=File.open(File.join(local_path, var), "STRING") do |var|;Fi[[	@oi2I"
        var = remote_path_for(@package)
        files_to_transfer_for(@package) do |var, var|
          Logger.message("STRING")
          File.open(File.join(local_path, var), "STRING") do |var|
            connection.put_object(container, File.join(var, var), var);Fi[	@¯	iTI"˝        var = remote_path_for(@package)
        files_to_transfer_for(@package) do |var, var|
          Logger.message("STRING")
          File.open(File.join(local_path, var), "STRING") do |var|
            connection.put_file(File.join(var, var), var);Fi[	@ri:I"        var = directory_for(var, true)
        files_to_transfer_for(@package) do |var, var|
          Logger.message("STRING")
          File.open(File.join(local_path, var), "STRING") do |var|
            var.files.create("LITERAL" => (var), "LITERAL" => (var));Fi[	@¬;@|i[[	@÷iRI"£      var.run
      if var.success? then
        Logger.message("STRING")
      else
        raise(Errors::Archive::PipelineError, ("STRING" + var.error_messages));Fi[	@iDI"Æ        var.run
        if var.success? then
          Logger.message("STRING")
        else
          raise(Errors::Database::PipelineError, ("STRING" + var.error_messages));Fi[	@iDI"Æ        var.run
        if var.success? then
          Logger.message("STRING")
        else
          raise(Errors::Database::PipelineError, ("STRING" + var.error_messages));Fi[	@Ë=@¬;i[[	@÷iQI"q      (var << "STRING")
      var.run
      if var.success? then
        Logger.message("STRING")
      else;Fi[	@iCI"{        (var << "STRING")
        var.run
        if var.success? then
          Logger.message("STRING")
        else;Fi[	@iCI"{        (var << "STRING")
        var.run
        if var.success? then
          Logger.message("STRING")
        else;Fi[	I"# Obtain destination path.;F@i[[	@iuI"k    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.;Fi[	@
i¡I"k    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.;Fi[	@ÌiI"k    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.;Fi[	@4I"when Integer then;Fi[[	@´iBI"}      # @return [Hash]
      def function(var, var)
        case var
        when Integer then
          var["LITERAL"] = var;Fi[	@iäI"¶      # @return [Hash]
      def function(var, var, var)
        case var
        when Integer then
          var[[var, "STRING"].compact.join("STRING").to_sym] = var;Fi[	@i®I"É        var, var = [], []
        var.flatten.each do |var|
          case var
          when Integer then
            (var << var);Fi[	I"require_all("STRING");F@bGi[[	@8i%I"|require("jekyll/generator")
require("jekyll/command")
require_all("STRING")
require_all("STRING")
require_all("STRING");Fi[	@8i&I"vrequire("jekyll/command")
require_all("STRING")
require_all("STRING")
require_all("STRING")
require_all("STRING");Fi[	@8i'I"jrequire_all("STRING")
require_all("STRING")
require_all("STRING")
require_all("STRING")
module Jekyll;Fi[	I"+var = var.value["LITERAL"].value.first;FI",var.value["LITERAL"].value = ["STRING"];Fi[[	@Ùi*I"\        var.each do |var|
          if var.value["LITERAL"].value["LITERAL"].value["LITERAL"] =~ "LITERAL" then
            var = var.value["LITERAL"].value.first
            var.value["LITERAL"].value = ["STRING"]
            var.value["LITERAL"] = Node.new("LITERAL", [var.value["LITERAL"].value["LITERAL"], Node.new("LITERAL", ["STRING", var])]);Fi[	@Ùi3I"Ö          if ["STRING", "STRING"].include?(var.value["LITERAL"].value.first) then
            var = var.value["LITERAL"].value.first.gsub("LITERAL", "STRING")
            var = var.value["LITERAL"].value.first
            var.value["LITERAL"].value = ["STRING"]
            var.value["LITERAL"] = Node.new("LITERAL", [Node.new("LITERAL", ["STRING"]), Node.new("LITERAL", ["STRING", var])]);Fi[	@Ùi8I">          else
            if ("STRING" == var.value["LITERAL"].value.first) then
              var = var.value["LITERAL"].value.first
              var.value["LITERAL"].value = ["STRING"]
              var.value["LITERAL"] = Node.new("LITERAL", [Node.new("LITERAL", ["STRING"]), Node.new("LITERAL", ["STRING", var])]);Fi[	@£I"it("STRING") do;Fi[[	@¡@iI"ã      end
      
      def function(var)
        it("STRING") do
          expect((last_request.env["STRING"] or {})["STRING"]).to(eq(var));Fi[	@¡@iI"ã      end
      
      def function(var)
        it("STRING") do
          expect((last_request.env["STRING"] or {})["STRING"]).to(eq(var));Fi[	@¡@iI"ã      end
      
      def function(var)
        it("STRING") do
          expect((last_request.env["STRING"] or {})["STRING"]).to(eq(var));Fi[	@£I"Pvar = [Hash, String, Symbol].include?(var.last.class).! ? (var.pop) : (nil);Fi[[	@(iFI"      # For more information see Nokogiri::XML::Node#css and
      # Nokogiri::XML::Node#xpath
      def function(var)
        var = [Hash, String, Symbol].include?(var.last.class).! ? (var.pop) : (nil)
        var = var.last.is_a?(Hash) ? (var.pop) : (nil);Fi[	@(iWI"„      #
      # For more information see Nokogiri::XML::Node#css
      def function(var)
        var = [Hash, String, Symbol].include?(var.last.class).! ? (var.pop) : (nil)
        var = var.last.is_a?(Hash) ? (var.pop) : (nil);Fi[	@(ikI"Â      #
      # For more information see Nokogiri::XML::Node#xpath
      def function(var)
        var = [Hash, String, Symbol].include?(var.last.class).! ? (var.pop) : (nil)
        var = var.last.is_a?(Hash) ? (var.pop) : (nil);Fi[	@	D@öi[[	@^iŸI"g      
      def function(var, var, var)
        var = [var.first, var.last]
        var
      end;Fi[	@^iﬁI"g      
      def function(var, var, var)
        var = [var.first, var.last]
        var
      end;Fi[	@^i„I"g      
      def function(var, var, var)
        var = [var.first, var.last]
        var
      end;Fi[	@£I"var = destination(var);Fi[[	@iÄI"    #
    # Returns nothing.
    def function(var)
      var = destination(var)
      FileUtils.mkdir_p(File.dirname(var));Fi[	@
i—I"    #
    # Returns nothing.
    def function(var)
      var = destination(var)
      FileUtils.mkdir_p(File.dirname(var));Fi[	@Ìi6I"π    #
    # Returns false if the file was not modified since last time (no-op).
    def function(var)
      var = destination(var)
      return false if File.exist?(var) and modified?.!;Fi[	@`&@ú?i[[	@r&iI"amodule Nokogiri
  module HTML
    module SAX
      class Parser < Nokogiri::XML::SAX::Parser;Fi[	@∑"iI"omodule Nokogiri
  module HTML
    module SAX
      class ParserContext < Nokogiri::XML::SAX::ParserContext;Fi[	@˜iI"Hmodule Nokogiri
  module HTML
    module SAX
      class PushParser;Fi[	@£I"4if (var["LITERAL", "LITERAL"] == "STRING") then;Fi[[	@˝i§I"{    end
    
    def function(var)
      if (var["LITERAL", "LITERAL"] == "STRING") then
        ["LITERAL", "STRING", nil];Fi[	@˝i¨I"|    end
    
    def function(var)
      if (var["LITERAL", "LITERAL"] == "STRING") then
        ["LITERAL", "STRING", true];Fi[	@˝i¥I"}    end
    
    def function(var)
      if (var["LITERAL", "LITERAL"] == "STRING") then
        ["LITERAL", "STRING", false];Fi[	@ÎI"module Encryptor;Fi[[	@û>i I"4module Backup
  module Encryptor
    class Base;Fi [	@zi I":module Backup
  module Encryptor
    class GPG < Base;Fi [	@1i I">module Backup
  module Encryptor
    class OpenSSL < Base;Fi [	@π$@ÅFi[[	@”1iI"õ      include(Backup::Configuration::Helpers)
      
      ##
      # Yields to the block the compressor command and filename extension.
      def function;Fi[	@3*iI"|      end
      
      ##
      # Yields to the block the compressor command and filename extension.
      def function;Fi[	@6*i#I"|      end
      
      ##
      # Yields to the block the compressor command and filename extension.
      def function;Fi[	@@I"if var["LITERAL"].! then;Fi[[	@i)I"      def function(var)
        if Nokogiri.jruby? then
          var = var.first.is_a?(Hash) ? (var.shift) : ({})
          if var["LITERAL"].! then
            var["LITERAL"] = Node::SaveOptions::NO_DECLARATION.|(Node::SaveOptions::NO_EMPTY_TAGS).|(Node::SaveOptions::AS_HTML);Fi[	@i7I"      def function(var)
        if Nokogiri.jruby? then
          var = var.first.is_a?(Hash) ? (var.shift) : ({})
          if var["LITERAL"].! then
            var["LITERAL"] = Node::SaveOptions::NO_DECLARATION.|(Node::SaveOptions::NO_EMPTY_TAGS).|(Node::SaveOptions::AS_XHTML);Fi[	@(iˆI"      def function(var)
        if Nokogiri.jruby? then
          var = var.first.is_a?(Hash) ? (var.shift) : ({})
          if var["LITERAL"].! then
            var["LITERAL"] = Node::SaveOptions::NO_DECLARATION.|(Node::SaveOptions::NO_EMPTY_TAGS).|(Node::SaveOptions::AS_HTML);Fi[	I"2# Returns self, to support chaining of calls.;F@i[[	@ÿi)I"Ú      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns self, to support chaining of calls.
      #
      # Also see related method +add_previous_sibling+.;Fi[	@ÿi5I"Ó      # +node_or_tags+ can be a Nokogiri::XML::Node, a Nokogiri::XML::DocumentFragment, or a string containing markup.
      #
      # Returns self, to support chaining of calls.
      #
      # Also see related method +add_next_sibling+.;Fi[	@ÿiwI"Â      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns self, to support chaining of calls.
      #
      # Also see related method +replace+.;Fi[	@£I"if is_haml? then;Fi[[	@⁄iI"¨    alias_method("LITERAL", "LITERAL")
    
    def function(var)
      if is_haml? then
        if Haml::Util.rails_xss_safe? and var.is_a?(ActiveSupport::SafeBuffer) then;Fi[	@;iêI"ä    
    module TextHelper
      def function(var)
        if is_haml? then
          haml_buffer.buffer.concat(haml_xss_html_escape(var));Fi[	@;iúI"â      alias_method("LITERAL", "LITERAL")
      
      def function(var)
        if is_haml? then
          haml_buffer.buffer.concat(var);Fi[	@Î@Í&i[[	@i I"<module Backup
  module Configuration
    module Helpers;Fi [	I"8projects//backup_proj/backup/configuration/store.rb;TiI"Yrequire("ostruct")
module Backup
  module Configuration
    class Store < OpenStruct;Fi[	I"2projects//backup_proj/backup/configuration.rb;TiI"}  require(File.expand_path("../configuration/#{file}", "(string)"))
end
module Backup
  module Configuration
    extend(self);Fi[	I"u# +node_or_tags+ can be a Nokogiri::XML::Node, a Nokogiri::XML::DocumentFragment, or a string containing markup.;F@i[[	@ÿi3I"˚      ####
      # Insert +node_or_tags+ after this node (as a sibling).
      # +node_or_tags+ can be a Nokogiri::XML::Node, a Nokogiri::XML::DocumentFragment, or a string containing markup.
      #
      # Returns self, to support chaining of calls.;Fi[	@ÿi?I"⁄      ####
      # Set the inner html for this Node to +node_or_tags+
      # +node_or_tags+ can be a Nokogiri::XML::Node, a Nokogiri::XML::DocumentFragment, or a string containing markup.
      #
      # Returns self.;Fi[	@ÿiKI"N      ####
      # Set the inner html for this Node +node_or_tags+
      # +node_or_tags+ can be a Nokogiri::XML::Node, a Nokogiri::XML::DocumentFragment, or a string containing markup.
      #
      # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).;Fi[	@π$I"4# Name of the database that needs to get dumped;Fi[[	@ciI"r      attr_accessor("LITERAL")
      
      ##
      # Name of the database that needs to get dumped
      ##;Fi[	@iI"      attr_deprecate("LITERAL", "LITERAL" => "STRING", "LITERAL" => "STRING", "LITERAL" => (lambda { |var, var| var.mysqldump_utility = var }))
      
      ##
      # Name of the database that needs to get dumped
      # To dump all databases, set this to `:all` or leave blank.;Fi[	@iI"‹      attr_deprecate("LITERAL", "LITERAL" => "STRING", "LITERAL" => "STRING", "LITERAL" => (lambda { |var, var| var.pg_dump_utility = var }))
      
      ##
      # Name of the database that needs to get dumped
      ##;Fi[	@£@MBi[[	@_'ilI"z  end
  
  def function(var)
    return image_url if (var == "STRING")
    if (var.nil? or var.match("LITERAL")) then;Fi[	@_'iuI"z  end
  
  def function(var)
    return image_url if (var == "STRING")
    if (var.nil? or var.match("LITERAL")) then;Fi[	@_'i~I"z  end
  
  def function(var)
    return image_url if (var == "STRING")
    if (var.nil? or var.match("LITERAL")) then;Fi[	@£I"!Rails.logger.debug("STRING");Fi[[	@Ωi%I"ç  end
  
  def function(var)
    Rails.logger.debug("STRING")
    if (self.parent_author_signature.nil?.! or self.parent.author.remote?) then;Fi[	@Ÿ2i/I"i  end
  
  def function(var)
    Rails.logger.debug("STRING")
    self.target.destroy if self.target;Fi[	@ÓiHI"ù  end
  
  def function(var)
    Rails.logger.debug("STRING")
    if var = Reshare.where("LITERAL" => (var.person.id), "LITERAL" => (target_guid)).first then;Fi[	@~GI"3var = var.last.is_a?(Hash) ? (var.pop) : (nil);Fi[[	@(iGI"Ë      # Nokogiri::XML::Node#xpath
      def function(var)
        var = [Hash, String, Symbol].include?(var.last.class).! ? (var.pop) : (nil)
        var = var.last.is_a?(Hash) ? (var.pop) : (nil)
        var = NodeSet.new(document);Fi[	@(iXI"ˇ      # For more information see Nokogiri::XML::Node#css
      def function(var)
        var = [Hash, String, Symbol].include?(var.last.class).! ? (var.pop) : (nil)
        var = var.last.is_a?(Hash) ? (var.pop) : (nil)
        var = NodeSet.new(document);Fi[	@(ilI"      # For more information see Nokogiri::XML::Node#xpath
      def function(var)
        var = [Hash, String, Symbol].include?(var.last.class).! ? (var.pop) : (nil)
        var = var.last.is_a?(Hash) ? (var.pop) : (nil)
        var = NodeSet.new(document);Fi[	@HI" var = NodeSet.new(document);Fi[[	@(iHI"‡      def function(var)
        var = [Hash, String, Symbol].include?(var.last.class).! ? (var.pop) : (nil)
        var = var.last.is_a?(Hash) ? (var.pop) : (nil)
        var = NodeSet.new(document)
        var.each do |var|;Fi[	@(iYI"‹      def function(var)
        var = [Hash, String, Symbol].include?(var.last.class).! ? (var.pop) : (nil)
        var = var.last.is_a?(Hash) ? (var.pop) : (nil)
        var = NodeSet.new(document)
        each do |var|;Fi[	@(imI"      def function(var)
        var = [Hash, String, Symbol].include?(var.last.class).! ? (var.pop) : (nil)
        var = var.last.is_a?(Hash) ? (var.pop) : (nil)
        var = NodeSet.new(document)
        each { |var| var = (var + var.xpath(*(var + [var, var].compact))) };Fi[	I"document.decorate(var);F@öi[[	@(iMI"™          var = (var + send((var =~ "LITERAL" ? ("LITERAL") : ("LITERAL")), *(var + [var, var]).compact))
        end
        document.decorate(var)
        var
      end;Fi[	@(icI"          var = (var + var.xpath(*(var + [var, var].compact)))
        end
        document.decorate(var)
        var
      end;Fi[	@(ipI"§        var = NodeSet.new(document)
        each { |var| var = (var + var.xpath(*(var + [var, var].compact))) }
        document.decorate(var)
        var
      end;Fi[	@π$I";# When set to true, the user will be notified by email;Fi[[	@‹iI"Æ      alias "LITERAL" "LITERAL"
      
      ##
      # When set to true, the user will be notified by email
      # when a backup process ends without raising any exceptions;Fi[	@‹iI"      # When set to true, the user will be notified by email
      # when a backup process ends without raising any exceptions
      ##
      # When set to true, the user will be notified by email
      # when a backup process is successful, but has warnings;Fi[	@‹iI"      # When set to true, the user will be notified by email
      # when a backup process is successful, but has warnings
      ##
      # When set to true, the user will be notified by email
      # when a backup process raises an exception before finishing;Fi[	I"require("omniauth");F@Ω@i[[	@∫"i I"Jrequire("omniauth")
module OmniAuth
  class Builder < ::Rack::Builder;Fi [	@.i I"5require("omniauth")
module OmniAuth
  class Form;Fi [	I"9projects//omni_proj/omniauth/strategies/developer.rb;Ti I"<require("omniauth")
module OmniAuth
  module Strategies;Fi [	@£I"verify_map(var, "STRING");Fi[[	@4i#I"á  #       background-image: inline-sprite($icon-sprites);
  #      }
  def function(var)
    verify_map(var, "STRING")
    var.generate;Fi[	@4iTI"¿  # Returns the name of a sprite map
  # The name is derived from the folder than contains the sprites.
  def function(var)
    verify_map(var, "STRING")
    Sass::Script::String.new(var.name);Fi[	@4i|I"q  
  # Returns a url to the sprite image.
  def function(var)
    verify_map(var, "STRING")
    var.generate;Fi[	I"#   class MyStrategy;FI"%#     include OmniAuth::Strategy;Fi[[	@€i'I"í      # @example Using a yield to configure the default options.
      #
      #   class MyStrategy
      #     include OmniAuth::Strategy
      #;Fi[	@€i1I"™      # @example Using a hash to configure the default options.
      #
      #   class MyStrategy
      #     include OmniAuth::Strategy
      #     configure foo: 'bar';Fi[	@€iCI"g      # @example
      #
      #   class MyStrategy
      #     include OmniAuth::Strategy
      #;Fi[	@1@å$i[[	@^i I"<module Paperclip
  module Storage
    module Filesystem;Fi [	@	i I"5module Paperclip
  module Storage
    module Fog;Fi [	@ci I"4module Paperclip
  module Storage
    module S3;Fi [	I"#@options["LITERAL"].call(self);F@|i[[	@i5I"ó    def function
      if @options["LITERAL"].respond_to?("LITERAL") then
        @options["LITERAL"].call(self)
      else
        @options["LITERAL"];Fi[	@	i~I"ª      def function(var)
        if @options["LITERAL"].respond_to?("LITERAL") then
          @options["LITERAL"].call(self)
        else
          if @options["LITERAL"] =~ "LITERAL" then;Fi[	@	ißI"ß      def function
        var = if @options["LITERAL"].respond_to?("LITERAL") then
          @options["LITERAL"].call(self)
        else
          @options["LITERAL"];Fi[	I"#instance_write("LITERAL", nil);F@THi[[	@iôI"      return if (@options["LITERAL"] or file?.!)
      @var = (@queued_for_delete + ["LITERAL", *styles.keys].uniq.map { |var| path(var) if exists?(var) }.compact)
      instance_write("LITERAL", nil)
      instance_write("LITERAL", nil)
      instance_write("LITERAL", nil);Fi[	@iöI"      @var = (@queued_for_delete + ["LITERAL", *styles.keys].uniq.map { |var| path(var) if exists?(var) }.compact)
      instance_write("LITERAL", nil)
      instance_write("LITERAL", nil)
      instance_write("LITERAL", nil)
      instance_write("LITERAL", nil);Fi[	@iõI"›      instance_write("LITERAL", nil)
      instance_write("LITERAL", nil)
      instance_write("LITERAL", nil)
      instance_write("LITERAL", nil)
      instance_write("LITERAL", nil) if has_enabled_but_unset_created_at?;Fi[	I"after_flush_writes;F@…i[[	@^iI"\          var.rewind
        end
        after_flush_writes
        @var = {}
      end;Fi[	@	iHI"V          end)
        end
        after_flush_writes
        @var = {}
      end;Fi[	@ci÷I"U          end
        end
        after_flush_writes
        @var = {}
      end;Fi[	I"¢Resque::Failure.create("LITERAL" => (Exception.new), "LITERAL" => (Resque::Worker.new("LITERAL")), "LITERAL" => "STRING", "LITERAL" => ({ "STRING" => "STRING" }));F@fHi[[	I"7projects//rescue_proj/resque/server/test_helper.rb;TiI"      
      def function
        Resque::Failure.create("LITERAL" => (Exception.new), "LITERAL" => (Resque::Worker.new("LITERAL")), "LITERAL" => "STRING", "LITERAL" => ({ "STRING" => "STRING" }))
        Resque::Failure.create("LITERAL" => (Exception.new), "LITERAL" => (Resque::Worker.new("LITERAL")), "LITERAL" => "STRING", "LITERAL" => ({ "STRING" => "STRING" }))
        Resque::Failure.create("LITERAL" => (Exception.new), "LITERAL" => (Resque::Worker.new("LITERAL")), "LITERAL" => "STRING", "LITERAL" => ({ "STRING" => "STRING" }));Fi[	@iHiI"æ      def function
        Resque::Failure.create("LITERAL" => (Exception.new), "LITERAL" => (Resque::Worker.new("LITERAL")), "LITERAL" => "STRING", "LITERAL" => ({ "STRING" => "STRING" }))
        Resque::Failure.create("LITERAL" => (Exception.new), "LITERAL" => (Resque::Worker.new("LITERAL")), "LITERAL" => "STRING", "LITERAL" => ({ "STRING" => "STRING" }))
        Resque::Failure.create("LITERAL" => (Exception.new), "LITERAL" => (Resque::Worker.new("LITERAL")), "LITERAL" => "STRING", "LITERAL" => ({ "STRING" => "STRING" }))
        Resque::Failure.create("LITERAL" => (Exception.new), "LITERAL" => (Resque::Worker.new("LITERAL")), "LITERAL" => "STRING", "LITERAL" => ({ "STRING" => "STRING" }));Fi[	@iHiI"µ        Resque::Failure.create("LITERAL" => (Exception.new), "LITERAL" => (Resque::Worker.new("LITERAL")), "LITERAL" => "STRING", "LITERAL" => ({ "STRING" => "STRING" }))
        Resque::Failure.create("LITERAL" => (Exception.new), "LITERAL" => (Resque::Worker.new("LITERAL")), "LITERAL" => "STRING", "LITERAL" => ({ "STRING" => "STRING" }))
        Resque::Failure.create("LITERAL" => (Exception.new), "LITERAL" => (Resque::Worker.new("LITERAL")), "LITERAL" => "STRING", "LITERAL" => ({ "STRING" => "STRING" }))
        Resque::Failure.create("LITERAL" => (Exception.new), "LITERAL" => (Resque::Worker.new("LITERAL")), "LITERAL" => "STRING", "LITERAL" => ({ "STRING" => "STRING" }))
      end;Fi[	I".if ((var >> "LITERAL") == "LITERAL") then;FI"%if check_next_sequence(var) then;Fi[[	@¬0iI"Ø  def self.sequence_length(var)
    var = var.get_byte["LITERAL"]
    if ((var >> "LITERAL") == "LITERAL") then
      if check_next_sequence(var) then
        return "LITERAL";Fi[	@¬0i$I"ñ      end
    else
      if ((var >> "LITERAL") == "LITERAL") then
        if check_next_sequence(var) then
          if check_next_sequence(var) then;Fi[	@¬0i/I"†        end
      else
        if ((var >> "LITERAL") == "LITERAL") then
          if check_next_sequence(var) then
            if check_next_sequence(var) then;Fi[	@π$I"J# Creates (if they don't exist yet) all the directories on the remote;Fi[[	@‡"iRI"≤      end
      
      ##
      # Creates (if they don't exist yet) all the directories on the remote
      # server in order to upload the backup file. Net::FTP does not support;Fi[	@uiSI"ò      end
      
      ##
      # Creates (if they don't exist yet) all the directories on the remote
      # server in order to upload the backup file.;Fi[	@iFI"≥      end
      
      ##
      # Creates (if they don't exist yet) all the directories on the remote
      # server in order to upload the backup file. Net::SFTP does not support;Fi[	@qH@qHi[[	@¬0i%I"©    else
      if ((var >> "LITERAL") == "LITERAL") then
        if check_next_sequence(var) then
          if check_next_sequence(var) then
            return "LITERAL";Fi[	@¬0i0I"√      else
        if ((var >> "LITERAL") == "LITERAL") then
          if check_next_sequence(var) then
            if check_next_sequence(var) then
              if check_next_sequence(var) then;Fi[	@¬0i1I"Ÿ        if ((var >> "LITERAL") == "LITERAL") then
          if check_next_sequence(var) then
            if check_next_sequence(var) then
              if check_next_sequence(var) then
                return "LITERAL";Fi[	@qH@ﬁ9i[[	@¬0iI"ö    var = var.get_byte["LITERAL"]
    if ((var >> "LITERAL") == "LITERAL") then
      if check_next_sequence(var) then
        return "LITERAL"
      else;Fi[	@¬0i&I"Ø      if ((var >> "LITERAL") == "LITERAL") then
        if check_next_sequence(var) then
          if check_next_sequence(var) then
            return "LITERAL"
          else;Fi[	@¬0i2I"∫          if check_next_sequence(var) then
            if check_next_sequence(var) then
              if check_next_sequence(var) then
                return "LITERAL"
              else;Fi[	I"(#       # pagination code goes here;F@>i[[	@JicI"{    #   module Pagination
    #     def page(number)
    #       # pagination code goes here
    #     end
    #   end;Fi[	@JirI"É    #   scope = Model.all.extending do
    #     def page(number)
    #       # pagination code goes here
    #     end
    #   end;Fi[	@Ji{I"ì    #   scope = Model.all.extending(Pagination) do
    #     def per_page(number)
    #       # pagination code goes here
    #     end
    #   end;Fi[	@ﬁ9@|i[[	@¬0iI"ï    if ((var >> "LITERAL") == "LITERAL") then
      if check_next_sequence(var) then
        return "LITERAL"
      else
        var.pos -= "LITERAL";Fi[	@¬0i'I"†        if check_next_sequence(var) then
          if check_next_sequence(var) then
            return "LITERAL"
          else
            var.pos -= "LITERAL";Fi[	@¬0i3I"¥            if check_next_sequence(var) then
              if check_next_sequence(var) then
                return "LITERAL"
              else
                var.pos -= "LITERAL";Fi[	I"G# Returns an Array of string pids of all the other workers on this;FI"<# machine. Useful when pruning dead workers on startup.;Fi[[	@]i¸I"†    end
    
    # Returns an Array of string pids of all the other workers on this
    # machine. Useful when pruning dead workers on startup.
    def function;Fi[	@]iI"√    # Find Resque worker pids on Windows.
    #
    # Returns an Array of string pids of all the other workers on this
    # machine. Useful when pruning dead workers on startup.
    def function;Fi[	@]i I"Ã    # Find worker pids - platform independent
    #
    # Returns an Array of string pids of all the other workers on this
    # machine. Useful when pruning dead workers on startup.
    def function(var);Fi[	I"-# +calculate+ for examples with options.;F@i[[	@∏i#I"    # Calculates the minimum value on a given column. The value is returned
    # with the same data type of the column, or +nil+ if there's no row. See
    # +calculate+ for examples with options.
    #
    #   Person.minimum('age') # => 7;Fi[	@∏i,I"Ò    # Calculates the maximum value on a given column. The value is returned
    # with the same data type of the column, or +nil+ if there's no row. See
    # +calculate+ for examples with options.
    #
    #   Person.maximum('age') # => 93;Fi[	@∏i5I"Ë    # Calculates the sum of values on a given column. The value is returned
    # with the same data type of the column, 0 if there's no row. See
    # +calculate+ for examples with options.
    #
    #   Person.sum('age') # => 4562;Fi[	I"J# Saving is not subjected to validation checks. Returns +true+ if the;FI"# record could be saved.;Fi[[	@1iI"    # Wrapper around +increment+ that saves the record. This method differs from
    # its non-bang version in that it passes through the attribute setter.
    # Saving is not subjected to validation checks. Returns +true+ if the
    # record could be saved.
    def function(var, var);Fi[	@1iI"    # Wrapper around +decrement+ that saves the record. This method differs from
    # its non-bang version in that it passes through the attribute setter.
    # Saving is not subjected to validation checks. Returns +true+ if the
    # record could be saved.
    def function(var, var);Fi[	@1i0I"    # Wrapper around +toggle+ that saves the record. This method differs from
    # its non-bang version in that it passes through the attribute setter.
    # Saving is not subjected to validation checks. Returns +true+ if the
    # record could be saved.
    def function(var);Fi[	I"K# its non-bang version in that it passes through the attribute setter.;F@∑Hi[[	@1iI"    
    # Wrapper around +increment+ that saves the record. This method differs from
    # its non-bang version in that it passes through the attribute setter.
    # Saving is not subjected to validation checks. Returns +true+ if the
    # record could be saved.;Fi[	@1iI"    
    # Wrapper around +decrement+ that saves the record. This method differs from
    # its non-bang version in that it passes through the attribute setter.
    # Saving is not subjected to validation checks. Returns +true+ if the
    # record could be saved.;Fi[	@1i/I"    
    # Wrapper around +toggle+ that saves the record. This method differs from
    # its non-bang version in that it passes through the attribute setter.
    # Saving is not subjected to validation checks. Returns +true+ if the
    # record could be saved.;Fi[	@£I"@var = var.to_s;Fi[[	@#$iPI"ú        
        # Set the column to use for optimistic locking. Defaults to +lock_version+.
        def function(var)
          @var = var.to_s
        end;Fi[	@&iâI"|      
      # Sets the value of inheritance_column
      def function(var)
        @var = var.to_s
        @var = true;Fi[	@&i™I"©      #     self.sequence_name = "projectseq"   # default would have been "project_seq"
      #   end
      def function(var)
        @var = var.to_s
        @var = true;Fi[	I"R# If no queue can be inferred this method will raise a `Resque::NoQueueError`;F@i[[	@`i"I"Ë  # from performing one of the above operations to determine the queue.
  #
  # If no queue can be inferred this method will raise a `Resque::NoQueueError`
  #
  # Returns true if the job was queued, nil if the job was rejected by a;Fi[	@`iHI"Ê  # from performing one of the above operations to determine the queue.
  #
  # If no queue can be inferred this method will raise a `Resque::NoQueueError`
  #
  # If no args are given, this method will dequeue *all* jobs matching;Fi[	@`irI"ﬁ  # Validates if the given klass could be a valid Resque job
  #
  # If no queue can be inferred this method will raise a `Resque::NoQueueError`
  #
  # If given klass is nil this method will raise a `Resque::NoClassError`;Fi[	@£@÷ i[[	@)i
I"[    
    module ClassMethods
      def function(var)
        raise("STRING")
      end;Fi[	@)iI"O      end
      
      def function(var)
        raise("STRING")
      end;Fi[	@æi}I"E    end
    
    def function(var)
      raise("STRING")
    end;Fi[	I"# raised.;F@i[[	@iI"¡    # Validates that the given hash only includes at *most* one of a set of
    # exclusive keys.  If more than one key is found, an ArgumentError will be
    # raised.
    # 
    # == Examples;Fi[	@Ìi.I"»    # *Note* that multiple events on the same state machine / attribute cannot
    # be run in parallel.  If this is attempted, an ArgumentError will be
    # raised.
    # 
    # == Halting callbacks;Fi[	@)i@I"Ω    # Determines the current state of the given object as configured by this
    # state machine.  If no state is found, then an ArgumentError will be
    # raised.
    # 
    # == Examples;Fi[	@•6@£i[[	@XiI"¢  module ConnectionAdapters
    class SQLite3Column < Column
      class << self
        def function(var)
          if var.encoding.!=(Encoding::ASCII_8BIT) then;Fi[	@iI"o    
    module Erb
      class << self
        def function(var)
          super.sub("LITERAL", "STRING");Fi[	@˚iPI"b  end
  
  class << self
    def function(var)
      var.nil? ? (@bottle_sha1) : (@var = var);Ti[	I"(require("state_machine/assertions");F@ài[[	@iI"çrequire("state_machine/matcher")
require("state_machine/eval_helpers")
require("state_machine/assertions")
module StateMachine
  class Branch;Fi[	@i I"]require("state_machine/assertions")
module StateMachine
  class MachineCollection < Hash;Fi [	@ji I"Srequire("state_machine/assertions")
module StateMachine
  class NodeCollection;Fi [	@•6I"###;Fi[[	@’iJI"      end
      
      class << self
        ###
        # Parse HTML.  +string_or_io+ may be a String, or any object that;Fi[	@–iI"Çmodule Nokogiri
  module XML
    class << self
      ###
      # Create a new Nokogiri::XML::RelaxNG document from +string_or_io+.;Fi[	@‹iI"Åmodule Nokogiri
  module XML
    class << self
      ###
      # Create a new Nokogiri::XML::Schema object using a +string_or_io+;Fi[	I"#      end;F@i[[	@&iI"p      #
      #        t.timestamps
      #      end
      #
      #      JobLevel.reset_column_information;Fi[	@æihI"æ    #      namespace :publisher do
    #        devise_for :account
    #      end
    #
    #    Will use publisher/sessions controller instead of devise/sessions controller. You can revert;Fi[	@æi¶I"u    #      def update
    #         # do something different here
    #      end
    #
    #      def deactivate;Fi[	I"N# * <tt>:from</tt> - One or more states being transitioned from.  If none;FI"E#   are specified, then this will be the object's current state.;Fi[[	@i|I"    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are;Fi[	@ÊiI"    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are;Fi[	@Êi3I"    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are;Fi[	I"	var);F@ë9i[[	@ziûI"ñ            run("STRING")
          end
          var)
        rescue => var
          raise(Errors::Encryptor::GPG::HomedirError.wrap(var, "STRING"));Fi[	@ziMI"–          var = var.match("LITERAL").to_a["LITERAL"]
          raise("STRING") unless var
          var)
        rescue => var
          Logger.warn(Errors::Encryptor::GPG::KeyImportError.wrap(var, "STRING"));Fi[	@¯	iÉI"≤          write_cache!(var)
          var.render("STRING")
          var)
        rescue => var
          raise(Errors::Storage::Dropbox::AuthenticationError.wrap(var, "STRING"));Fi[	I"N# * <tt>:to</tt> - One or more states being transitioned to.  If none are;FI"6#   specified, then this will match any to state.;Fi[[	@i~I"`    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless;Fi[	@ÊiI"c    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:on</tt> - One or more events that fire the transition.  If none;Fi[	@Êi5I"c    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:on</tt> - One or more events that fire the transition.  If none;Fi[	I"#require("state_machine/error");F@ài[[	@i	I"úrequire("state_machine/assertions")
require("state_machine/matcher_helpers")
require("state_machine/error")
module StateMachine
  class InvalidEvent < Error;Fi[	I"?projects//state_machine_proj/state_machine/integrations.rb;Ti	I"ô  require("state_machine/integrations/#{File.basename(path)}")
end
require("state_machine/error")
module StateMachine
  class IntegrationNotFound < Error;Fi[	@3iI"Érequire("state_machine/transition_collection")
require("state_machine/error")
module StateMachine
  class InvalidTransition < Error;Fi[	I"!# Valid requirement options:;F@Ii[[	@i{I"    # object.  If no transitions can be made, then this will return nil.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.;Fi[	@ÊiI"ˇ    # Gets the list of events that can be fired on the given object.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.;Fi[	@Êi2I"    # Gets the list of transitions that can be run on the given object.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.;Fi[	@I@#Ii[[	@i}I"7    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.;Fi[	@ÊiI"7    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.;Fi[	@Êi4I"7    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.;Fi[	I"?require("active_support/core_ext/hash/indifferent_access");F@Æi[[	@ i I"hrequire("active_support/core_ext/hash/indifferent_access")
module ActiveRecord
  module Inheritance;Fi [	@ç
iI"≈require("active_support/core_ext/hash/except")
require("active_support/core_ext/object/try")
require("active_support/core_ext/hash/indifferent_access")
module ActiveRecord
  module NestedAttributes;Fi[	@ªi I"brequire("active_support/core_ext/hash/indifferent_access")
module ActiveRecord
  module Store;Fi [	@£I"ensure_not_nested;Fi[[	@Xi&I"[      end
      
      def function(var)
        ensure_not_nested
        var = super;Fi[	@Xi[I"`      end
      
      def function(var)
        ensure_not_nested
        var = super(var);Fi[	@ÀiI"      private
      
      def function(var)
        ensure_not_nested
        var = owner.association(through_reflection.name);Fi[	@â7@i[[	@ÊiI"÷    #   are specified, then this will match any event.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.
    # 
    # == Examples;Fi[	@Êi:I"÷    #   are specified, then this will match any event.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.
    # 
    # == Examples;Fi[	@iôI"”    #   specified, then this will match any event.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.
    # 
    # For example,;Fi[	@£@«-i[[	@DiI"        # Unlike the other associations, we want to get a raw array of rows so that we can
        # access the aliased column on the join table
        def function(var)
          var = super
          klass.connection.select_all(var.arel, "STRING", var.bind_values);Fi[	@ñiéI"        # Quote date/time values for use in SQL input. Includes microseconds
        # if the value is a Time responding to usec.
        def function(var)
          var = super
          var = "STRING" if var.acts_like?("LITERAL") and var.respond_to?("LITERAL");Fi[	@√iI"|      end
      
      def function(var)
        var = super
        var["LITERAL"]["LITERAL"] = ::ActionView::Base.new;Fi[	@£@™,i[[	@æi¥I"b    #     end
    #
    def function(var)
      @var = false
      var = var.extract_options!;Fi[	@3
i¥I"K    end
    
    def function(var)
      @var = false
      @var = nil;Fi[	@3
i∫I"B    end
    
    def function(var)
      @var = false
    end;Fi[	I"case var.sql_type;F@8i[[	@ñi%I"≥            end
          when Range then
            case var.sql_type
            when "STRING", "STRING" then
              super(PostgreSQLColumn.intrange_to_string(var), var);Fi[	@ñi,I"∞            end
          when IPAddr then
            case var.sql_type
            when "STRING", "STRING" then
              super(PostgreSQLColumn.cidr_to_string(var), var);Fi[	@ñigI"ß            end
          when Range then
            case var.sql_type
            when "STRING", "STRING" then
              PostgreSQLColumn.intrange_to_string(var);Fi[	@rI@îi[[	@ñiI"√            var.array ? ("STRING") : (super)
          when Hash then
            case var.sql_type
            when "STRING" then
              super(PostgreSQLColumn.hstore_to_string(var), var);Fi[	@ñi<I"É            "STRING"
          when String then
            case var.sql_type
            when "STRING" then
              "STRING";Fi[	@ñi^I"≈            { "LITERAL" => (var), "LITERAL" => "LITERAL" }
          when Hash then
            case var.sql_type
            when "STRING" then
              PostgreSQLColumn.hstore_to_string(var);Fi[	@£I"#var = var.extract_options!.dup;Fi[[	@ÇigI"Ï      #
      #   validates :password, presence: { if: :password_required?, message: 'is forgotten.' }, confirmation: true
      def function(var)
        var = var.extract_options!.dup
        var = var.slice!(*_validates_default_keys);Fi[	@°i3I"®    # for a complete description on those values.
    #
    def function(var)
      var = var.extract_options!.dup
      var = var.map(&"LITERAL").uniq.sort_by do |var|;Fi[	@Bi I"≠      #      :size => { :in => 0..10.kilobytes }
      #
      def function(var)
        var = var.extract_options!.dup
        Paperclip::Validators.constants.each do |var|;Fi[	I"A#   # => { "id" => 1, "name" => "Konata Izumi", "age" => 16,;FI"@#   #      "created_at" => "2006/08/01", "awesome" => true,;Fi[[	@`iBI"Î      #
      #   user.as_json(methods: :permalink)
      #   # => { "id" => 1, "name" => "Konata Izumi", "age" => 16,
      #   #      "created_at" => "2006/08/01", "awesome" => true,
      #   #      "permalink" => "1-konata-izumi" };Fi[	@`iII"      #
      #   user.as_json(include: :posts)
      #   # => { "id" => 1, "name" => "Konata Izumi", "age" => 16,
      #   #      "created_at" => "2006/08/01", "awesome" => true,
      #   #      "posts" => [ { "id" => 1, "author_id" => 1, "title" => "Welcome to the weblog" },;Fi[	@`iTI"f      #                                             only: :body } },
      #                              only: :title } })
      #   # => { "id" => 1, "name" => "Konata Izumi", "age" => 16,
      #   #      "created_at" => "2006/08/01", "awesome" => true,
      #   #      "posts" => [ { "comments" => [ { "body" => "1st post!" }, { "body" => "Second!" } ],;Fi[	@p6@ni[[	@i
I"o        instance.save)
      rescue Errno::EACCES => var
        warn("STRING")
        false
      ensure;Fi[	@	izI"s          end)
        rescue ::Fog::Errors::Error => var
          warn("STRING")
          false
        end;Fi[	@ciÔI"v          var.close)
        rescue AWS::Errors::Base => var
          warn("STRING")
          false
        end;Fi[	I"var = false;F@|i[[	@
i3I"|            if var then
              (var << var)
              var = false
            else
              if var then;Fi[	@ÏiÇI"Ñ        var = var["LITERAL"] ? (nil) : (var["LITERAL"])
        var = {}
        var = false
      else
        var = var["LITERAL"];Fi[	@3
iYI"¿          if (var["LITERAL"] == "STRING") then
            var = unescape_interpolation(var["LITERAL"].strip, var)
            var = false
          else
            var = var["LITERAL"].strip;Fi[	@£I"var = [var];Fi[[	@miÄI"o      end
      
      def function(var)
        var = [var]
        (var << "STRING") if var.development?;Fi[	@`iyI"è      end
      
      def function(var)
        var = [var]
        var.concat(["STRING", configuration["STRING"]]) if configuration["STRING"];Fi[	@ãi˝I"Ê    # Given an action, it will try to find all of the actions which are aliased to it.
    # This does the opposite kind of lookup as expand_actions.
    def function(var)
      var = [var]
      aliased_actions.each do |var, var|;Fi[	@£I"var.each do |var, var|;Fi[[	@v
iTI"Ä      end
      
      def function(var)
        var.each do |var, var|
          Preloader.new(records, var, preload_scope).run;Fi[	@a"iDI"à      end
      
      def function(var)
        var.each do |var, var|
          self.send("STRING", var) if self.respond_to?("STRING");Fi[	@Îi
I"ü      ###
      # Register namespaces in +namespaces+
      def function(var)
        var.each do |var, var|
          var = var.to_s.gsub("LITERAL", "STRING");Fi[	@î@õFi[[	@˝iôI"Ÿ      when Spc then
        ["LITERAL", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then
        ["LITERAL", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then;Fi[	@˝iõI"ﬁ      when "STRING" then
        ["LITERAL", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then
        ["LITERAL", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then;Fi[	@˝iùI"–      when "STRING" then
        ["LITERAL", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      when "STRING" then
        ["LITERAL", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]]
      else;Fi[	@£I"var ||= {};Fi[[	@]i!I"¬    #   person.serializable_hash(methods: :capitalized_name)
    #   # => {"name"=>"bob", "age"=>22, "capitalized_name"=>"Bob"}
    def function(var)
      var ||= {}
      var = attributes.keys;Fi[	@“iI""  end
  
  def function(var)
    var ||= {}
    var = { "LITERAL" => (self.id), "LITERAL" => (self.guid), "LITERAL" => (self.name), "LITERAL" => (self.profile.image_url("LITERAL")), "LITERAL" => (self.diaspora_handle), "LITERAL" => (Rails.application.routes.url_helpers.person_path(self)) };Fi[	@i•I"Ú    # given query.  If a match is found, then a hash containing the
    # event/state requirements that passed will be returned; otherwise, nil.
    def function(var)
      var ||= {}
      if match_event(var) and var = match_states(var) then;Fi[	@—$I"!#       other_states :idling;Fi[[	@)iI"    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end;Fi[	@)i*I"    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end;Fi[	@)iEI"    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end;Fi[	I"(#         transition all => :active;F@i[[	@ÌiMI"±    #     state_machine :alarm_state, :namespace => 'alarm', :initial => :on do
    #       event :enable do
    #         transition all => :active
    #       end
    #       ;Fi[	@ÌiI"µ    #     state_machine :alarm_state, :namespace => 'alarm', :initial => :active do
    #       event :enable do
    #         transition all => :active
    #       end
    #       ;Fi[	@iÃI"∂    #     state_machine :alarm_state, :initial => :active, :namespace => 'alarm' do
    #       event :turn_on do
    #         transition all => :active
    #       end
    #       ;Fi[	I"#       event :disable do;F@ï5i[[	@ÌiPI"t    #       end
    #       
    #       event :disable do
    #         transition all => :off
    #       end;Fi[	@Ìi}I"t    #       end
    #       
    #       event :disable do
    #         transition all => :off
    #       end;Fi[	@iîI"ö    #     
    #     state_machine :alarm_state, :initial => :active do
    #       event :disable do
    #         transition all => :off
    #       end;Fi[	@@Ÿi[[	@i…I"Õ      #     t.references :tagger, polymorphic: true, index: true
      #     t.references :taggable, polymorphic: { default: 'Photo' }
      #   end
      def function(var, var, var)
        var = var.to_s;Fi[	@˙iI"ó      #   Nokogiri::XML::Builder.new(:encoding => 'UTF-8') do |xml|
      #     ...
      #   end
      def function(var, var, var)
        if var then;Fi[	@)1iPI"Í    #   Factory.define :band_with_demo_tape, :parent => :band do |band|
    #     band.demo_tape { band.paperclip_fixture("band", "demo_tape", "png") }
    #   end
    def function(var, var, var)
      stub_paperclip_s3(var, var, var);Fi[	@@:i[[	@9ioI"Œ    #     # Will yield :name and "can't be blank"
    #     # then yield :name and "must be specified"
    #   end
    def function
      messages.each_key { |var| self[var].each { |var| yield(var, var) } };Fi[	@òi#I"e    #       @data[key]
    #     end
    #   end
    def function
      run_callbacks("LITERAL");Fi[	@iKI"Ê      #   class Post < ActiveRecord::Base
      #     scope :published_and_commented, published.and(self.arel_table[:comments_count].gt(0))
      #   end
      def function
        @var ||= Arel::Table.new(table_name, arel_engine);Fi[	I"D#   vehicle.state                                 # => "idling";FI"A#   vehicle.alarm_state                           # => "off";Fi[[	@Ìi[I"÷    #   
    #   vehicle.fire_events(:ignite, :disable_alarm)  # => true
    #   vehicle.state                                 # => "idling"
    #   vehicle.alarm_state                           # => "off"
    #   ;Fi[	@Ìi`I"	    #   # If any event fails, the entire event chain fails
    #   vehicle.fire_events(:ignite, :enable_alarm)   # => false
    #   vehicle.state                                 # => "idling"
    #   vehicle.alarm_state                           # => "off"
    #   ;Fi[	@ÌieI":    #   # Exception raised on invalid event
    #   vehicle.fire_events(:park, :invalid)          # => StateMachine::InvalidEvent: :invalid is an unknown event
    #   vehicle.state                                 # => "idling"
    #   vehicle.alarm_state                           # => "off"
    def function(var);Fi[	@sI"&#     validates_presence_of :name;Fi[[	@òiΩI"Ä    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end;Fi[	@òiŒI"Ä    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end;Fi[	@òiıI"Ä    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end;Fi[	@ß@si[[	@≤i¥I"j      # with the new objects.
      #
      #   class Person
      #     has_many :pets
      #   end;Ti[	@≤iœI"m      # passes the validations).
      #
      #   class Person
      #     has_many :pets
      #   end;Ti[	@≤iÎI"ô      # Like +create+, except that if the record is invalid, raises an exception.
      #
      #   class Person
      #     has_many :pets
      #   end;Ti[	I"	# to;F@i[[	@ iI"~      #   #{prefix}#{attr}(*args, &block)
      #
      # to
      #
      #   #{prefix}attribute(#{attr}, *args, &block);Fi[	@ iAI"~      #   #{attr}#{suffix}(*args, &block)
      #
      # to
      #
      #   attribute#{suffix}(#{attr}, *args, &block);Fi[	@ ieI"ã      #   #{prefix}#{attr}#{suffix}(*args, &block)
      #
      # to
      #
      #   #{prefix}attribute#{suffix}(#{attr}, *args, &block);Fi[	@âI"module DataMapper;Fi[[	@ıiI"Zmodule StateMachine
  module Integrations
    module DataMapper
      module Observer;Fi[	@πiI"_module StateMachine
  module Integrations
    module DataMapper
      version("STRING") do;Fi[	@	iI"Xmodule StateMachine
  module Integrations
    module DataMapper
      include(Base);Fi[	@I"%# @return [Array<Twitter::Size>];Fi[[	@/iI"k    
    # Returns an array of photo sizes
    #
    # @return [Array<Twitter::Size>]
    def function;Fi[	@ˇ*iI"u      
      # Returns an array of photo sizes
      #
      # @return [Array<Twitter::Size>]
      def function;Fi[	@Ai	I"á  class ProfileBanner < Twitter::Base
    # Returns an array of photo sizes
    #
    # @return [Array<Twitter::Size>]
    def function;Fi[	I",#   rename_table('octopuses', 'octopi');F@Hi[[	@Ui∞I"}      #
      # Example:
      #   rename_table('octopuses', 'octopi')
      def function(var, var)
        execute("STRING");Fi[	@õi⁄I"Ç        #
        # Example:
        #   rename_table('octopuses', 'octopi')
        def function(var, var)
          clear_cache!;Fi[	@XivI"Ä      #
      # Example:
      #   rename_table('octopuses', 'octopi')
      def function(var, var)
        exec_query("STRING");Fi[	I"2# Adds a validation error to the given object;F@	+i[[	@ÛiI"í      end
      
      # Adds a validation error to the given object 
      def function(var, var, var, var)
        if supports_validations? then;Fi[	@	iI"ë      end
      
      # Adds a validation error to the given object
      def function(var, var, var, var)
        if supports_validations? then;Fi[	@JiI"≥      end
      
      # Adds a validation error to the given object
      def function(var, var, var, var)
        var.errors.add(self.attribute(var), generate_message(var, var));Fi[	I"unless var then;FI"1var = extract_table_ref_from_insert_sql(var);Fi[[	@Ç
i&I"Ì        # Executes an INSERT query and returns the new record's ID
        def function(var, var, var, var, var)
          unless var then
            var = extract_table_ref_from_insert_sql(var)
            var = primary_key(var) if var;Fi[	@Ç
i~I"≥        
        def function(var, var, var, var, var)
          unless var then
            var = extract_table_ref_from_insert_sql(var)
            var = primary_key(var) if var;Fi[	@Ç
iâI"Ê          var = exec_query(var, var, var)
          if use_insert_returning?.! and var then
            unless var then
              var = extract_table_ref_from_insert_sql(var)
              var = default_sequence_name(var, var);Fi[	I"return false unless var;F@÷ i[[	@·i≤I"ê  def function(var)
    if Hardware.is_32_bit? and (MacOS.version == "LITERAL") then
      return false unless var
      raise("STRING")
    end;Fi[	@·i∂I"{    end
    unless (HOMEBREW_PREFIX.to_s == "STRING") then
      return false unless var
      raise("STRING")
    end;Fi[	@·i∫I"{    end
    unless (HOMEBREW_CELLAR.to_s == "STRING") then
      return false unless var
      raise("STRING")
    end;Fi[	I"L# Describes the current validation errors on the given object.  If none;FI"F# are specific, then the default error is interpeted as a "halt".;Fi[[	@Ûi%I"æ      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(var);Fi[	@	iI"æ      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(var);Fi[	@Ji"I"æ      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(var);Fi[	I"A# DATABASE STATEMENTS ======================================;F@Hi[[	@ÅiXI"á      end
      
      # DATABASE STATEMENTS ======================================
      def function(var, var)
        var = "STRING";Fi[	@Ã	i¡I"ù      end
      
      # DATABASE STATEMENTS ======================================
      def function(var, var)
        @connection.query_with_result = true;Fi[	@Xi„I"á      end
      
      # DATABASE STATEMENTS ======================================
      def function(var, var)
        var = "STRING";Fi[	I"# method does nothing.;F@:i[[	@PiƒI"ó      
      # Disconnects from the database if already connected. Otherwise, this
      # method does nothing.
      def function
        clear_cache!;Fi[	@Ã	i¥I"ê      
      # Disconnects from the database if already connected. Otherwise, this
      # method does nothing.
      def function
        super;Fi[	@XiñI"ê      
      # Disconnects from the database if already connected. Otherwise, this
      # method does nothing.
      def function
        super;Fi[	I"J# Disconnects from the database if already connected. Otherwise, this;F@cJi[[	@Pi√I"å      end
      
      # Disconnects from the database if already connected. Otherwise, this
      # method does nothing.
      def function;Fi[	@Ã	i≥I"å      end
      
      # Disconnects from the database if already connected. Otherwise, this
      # method does nothing.
      def function;Fi[	@XiïI"å      end
      
      # Disconnects from the database if already connected. Otherwise, this
      # method does nothing.
      def function;Fi[	@QJ@£i[[	@Ûi&I"      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(var)
        var.errors.empty? ? ("STRING") : ((var.errors.full_messages * "STRING"));Fi[	@	iI"÷      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(var)
        if var.errors.empty? then;Fi[	@Ji#I"      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(var)
        var.errors.empty? ? ("STRING") : ((var.errors.full_messages * "STRING"));Fi[	I"L# Resets any errors previously added when invalidating the given object;F@£i[[	@Ûi+I"®      end
      
      # Resets any errors previously added when invalidating the given object
      def function(var)
        var.errors.clear if supports_validations?;Fi[	@	i*I"®      end
      
      # Resets any errors previously added when invalidating the given object
      def function(var)
        var.errors.clear if supports_validations?;Fi[	@Ji(I"è      end
      
      # Resets any errors previously added when invalidating the given object
      def function(var)
        var.errors.clear;Fi[	I"A# Adds hooks into validation for automatically firing events;F@:i[[	@ÛiïI"y      end
      
      # Adds hooks into validation for automatically firing events
      def function
        super;Fi[	@	iiI"y      end
      
      # Adds hooks into validation for automatically firing events
      def function
        super;Fi[	@Ji\I"¥      end
      
      # Adds hooks into validation for automatically firing events
      def function
        define_helper("LITERAL", "STRING", "STRING", ("LITERAL" + "LITERAL"));Fi[	I"clear_cache!;F@N i[[	@õi‹I"Ø        #   rename_table('octopuses', 'octopi')
        def function(var, var)
          clear_cache!
          execute("STRING")
          var, var = pk_and_sequence_for(var);Fi[	@õi˝I"ô        # Changes the default value of a table column.
        def function(var, var, var)
          clear_cache!
          execute("STRING")
        end;Fi[	@õi	I"â        # Renames a column in a table.
        def function(var, var, var)
          clear_cache!
          execute("STRING")
        end;Fi[	I"A# QUOTING ==================================================;F@Hi[[	@UiºI"‚      end
      
      # QUOTING ==================================================
      def function(var, var)
        if var.kind_of?(String) and (var and ((var.type == "LITERAL") and var.class.respond_to?("LITERAL"))) then;Fi[	@Ã	iïI"Æ      end
      
      # QUOTING ==================================================
      def function(var, var)
        return super unless ((var == true) or (var == false));Fi[	@XiøI"‚      end
      
      # QUOTING ==================================================
      def function(var, var)
        if var.kind_of?(String) and (var and ((var.type == "LITERAL") and var.class.respond_to?("LITERAL"))) then;Fi[	I"autoload_at("STRING") do;F@Si[[	@PiI"r    autoload("LITERAL")
    
    autoload_at("STRING") do
      autoload("LITERAL")
      autoload("LITERAL");Fi[	@PiI"b    end
    
    autoload_at("STRING") do
      autoload("LITERAL")
      autoload("LITERAL");Fi[	@Pi)I"b    end
    
    autoload_at("STRING") do
      autoload("LITERAL")
      autoload("LITERAL");Fi[	@ˇI@i[[	@òiæI"`    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #;Fi[	@òiœI"`    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #;Fi[	@òiˆI"`    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #;Fi[	@I"K# @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline;Fi[[	@Îi'I"‡      
      # Returns the 20 most recent Tweets posted by the specified user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.;Fi[	@Îi?I"‚      
      # Returns the 20 most recent retweets posted by the specified user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.;Fi[	@ÎiWI"Á      
      # Returns the 20 most recent retweets posted by the authenticating user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.;Fi[	@¶EI"Avar["LITERAL"]["LITERAL"] = var["LITERAL"].delete("LITERAL");Fi[[	@æ1iI"var = "STRING"
var = eval(IO.read(var), binding, var)
var["LITERAL"]["LITERAL"] = var["LITERAL"].delete("LITERAL")
unless (::ActiveRecord::VERSION::MAJOR == "LITERAL") and ((::ActiveRecord::VERSION::MINOR < "LITERAL") or (::ActiveRecord::VERSION::TINY < "LITERAL")) then;Fi[	@´EiI"{var = "STRING"
var = eval(IO.read(var), binding, var)
var["LITERAL"]["LITERAL"] = var["LITERAL"].delete("LITERAL")
var;Fi[	@ÆEiI"{var = "STRING"
var = eval(IO.read(var), binding, var)
var["LITERAL"]["LITERAL"] = var["LITERAL"].delete("LITERAL")
var;Fi[	@I"E# @see https://dev.twitter.com/docs/api/1.1/get/friendships/show;Fi[[	@ÖiŒI"Ω      
      # Returns detailed information about the relationship between two users
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes;Fi[	@ÖiËI"Æ      
      # Test for the existence of friendship between two users
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes;Fi[	@ÖiI"˙      
      # Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes;Fi[	@g1I"Rowner_class.set_callback("LITERAL", "LITERAL", "STRING", "LITERAL" => (true));Fi[[	@ÃihI"µ        end
        def function
          if (action_hook == "LITERAL") then
            owner_class.set_callback("LITERAL", "LITERAL", "STRING", "LITERAL" => (true))
          end;Fi[	@”iPI"µ        end
        def function
          if (action_hook == "LITERAL") then
            owner_class.set_callback("LITERAL", "LITERAL", "STRING", "LITERAL" => (true))
          end;Fi[	@ÃiI"µ        end
        def function
          if (action_hook == "LITERAL") then
            owner_class.set_callback("LITERAL", "LITERAL", "STRING", "LITERAL" => (true))
          end;Fi[	@N @<i[[	@UiI"g      def function
        begin
          execute("STRING")
        rescue
          # do nothing;Fi[	@UiI"g      def function
        begin
          execute("STRING")
        rescue
          # do nothing;Fi[	@UiI"g      def function
        begin
          execute("STRING")
        rescue
          # do nothing;Fi[	@÷ @|i[[	@ÜiI"ê        (var - var).each do |var|
          if var.include?(var) then
            raise("STRING")
          else
            if (var < var) then;Fi[	@æiwI"∫    def function(var)
      if ::OmniAuth.config.path_prefix and ::OmniAuth.config.path_prefix.!=(var) then
        raise("STRING")
      else
        ::OmniAuth.config.path_prefix = var;Fi[	@ˇiÔI"Ñ            raise("STRING")
          when ::Haml::Error then
            raise("STRING")
          else
            raise("STRING");Fi[	I"# Renames a table.;F@i[[	@Üi%I"c      end
      
      # Renames a table.
      #
      #  rename_table('octopuses', 'octopi');Fi[	@Ui≠I"G      end
      
      # Renames a table.
      #
      # Example:;Fi[	@XisI"G      end
      
      # Renames a table.
      #
      # Example:;Fi[	@g1I"Nowner_class.set_callback("LITERAL", "LITERAL", self, "LITERAL" => (true));Fi[[	@)i<I"Ë      # Uses around callbacks to run state events if using the :save hook
      def function
        if (action_hook == "LITERAL") then
          owner_class.set_callback("LITERAL", "LITERAL", self, "LITERAL" => (true))
        else;Fi[	@,i5I"Ë      # Uses around callbacks to run state events if using the :save hook
      def function
        if (action_hook == "LITERAL") then
          owner_class.set_callback("LITERAL", "LITERAL", self, "LITERAL" => (true))
        else;Fi[	@/i9I"Ë      # Uses around callbacks to run state events if using the :save hook
      def function
        if (action_hook == "LITERAL") then
          owner_class.set_callback("LITERAL", "LITERAL", self, "LITERAL" => (true))
        else;Fi[	I"B# Only runs validations on the action if using <tt>:save</tt>;F@:i[[	@)iI"ã      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function
        (action == "LITERAL");Fi[	@,iI"ã      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function
        (action == "LITERAL");Fi[	@/iI"ã      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function
        (action == "LITERAL");Fi[	@I",#   machine = StateMachine.new(Vehicle);Fi[[	@3iïI"¥    # 
    # == Example
    # 
    #   machine = StateMachine.new(Vehicle)
    #   StateMachine::Transition.new(Vehicle.new, machine, :park, :parked, :parked).loopback?   # => true;Fi[	@3i£I"≠    # 
    # == Example
    # 
    #   machine = StateMachine.new(Vehicle)
    #   transition = StateMachine::Transition.new(Vehicle.new, machine, :ignite, :parked, :idling);Fi[	@3iòI"≠    # 
    # == Example
    # 
    #   machine = StateMachine.new(Vehicle)
    #   transition = StateMachine::Transition.new(Vehicle.new, machine, :ignite, :parked, :idling);Fi[	@I".#   states = Vehicle.state_machine.states;Fi[[	@)iI"ß    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   vehicle = Vehicle.new               # => #<Vehicle:0xb7c464b0 @state="parked">;Fi[	@)i.I"^    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   ;Fi[	@)iII"^    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   ;Fi[	@	+@ˆi[[	@DiI"°        attr_reader("LITERAL")
        
        def function(var, var, var, var)
          super
          @var = Arel::Table.new(var.join_table).alias("STRING");Fi[	@Åi I"É      ADAPTER_NAME = "STRING"
      
      def function(var, var, var, var)
        super
        @var = BindSubstitution.new(self);Fi[	@Ã	iyI"ó      end
      
      def function(var, var, var, var)
        super
        @var = StatementPool.new(@connection, var.fetch("LITERAL") { "LITERAL" });Fi[	I"H# Uses around callbacks to run state events if using the :save hook;F@:i[[	@)i:I"ò      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function
        if (action_hook == "LITERAL") then;Fi[	@,i3I"ò      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function
        if (action_hook == "LITERAL") then;Fi[	@/i7I"ò      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function
        if (action_hook == "LITERAL") then;Fi[	I"#   Defaults to false.;F@i[[	@Üi~I"ƒ      # [<tt>:force</tt>]
      #   Set to true to drop the table before creating it.
      #   Defaults to false.
      #
      # ====== Add a backend specific option to the generated SQL (MySQL);Fi[	@ÜiΩI"ƒ      # [<tt>:force</tt>]
      #   Set to true to drop the table before creating it.
      #   Defaults to false.
      #
      # ====== Add a backend specific option to the generated SQL (MySQL);Fi[	@ÜiÍI"†      #   ALTER TABLE `users` ADD COLUMN age INT(11), ADD COLUMN birthdate DATETIME ...
      #
      #   Defaults to false.
      #
      # ====== Add a column;Fi[	@	+I"var = column_for(var, var);Fi[[	@´i(I"|      end
      
      def function(var, var, var, var)
        var = column_for(var, var)
        bind_value(var, var, var);Fi[	@UiæI"ç      end
      
      def function(var, var, var, var)
        var = column_for(var, var)
        execute("STRING") unless (var or var.nil?);Fi[	@UiaI"§      end
      
      def function(var, var, var, var)
        var = column_for(var, var)
        var["LITERAL"] = var.default unless options_include_default?(var);Fi[	I"7# Returns an array of indexes for the given table.;F@Hi[[	@UiÑI"|      end
      
      # Returns an array of indexes for the given table.
      def function(var, var)
        var = [];Fi[	@õiNI"ò        end
        
        # Returns an array of indexes for the given table.
        def function(var, var)
          var = query("STRING", "STRING");Fi[	@XicI"ö      end
      
      # Returns an array of indexes for the given table.
      def function(var, var)
        exec_query("STRING", "STRING").map do |var|;Fi[	@	+@N i[[	@ÜiLI"‚      # to provide these in a migration's +change+ method so it can be reverted.
      # In that case, +type+ and +options+ will be used by add_column.
      def function(var, var, var, var)
        execute("STRING")
      end;Fi[	@UiµI"`      end
      
      def function(var, var, var, var)
        execute("STRING")
      end;Fi[	@UiƒI"`      end
      
      def function(var, var, var, var)
        execute("STRING")
      end;Fi[	@	+@èJi[[	@õiÁI"’        # Adds a new column to the named table.
        # See TableDefinition#column for details of the options you can use.
        def function(var, var, var, var)
          clear_cache!
          var = "STRING";Fi[	@õiÔI"ó        
        # Changes the column of a table.
        def function(var, var, var, var)
          clear_cache!
          var = quote_table_name(var);Fi[	@õiI"â        end
        
        def function(var, var, var, var)
          clear_cache!
          execute("STRING") unless (var or var.nil?);Fi[	I"I# See TableDefinition#column for details of the options you can use.;F@i[[	@iI"Ø      
      # Adds a new column to the named table.
      # See TableDefinition#column for details of the options you can use.
      #
      # ====== Creating a simple column;Fi[	@iJI"Ã      
      # Changes the column's definition according to the new options.
      # See TableDefinition#column for details of the options you can use.
      #
      #  t.change(:name, :string, limit: 80);Fi[	@ÜiQI"›      
      # Changes the column's definition according to the new options.
      # See TableDefinition#column for details of the options you can use.
      #
      #  change_column(:suppliers, :name, :string, limit: 80);Fi[	I",# Adds a new column to the named table.;F@OKi[[	@iI"ë      end
      
      # Adds a new column to the named table.
      # See TableDefinition#column for details of the options you can use.
      #;Fi[	@Üi5I"∞      end
      
      # Adds a new column to the named table.
      # See TableDefinition#column for details of the options you can use.
      def function(var, var, var, var);Fi[	@õiÂI"∫        end
        
        # Adds a new column to the named table.
        # See TableDefinition#column for details of the options you can use.
        def function(var, var, var, var);Fi[	I" var = var.delete("LITERAL");F@aKi[[	@iÓI"ú      def function(var)
        var = var.extract_options!
        var = var.delete("LITERAL")
        var = var.delete("LITERAL")
        var.each do |var|;Fi[	@Üi‹I"£      #
      def function(var, var, var)
        var = var.delete("LITERAL")
        var = var.delete("LITERAL")
        add_column(var, "STRING", "LITERAL", var);Fi[	@0i:I"µ    def function(var, var)
      var.last.is_a?(Hash) ? (var = var.last) : ((var << (var = {})))
      var = var.delete("LITERAL")
      var = var.delete("LITERAL")
      var = self;Fi[	@ÔJ@|i[[	@)i=I"Æ      def function
        if (action_hook == "LITERAL") then
          owner_class.set_callback("LITERAL", "LITERAL", self, "LITERAL" => (true))
        else
          super;Fi[	@,i6I"Æ      def function
        if (action_hook == "LITERAL") then
          owner_class.set_callback("LITERAL", "LITERAL", self, "LITERAL" => (true))
        else
          super;Fi[	@/i:I"Æ      def function
        if (action_hook == "LITERAL") then
          owner_class.set_callback("LITERAL", "LITERAL", self, "LITERAL" => (true))
        else
          super;Fi[	@ó@6;i[[	@ﬁi(I"®      var = case read("LITERAL", var).unpack("STRING")
      when ["LITERAL", "LITERAL"] then
        "LITERAL"
      when ["LITERAL", "LITERAL"] then
        "LITERAL";Fi[	@ﬁi*I"É        "LITERAL"
      when ["LITERAL", "LITERAL"] then
        "LITERAL"
      when ["LITERAL", "LITERAL"] then
        "LITERAL";Fi[	@ﬁi,I"É        "LITERAL"
      when ["LITERAL", "LITERAL"] then
        "LITERAL"
      when ["LITERAL", "LITERAL"] then
        "LITERAL";Fi[	@	+@ÿi[[	@´iI"ê      end
      
      def function(var, var, var, var)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop);Fi[	@i+I"≥      # @param args [Array]
      # @return [Array]
      def function(var, var, var, var)
        var = Twitter::API::Arguments.new(var)
        merge_user!(var.options, var.pop);Fi[	@iGI"≥      # @param args [Array]
      # @return [Array]
      def function(var, var, var, var)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |var|;Fi[	I":# Runs state events around the machine's :save action;F@£i[[	@)iCI"∞      end
      
      # Runs state events around the machine's :save action
      def function(var)
        var.class.state_machines.transitions(var, action).perform { yield };Fi[	@,i<I"∞      end
      
      # Runs state events around the machine's :save action
      def function(var)
        var.class.state_machines.transitions(var, action).perform { yield };Fi[	@/i@I"∞      end
      
      # Runs state events around the machine's :save action
      def function(var)
        var.class.state_machines.transitions(var, action).perform { yield };Fi[	@I"*#     def initialize(attributes = {});Fi[[	@i˚I"g    #       ...
    #     end
    #     
    #     def initialize(attributes = {})
    #       ...;Fi[	@iI"g    #       ...
    #     end
    #     
    #     def initialize(attributes = {})
    #       ...;Fi[	@i%I"u    #       ...
    #     end
    #     
    #     def initialize(attributes = {})
    #       @state = 'idling';Fi[	@I"#   vehicle = Vehicle.new;Fi[[	@i®I"Ä    #     end
    #   end
    #   
    #   vehicle = Vehicle.new
    #   vehicle.state                             # => "parked";Fi[	@3i∂I"ü    #     end
    #   end
    #   
    #   vehicle = Vehicle.new
    #   transition = StateMachine::Transition.new(vehicle, machine, :ignite, :parked, :idling);Fi[	@3iÍI"≠    #     end
    #   end
    #   
    #   vehicle = Vehicle.new
    #   transition = StateMachine::Transition.new(vehicle, Vehicle.state_machine, :ignite, :parked, :idling);Fi[	@I"O# See +before_transition+ for a description of the possible configurations;Fi[[	@ıiFI"ﬁ        # performed so long as the given configuration options match the
        # transition.
        # 
        # See +before_transition+ for a description of the possible configurations
        # for defining callbacks.;Fi[	@ıijI"°        #     end
        #   end
        # 
        # See +before_transition+ for a description of the possible configurations
        # for defining callbacks.;Fi[	@ıiáI"“        #     end
        #   end
        # 
        # See +before_transition+ for a description of the possible configurations
        # for defining callbacks.  *Note* however that you cannot define the state;Fi[	I"1raise(ArgumentError, "STRING") if var.empty?;F@!6i[[	@~iI"®      def function
        var = CHECKS.keys.&(options.keys)
        raise(ArgumentError, "STRING") if var.empty?
        var.each do |var|
          var = options[var];Fi[	I"1projects//paperclip_proj/paperclip/schema.rb;TiI"À    module Statements
      def function(var, var)
        raise(ArgumentError, "STRING") if var.empty?
        var.each do |var|
          COLUMNS.each_pair { |var, var| add_column(var, "STRING", var) };Fi[	@´KiI"∫      
      def function(var, var)
        raise(ArgumentError, "STRING") if var.empty?
        var.each do |var|
          COLUMNS.each_pair { |var, var| remove_column(var, "STRING") };Fi[	@;I"end.join("STRING");Fi[[	@iÉI"ö        skip_tables.map do |var|
          var = (dump_all? or var["STRING"]) ? (var) : ("STRING")
          "STRING"
        end.join("STRING")
      end;Fi[	@i]I"õ        var.namespace_scopes.map do |var|
          var = var.prefix.nil? ? ("STRING") : ("STRING")
          "STRING"
        end.join("STRING")
      end;Fi[	@«iI"t            end
          end.map do |var|
            "STRING"
          end.join("STRING")
          "STRING";Fi[	@I"#   class VehicleObserver;Fi[[	@ıi!I"{        #     end
        #   end
        #   
        #   class VehicleObserver
        #     include DataMapper::Observer;Fi[	@ıi^I"{        #     end
        #   end
        #   
        #   class VehicleObserver
        #     include DataMapper::Observer;Fi[	@ıi}I"á        #     end
        #   end
        #   
        #   class VehicleObserver
        #     after_transition_failure do |transition|;Fi[	@I"#     property :id, Serial;Fi[[	@ıiI"ù        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String;Fi[	@ıiTI"ù        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String;Fi[	@ıixI"ù        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String;Fi[	@8@i[[	@ıiI"Å        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial;Fi[	@ıiSI"Å        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial;Fi[	@ıiwI"Å        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial;Fi[	@I"if options["LITERAL"] then;Fi[[	@8i.I"†      def function
        case macro
        when "LITERAL" then
          if options["LITERAL"] then
            Associations::BelongsToPolymorphicAssociation;Fi[	@8i6I"«        when "LITERAL" then
          Associations::HasAndBelongsToManyAssociation
        when "LITERAL" then
          if options["LITERAL"] then
            Associations::HasManyThroughAssociation;Fi[	@8i<I"Æ            Associations::HasManyAssociation
          end
        when "LITERAL" then
          if options["LITERAL"] then
            Associations::HasOneThroughAssociation;Fi[	@I"!#   vehicle.state = 'idling';Fi[[	@Êi)I"n    #   vehicle = Vehicle.new               # => #<Vehicle:0xb7c464b0 @state="parked">
    #   events.valid_for(vehicle)           # => [#<StateMachine::Event name=:ignite transitions=[:parked => :idling]>]
    #   
    #   vehicle.state = 'idling'
    #   events.valid_for(vehicle)           # => [#<StateMachine::Event name=:park transitions=[:idling => :parked]>];Fi[	@ÊiNI"¸    #   vehicle = Vehicle.new                             # => #<Vehicle:0xb7c464b0 @state="parked">
    #   events.transitions_for(vehicle)                   # => [#<StateMachine::Transition attribute=:state event=:ignite from="parked" from_name=:parked to="idling" to_name=:idling>]
    #   
    #   vehicle.state = 'idling'
    #   events.transitions_for(vehicle)                   # => [#<StateMachine::Transition attribute=:state event=:park from="idling" from_name=:idling to="parked" to_name=:parked>];Fi[	@)i3I"P    #   vehicle = Vehicle.new         # => #<Vehicle:0xb7c464b0 @state="parked">
    #   states.match(vehicle)         # => #<StateMachine::State name=:parked value="parked" initial=true>
    #   
    #   vehicle.state = 'idling'
    #   states.match(vehicle)         # => #<StateMachine::State name=:idling value="idling" initial=true>;Fi[	@¬KI"##     property :state, :String;Fi[[	@ıiI"í        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     ;Fi[	@ıiUI"í        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     ;Fi[	@ıiyI"í        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     ;Fi[	@@˚5i[[	@ÌiEI"è    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked;Fi[	@ÌiwI"è    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked;Fi[	@i¢I"è    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked;Fi[	I"case var.type;F@i[[	@KiI"à          var = var.to_s
          return "STRING" unless var
          case var.type
          when "LITERAL" then
            "STRING";Fi[	@Ki;I"~          var = var.to_s
          return var unless var
          case var.type
          when "LITERAL" then
            var;Fi[	@S!iI"≈        # Extracts the value from the node as either a string or symbol
        def function(var)
          case var.type
          when "LITERAL" then
            var.jump("LITERAL").source.to_sym;Fi[	@@7Ii[[	@iI"    # Finds and builds the next transition that can be performed on the given
    # object.  If no transitions can be made, then this will return nil.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none;Fi[	@ÊiI"ø    
    # Gets the list of events that can be fired on the given object.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none;Fi[	@Êi1I"¬    
    # Gets the list of transitions that can be run on the given object.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none;Fi[	I"rescue Exception => var;F@"<i[[	@—iäI"~      begin
        Keg.new(f.prefix).optlink
      rescue Exception => var
        onoe("STRING")
        puts("STRING");Fi[	@—i–I"c    begin
      var.link
    rescue Exception => var
      onoe("STRING")
      puts("STRING");Fi[	@—iÂI"~    begin
      Keg.new(f.prefix).fix_install_names
    rescue Exception => var
      onoe("STRING")
      puts("STRING");Fi[	@ÂK@i[[	@ıiI"ö        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do;Fi[	@ıiVI"ö        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do;Fi[	@ıizI"ö        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do;Fi[	@@”Hi[[	@`i!I"È  # If either of those conditions are met, it will use the value obtained
  # from performing one of the above operations to determine the queue.
  #
  # If no queue can be inferred this method will raise a `Resque::NoQueueError`
  #;Fi[	@`iGI"È  # If either of those conditions are met, it will use the value obtained
  # from performing one of the above operations to determine the queue.
  #
  # If no queue can be inferred this method will raise a `Resque::NoQueueError`
  #;Fi[	@`iqI"ó  
  # Validates if the given klass could be a valid Resque job
  #
  # If no queue can be inferred this method will raise a `Resque::NoQueueError`
  #;Fi[	I"/def function(var, var, var, var, var, var);F@Hi[[	@UiI"è        attr_reader("LITERAL", "LITERAL")
        
        def function(var, var, var, var, var, var)
          @var = var
          @var = var;Fi[	@3iQI"¬    # Whether the transition is only existing temporarily for the object
    # Creates a new, specific transition
    def function(var, var, var, var, var, var)
      @var = var
      @var = var;Fi[	@/iI"ì    # @param method_options [Hash]
    # @return [Twitter::Cursor]
    def function(var, var, var, var, var, var)
      @var = var
      @var = var;Fi[	@ë?@Ÿi[[	@iCI"Í      # Executes +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(var, var, var)
        # do nothing;Fi[	@iQI"˛      # Executes delete +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(var, var, var)
        exec_query(var, var, var);Fi[	@iXI"˛      # Executes update +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(var, var, var)
        exec_query(var, var, var);Fi[	@ I@>i[[	@)iI"    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end;Fi[	@)i+I"    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end;Fi[	@)iFI"    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end;Fi[	@I"4Sass::Script::Number.new("LITERAL", ["STRING"]);Fi[[	@¶iÕI"¶      var.value.map! do |var|
        case var.value
        when "LITERAL" then
          Sass::Script::Number.new("LITERAL", ["STRING"])
        when "LITERAL" then;Fi[	@¶iœI"«        when "LITERAL" then
          Sass::Script::Number.new("LITERAL", ["STRING"])
        when "LITERAL" then
          Sass::Script::Number.new("LITERAL", ["STRING"])
        when "LITERAL" then;Fi[	@¶i—I"∏        when "LITERAL" then
          Sass::Script::Number.new("LITERAL", ["STRING"])
        when "LITERAL" then
          Sass::Script::Number.new("LITERAL", ["STRING"])
        else;Fi[	I"D# Executes the SQL statement in the context of this connection.;F@Hi[[	@i:I"ú      undef_method("LITERAL")
      
      # Executes the SQL statement in the context of this connection.
      def function(var, var)
        # do nothing;Fi[	@Ui‚I"∫      
      # DATABASE STATEMENTS ======================================
      # Executes the SQL statement in the context of this connection.
      def function(var, var)
        begin;Fi[	@Åi´I"∆      end
      
      # Executes the SQL statement in the context of this connection.
      def function(var, var)
        @connection.query_options["LITERAL"] = ActiveRecord::Base.default_timezone;Fi[	@I"+raise("STRING") unless which("STRING");Fi[[	@Èi_I"°      safe_system("STRING", "STRING", @tarball_path)
      chdir
    when "LITERAL" then
      raise("STRING") unless which("STRING")
      safe_system("STRING");Fi[	@ÈifI"      safe_system("STRING", "STRING", @tarball_path, File.basename(@url))
      chdir
    when "LITERAL" then
      raise("STRING") unless which("STRING")
      quiet_safe_system("STRING", "STRING", { "LITERAL" => "STRING" }, @tarball_path);Fi[	@ÈiiI"¸      raise("STRING") unless which("STRING")
      quiet_safe_system("STRING", "STRING", { "LITERAL" => "STRING" }, @tarball_path)
    when "LITERAL" then
      raise("STRING") unless which("STRING")
      safe_system("STRING", "STRING", @tarball_path);Fi[	I"# column values as values.;F@Ÿi[[	@iI"¿      
      # Returns an array of record hashes with the column names as keys and
      # column values as values.
      def function(var, var, var)
        select(to_sql(var, var), var, var);Fi[	@ihI"™      
      # Returns an array of record hashes with the column names as keys and
      # column values as values.
      def function(var, var, var)
        # do nothing;Fi[	@ÅiπI"≤      
      # Returns an array of record hashes with the column names as keys and
      # column values as values.
      def function(var, var, var)
        exec_query(var, var);Fi[	I"J# Returns an array of record hashes with the column names as keys and;F@TLi[[	@iI"ü      end
      
      # Returns an array of record hashes with the column names as keys and
      # column values as values.
      def function(var, var, var);Fi[	@igI"ü      end
      
      # Returns an array of record hashes with the column names as keys and
      # column values as values.
      def function(var, var, var);Fi[	@Åi∏I"µ      alias "LITERAL" "LITERAL"
      
      # Returns an array of record hashes with the column names as keys and
      # column values as values.
      def function(var, var, var);Fi[	I"3var.docstring = ["STRING", "STRING", "STRING"];FI" var.parameters = ["STRING"];Fi[[	@›i{I"H          return if inherited_machine
          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING", "LITERAL")))
          var.docstring = ["STRING", "STRING", "STRING"]
          var.parameters = ["STRING"]
          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING", "LITERAL")));Fi[	@›i~I"D          var.parameters = ["STRING"]
          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING", "LITERAL")))
          var.docstring = ["STRING", "STRING", "STRING"]
          var.parameters = ["STRING"]
          unless (integration or instance_attributes.include?(machine.attribute.to_sym)) then;Fi[	@›i∂I"R            var.parameters = [["STRING", "STRING"]]
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, var.qualified_name)))
            var.docstring = ["STRING", "STRING", "STRING"]
            var.parameters = ["STRING"]
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")));Fi[	@@ Di[[	@Èi˚I"~    when "LITERAL" then
      BazaarDownloadStrategy
    when "LITERAL" then
      GitDownloadStrategy
    when "LITERAL" then;Fi[	@Èi˝I"{    when "LITERAL" then
      GitDownloadStrategy
    when "LITERAL" then
      GitDownloadStrategy
    when "LITERAL" then;Fi[	@Èi"I"{    when "LITERAL" then
      CVSDownloadStrategy
    when "LITERAL" then
      GitDownloadStrategy
    when "LITERAL" then;Fi[	@@Di[[	@ÈiˇI"Å    when "LITERAL" then
      GitDownloadStrategy
    when "LITERAL" then
      MercurialDownloadStrategy
    when "LITERAL" then;Fi[	@ÈiI"Ñ    when "LITERAL" then
      FossilDownloadStrategy
    when "LITERAL" then
      MercurialDownloadStrategy
    when "LITERAL" then;Fi[	@Èi$I"Å    when "LITERAL" then
      GitDownloadStrategy
    when "LITERAL" then
      MercurialDownloadStrategy
    when "LITERAL" then;Fi[	@≥?I"Qregister((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")));Fi[[	@›iÖI"a            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, var)))
            namespace.attributes["LITERAL"][var]["LITERAL"] = var
            var.docstring = ["STRING", "STRING"]
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")))
            namespace.attributes["LITERAL"][var]["LITERAL"] = var;Fi[	@›iêI"a            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, var)))
            namespace.attributes["LITERAL"][var]["LITERAL"] = var
            var.docstring = ["STRING", "STRING"]
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")))
            namespace.attributes["LITERAL"][var]["LITERAL"] = var;Fi[	@›iöI"E          var.parameters = ["STRING"]
          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, machine.attribute("LITERAL"))))
          var.docstring = ["STRING", "STRING"]
          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")))
          var.docstring = ["STRING", "STRING"];Fi[	@‰(@ë9i[[	@Ë	i7I"ä            var.perform!
            Logger.clear!
          end)
        rescue => var
          Logger.error(Errors::CLIError.wrap(var));Fi[	@iI"          self.content = $POSTMATCH
          self.data = YAML.load($1)
        end)
      rescue => var
        puts("STRING");Fi[	@Äi(I"é            var.puts("STRING")
            var.puts(var.at("STRING").inner_text)
          end)
        rescue => var
          puts("STRING");Fi[	@ÄLI"=var.docstring = ["STRING", "STRING", "STRING", "STRING"];Fi[[	@›iñI"ı            var.parameters = ["STRING"]
          end
          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")))
          var.docstring = ["STRING", "STRING", "STRING", "STRING"]
          var.parameters = ["STRING"];Fi[	@›i¶I"\          var.docstring = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"]
          var.parameters = [["STRING", "STRING"]]
          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")))
          var.docstring = ["STRING", "STRING", "STRING", "STRING"]
          var.parameters = ["STRING", "STRING"];Fi[	@›i∏I"(            var.docstring = ["STRING", "STRING", "STRING"]
            var.parameters = ["STRING"]
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")))
            var.docstring = ["STRING", "STRING", "STRING", "STRING"]
            var.parameters = ["STRING"];Fi[	@@9Hi[[	@€i&I"í      #
      # @example Using a yield to configure the default options.
      #
      #   class MyStrategy
      #     include OmniAuth::Strategy;Fi[	@€i0I"ë      #
      # @example Using a hash to configure the default options.
      #
      #   class MyStrategy
      #     include OmniAuth::Strategy;Fi[	@€iBI"g      #
      # @example
      #
      #   class MyStrategy
      #     include OmniAuth::Strategy;Fi[	@@√Gi[[	@ÿi(I"˘      # Insert +node_or_tags+ before this node (as a sibling).
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns self, to support chaining of calls.
      #;Fi[	@ÿi4I"¯      # Insert +node_or_tags+ after this node (as a sibling).
      # +node_or_tags+ can be a Nokogiri::XML::Node, a Nokogiri::XML::DocumentFragment, or a string containing markup.
      #
      # Returns self, to support chaining of calls.
      #;Fi[	@ÿivI"‰      # Swap this Node for +node_or_tags+
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns self, to support chaining of calls.
      #;Fi[	I"eregister((var = ::YARD::CodeObjects::MethodObject.new(namespace, machine.attribute("LITERAL"))));FI"[var.docstring = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"];Fi[[	@›iùI"É          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")))
          var.docstring = ["STRING", "STRING"]
          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, machine.attribute("LITERAL"))))
          var.docstring = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"]
          var.parameters = [["STRING", "STRING"]];Fi[	@›i†I"ê          var.docstring = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"]
          var.parameters = [["STRING", "STRING"]]
          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, machine.attribute("LITERAL"))))
          var.docstring = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"]
          var.parameters = [["STRING", "STRING"]];Fi[	@›i£I"ê          var.docstring = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"]
          var.parameters = [["STRING", "STRING"]]
          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, machine.attribute("LITERAL"))))
          var.docstring = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"]
          var.parameters = [["STRING", "STRING"]];Fi[	@¸0@¸0i[[	@w!iMI"—    authenticate_user! if remote_profile_with_no_user_session?
    raise(Diaspora::AccountClosed) if @person.closed_account?
    @var = "LITERAL"
    @var = "LITERAL"
    @var = (params["LITERAL"] == "STRING");Fi[	@ÈiYI"ö      @var = var
      @var = new_encoded_string
      @var = "LITERAL"
      @var = "LITERAL"
      @var = /<[\s]*#{@options["LITERAL"].join("STRING")}/i;Fi[	@3
iXI"a      @var = "LITERAL"
      @var = []
      @var = "LITERAL"
      @var = "LITERAL"
    end;Fi[	@´LI",var.parameters = [["STRING", "STRING"]];Fi[[	@›iûI"ó          var.docstring = ["STRING", "STRING"]
          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, machine.attribute("LITERAL"))))
          var.docstring = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"]
          var.parameters = [["STRING", "STRING"]]
          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, machine.attribute("LITERAL"))));Fi[	@›i°I"ö          var.parameters = [["STRING", "STRING"]]
          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, machine.attribute("LITERAL"))))
          var.docstring = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"]
          var.parameters = [["STRING", "STRING"]]
          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, machine.attribute("LITERAL"))));Fi[	@›i§I"Ü          var.parameters = [["STRING", "STRING"]]
          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, machine.attribute("LITERAL"))))
          var.docstring = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"]
          var.parameters = [["STRING", "STRING"]]
          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")));Fi[	I"$require("twitter/action/tweet");F@i[[	@Z-i I"Crequire("twitter/action/tweet")
module Twitter
  module Action;Fi [	@c-i I"Crequire("twitter/action/tweet")
module Twitter
  module Action;Fi [	@~'i I"Crequire("twitter/action/tweet")
module Twitter
  module Action;Fi [	@I"class Entity;Fi[[	I"5projects//twitter_proj/twitter/entity/hashtag.rb;TiI"`require("twitter/entity")
module Twitter
  class Entity
    class Hashtag < Twitter::Entity;Fi[	I"1projects//twitter_proj/twitter/entity/url.rb;TiI"\require("twitter/entity")
module Twitter
  class Entity
    class Url < Twitter::Entity;Fi[	I":projects//twitter_proj/twitter/entity/user_mention.rb;TiI"drequire("twitter/entity")
module Twitter
  class Entity
    class UserMention < Twitter::Entity;Fi[	@@ÚFi[[	@@i*I"k    #
    # date - The Time to format.
    #
    # Returns the formatted String.
    def function(var);Fi[	@@i8I"å    #   date_to_xmlschema(Time.now)
    #   # => "2011-04-24T20:34:46+08:00"
    #
    # Returns the formatted String.
    def function(var);Fi[	@@irI"¨    #   array_to_sentence_string(["apples", "oranges", "grapes"])
    #   # => "apples, oranges, and grapes"
    #
    # Returns the formatted String.
    def function(var);Fi[	@@‡Fi[[	@iI"ñ    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.;Fi[	@i!I"ñ    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.;Fi[	@
i?I"ñ    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.;Fi[	@◊"@Ÿ-i[[	@¯	i!I"£      # Creates a new instance of the storage object
      def function(var, var, var)
        super(var, var)
        @var ||= "STRING"
        @var ||= "LITERAL";Fi[	@riI"¥      # Creates a new instance of the storage object
      def function(var, var, var)
        super(var, var)
        @var ||= "STRING"
        instance_eval(&var) if block_given?;Fi[	@ziI"¥      # Creates a new instance of the storage object
      def function(var, var, var)
        super(var, var)
        @var ||= "STRING"
        instance_eval(&var) if block_given?;Fi[	@[>@Û*i[[	@˘*i I"Lrequire("twitter/creatable")
require("twitter/identity")
module Twitter;Fi [	@¸*i I"Lrequire("twitter/creatable")
require("twitter/identity")
module Twitter;Fi [	@+i I"Lrequire("twitter/creatable")
require("twitter/identity")
module Twitter;Fi [	I"M# * <tt>:on</tt> - Specifies when this validation is active. Runs in all;FI"S#   validation contexts by default (+nil+), other options are <tt>:create</tt>;Fi[[	@ÇiMI"      # There is also a list of options that could be used along with validators:
      #
      # * <tt>:on</tt> - Specifies when this validation is active. Runs in all
      #   validation contexts by default (+nil+), other options are <tt>:create</tt>
      #   and <tt>:update</tt>.;Fi[	@ki&I"      #
      # * <tt>:message</tt> - A custom error message (default is: "is invalid").
      # * <tt>:on</tt> - Specifies when this validation is active. Runs in all
      #   validation contexts by default (+nil+), other options are <tt>:create</tt>
      #   and <tt>:update</tt>.;Fi[	@ni1I"7      # Configuration options:
      # * <tt>:message</tt> - A custom error message (default is: "can't be blank").
      # * <tt>:on</tt> - Specifies when this validation is active. Runs in all
      #   validation contexts by default (+nil+), other options are <tt>:create</tt>
      #   and <tt>:update</tt>.;Fi[	@˚LI"#   and <tt>:update</tt>.;Fi[[	@ÇiNI"      #
      # * <tt>:on</tt> - Specifies when this validation is active. Runs in all
      #   validation contexts by default (+nil+), other options are <tt>:create</tt>
      #   and <tt>:update</tt>.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine;Fi[	@ki'I"e      # * <tt>:message</tt> - A custom error message (default is: "is invalid").
      # * <tt>:on</tt> - Specifies when this validation is active. Runs in all
      #   validation contexts by default (+nil+), other options are <tt>:create</tt>
      #   and <tt>:update</tt>.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine;Fi[	@ni2I"l      # * <tt>:message</tt> - A custom error message (default is: "can't be blank").
      # * <tt>:on</tt> - Specifies when this validation is active. Runs in all
      #   validation contexts by default (+nil+), other options are <tt>:create</tt>
      #   and <tt>:update</tt>.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine if;Fi[	@l'@Ÿi[[	@´iI"∞      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(var, var, var)
        var = Twitter::API::Arguments.new(var);Fi[	@iI"∞      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(var, var, var)
        var = Twitter::API::Arguments.new(var);Fi[	@iI"∞      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(var, var, var)
        var = Twitter::API::Arguments.new(var);Fi[	@n@l'i[[	@iAI"$      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::User>]
      # @param query [String] The search query to run against people search.;Fi[	@iRI"      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::User>]
      # @overload contributees(options={});Fi[	@iiI"      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::User>]
      # @overload contributors(options={});Fi[	@I"-#     $icons: sprite-map("icons/*.png");;Fi[[	@4i-I"&  # Creates a Compass::SassExtensions::Sprites::SpriteMap object. A sprite map, when used in a property is the same
  # as calling sprite-url. So the following background properties are equivalent:
  #
  #     $icons: sprite-map("icons/*.png");
  #     background: sprite-url($icons) no-repeat;;Fi[	@4iÜI"Ë  # Returns the position for the original image in the sprite.
  # This is suitable for use as a value to background-position:
  #
  #     $icons: sprite-map("icons/*.png");
  #     background-position: sprite-position($icons, new);;Fi[	@4iêI"Á  # You can adjust the background relative to this position by passing values for
  # `$offset-x` and `$offset-y`:
  #
  #     $icons: sprite-map("icons/*.png");
  #     background-position: sprite-position($icons, new, 3px, -2px);;Fi[	@nI"2# @return [Twitter::List] The specified list.;Fi[[	@´i¢I"      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::List] The specified list.
      # @overload list_subscribe(list, options={});Fi[	@´iŸI"      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::List] The specified list.
      # @overload list_unsubscribe(list, options={});Fi[	@´i≥I"      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::List] The specified list.
      # @overload list(list, options={});Fi[	@I"#   en:;Fi[[	@ñi/I"í    #
    # You can also use I18n to customize the message. Action aliases defined in Ability work here.
    #
    #   en:
    #     unauthorized:;Fi[	@'iFI"£      # Setup a subject doing an I18n lookup. At first, it attemps to set a subject
      # based on the current mapping:
      #
      #   en:
      #     devise:;Fi[	@'iNI"{      #
      # If one does not exist, it fallbacks to ActionMailer default:
      #
      #   en:
      #     devise:;Fi[	@I"=#   class ApplicationController < ActionController::Base;Fi[[	@ñiﬂI"Q      # If neither of these authorization methods are called, a CanCan::AuthorizationNotPerformed exception will be raised.
      # This is normally added to the ApplicationController to ensure all controller actions do authorization.
      #
      #   class ApplicationController < ActionController::Base
      #     check_authorization;Fi[	@ñi:I"˚    # You can rescue from the exception in the controller to customize how unauthorized
    # access is displayed to the user.
    #
    #   class ApplicationController < ActionController::Base
    #     rescue_from CanCan::AccessDenied do |exception|;Fi[	@æiïI"„    # you are required to configure default_url_options in your
    # ApplicationController class, so Devise can pick it:
    #
    #   class ApplicationController < ActionController::Base
    #     def self.default_url_options;Fi[	@@≈Bi[[	@ñiµI"√      #     skip_load_and_authorize_resource :only => :index
      #   end
      #
      # You can also pass the resource name as the first argument to skip that resource.
      def function(var);Fi[	@ñiƒI"µ      #     skip_load_resource :only => :index
      #   end
      #
      # You can also pass the resource name as the first argument to skip that resource.
      def function(var);Fi[	@ñi‘I"∫      #     skip_authorize_resource :only => :index
      #   end
      #
      # You can also pass the resource name as the first argument to skip that resource.
      def function(var);Fi[	@Œ+@:i[[	@Œi"I"Ì      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.;Fi[	@Œi5I"Ì      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.;Fi[	@ŒiOI"Ì      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.;Fi[	@@+Ji[[	@UiØI"|      # Renames a table.
      #
      # Example:
      #   rename_table('octopuses', 'octopi')
      def function(var, var);Fi[	@õiŸI"å        # Active Record default.
        #
        # Example:
        #   rename_table('octopuses', 'octopi')
        def function(var, var);Fi[	@XiuI"|      # Renames a table.
      #
      # Example:
      #   rename_table('octopuses', 'octopi')
      def function(var, var);Fi[	@I"# [:+except+];Fi[[	@ñiDI"ù      # [:+only+]
      #   Only applies before filter to given actions.
      #
      # [:+except+]
      #   Does not apply before filter to given actions.;Fi[	@ñiíI"ù      # [:+only+]
      #   Only applies before filter to given actions.
      #
      # [:+except+]
      #   Does not apply before filter to given actions.;Fi[	@ñiÈI"Å      # [:+only+]
      #   Only applies to given actions.
      #
      # [:+except+]
      #   Does not apply to given actions.;Fi[	@ÿI"if var = var.pop then;Fi[[	@~i'I"¥      #     Twitter.favorites('sferik')
      def function(var)
        var = Twitter::API::Arguments.new(var)
        if var = var.pop then
          merge_user!(var.options, var);Fi[	@Ëi"I"Ë      #     Twitter.suggestions("art-design")
      def function(var)
        var = Twitter::API::Arguments.new(var)
        if var = var.pop then
          object_from_response(Twitter::Suggestion, "LITERAL", "STRING", var.options);Fi[	@iI"ø      #     Twitter.user(7505382)  # Same as above
      def function(var)
        var = Twitter::API::Arguments.new(var)
        if var = var.pop then
          merge_user!(var.options, var);Fi[	@∞0@öi[[	@ÇiôI"q        when TrueClass then
          {}
        when Hash then
          var
        when Range, Array then;Fi[	@	iñI"à        when String, Pathname then
          YAML.load(ERB.new(File.read(var)).result)
        when Hash then
          var
        else;Fi[	@ci¸I"à        when String, Pathname then
          YAML.load(ERB.new(File.read(var)).result)
        when Hash then
          var
        else;Fi[	I"p#   See ActiveRecord::Associations::ClassMethods's overview on Bi-directional associations for more detail.;F@i[[	@ÒiQI".      #   that is the inverse of this <tt>has_many</tt> association. Does not work in combination
      #   with <tt>:through</tt> or <tt>:as</tt> options.
      #   See ActiveRecord::Associations::ClassMethods's overview on Bi-directional associations for more detail.
      #
      # Option examples:;Fi[	@Òi∑I"-      #   that is the inverse of this <tt>has_one</tt> association. Does not work in combination
      #   with <tt>:through</tt> or <tt>:as</tt> options.
      #   See ActiveRecord::Associations::ClassMethods's overview on Bi-directional associations for more detail.
      #
      # Option examples:;Fi[	@Òi&I"/      #   object that is the inverse of this <tt>belongs_to</tt> association. Does not work in
      #   combination with the <tt>:polymorphic</tt> options.
      #   See ActiveRecord::Associations::ClassMethods's overview on Bi-directional associations for more detail.
      #
      # Option examples:;Fi[	@I"1#   Backup::Encryptor::GPG.defaults do |enc|;Fi[[	@ziQI"˜      # just specify this in the defaults. Leading tabs/spaces are stripped
      # before writing the given string to the temporary configuration file.
      #
      #   Backup::Encryptor::GPG.defaults do |enc|
      #     enc.gpg_config = <<-EOF;Fi[	@zi{I"æ      # to use be setup in {#keys}. The best place to do this is in your defaults
      # in +config.rb+.
      #
      #   Backup::Encryptor::GPG.defaults do |enc|
      #     enc.keys = {};Fi[	@ziˇI"ı      # but wish to use {#passphrase_file} with a specific {Model}, be sure
      # to clear {#passphrase} within that model's configuration.
      #
      #   Backup::Encryptor::GPG.defaults do |enc|
      #     enc.passphrase = 'secret phrase';Fi[	@ÿ@.i[[	@´iII"Î      #     Twitter.list_timeline(7505382, 8863586)
      def function(var)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options["LITERAL"] or var.options["LITERAL"]) then;Fi[	@´iI"Ë      # @return [Array<Twitter::User>]
      def function(var, var, var)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options["LITERAL"] or var.options["LITERAL"]) then;Fi[	@´iI"Õ      
      def function(var, var, var, var)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options["LITERAL"] or var.options["LITERAL"]) then;Fi[	@Y8@i[[	@ÒiÑI"      # * <tt>Account#create_beneficiary!</tt> (similar to <tt>b = Beneficiary.new("account_id" => id); b.save!; b</tt>)
      #
      # === Options
      #
      # The declaration can also include an options hash to specialize the behavior of the association.;Fi[	@ÒiÎI"°      # The declaration can also include an options hash to specialize the behavior of the association.
      #
      # === Options
      #
      # [:class_name];Fi[	@ÒiîI"ú      # The declaration may include an options hash to specialize the behavior of the association.
      #
      # === Options
      #
      # [:class_name];Fi[	I"f# The declaration can also include an options hash to specialize the behavior of the association.;F@i[[	@ÒiI"C      # * <tt>Firm#clients.build</tt> (similar to <tt>Client.new("firm_id" => id)</tt>)
      # * <tt>Firm#clients.create</tt> (similar to <tt>c = Client.new("firm_id" => id); c.save; c</tt>)
      # The declaration can also include an options hash to specialize the behavior of the association.
      #
      # === Options;Fi[	@ÒiÜI"†      # === Options
      #
      # The declaration can also include an options hash to specialize the behavior of the association.
      #
      # Options are:;Fi[	@ÒiÈI"m      # * <tt>Post#create_author</tt> (similar to <tt>post.author = Author.new; post.author.save; post.author</tt>)
      # * <tt>Post#create_author!</tt> (similar to <tt>post.author = Author.new; post.author.save!; post.author</tt>)
      # The declaration can also include an options hash to specialize the behavior of the association.
      #
      # === Options;Fi[	@I")#   class Shirt < ActiveRecord::Base;Fi[[	@[i9I"        # represents a narrowing of a database query, such as
        # <tt>where(color: :red).select('shirts.*').includes(:washing_instructions)</tt>.
        #
        #   class Shirt < ActiveRecord::Base
        #     scope :red, -> { where(color: 'red') };Fi[	@[iII"µ        # Note that this is simply 'syntactic sugar' for defining an actual
        # class method:
        #
        #   class Shirt < ActiveRecord::Base
        #     def self.red;Fi[	@[inI"–        # \Named scopes can also have extensions, just as with +has_many+
        # declarations:
        #
        #   class Shirt < ActiveRecord::Base
        #     scope :red, -> { where(color: 'red') } do;Fi[	@ÿ@.i[[	@i±I"      #     Twitter.profile_banner(7505382)  # Same as above
      def function(var)
        var = Twitter::API::Arguments.new(var)
        unless (var.options["LITERAL"] or var.options["LITERAL"]) then
          merge_user!(var.options, (var.pop or screen_name));Fi[	@iI"˚      # @return [Array<Twitter::User>]
      def function(var, var, var)
        var = Twitter::API::Arguments.new(var)
        unless (var.options["LITERAL"] or var.options["LITERAL"]) then
          merge_user!(var.options, (var.pop or screen_name));Fi[	@i`I"      # @return [Twitter::Cursor]
      def function(var, var, var, var, var, var)
        var = Twitter::API::Arguments.new(var)
        unless (var.options["LITERAL"] or var.options["LITERAL"]) then
          merge_user!(var.options, (var.pop or screen_name));Fi[	@ß:I"^#   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,;Fi[[	@òi-I"ö      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The;Fi[	@òigI"ö      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The;Fi[	@ki-I"ö      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The;Fi[	I"[var, var];FI"	end];Fi[[	@Úi#I"~              var.association(through_reflection.name).reset
            end
            [var, var]
          end]
        end;Fi[	@ìi'I"†                end
                var = var.gsub("LITERAL", "STRING").gsub("LITERAL", "STRING")
                [var, var]
              end]
            else;Fi[	@
ioI"o          var.puts(("STRING" + "STRING"))
        end
        [var, var]
      end]
      var.map do |var|;Fi[	@¬7@öi[[	@÷iI"o      def function(var, var)
        var = "STRING"
        (var << "STRING") if var
        var
      end;Fi[	@⁄ivI"î          end
          var = (form_tag_without_haml(var, var, *var, &var) + "STRING")
          (var << "STRING") if var
          var
        else;Fi[	@⁄iÖI"|        end
        var = form_for_without_haml(var, *var, &var)
        (var << "STRING") if var
        var
      end;Fi[	@ÿI"&merge_user!(var.options, var.pop);Fi[[	@´i'I"´      
      def function(var, var, var)
        var = Twitter::API::Arguments.new(var)
        merge_user!(var.options, var.pop)
        merge_list!(var.options, var.pop);Fi[	@ißI"	      #   @param options [Hash] A customizable set of options.
      def function(var)
        var = Twitter::API::Arguments.new(var)
        merge_user!(var.options, var.pop)
        cursor_from_response("LITERAL", nil, "LITERAL", "STRING", var.options, "LITERAL");Fi[	@i,I"—      # @return [Array]
      def function(var, var, var, var)
        var = Twitter::API::Arguments.new(var)
        merge_user!(var.options, var.pop)
        objects_from_response(var, var, var, var.options);Fi[	@v0I"# [:+only+];Fi[[	@ñiAI"∂      # See load_and_authorize_resource to automatically authorize the resource too.
      #
      # Options:
      # [:+only+]
      #   Only applies before filter to given actions.;Fi[	@ñièI"±      # See load_and_authorize_resource to automatically load the resource too.
      #
      # Options:
      # [:+only+]
      #   Only applies before filter to given actions.;Fi[	@ñiÊI"≠      # See skip_authorization_check to bypass this check on specific controller actions.
      #
      # Options:
      # [:+only+]
      #   Only applies to given actions.;Fi[	@Ù@∞Ii[[	@bi@I"Y    
    def function(var)
      var = []
      var.each do |var, var|
        begin;Fi[	@≥iI"Ç  class PredicateBuilder
    def self.build_from_hash(var, var, var)
      var = []
      var.each do |var, var|
        var = var;Fi[	@—i≠I"–      # Removes empty hashes and moves everything into arrays.
      def function(var)
        var = []
        var.each do |var, var|
          (var << (var.empty? ? (var) : ({ var => (clean_joins(var)) })));Fi[	@I"# * Validation is skipped.;Fi[[	@1i√I"–    # Updates a single attribute and saves the record.
    # This is especially useful for boolean flags on existing records. Also note that
    #
    # * Validation is skipped.
    # * Callbacks are invoked.;Fi[	@1iËI"Æ    
    # Updates a single attribute of an object, without having to explicitly call save on that object.
    #
    # * Validation is skipped.
    # * Callbacks are skipped.;Fi[	@1iÙI"µ    
    # Updates the attributes from the passed-in hash, without having to explicitly call save on that object.
    #
    # * Validation is skipped.
    # * Callbacks are skipped.;Fi[	I"^# @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.;F@Œ+i[[	@Öi¬I"ë      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Relationship]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      # @param options [Hash] A customizable set of options.
      # @option options [Boolean] :device Enable/disable device notifications from the target user.;Fi[	@ÎiFI"Ø      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;Fi[	@i≥I"∏      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Boolean] true if the authenticating user is blocking the target user, otherwise false.
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      # @param options [Hash] A customizable set of options.
      # @example Check whether the authenticating user is blocking @sferik;Fi[	@(@™,i[[	@∫i2I"{        super(var)
        @var = var
        @var = []
        @var = false
        @var = var.fetch("LITERAL", true);Fi[	@ÏiFI"~        (@precompiled << (@options["LITERAL"] ? ("STRING") : ("STRING")))
      end
      @var = []
      @var = false
    end;Fi[	@3iTI"Z      @var = var
      @var = var
      @var = []
      @var = false
      @var = nil;Fi[	@ØM@?:i[[	@òi.I"õ      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+;Fi[	@òihI"õ      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+;Fi[	@ki.I"õ      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+;Fi[	@I"=#   file                  class               table_name;Fi[[	@&i#I"æ      #   class Invoice < ActiveRecord::Base
      #   end
      #
      #   file                  class               table_name
      #   invoice.rb            Invoice             invoices;Fi[	@&i+I"™      #     end
      #   end
      #
      #   file                  class               table_name
      #   invoice.rb            Invoice::Lineitem   invoice_lineitems;Fi[	@&i3I"¢      #     end
      #   end
      #
      #   file                  class               table_name
      #   invoice/lineitem.rb   Invoice::Lineitem   lineitems;Fi[	@ú:@™i[[	@òi<I"ë      # This can be done with a symbol pointing to a method:
      #
      #   class Comment
      #     include ActiveModel::Validations
      #;Fi[	@òiHI"¢      # With a block which is passed with the current record to be validated:
      #
      #   class Comment
      #     include ActiveModel::Validations
      #;Fi[	@òiVI"•      # Or with a block where self points to the current record to be validated:
      #
      #   class Comment
      #     include ActiveModel::Validations
      #;Fi[	@c%@ Li[[	@i^I"¡      # @param args [Array]
      # @param method_name [Symbol]
      # @return [Twitter::Cursor]
      def function(var, var, var, var, var, var)
        var = Twitter::API::Arguments.new(var);Fi[	@imI"∑      # @param options [Hash]
      # @param method_name [Symbol]
      # @return [Twitter::Cursor]
      def function(var, var, var, var, var, var)
        merge_default_cursor!(var);Fi[	@/iI"¨    # @param method_name [String, Symbol]
    # @param method_options [Hash]
    # @return [Twitter::Cursor]
    def function(var, var, var, var, var, var)
      @var = var;Fi[	I"k#       errors.add(:base, 'Must be friends to leave a comment') unless commenter.friend_of?(commentee);F@>i[[	@òiBI"≤      #
      #     def must_be_friends
      #       errors.add(:base, 'Must be friends to leave a comment') unless commenter.friend_of?(commentee)
      #     end
      #   end;Fi[	@òiPI"≤      #
      #     def must_be_friends
      #       errors.add(:base, 'Must be friends to leave a comment') unless commenter.friend_of?(commentee)
      #     end
      #   end;Fi[	@òiZI"™      #
      #     validate do
      #       errors.add(:base, 'Must be friends to leave a comment') unless commenter.friend_of?(commentee)
      #     end
      #   end;Fi[	@c%I"'# @overload friend_ids(options={});Fi[[	@ÖiI">      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following;Fi[	@ÖiˇI">      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following;Fi[	@ÖiI">      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following;Fi[	@(NI"[#   Returns an array of numeric IDs for every user the authenticated user is following;Fi[[	@ÖiI"      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #;Fi[	@Öi I"      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #;Fi[	@ÖiI"      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #;Fi[	@I"# Raises:;Fi[[	@gi>I"∆        # available, waiting up to +timeout+ seconds for an element to
        # become available.
        #
        # Raises:
        # - ConnectionTimeoutError if +timeout+ is given and no element;Fi[	@giI"ö      #
      # Returns: an AbstractAdapter object.
      #
      # Raises:
      # - ConnectionTimeoutError: no connection can be obtained from the pool.;Fi[	@gi8I"◊      # connection if the pool is not at capacity, 3) waiting on the
      # queue for a connection to become available.
      #
      # Raises:
      # - ConnectionTimeoutError if a connection could not be acquired;Fi[	@…@™,i[[	@i I"Z      @var = {}
      @var = {}
      @var = {}
      @var = false
      @var = false;Fi[	@i3I"c      @var = []
      @var = {}
      @var = {}
      @var = false
      @var = var["LITERAL"];Fi[	@k
igI"Q    # collection
    def function
      @var = {}
      @var = false
    end;Fi[	@…@Hi[[	@i/I"W        @var = []
        @var = {}
        @var = {}
        @var = var
      end;Fi[	@[iyI"`    
    def function(var, var, var, var)
      @var = {}
      @var = var
      @var = var;Fi[	@^%iI"\      super()
      @var = var
      @var = {}
      @var = var
      var.each do |var|;Fi[	@1N@i[[	@ÖiI"Ó      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.;Fi[	@ÖiI"Ó      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.;Fi[	@Öi I"Ó      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.;Fi[	I">#   @example Return the authenticated user's friends' IDs;FI"#     Twitter.friend_ids;Fi[[	@ÖiI"       #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={});Fi[	@ÖiI"ô      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={});Fi[	@Öi&I"ô      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={});Fi[	@_@r<i[[	@≤iLI"À      #
      #   person.pets.select { |pet| pet.name =~ /oo/ }
      #   # => [
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤i£I"±      #
      #   person.pets.last(2)
      #   # => [
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@≤i◊I"ÿ      #
      #   person.pets.create([{name: 'Spook'}, {name: 'Choo-Choo'}])
      #   # => [
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@_I"@#   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[[	@≤iÖI"¥      #
      #   person.pets.first(2)
      #   # => [
      #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>;Ti[	@≤iDI"´      #
      #   person.pets
      #   # => [
      #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>;Ti[	@≤iåI"ø      #   person.id # => 1
      #   person.pets
      #   # => [
      #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@\NI"-# @overload friend_ids(user, options={});Fi[[	@ÖiI"      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following;Fi[	@ÖiI"p      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following;Fi[	@Öi'I"p      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following;Fi[	I"H#   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>];T@i[[	@≤ißI"º      #
      #   person.pets # fetches pets from the database
      #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>]
      #
      #   person.pets # uses the pets cache;Ti[	@≤i™I"√      #
      #   person.pets # uses the pets cache
      #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>]
      #
      #   person.pets.reload # fetches pets from the database;Ti[	@≤i≠I"’      #
      #   person.pets.reload # fetches pets from the database
      #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>]
      #
      #   person.pets(true)  # fetches pets from the database;Ti[	@vNI"W#   Returns an array of numeric IDs for every user the specified user is following;Fi[[	@ÖiI"Ó      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #;Fi[	@Öi	I"Ó      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #;Fi[	@Öi(I"Ó      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #;Fi[	@I@£i[[	@òiñI"N      #   #       #<ActiveModel::Validations::PresenceValidator:0x007fe604914e60 @attributes=[:name], @options={}>,
      #   #       #<ActiveModel::Validations::InclusionValidator:0x007fe603bb8780 @attributes=[:age], @options={in:0..99}>
      #   #    ]
      def function(var)
        var.flat_map { |var| _validators[var.to_sym] };Fi[	@≤iI"«      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(var)
        @association.delete(*var);Ti[	@≤iêI"“      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(var)
        proxy_association.concat(var) and self;Ti[	@àN@i[[	@ÖiI"      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.;Fi[	@Öi
I"      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.;Fi[	@Öi)I"      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.;Fi[	@I@:i[[	@òiÇI"„      #   #      #<OtherValidator:0x007fbff403d930 @options={on: :create}>,
      #   #      #<StrictValidator:0x007fbff3204a30 @options={strict:true}>
      #   #    ]
      def function
        _validators.values.flatten.uniq;Fi[	@≤iµI"º      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function
        @association.length;Ti[	@≤ivI"¥      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      def function
        load_target.dup;Ti[	@r@Hi[[	@NiI"d      @var = var
      if var.is_a?(Hash) then
        @var = nil
        @var = var
      else;Fi[	@ëiI"P      @var = var
      @var = var
      @var = nil
      @var = var
    end;Fi[	@Æi-I"l          @var = nil
          @var = nil
          @var = nil
          @var = var
          validate!;Fi[	@ƒJ@(	i[[	@ÖiœI"‰      # Returns detailed information about the relationship between two users
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	@ÖiÈI"’      # Test for the existence of friendship between two users
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	@ÖiI"!      # Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	I"$merge_user!(var, var, "STRING");FI"Fvar["LITERAL"] = var.delete("LITERAL") unless var["LITERAL"].nil?;Fi[[	@Öi‹I"˛      #   Twitter.friendship(7505382, 14100886)    # Same as above
      def function(var, var, var)
        merge_user!(var, var, "STRING")
        var["LITERAL"] = var.delete("LITERAL") unless var["LITERAL"].nil?
        merge_user!(var, var, "STRING");Fi[	@ÖiﬁI"1        merge_user!(var, var, "STRING")
        var["LITERAL"] = var.delete("LITERAL") unless var["LITERAL"].nil?
        merge_user!(var, var, "STRING")
        var["LITERAL"] = var.delete("LITERAL") unless var["LITERAL"].nil?
        object_from_response(Twitter::Relationship, "LITERAL", "STRING", var);Fi[	@´iVI"±      # @return [Hash]
      def function(var, var)
        merge_user!(var, var, "STRING")
        var["LITERAL"] = var.delete("LITERAL") unless var["LITERAL"].nil?
        var;Fi[	@I"#   Pet.find(1, 2, 3);Ti[[	@≤iMI"~      #   person.pets.size # => 0
      #   person.pets      # => []
      #
      #   Pet.find(1, 2, 3)
      #   # => [;Ti[	@≤ikI"†      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1, 2, 3)
      #   # => ActiveRecord::RecordNotFound;Ti[	@≤iÑI"†      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1, 2, 3)
      #   # => ActiveRecord::RecordNotFound;Ti[	@Ú!I"# @param options [Hash];Fi[[	@i3I"ñ      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param options [Hash]
      # @return [Array];Fi[	@iPI"ó      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param options [Hash]
      # @return [Object];Fi[	@ijI"¢      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param options [Hash]
      # @param method_name [Symbol];Fi[	@Õ,@l'i[[	@´iI"®      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(var, var, var);Fi[	@iI"®      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(var, var, var);Fi[	@iI"®      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(var, var, var);Fi[	I"# @return [Array];F@Hi[[	@Îi∏I"p      
      # @param count [Integer]
      # @return [Array]
      def function(var, var)
        var = {};Fi[	@i=I"û      # @param klass [Class]
      # @param array [Array]
      # @return [Array]
      def function(var, var)
        var.map { |var| var.fetch_or_new(var) };Fi[	@/i&I"«    # @param collection [Array]
    # @param cursor [Integer]
    # @return [Array]
    def function(var, var)
      var = @client.send(@method_name.to_sym, @method_options.merge("LITERAL" => (var)));Fi[	@09@_i[[	@≤iDI"ç      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@≤ieI"ç      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@≤i~I"ç      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@›N@	+i[[	@i*I"¶      # @param path [String]
      # @param args [Array]
      # @return [Array]
      def function(var, var, var, var)
        var = Twitter::API::Arguments.new(var);Fi[	@i5I"≠      # @param path [String]
      # @param options [Hash]
      # @return [Array]
      def function(var, var, var, var)
        var = send(var.to_sym, var, var)["LITERAL"];Fi[	@iFI"¶      # @param path [String]
      # @param args [Array]
      # @return [Array]
      def function(var, var, var, var)
        var = Twitter::API::Arguments.new(var);Fi[	@≤JI"<# @note This method can only return up to 3,200 Tweets.;Fi[[	@Îi(I"Û      # Returns the 20 most recent Tweets posted by the specified user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes;Fi[	@Îi@I"ı      # Returns the 20 most recent retweets posted by the specified user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes;Fi[	@ÎiXI"˙      # Returns the 20 most recent retweets posted by the authenticating user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes;Fi[	@ˆN@(	i[[	@Îi)I"⁄      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	@ÎiAI"⁄      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	@ÎiYI"⁄      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	@@i[[	@|iwI"q      # * <tt>:less_than</tt>
      # * <tt>:less_than_or_equal_to</tt>
      #
      # For example:
      #;Fi[	@ç
iéI"ë    # value and a <tt>:_destroy</tt> key set to a truthy value will mark the
    # matched record for destruction.
    #
    # For example:
    #;Fi[	@JiÒI"ê    # Used in cases where a method or scope could return zero records but the
    # result needs to be chainable.
    #
    # For example:
    #;Fi[	@@	+i[[	@ãioI"ü    #     # check the database and return true/false
    #   end
    #
    def function(var, var, var, var)
      (rules << Rule.new(true, var, var, var, var));Fi[	@ãiI"à    #     product.invisible?
    #   end
    #
    def function(var, var, var, var)
      (rules << Rule.new(false, var, var, var, var));Fi[	@Õ*iI"†    #
    #   :swallow_stderr -> Set to true if you don't care what happens on STDERR.
    #
    def function(var, var, var, var)
      var = options["LITERAL"];Fi[	@t;I"´# @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.;Fi[[	@ÎiLI"Ö      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @example Return the 20 most recent retweets posted by @sferik;Fi[	@ÎicI"ï      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @example Return the 20 most recent retweets posted by the authenticating user;Fi[	@ÎiäI"√      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @option options [Boolean, String, Integer] :include_entities The tweet entities node will be disincluded when set to false.;Fi[	@~4@”i[[	@v
i
I"ê      extend(ActiveSupport::Autoload)
      
      eager_autoload do
        autoload("LITERAL", "STRING")
        autoload("LITERAL", "STRING");Fi[	@ÒiëI"o    end
    
    eager_autoload do
      autoload("LITERAL", "STRING")
      autoload("LITERAL", "STRING");Fi[	@niHI"u  autoload("LITERAL")
  
  eager_autoload do
    autoload("LITERAL", "STRING")
    autoload("LITERAL", "STRING");Fi[	@I"/#   <?xml version="1.0" encoding="UTF-8"?>;Fi[[	@ci´I"}      #   user = User.find(1)
      #   user.to_xml
      #
      #   <?xml version="1.0" encoding="UTF-8"?>
      #   <user>;Fi[	@hiI"Ã    # By default the generated XML document will include the processing
    # instruction and all the object's attributes. For example:
    #
    #   <?xml version="1.0" encoding="UTF-8"?>
    #   <topic>;Fi[	@hi9I"}    #
    #   firm.to_xml include: [ :account, :clients ]
    #
    #   <?xml version="1.0" encoding="UTF-8"?>
    #   <firm>;Fi[	@Q/@Œ+i[[	@i0I"Ñ      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::User] The authenticated user.
      # @param options [Hash] A customizable set of options.
      # @option options [Boolean, String, Integer] :skip_status Do not include user's Tweets when set to true, 't' or 1.;Fi[	@iQI"s      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::User] The authenticated user.
      # @param options [Hash] A customizable set of options.
      # @option options [String] :name Full name associated with the profile. Maximum of 20 characters.;Fi[	@isI"`      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::User] The authenticated user.
      # @param options [Hash] A customizable set of options.
      # @option options [String] :profile_background_color Profile background color.;Fi[	I"# Initializes a new object;F@i[[	@oi6I"P    end
    
    # Initializes a new object
    #
    # @param attrs [Hash];Fi[	@[iI"P    end
    
    # Initializes a new object
    #
    # @param attrs [Hash];Fi[	@DiI"wmodule Twitter
  class Relationship < Twitter::Base
    # Initializes a new object
    #
    # @param attrs [Hash];Fi[	@Æ@Si[[	@ki I"hmodule ActiveRecord
  module Validations
    class AssociatedValidator < ActiveModel::EachValidator;Fi [	@ni I"wmodule ActiveRecord
  module Validations
    class PresenceValidator < ActiveModel::Validations::PresenceValidator;Fi [	@qi I"hmodule ActiveRecord
  module Validations
    class UniquenessValidator < ActiveModel::EachValidator;Fi [	@I"#     def attributes;Fi[[	@]iI"w    #
    #     attr_accessor :name, :age
    #
    #     def attributes
    #       {'name' => nil, 'age' => nil};Fi[	@`ipI"g      #       end
      #     end
      #
      #     def attributes
      #       instance_values;Fi[	@ciÃI"g      #       end
      #     end
      #
      #     def attributes
      #       instance_values;Fi[	@I"(#   class User < ActiveRecord::Base;Fi[[	@ViEI"—    module InstanceMethodsOnActivation
      # Returns +self+ if the password is correct, otherwise +false+.
      #
      #   class User < ActiveRecord::Base
      #     has_secure_password validations: false;Fi[	@ViTI"◊      # Encrypts the password into the +password_digest+ attribute, only if the
      # new password is not blank.
      #
      #   class User < ActiveRecord::Base
      #     has_secure_password validations: false;Fi[	@#iI"›    # You can override +to_param+ in your model to make +user_path+ construct
    # a path using the user's name instead of the user's id:
    #
    #   class User < ActiveRecord::Base
    #     def to_param  # overridden;Fi[	I"&# Returns an array of photo sizes;F@i[[	@/i
I"ß    attr_reader("LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL")
    
    # Returns an array of photo sizes
    #
    # @return [Array<Twitter::Size>];Fi[	@ˇ*iI"±      attr_reader("LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL")
      
      # Returns an array of photo sizes
      #
      # @return [Array<Twitter::Size>];Fi[	@AiI"Ömodule Twitter
  class ProfileBanner < Twitter::Base
    # Returns an array of photo sizes
    #
    # @return [Array<Twitter::Size>];Fi[	@"J@:i[[	@/iI"¢    # Returns an array of photo sizes
    #
    # @return [Array<Twitter::Size>]
    def function
      @var ||= Array(@attrs["LITERAL"]).inject({}) do |var, var|;Fi[	@ˇ*iI"¨      # Returns an array of photo sizes
      #
      # @return [Array<Twitter::Size>]
      def function
        @var ||= Array(@attrs["LITERAL"]).inject({}) do |var, var|;Fi[	@Ai
I"¢    # Returns an array of photo sizes
    #
    # @return [Array<Twitter::Size>]
    def function
      @var ||= Array(@attrs["LITERAL"]).inject({}) do |var, var|;Fi[	@çBI"/var[var] = Twitter::Size.fetch_or_new(var);Fi[[	@/iI"µ    # @return [Array<Twitter::Size>]
    def function
      @var ||= Array(@attrs["LITERAL"]).inject({}) do |var, var|
        var[var] = Twitter::Size.fetch_or_new(var)
        var;Fi[	@ˇ*iI"ø      # @return [Array<Twitter::Size>]
      def function
        @var ||= Array(@attrs["LITERAL"]).inject({}) do |var, var|
          var[var] = Twitter::Size.fetch_or_new(var)
          var;Fi[	@AiI"µ    # @return [Array<Twitter::Size>]
    def function
      @var ||= Array(@attrs["LITERAL"]).inject({}) do |var, var|
        var[var] = Twitter::Size.fetch_or_new(var)
        var;Fi[	@mO@öi[[	@/iI"ö    def function
      @var ||= Array(@attrs["LITERAL"]).inject({}) do |var, var|
        var[var] = Twitter::Size.fetch_or_new(var)
        var
      end;Fi[	@ˇ*iI"§      def function
        @var ||= Array(@attrs["LITERAL"]).inject({}) do |var, var|
          var[var] = Twitter::Size.fetch_or_new(var)
          var
        end;Fi[	@AiI"ö    def function
      @var ||= Array(@attrs["LITERAL"]).inject({}) do |var, var|
        var[var] = Twitter::Size.fetch_or_new(var)
        var
      end;Fi[	@ÆI"module Scoping;Fi[[	@Ti I"<module ActiveRecord
  module Scoping
    module Default;Fi [	@[iI"ûrequire("active_support/core_ext/hash/except")
require("active_support/core_ext/kernel/singleton_class")
module ActiveRecord
  module Scoping
    module Named;Fi[	@@i I"Lmodule ActiveRecord
  module Scoping
    extend(ActiveSupport::Concern);Fi [	@@Ji[[	@ iI"Q      #
      #   #{prefix}#{attr}(*args, &block)
      #
      # to
      #;Fi[	@ i@I"Q      #
      #   #{attr}#{suffix}(*args, &block)
      #
      # to
      #;Fi[	@ idI"Z      #
      #   #{prefix}#{attr}#{suffix}(*args, &block)
      #
      # to
      #;Fi[	@@i[[	@ÇiaI"      #   validates :password, presence: true, confirmation: true, if: :password_required?
      #   validates :token, uniqueness: true, strict: TokenGenerationException
      #
      #
      # Finally, the options +:if+, +:unless+, +:on+, +:allow_blank+, +:allow_nil+, +:strict+;Fi[	@ iSI"      #     self.table_name = 'the_table_i_really_want'
      #   end
      #
      #
      # <tt>self.abstract_class = true</tt> is required to make <tt>Child<.find,.create, or any Arel method></tt> use <tt>the_table_i_really_want</tt> instead of a table called <tt>super_classes</tt>;Fi[	@ÔiI"z    #         <p>bar</p>
    #     <strong>baz</strong>
    #
    #
    # @param i [Fixnum] The number of tabs to use;Fi[	I"require("twitter/entity");F@i[[	@—Li I"<require("twitter/entity")
module Twitter
  class Entity;Fi [	@‘Li I"<require("twitter/entity")
module Twitter
  class Entity;Fi [	@◊Li I"<require("twitter/entity")
module Twitter
  class Entity;Fi [	@)I"J# Attempt to find a user by its email. If a record is found, send new;Fi[[	@0iºI"Ÿ      end
      
      module ClassMethods
        # Attempt to find a user by its email. If a record is found, send new
        # confirmation instructions to it. If not, try searching for a user by unconfirmed_email;Fi[	@iÅI"∆      end
      
      module ClassMethods
        # Attempt to find a user by its email. If a record is found, send new
        # unlock instructions to it. If not user is found, returns a new user;Fi[	@iUI"»      end
      
      module ClassMethods
        # Attempt to find a user by its email. If a record is found, send new
        # password instructions to it. If user is not found, returns a new user;Fi[	@)@:i[[	@iI"x      included { @var = Mutex.new }
      
      module ClassMethods
        def function
          superclass.name;Fi[	@‚i
I"•      extend(ActiveSupport::Concern)
      
      module ClassMethods
        def function
          defined? @scoped_views ? (@scoped_views) : (Devise.scoped_views);Fi[	@™iI"      end
      
      module ClassMethods
        def function
          Rails::Generators.hide_namespace(self.namespace);Fi[	@)@Hi[[	@∞i\I"π        extend(ActiveSupport::Concern)
        
        module ClassMethods
          def function(var, var)
            var = var.delete("LITERAL") { true } ? ("LITERAL") : ("LITERAL");Fi[	@∏i	I"    extend(ActiveSupport::Concern)
    
    module ClassMethods
      def function(var, var)
        connection.quote(var, var);Fi[	@ªiI"~    end
    
    module ClassMethods
      def function(var, var)
        serialize(var, IndifferentCoder.new(var["LITERAL"]));Fi[	@$I"4mattr_accessor("LITERAL", "LITERAL" => (false));Fi[[	@≥iI"•      extend(ActiveSupport::Concern)
      
      included do
        mattr_accessor("LITERAL", "LITERAL" => (false))
        self.time_zone_aware_attributes = false;Fi[	@iI"£    extend(ActiveSupport::Concern)
    
    included do
      mattr_accessor("LITERAL", "LITERAL" => (false))
      mattr_accessor("LITERAL", "LITERAL" => (false));Fi[	@&i	I"§    extend(ActiveSupport::Concern)
    
    included do
      mattr_accessor("LITERAL", "LITERAL" => (false))
      class_attribute("LITERAL", "LITERAL" => (false));Fi[	@™,@™,i[[	@i!I"]      @var = {}
      @var = {}
      @var = false
      @var = false
      @var = false;Fi[	@i"I"_      @var = {}
      @var = false
      @var = false
      @var = false
      @var = true;Fi[	@Qi I"T      @var = var
      @var = nil
      @var = false
      @var = false
    end;Ti[	I"rescue NotImplementedError;F@n
i[[	@G
i*I"î            begin
              File.lchown(var.uid, var.gid, var)
            rescue NotImplementedError
              # do nothing
            end;Fi[	@G
i4I"ô            begin
              File.lchmod(var.mode.&("LITERAL"), var)
            rescue NotImplementedError
              # do nothing
            end;Fi[	@G
i>I"å            begin
              File.lchmod(var.mode, var)
            rescue NotImplementedError
              # do nothing
            end;Fi[	I"M# See StateMachine::Machine#transition for a description of the possible;FI"/# configurations for defining transitions.;Fi[[	@ieI"£    #  end
    # 
    # See StateMachine::Machine#transition for a description of the possible
    # configurations for defining transitions.
    def function(var);Fi[	@0i*I"§    #   end
    # 
    # See StateMachine::Machine#transition for a description of the possible
    # configurations for defining transitions.
    def function(var);Fi[	I"var, var = var;F@p6i[[	@i<I"ã        var.!=(@machine) and var.events[qualified_name, "LITERAL"]
      end) then
        var, var = var
        warn("STRING")
      else;Fi[	@*iKI"ö        end
        if var = var.detect { |var, var| var.attribute.!=(var.attribute) } then
          var, var = var
          warn("STRING")
        else;Fi[	I"var = var.foreign_key;F@|i[[	@´i<I"í              var = var.association_primary_key
            end
            var = var.foreign_key
          else
            var = var.foreign_key;Fi[	@qiDI"ƒ          if var = var.class.reflect_on_association(var) then
            var = var.send(var.foreign_key)
            var = var.foreign_key
          else
            var = var.read_attribute(var);Fi[	@5.@ni[[	@
i9I"~    def function(var)
      var = @controller.class.cancan_skipper[var][@name]
      if var.nil? then
        false
      else;Fi[	@·#iI"Y  
  def self.user_is_following?(var, var)
    if var.nil? then
      false
    else;Fi[	@hCI"reset_scope;Fi[[	@®iI"j        var.check_validity!
        @var, @var = var, var
        reset
        reset_scope
      end;Fi[	@®i%I"É      # Reloads the \target and returns +self+ on success.
      def function
        reset
        reset_scope
        load_target;Fi[	@5.@;i[[	@ìi~I"f        
        def function(var)
          if var.nil? then
            "STRING"
          else;Fi[	@	iI"d      
      def self.parse_error(var)
        if var.nil? then
          "STRING"
        else;Fi[	I"*class BelongsTo < SingularAssociation;F@:i[[	@ÑiI"xmodule ActiveRecord::Associations::Builder
  class BelongsTo < SingularAssociation
    def function
      "LITERAL";Fi[	@€iI"µ  module Associations
    class Preloader
      class BelongsTo < SingularAssociation
        def function
          (reflection.options["LITERAL"] or (klass and klass.primary_key));Fi[	I"*class HasMany < CollectionAssociation;F@:i[[	@âiI"xmodule ActiveRecord::Associations::Builder
  class HasMany < CollectionAssociation
    def function
      "LITERAL";Fi[	@„iI"ã  module Associations
    class Preloader
      class HasMany < CollectionAssociation
        def function
          reflection.foreign_key;Fi[	I"'class HasOne < SingularAssociation;F@:i[[	@åiI"umodule ActiveRecord::Associations::Builder
  class HasOne < SingularAssociation
    def function
      "LITERAL";Fi[	@ÈiI"à  module Associations
    class Preloader
      class HasOne < SingularAssociation
        def function
          reflection.foreign_key;Fi[	@S.I"&@set_attributes["LITERAL"] = true;Fi[[	@a"iZI"â      def function(var)
        @var ||= {}
        if block_given? then
          @set_attributes["LITERAL"] = true
          @var = var;Fi[	@a"iuI"é      def function(var, var)
        @var ||= {}
        if block_given? then
          @set_attributes["LITERAL"] = true
          @var = var;Fi[	I"6reflection.klass.count_by_sql(custom_counter_sql);F@|i[[	@ØiÄI"Ì        if (options["LITERAL"] or options["LITERAL"]) then
          raise(ArgumentError, "STRING") unless var.blank?
          reflection.klass.count_by_sql(custom_counter_sql)
        else
          if association_scope.uniq_value then;Fi[	@ƒi3I"Æ        else
          if (options["LITERAL"] or options["LITERAL"]) then
            reflection.klass.count_by_sql(custom_counter_sql)
          else
            scope.count;Fi[	I"Nif var.any? { |var| (var.kind_of?(Fixnum) or var.kind_of?(String)) } then;FI"var = find(var);Fi[[	@ØiùI"ò          end
        else
          if var.any? { |var| (var.kind_of?(Fixnum) or var.kind_of?(String)) } then
            var = find(var)
          end;Fi[	@Øi™I"π      # ignoring the +:dependent+ option.
      def function(var)
        if var.any? { |var| (var.kind_of?(Fixnum) or var.kind_of?(String)) } then
          var = find(var)
        end;Fi[	I"H# If the collection has been already loaded +size+ and +length+ are;FI"F# equivalent. If not and you are going to need the records anyway;Fi[[	@Øi¥I"      # <tt>collection.size</tt> if it has.
      #
      # If the collection has been already loaded +size+ and +length+ are
      # equivalent. If not and you are going to need the records anyway
      # +length+ will take one less query. Otherwise +size+ is more efficient.;Fi[	@≤iâI"F      # it executes a <tt>SELECT COUNT(*)</tt> query. Else it calls <tt>collection.size</tt>.
      #
      # If the collection has been already loaded +size+ and +length+ are
      # equivalent. If not and you are going to need the records anyway
      # +length+ will take one less query. Otherwise +size+ is more efficient.;Ti[	@(PI"M# +length+ will take one less query. Otherwise +size+ is more efficient.;Fi[[	@ØiµI"      #
      # If the collection has been already loaded +size+ and +length+ are
      # equivalent. If not and you are going to need the records anyway
      # +length+ will take one less query. Otherwise +size+ is more efficient.
      #;Fi[	@≤iäI"      #
      # If the collection has been already loaded +size+ and +length+ are
      # equivalent. If not and you are going to need the records anyway
      # +length+ will take one less query. Otherwise +size+ is more efficient.
      #;Ti[	@/P@i[[	@Øi∂I"'      # If the collection has been already loaded +size+ and +length+ are
      # equivalent. If not and you are going to need the records anyway
      # +length+ will take one less query. Otherwise +size+ is more efficient.
      #
      # This method is abstract in the sense that it relies on;Fi[	@≤iãI"      # If the collection has been already loaded +size+ and +length+ are
      # equivalent. If not and you are going to need the records anyway
      # +length+ will take one less query. Otherwise +size+ is more efficient.
      #
      #   class Person < ActiveRecord::Base;Ti[	I"K# equivalent. If not and you are going to need the records anyway this;FI"K# method will take one less query. Otherwise +size+ is more efficient.;Fi[[	@ØiŒI"˛      #
      # If the collection has been already loaded +length+ and +size+ are
      # equivalent. If not and you are going to need the records anyway this
      # method will take one less query. Otherwise +size+ is more efficient.
      def function;Fi[	@≤i§I"5      # Returns the size of the collection calling +size+ on the target.
      # If the collection has been already loaded, +length+ and +size+ are
      # equivalent. If not and you are going to need the records anyway this
      # method will take one less query. Otherwise +size+ is more efficient.
      #;Ti[	I"K# Replace this collection with +other_array+. This will perform a diff;FI"5# and delete/add only records that have changed.;Fi[[	@ØiıI"¨      end
      
      # Replace this collection with +other_array+. This will perform a diff
      # and delete/add only records that have changed.
      def function(var);Fi[	@≤iI"ú      end
      
      # Replace this collection with +other_array+. This will perform a diff
      # and delete/add only records that have changed.
      #;Ti[	I"if var.new_record? then;F@M%i[[	@¡iI"à      
      def function(var, var, var)
        if var.new_record? then
          if var then
            var.save!("LITERAL" => (var));Fi[	@Xi1I"õ      def function(var, var, var)
        ensure_not_nested
        if var.new_record? then
          if var then
            var.save!("LITERAL" => (var));Fi[	@ì@@öi[[	@Ã	i‡I"w          var, var = exec_stmt(var, var, var)
        end
        yield(var) if block_given?
        var
      end;Fi[	@’)iI"≤      var = var.rack.subdirs.map { |var| Keg.new(var) }
      unless var.any? { |var| (var.version >= var.version) } then
        yield(var) if block_given?
        var
      end;Fi[	I"var = var.flatten;F@öi[[	@^i5I"]      
      def function(var, var, var)
        var = var.flatten
        var
      end;Fi[	@^i:I"]      
      def function(var, var, var)
        var = var.flatten
        var
      end;Fi[	I"2require("active_support/core_ext/array/wrap");F@Æi[[	@®i I"\require("active_support/core_ext/array/wrap")
module ActiveRecord
  module Associations;Fi [	@Ji I"\require("active_support/core_ext/array/wrap")
module ActiveRecord
  module QueryMethods;Fi [	@ÆI"class Relation;Fi[[	@äiI"krequire("active_support/core_ext/hash/keys")
module ActiveRecord
  class Relation
    class HashMerger;Fi[	@Qi I"imodule ActiveRecord
  class Relation
    JoinOperation = Struct.new("LITERAL", "LITERAL", "LITERAL");Ti [	@Ì2@ûIi[[	@3
i`I"û          if contains_interpolation?(var) then
            var = unescape_interpolation(var, var)
            var = true
            var = false
          end;Fi[	@3
igI"î        if contains_interpolation?(var) then
          var = unescape_interpolation(var, var)
          var = true
          var = false
        end;Fi[	I"var.flatten.each do |var|;FI" raise_on_type_mismatch(var);Fi[[	@ØiõI"ò      def function(var)
        var = true
        var.flatten.each do |var|
          raise_on_type_mismatch(var)
          add_to_target(var) do |var|;Fi[	@XiI"≤      def function(var)
        unless owner.new_record? then
          var.flatten.each do |var|
            raise_on_type_mismatch(var)
            var.save! if var.new_record?;Fi[	I"$if (var.size == "LITERAL") then;F@–>i[[	@—i{I"Á        var = @rules.map(&"LITERAL").compact
        if defined? ActiveRecord::Relation and var.any? { |var| var.kind_of?(ActiveRecord::Relation) } then
          if (var.size == "LITERAL") then
            var.first
          else;Fi[	@É$iI"§      var = /^#{Regexp.escape(var)}/
      var = @commands.keys.select { |var| var.to_s.=~(var) }
      if (var.size == "LITERAL") then
        var.first
      else;Fi[	@ÿ7I"#var = var.delete_at("LITERAL");Fi[[	@mioI"§      
      def function(var)
        var = var.first
        var = var.delete_at("LITERAL")
        class_for_adapter(var["STRING"]).new(*var).structure_dump(var);Fi[	@miuI"§      
      def function(var)
        var = var.first
        var = var.delete_at("LITERAL")
        class_for_adapter(var["STRING"]).new(*var).structure_load(var);Fi[	I"var ? ([var]) : (var);F@|i[[	@Øi€I"ø          var = var.first
          var = load_target.detect { |var| (var == var.id) }
          var ? ([var]) : (var)
        else
          load_target.select { |var| var.include?(var.id) };Fi[	@‹	iËI"{      when "LITERAL" then
        var = find_one(var.first)
        var ? ([var]) : (var)
      else
        find_some(var);Fi[	@ÆI"class Migration;Fi[[	@Ÿ	i I"Dmodule ActiveRecord
  class Migration
    class CommandRecorder;Fi [	I"Fprojects//activerecord_proj/active_record/migration/join_table.rb;Ti I"?module ActiveRecord
  class Migration
    module JoinTable;Fi [	@ÆI"module Locking;Fi[[	@#$i I"?module ActiveRecord
  module Locking
    module Optimistic;Fi [	I"Eprojects//activerecord_proj/active_record/locking/pessimistic.rb;Ti I"@module ActiveRecord
  module Locking
    module Pessimistic;Fi [	@ÆI"module Serialization;Fi[[	I"?projects//activerecord_proj/active_record/serialization.rb;Ti I"Rmodule ActiveRecord
  module Serialization
    extend(ActiveSupport::Concern);Fi [	@hiI"ârequire("active_support/core_ext/hash/conversions")
module ActiveRecord
  module Serialization
    include(ActiveModel::Serializers::Xml);Fi[	I"require("active_support");FI"$require("active_support/rails");Fi[[	@˘i I"^require("active_support")
require("active_support/rails")
require("active_model/version");Fi [	@ni I"Vrequire("active_support")
require("active_support/rails")
require("active_model");Fi [	I"run_callbacks("LITERAL");F@Æi[[	@„	igI"v    def function
      begin
        run_callbacks("LITERAL")
      ensure
        clear_transaction_record_state;Fi[	@„	iqI"}    def function(var)
      begin
        run_callbacks("LITERAL")
      ensure
        restore_transaction_record_state(var);Fi[	I""#   person.pets.select(:name);T@_i[[	@≤i0I"É      #   #    ]
      #
      #   person.pets.select(:name)
      #   # => [
      #   #      #<Pet id: nil, name: "Fancy-Fancy">,;Ti[	@≤iiI"|      #   end
      #
      #   person.pets.select(:name)
      #   # => [
      #   #      #<Pet name: "Fancy-Fancy">,;Ti[	I",#   #      #<Pet id: 2, name: "Spook">,;TI"/#   #      #<Pet id: 3, name: "Choo-Choo">;Ti[[	@≤i:I"¥      #   # => [
      #   #      #<Pet id: 1, name: "Fancy-Fancy">,
      #   #      #<Pet id: 2, name: "Spook">,
      #   #      #<Pet id: 3, name: "Choo-Choo">
      #   #    ];Ti[	@≤iSI"ø      #   person.pets.select(:name) { |pet| pet.name =~ /oo/ }
      #   # => [
      #   #      #<Pet id: 2, name: "Spook">,
      #   #      #<Pet id: 3, name: "Choo-Choo">
      #   #    ];Ti[	@¿P@Ii[[	@≤i;I"´      #   #      #<Pet id: 1, name: "Fancy-Fancy">,
      #   #      #<Pet id: 2, name: "Spook">,
      #   #      #<Pet id: 3, name: "Choo-Choo">
      #   #    ]
      #;Ti[	@≤iTI"ù      #   # => [
      #   #      #<Pet id: 2, name: "Spook">,
      #   #      #<Pet id: 3, name: "Choo-Choo">
      #   #    ]
      def function(var, var);Ti[	@ÆI"%($stderr.write(color("LITERAL"));Fi[[	@
i$I"ï        $stdout.write(color("LITERAL"))
        yield)
      ensure
        ($stderr.write(color("LITERAL"))
        $stdout.write(color("LITERAL")));Fi[	@
i/I"ï        $stdout.write(color("LITERAL"))
        yield)
      ensure
        ($stderr.write(color("LITERAL"))
        $stdout.write(color("LITERAL")));Fi[	@ÆI"var.rewind;Fi[[	@	iDI"h            directory.save
            retry
          ensure
            var.rewind
          end);Fi[	@ci“I"f            create_bucket
            retry
          ensure
            var.rewind
          end;Fi[	I"O# If the collection is empty, the first form returns +nil+, and the second;TI"## form returns an empty array.;Ti[[	@≤iyI"’      
      # Returns the first record, or the first +n+ records, from the collection.
      # If the collection is empty, the first form returns +nil+, and the second
      # form returns an empty array.
      #;Ti[	@≤iíI"”      
      # Returns the last record, or the last +n+ records, from the collection.
      # If the collection is empty, the first form returns +nil+, and the second
      # form returns an empty array.
      #;Ti[	@‹P@i[[	@≤izI"˙      # Returns the first record, or the first +n+ records, from the collection.
      # If the collection is empty, the first form returns +nil+, and the second
      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base;Ti[	@≤iìI"¯      # Returns the last record, or the last +n+ records, from the collection.
      # If the collection is empty, the first form returns +nil+, and the second
      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base;Ti[	@mNI"9#   #      #<Pet id: 2, name: "Spook", person_id: 1>;Ti[[	@≤iÜI"Ω      #   person.pets.first(2)
      #   # => [
      #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>
      #   #    ];Ti[	@≤iEI"¥      #   person.pets
      #   # => [
      #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>
      #   #    ];Ti[	@ÈP@Ii[[	@≤iáI"¶      #   # => [
      #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>
      #   #    ]
      #;Ti[	@≤iFI"¶      #   # => [
      #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>
      #   #    ]
      #;Ti[	@;9I"!#   person.pets      # => [];Ti[[	@≤iKI"j      #   #    ]
      #
      #   person.pets.size # => 0
      #   person.pets      # => []
      #;Ti[	@≤iùI"{      #   person.pets.destroy_all
      #
      #   person.pets.size # => 0
      #   person.pets      # => []
      #;Ti[	@˛@i[[	@≤iI"–      #   person.pets.concat(Pet.new(name: 'Fancy-Fancy'))
      #   person.pets.concat(Pet.new(name: 'Spook'), Pet.new(name: 'Choo-Choo'))
      #   person.pets.size # => 3
      #
      #   person.id # => 1;Ti[	@≤iàI"»      #   person.pets << Pet.new(name: 'Fancy-Fancy')
      #   person.pets << [Pet.new(name: 'Spook'), Pet.new(name: 'Choo-Choo')]
      #   person.pets.size # => 3
      #
      #   person.id # => 1;Ti[	@Æ@ri[[	@
i7I"Q        yield
        @registered)
      ensure
        @var = nil
      end;Fi[	@®ixI"[          (@var = var
          yield)
        ensure
          @var = nil
        end;Fi[	I"#   person.id # => 1;T@^i[[	@≤iI"p      #   person.pets.size # => 3
      #
      #   person.id # => 1
      #   person.pets
      #   # => [;Ti[	@≤iäI"p      #   person.pets.size # => 3
      #
      #   person.id # => 1
      #   person.pets
      #   # => [;Ti[	I"A#     has_many :pets # dependent: :nullify option by default;T@i[[	@≤i9I"å      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets # dependent: :nullify option by default
      #   end
      #;Ti[	@≤i∞I"å      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets # dependent: :nullify option by default
      #   end
      #;Ti[	@ÆI"var["LITERAL"] = var;Fi[[	@‘	i2I"å        var, var["LITERAL"] = var["LITERAL"], []
        return [yield, var["LITERAL"]])
      ensure
        var["LITERAL"] = var
      end;Fi[	@‘	iVI"{        var, var["LITERAL"] = var["LITERAL"], false
        yield)
      ensure
        var["LITERAL"] = var
      end;Fi[	@ˆP@i[[	@≤iLI"u      #
      #   person.pets.size # => 0
      #   person.pets      # => []
      #
      #   Pet.find(1, 2, 3);Ti[	@≤iûI"ã      #
      #   person.pets.size # => 0
      #   person.pets      # => []
      #
      #   Pet.find(1) # => Couldn't find Pet with id=1;Ti[	@√NI"*#   # => ActiveRecord::RecordNotFound;Ti[[	@≤ilI"m      #   #    ]
      #
      #   Pet.find(1, 2, 3)
      #   # => ActiveRecord::RecordNotFound
      #;Ti[	@≤iÖI"x      #   #    ]
      #
      #   Pet.find(1, 2, 3)
      #   # => ActiveRecord::RecordNotFound
      def function;Ti[	I"# information.;T@i[[	@≤iWI"‰      # If it is set to <tt>:destroy</tt> all the objects from the collection
      # are removed by calling their +destroy+ method. See +destroy+ for more
      # information.
      #
      #   class Person < ActiveRecord::Base;Ti[	@`iLI"¿  # If no args are given, this method will dequeue *all* jobs matching
  # the provided class. See `Resque::Job.destroy` for more
  # information.
  #
  # Returns the number of jobs destroyed.;Fi[	I".#     has_many :pets, dependent: :destroy;T@i[[	@≤iZI"~      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :destroy
      #   end
      #;Ti[	@≤iÃI"~      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :destroy
      #   end
      #;Ti[	I"0# *without* calling their +destroy+ method.;T@i[[	@≤ipI"∑      #
      # If it is set to <tt>:delete_all</tt>, all the objects are deleted
      # *without* calling their +destroy+ method.
      #
      #   class Person < ActiveRecord::Base;Ti[	@≤iÂI"π      #
      # If it is set to <tt>:delete_all</tt>, all the +records+ are deleted
      # *without* calling their +destroy+ method.
      #
      #   class Person < ActiveRecord::Base;Ti[	I"1#     has_many :pets, dependent: :delete_all;T@i[[	@≤isI"|      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :delete_all
      #   end
      #;Ti[	@≤iËI"|      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :delete_all
      #   end
      #;Ti[	I"(#   person.pets.delete(Pet.find(1));T@:i[[	@≤iªI"ã      #   #    ]
      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #;Ti[	@≤iÛI"ã      #   #    ]
      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #;Ti[	@Æ@Hi[[	@ÏiI"ä          send(:"compile_#{var.type}") { var.children.each { |var| compile(var) } }
        end)
      ensure
        @var = var
      end;Fi[	@,
i4I"g          var = @_haml_concat_raw
          yield)
        ensure
          @var = var
        end;Fi[	I"0#     validates_presence_of :name, on: :new;F@i[[	@òiﬂI"j    #
    #     attr_accessor :name
    #     validates_presence_of :name, on: :new
    #   end
    #;Fi[	@òiI"j    #
    #     attr_accessor :name
    #     validates_presence_of :name, on: :new
    #   end
    #;Fi[	I"!#   person.pets.size  # => 0;TI""#   person.pets       # => [];Ti[[	@≤i;I"l      #   #    ]
      #
      #   person.pets.size  # => 0
      #   person.pets       # => []
      #;Ti[	@≤i[I"l      #   #    ]
      #
      #   person.pets.size  # => 0
      #   person.pets       # => []
      #;Ti[	@\Q@i[[	@≤i<I"ø      #
      #   person.pets.size  # => 0
      #   person.pets       # => []
      #
      #   Pet.find(1, 2, 3) # => ActiveRecord::RecordNotFound: Couldn't find all Pets with IDs (1, 2, 3);Ti[	@≤i\I"ø      #
      #   person.pets.size  # => 0
      #   person.pets       # => []
      #
      #   Pet.find(4, 5, 6) # => ActiveRecord::RecordNotFound: Couldn't find all Pets with IDs (4, 5, 6);Ti[	I"N# against (the context is defined on the validations using <tt>:on</tt>).;F@i[[	@òiŸI"π    #
    # Context can optionally be supplied to define which callbacks to test
    # against (the context is defined on the validations using <tt>:on</tt>).
    #
    #   class Person;Fi[	@òi I"π    #
    # Context can optionally be supplied to define which callbacks to test
    # against (the context is defined on the validations using <tt>:on</tt>).
    #
    #   class Person;Fi[	I"K# Context can optionally be supplied to define which callbacks to test;F@iQi[[	@òiÿI"ƒ    #   person.valid? # => true
    #
    # Context can optionally be supplied to define which callbacks to test
    # against (the context is defined on the validations using <tt>:on</tt>).
    #;Fi[	@òiˇI"«    #   person.invalid? # => false
    #
    # Context can optionally be supplied to define which callbacks to test
    # against (the context is defined on the validations using <tt>:on</tt>).
    #;Fi[	@r@…i[[	@i%I"R      @var = false
      @var = true
      @var = nil
      @var = {}
    end;Fi[	@iI"q        if var.is_a?(String) then
          @var = var
          @var = nil
          @var = {}
        else;Fi[	I"#     pet.group == 'cats';T@i[[	@≤iÂI"s      #
      #   person.pets.any? do |pet|
      #     pet.group == 'cats'
      #   end
      #   # => false;Ti[	@≤iI"s      #
      #   person.pets.many? do |pet|
      #     pet.group == 'cats'
      #   end
      #   # => true;Ti[	I"#   # => false;T@i[[	@≤iÁI"s      #     pet.group == 'cats'
      #   end
      #   # => false
      #
      #   person.pets.any? do |pet|;Ti[	@≤iI"t      #     pet.group == 'dogs'
      #   end
      #   # => false
      #
      #   person.pets.many? do |pet|;Ti[	@ÑQ@£i[[	@≤iQI"u      #
      #   person.pets == other
      #   # => false
      def function(var)
        (load_target == var);Ti[	@¸i=I"¢      #
      #   Person.instance_method_already_implemented?(:name)
      #   # => false
      def function(var)
        if dangerous_attribute_method?(var) then;Fi[	I"#     pet.group == 'dogs';T@i[[	@≤iÍI"r      #
      #   person.pets.any? do |pet|
      #     pet.group == 'dogs'
      #   end
      #   # => true;Ti[	@≤iI"t      #
      #   person.pets.many? do |pet|
      #     pet.group == 'dogs'
      #   end
      #   # => false;Ti[	I"#   # => true;T@£i[[	@≤iÏI"~      #     pet.group == 'dogs'
      #   end
      #   # => true
      def function(var)
        @association.any?(&var);Ti[	@≤iI"      #     pet.group == 'cats'
      #   end
      #   # => true
      def function(var)
        @association.many?(&var);Ti[	@_@D.i[[	@≤iPI"¡      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>;Ti[	@≤iVI"µ      #
      #   person.pets.destroy(5, 6)
      #   # => [
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>;Ti[	I""var.save!("LITERAL" => (var));F@|i[[	@¡iI"•        if var.new_record? then
          if var then
            var.save!("LITERAL" => (var))
          else
            return unless var.save("LITERAL" => (var));Fi[	@Xi3I"•        if var.new_record? then
          if var then
            var.save!("LITERAL" => (var))
          else
            return unless var.save("LITERAL" => (var));Fi[	I"case options["LITERAL"];F@ï;i[[	@ƒi	I"´    class HasManyAssociation < CollectionAssociation
      def function
        case options["LITERAL"]
        when "LITERAL", "LITERAL" then
          unless empty? then;Fi[	@q
i	I"©    class HasOneAssociation < SingularAssociation
      def function
        case options["LITERAL"]
        when "LITERAL", "LITERAL" then
          if load_target then;Fi[	I"?var = klass.human_attribute_name(reflection.name).downcase;FI"?owner.errors.add("LITERAL", "LITERAL", "LITERAL" => (var));Fi[[	@ƒiI"ÿ        when "LITERAL" then
          unless empty? then
            var = klass.human_attribute_name(reflection.name).downcase
            owner.errors.add("LITERAL", "LITERAL", "LITERAL" => (var))
            false;Fi[	@q
iI"Ÿ        when "LITERAL" then
          if load_target then
            var = klass.human_attribute_name(reflection.name).downcase
            owner.errors.add("LITERAL", "LITERAL", "LITERAL" => (var))
            false;Fi[	@¥Q@ni[[	@ƒiI"           unless empty? then
            var = klass.human_attribute_name(reflection.name).downcase
            owner.errors.add("LITERAL", "LITERAL", "LITERAL" => (var))
            false
          end;Fi[	@q
iI"À          if load_target then
            var = klass.human_attribute_name(reflection.name).downcase
            owner.errors.add("LITERAL", "LITERAL", "LITERAL" => (var))
            false
          end;Fi[	I"9owner.send("LITERAL", cached_counter_attribute_name);F@|i[[	@ƒi0I"≈      def function
        var = if has_cached_counter? then
          owner.send("LITERAL", cached_counter_attribute_name)
        else
          if (options["LITERAL"] or options["LITERAL"]) then;Fi[	@XiI"Æ      def function
        if has_cached_counter? then
          owner.send("LITERAL", cached_counter_attribute_name)
        else
          loaded? ? (target.size) : (count);Fi[	@6I"Lreturn [var, var["LITERAL"]] if (var["LITERAL"]["LITERAL"] == "STRING");Fi[[	@˝i]I"€      return [var, var["LITERAL"]] if (var["LITERAL"]["LITERAL"] == "STRING")
      var, var = valparse(var)
      (var << var)
      return [var, var["LITERAL"]] if (var["LITERAL"]["LITERAL"] == "STRING")
      loop do;Fi[	@˝ibI"∞        var = eat("STRING", var)
        var, var = valparse(var)
        (var << var)
        return [var, var["LITERAL"]] if (var["LITERAL"]["LITERAL"] == "STRING")
      end;Fi[	@…@ri[[	@XiI"^      def function(var, var)
        super
        @var = {}
        @var = nil
      end;Fi[	@AiI"h        def function(var)
          @var = var
          @var = {}
          @var = nil
        end;Fi[	@6I"&((var << "STRING") << var) if var;Fi[[	@Èi‡I"|    end
    (var << var) if var.exist?.!
    (var << var)
    ((var << "STRING") << var) if var
    (var << "STRING") if var;Fi[	@Èi˙I"©    var = [@@svn, var, "STRING", "STRING", "STRING"]
    (var << var) if var.exist?.!
    (var << var)
    ((var << "STRING") << var) if var
    (var << "STRING") if var;Fi[	@6@ø	i[[	@‡"i]I"í        var = Array.new
        var.split("STRING").each do |var|
          (var << var)
          begin
            var.mkdir(var.join("STRING"));Fi[	@iQI"ì        var = Array.new
        var.split("STRING").each do |var|
          (var << var)
          begin
            var.mkdir!(var.join("STRING"));Fi[	@…@(i[[	@XiI"é        @var = var
        @var = [JoinBase.new(var)]
        @var = {}
        @var = []
        @var = AliasTracker.new(var.connection, var);Fi[	@[iäI"{        raise(RuntimeError, "STRING")
      end
      @var = {}
      @var = []
      @@already_loaded_fixtures ||= {};Fi[	I"target.delete;F@i[[	@q
i1I"É          case var
          when "LITERAL" then
            target.delete
          when "LITERAL" then
            target.destroy;Fi[	@q
iII"~        case var
        when "LITERAL" then
          target.delete
        when "LITERAL" then
          target.destroy;Fi[	@6@|i[[	@∞i8I"∞          end
          if block_given? and var = yield(var, var) then
            (var << var)
          else
            (var << serialize_property(var, var)) unless var.nil?;Fi[	@.!iQI"å    var.children.sort.each do |var|
      if var.directory? then
        (var << var)
      else
        if block_given? and yield(var) then;Fi[	@(@I1i[[	@ı	iI"S    def function
      @var = []
      @var = []
      @var = "STRING"
    end;Fi[	@ÏiI"Z      @var = var
      @var = "LITERAL"
      @var = []
      @var = "STRING"
    end;Fi[	I"#     def must_be_friends;F@Ni[[	@òiAI"       #     validate :must_be_friends
      #
      #     def must_be_friends
      #       errors.add(:base, 'Must be friends to leave a comment') unless commenter.friend_of?(commentee)
      #     end;Fi[	@òiOI"¥      #     end
      #
      #     def must_be_friends
      #       errors.add(:base, 'Must be friends to leave a comment') unless commenter.friend_of?(commentee)
      #     end;Fi[	@(@ri[[	@zinI"è      def function
        FileUtils.rm_rf(@tempdirs, "LITERAL" => (true)) if @tempdirs
        @var = []
        @var = nil
        @var = nil;Fi[	@i I"ë      # A list of Nokogiri::XML::SyntaxError found when parsing a document
      def function(var)
        @var = []
        @var = nil
      end;Fi[	I"G# * <tt>:allow_blank</tt> - Skip validation if attribute is blank.;F@Ï0i[[	@òi(I"Ä      #   (e.g. <tt>on: :create</tt> or <tt>on: :custom_validation_context</tt>)
      # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.
      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,;Fi[	@òibI"Ä      #   (e.g. <tt>on: :create</tt> or <tt>on: :custom_validation_context</tt>)
      # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.
      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,;Fi[	@(@…i[[	@i-I"r      # that have been defined.
      def function(var)
        @var = []
        @var = {}
        @var = {};Fi[	@i1I"W      @var = var
      @var = true
      @var = []
      @var = {}
      @var = {};Fi[	I"E# * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.;F@Ri[[	@òi'I"Ä      # * <tt>:on</tt> - Specifies the context where this validation is active
      #   (e.g. <tt>on: :create</tt> or <tt>on: :custom_validation_context</tt>)
      # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.
      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine;Fi[	@òiaI"Ä      # * <tt>:on</tt> - Specifies the context where this validation is active
      #   (e.g. <tt>on: :create</tt> or <tt>on: :custom_validation_context</tt>)
      # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.
      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine;Fi[	@(@¸0i[[	@“iI"_      else
        @var = Contact.new
        @var = []
        @var = "LITERAL"
      end;Fi[	@3
iWI"l      @var = false
      @var = "LITERAL"
      @var = []
      @var = "LITERAL"
      @var = "LITERAL";Fi[	@(I"if @contact then;Fi[[	@“iI"±      @var = current_user.contact_for(@person)
      @var = (@person.!=(current_user.person) and @contact)
      @var = []
      if @contact then
        @var = @contact.aspects;Fi[	@B5iI"å      @var = "LITERAL"
      @var = current_user.contact_for(@person)
      @var = []
      if @contact then
        @var = @contact.aspects;Fi[	I"var = var.reflections[var];FI"(remove_uniq_by_reflection(var, var);Fi[[	@XiAI"ú        case var
        when Symbol, String then
          var = var.reflections[var]
          remove_uniq_by_reflection(var, var)
        when Array then;Fi[	@XiGI"£        when Hash then
          var.keys.each do |var|
            var = var.reflections[var]
            remove_uniq_by_reflection(var, var)
            var = [];Fi[	@˚$I"sanitize_sql_array(var);Fi[[	@∏iI"Ç        return nil if var.blank?
        case var
        when Array then
          sanitize_sql_array(var)
        when Hash then;Fi[	@∏i-I"~      def function(var)
        case var
        when Array then
          sanitize_sql_array(var)
        when Hash then;Fi[	@˚$I"arrenc(var);Fi[[	@˝i]I"b      when Hash then
        objenc(var)
      when Array then
        arrenc(var)
      else;Fi[	@˝ihI"n      when Hash then
        objenc(var)
      when Array then
        arrenc(var)
      when String then;Fi[	I"O#   (e.g. <tt>on: :create</tt> or <tt>on: :custom_validation_context</tt>);F@Ri[[	@òi&I"@      # Options:
      # * <tt>:on</tt> - Specifies the context where this validation is active
      #   (e.g. <tt>on: :create</tt> or <tt>on: :custom_validation_context</tt>)
      # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.
      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.;Fi[	@òi`I"@      # Options:
      # * <tt>:on</tt> - Specifies the context where this validation is active
      #   (e.g. <tt>on: :create</tt> or <tt>on: :custom_validation_context</tt>)
      # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.
      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.;Fi[	@Ù@ø	i[[	@ï#iAI"g        def function
          fast_fit
          var = []
          begin
            var = false;Fi[	@
iI"}      var = (var + "STRING")
      var = "LITERAL"
      var = []
      begin
        (var = ((var or "LITERAL") + "LITERAL");Fi[	I"M# * <tt>:on</tt> - Specifies the context where this validation is active;F@?Ri[[	@òi%I"ˇ      #
      # Options:
      # * <tt>:on</tt> - Specifies the context where this validation is active
      #   (e.g. <tt>on: :create</tt> or <tt>on: :custom_validation_context</tt>)
      # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.;Fi[	@òi_I"ˇ      #
      # Options:
      # * <tt>:on</tt> - Specifies the context where this validation is active
      #   (e.g. <tt>on: :create</tt> or <tt>on: :custom_validation_context</tt>)
      # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.;Fi[	@v0@LRi[[	@òi$I"∆      #   end
      #
      # Options:
      # * <tt>:on</tt> - Specifies the context where this validation is active
      #   (e.g. <tt>on: :create</tt> or <tt>on: :custom_validation_context</tt>);Fi[	@òi^I"∆      #   end
      #
      # Options:
      # * <tt>:on</tt> - Specifies the context where this validation is active
      #   (e.g. <tt>on: :create</tt> or <tt>on: :custom_validation_context</tt>);Fi[	@ÙI"chain.each do |var|;Fi[[	@÷iI"Ω      
      def function
        var = []
        chain.each do |var|
          (var << alias_tracker.aliased_table_for(table_name_for(var), table_alias_for(var, var.!=(self.reflection))));Fi[	@»i≈I",          var = {}
          ATTRIBUTES.each do |var|
            var = []
            chain.each do |var|
              (var << { "LITERAL" => (var.send("STRING") rescue nil), "LITERAL" => (var.send("STRING") rescue nil), "LITERAL" => (var.send("STRING") rescue nil), "LITERAL" => (var.send(var)) });Fi[	@ÙI"Mtransferred_files_for(var) { |var, var| (var << ("STRING" + "STRING")) };Fi[[	@¯	iaI"«      def function(var)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) { |var, var| (var << ("STRING" + "STRING")) }
        Logger.message(var.join("STRING"));Fi[	@i?I"«      def function(var)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) { |var, var| (var << ("STRING" + "STRING")) }
        Logger.message(var.join("STRING"));Fi[	@ÙI"?var.find_formula { |var| (var << var.basename.join(var)) };Fi[[	@ÊiI"≥    raise("STRING") if var.directory?
    abort unless system("STRING")
    var = []
    var.find_formula { |var| (var << var.basename.join(var)) }
    var = link_tap_formula(var);Fi[	@ÊiNI"À    var = "LITERAL"
    HOMEBREW_REPOSITORY.join("STRING").children.each do |var|
      var = []
      var.find_formula { |var| (var << var.basename.join(var)) }
      var = (var + link_tap_formula(var));Fi[	I"*set_target_and_inverse(var, var, var);F@|i[[	@XißI"Ê          end
          var = var.instantiate(var) unless var[var.aliased_primary_key].nil?
          set_target_and_inverse(var, var, var)
        else
          var = var.instantiate(var) unless var[var.aliased_primary_key].nil?;Fi[	@Xi±I"∏            var.set_inverse_instance(var)
          when "LITERAL" then
            set_target_and_inverse(var, var, var)
          else
            raise(ConfigurationError, "STRING");Fi[	I"var.target = var;FI""var.set_inverse_instance(var);Fi[[	@XiªI"ù      def function(var, var, var)
        var = var.association(var.reflection.name)
        var.target = var
        var.set_inverse_instance(var)
      end;Fi[	@ÔiI"£            var = var.first
            var = var.association(reflection.name)
            var.target = var
            var.set_inverse_instance(var)
          end;Fi[	I"extend(HelperMethods);FI"include(HelperMethods);Fi[[	@òiI"£      extend(ActiveModel::Callbacks)
      extend(ActiveModel::Translation)
      extend(HelperMethods)
      include(HelperMethods)
      attr_accessor("LITERAL");Fi[	@BiI"Z    
    included do
      extend(HelperMethods)
      include(HelperMethods)
    end;Fi[	I"J# * <tt>:strict</tt> - Specifies whether validation should be strict.;FI"N#   See <tt>ActiveModel::Validation#validates!</tt> for more information.;Fi[[	@ãiHI"
      #   The method, proc or string should return or evaluate to a +true+ or
      #   +false+ value.
      # * <tt>:strict</tt> - Specifies whether validation should be strict.
      #   See <tt>ActiveModel::Validation#validates!</tt> for more information.
      #;Fi[	@ni<I"Z      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:strict</tt> - Specifies whether validation should be strict.
      #   See <tt>ActiveModel::Validation#validates!</tt> for more information.
      def function(var);Fi[	I"L#   The method, proc or string should return or evaluate to a +true+ or;FI"#   +false+ value.;Fi[[	@ãi@I"E      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>).
      #   The method, proc or string should return or evaluate to a +true+ or
      #   +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to;Fi[	@ãiFI"/      #   (e.g. <tt>unless: :skip_validation</tt>, or
      #   <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>).
      #   The method, proc or string should return or evaluate to a +true+ or
      #   +false+ value.
      # * <tt>:strict</tt> - Specifies whether validation should be strict.;Fi[	@$4I"strenc(var);Fi[[	@˝ijI"q      when Array then
        arrenc(var)
      when String then
        strenc(var)
      when Numeric then;Fi[	@˝iÉI"_    def function(var)
      case var
      when String then
        strenc(var)
      else;Fi[	I"case var.macro;F@i[[	@v
i}I"ë      
      def function(var)
        case var.macro
        when "LITERAL" then
          var.options["LITERAL"] ? (HasManyThrough) : (HasMany);Fi[	@[i¨I"æ          end
          var.reflect_on_all_associations.each do |var|
            case var.macro
            when "LITERAL" then
              var = (var.options["LITERAL"] or "STRING").to_s;Fi[	I"var = build_record(var);F@ì@i[[	@˜iI"}      
      def function(var)
        var = build_record(var)
        yield(var) if block_given?
        set_new_record(var);Fi[	@˜i9I"}      
      def function(var, var)
        var = build_record(var)
        yield(var) if block_given?
        var = var.save;Fi[	I"$require("active_record/errors");F@Æi[[	@ÒiI"ﬂrequire("active_support/core_ext/string/conversions")
require("active_support/core_ext/module/remove_method")
require("active_record/errors")
module ActiveRecord
  class InverseOfAssociationNotFoundError < ActiveRecordError;Fi[	@[i
I"√require("active_support/dependencies")
require("active_record/fixture_set/file")
require("active_record/errors")
module ActiveRecord
  class FixtureClassNotFound < ActiveRecord::ActiveRecordError;Fi[	I")# [collection(force_reload = false)];FI"8#   Returns an array of all the associated objects.;Fi[[	@ÒiΩI"›      # collections of associated objects will be added:
      #
      # [collection(force_reload = false)]
      #   Returns an array of all the associated objects.
      #   An empty array is returned if none are found.;Fi[	@ÒiUI"‡      # Adds the following methods for retrieval and query:
      #
      # [collection(force_reload = false)]
      #   Returns an array of all the associated objects.
      #   An empty array is returned if none are found.;Fi[	@≤RI"6#   An empty array is returned if none are found.;Fi[[	@ÒiæI"»      #
      # [collection(force_reload = false)]
      #   Returns an array of all the associated objects.
      #   An empty array is returned if none are found.
      # [collection<<(object, ...)];Fi[	@ÒiVI"»      #
      # [collection(force_reload = false)]
      #   Returns an array of all the associated objects.
      #   An empty array is returned if none are found.
      # [collection<<(object, ...)];Fi[	@πRI""# [collection<<(object, ...)];Fi[[	@ÒiøI"4      # [collection(force_reload = false)]
      #   Returns an array of all the associated objects.
      #   An empty array is returned if none are found.
      # [collection<<(object, ...)]
      #   Adds one or more objects to the collection by setting their foreign keys to the collection's primary key.;Fi[	@ÒiWI"       # [collection(force_reload = false)]
      #   Returns an array of all the associated objects.
      #   An empty array is returned if none are found.
      # [collection<<(object, ...)]
      #   Adds one or more objects to the collection by creating associations in the join table;Fi[	I"o#   Note that this operation instantly fires update sql without waiting for the save or update call on the;FI"#   parent object.;Fi[[	@Òi¬I"J      # [collection<<(object, ...)]
      #   Adds one or more objects to the collection by setting their foreign keys to the collection's primary key.
      #   Note that this operation instantly fires update sql without waiting for the save or update call on the
      #   parent object.
      # [collection.delete(object, ...)];Fi[	@Òi[I"r      #   Adds one or more objects to the collection by creating associations in the join table
      #   (<tt>collection.push</tt> and <tt>collection.concat</tt> are aliases to this method).
      #   Note that this operation instantly fires update sql without waiting for the save or update call on the
      #   parent object.
      # [collection.delete(object, ...)];Fi[	@»RI"'# [collection.delete(object, ...)];Fi[[	@Òi√I"â      #   Adds one or more objects to the collection by setting their foreign keys to the collection's primary key.
      #   Note that this operation instantly fires update sql without waiting for the save or update call on the
      #   parent object.
      # [collection.delete(object, ...)]
      #   Removes one or more objects from the collection by setting their foreign keys to +NULL+.;Fi[	@Òi\I"Ä      #   (<tt>collection.push</tt> and <tt>collection.concat</tt> are aliases to this method).
      #   Note that this operation instantly fires update sql without waiting for the save or update call on the
      #   parent object.
      # [collection.delete(object, ...)]
      #   Removes one or more objects from the collection by removing their associations from the join table.;Fi[	I"# [collection.empty?];FI";#   Returns +true+ if there are no associated objects.;Fi[[	@Òi·I"      #   If the <tt>:through</tt> option is true no destroy callbacks are invoked on the join models.
      #   Join models are directly deleted.
      # [collection.empty?]
      #   Returns +true+ if there are no associated objects.
      # [collection.size];Fi[	@ÒikI"‰      # [collection.clear]
      #   Removes every object from the collection. This does not destroy the objects.
      # [collection.empty?]
      #   Returns +true+ if there are no associated objects.
      # [collection.size];Fi[	@◊RI"# [collection.size];Fi[[	@Òi‚I"“      #   Join models are directly deleted.
      # [collection.empty?]
      #   Returns +true+ if there are no associated objects.
      # [collection.size]
      #   Returns the number of associated objects.;Fi[	@ÒilI"˝      #   Removes every object from the collection. This does not destroy the objects.
      # [collection.empty?]
      #   Returns +true+ if there are no associated objects.
      # [collection.size]
      #   Returns the number of associated objects.;Fi[	@ﬁRI"2#   Returns the number of associated objects.;Fi[[	@Òi„I"≈      # [collection.empty?]
      #   Returns +true+ if there are no associated objects.
      # [collection.size]
      #   Returns the number of associated objects.
      # [collection.find(...)];Fi[	@ÒimI"ƒ      # [collection.empty?]
      #   Returns +true+ if there are no associated objects.
      # [collection.size]
      #   Returns the number of associated objects.
      # [collection.find(id)];Fi[	I" # [collection.exists?(...)];FI"N#   Checks whether an associated object with the given conditions exists.;Fi[[	@ÒiÁI"*      # [collection.find(...)]
      #   Finds an associated object according to the same rules as ActiveRecord::Base.find.
      # [collection.exists?(...)]
      #   Checks whether an associated object with the given conditions exists.
      #   Uses the same rules as ActiveRecord::Base.exists?.;Fi[	@ÒisI"5      #   meets the condition that it has to be associated with this object.
      #   Uses the same rules as ActiveRecord::Base.find.
      # [collection.exists?(...)]
      #   Checks whether an associated object with the given conditions exists.
      #   Uses the same rules as ActiveRecord::Base.exists?.;Fi[	@ÌRI";#   Uses the same rules as ActiveRecord::Base.exists?.;Fi[[	@ÒiËI"<      #   Finds an associated object according to the same rules as ActiveRecord::Base.find.
      # [collection.exists?(...)]
      #   Checks whether an associated object with the given conditions exists.
      #   Uses the same rules as ActiveRecord::Base.exists?.
      # [collection.build(attributes = {}, ...)];Fi[	@ÒitI"      #   Uses the same rules as ActiveRecord::Base.find.
      # [collection.exists?(...)]
      #   Checks whether an associated object with the given conditions exists.
      #   Uses the same rules as ActiveRecord::Base.exists?.
      # [collection.build(attributes = {})];Fi[	I"+# [collection.create(attributes = {})];FI"O#   Returns a new object of the collection type that has been instantiated;Fi[[	@ÒiÓI"P      #   with +attributes+ and linked to this object through a foreign key, but have not yet
      #   been saved.
      # [collection.create(attributes = {})]
      #   Returns a new object of the collection type that has been instantiated
      #   with +attributes+, linked to this object through a foreign key, and that has already;Fi[	@ÒiyI"ù      #   Returns a new object of the collection type that has been instantiated
      #   with +attributes+ and linked to this object through the join table, but has not yet been saved.
      # [collection.create(attributes = {})]
      #   Returns a new object of the collection type that has been instantiated
      #   with +attributes+, linked to this object through the join table, and that has already been;Fi[	I"6# You may also pass it multiple classes, like so:;F@i[[	@ãi3I"q      #   end
      #
      # You may also pass it multiple classes, like so:
      #
      #   class Person;Fi[	@ãiwI"~    # creating your own validator.
    #
    # You may also pass it multiple classes, like so:
    #
    #   class Person;Fi[	I"3#   class MyValidator < ActiveModel::Validator;FI"#     def validate(record);Fi[[	@ãi&I"è      #   end
      #
      #   class MyValidator < ActiveModel::Validator
      #     def validate(record)
      #       if some_complex_logic;Fi[	@ãiSI"®      #   end
      #
      #   class MyValidator < ActiveModel::Validator
      #     def validate(record)
      #       options[:my_custom_key] # => "my custom value";Fi[	I"6# to add errors based on more complex conditions.;F@i[[	@ãiI"æ    module ClassMethods
      # Passes the record off to the class or classes specified and allows them
      # to add errors based on more complex conditions.
      #
      #   class Person;Fi[	@ãihI"£    
    # Passes the record off to the class or classes specified and allows them
    # to add errors based on more complex conditions.
    #
    #   class Person;Fi[	I"N# Passes the record off to the class or classes specified and allows them;F@Si[[	@ãiI"¨    
    module ClassMethods
      # Passes the record off to the class or classes specified and allows them
      # to add errors based on more complex conditions.
      #;Fi[	@ãigI"ñ    end
    
    # Passes the record off to the class or classes specified and allows them
    # to add errors based on more complex conditions.
    #;Fi[	@∞0I"objenc(var);Fi[[	@˝i[I"h    def function(var)
      case var
      when Hash then
        objenc(var)
      when Array then;Fi[	@˝ifI"h    def function(var)
      case var
      when Hash then
        objenc(var)
      when Array then;Fi[	I"# [:primary_key];FI"k#   Specify the method that returns the primary key used for the association. By default this is +id+.;Fi[[	@ÒiI"M      #   of this class in lower-case and "_id" suffixed. So a Person class that makes a +has_many+
      #   association will use "person_id" as the default <tt>:foreign_key</tt>.
      # [:primary_key]
      #   Specify the method that returns the primary key used for the association. By default this is +id+.
      # [:dependent];Fi[	@ÒiöI"E      #   of this class in lower-case and "_id" suffixed. So a Person class that makes a +has_one+ association
      #   will use "person_id" as the default <tt>:foreign_key</tt>.
      # [:primary_key]
      #   Specify the method that returns the primary key used for the association. By default this is +id+.
      # [:as];Fi[	I"# [:as];FI"E#   Specifies a polymorphic interface (See <tt>belongs_to</tt>).;Fi[[	@Òi)I"H      #   This option can be used to configure a custom named <tt>:counter_cache.</tt> You only need this option,
      #   when you customized the name of your <tt>:counter_cache</tt> on the <tt>belongs_to</tt> association.
      # [:as]
      #   Specifies a polymorphic interface (See <tt>belongs_to</tt>).
      # [:through];Fi[	@ÒiúI"Î      # [:primary_key]
      #   Specify the method that returns the primary key used for the association. By default this is +id+.
      # [:as]
      #   Specifies a polymorphic interface (See <tt>belongs_to</tt>).
      # [:through];Fi[	@0SI"# [:through];Fi[[	@Òi*I"8      #   when you customized the name of your <tt>:counter_cache</tt> on the <tt>belongs_to</tt> association.
      # [:as]
      #   Specifies a polymorphic interface (See <tt>belongs_to</tt>).
      # [:through]
      #   Specifies an association through which to perform the query. This can be any other type;Fi[	@ÒiùI";      #   Specify the method that returns the primary key used for the association. By default this is +id+.
      # [:as]
      #   Specifies a polymorphic interface (See <tt>belongs_to</tt>).
      # [:through]
      #   Specifies a Join Model through which to perform the query. Options for <tt>:class_name</tt>,;Fi[	I"3#   association is a polymorphic +belongs_to+.;FI"# [:validate];Fi[[	@ÒiBI":      # [:source_type]
      #   Specifies type of the source association used by <tt>has_many :through</tt> queries where the source
      #   association is a polymorphic +belongs_to+.
      # [:validate]
      #   If +false+, don't validate the associated objects when saving the parent object. true by default.;Fi[	@Òi™I";      # [:source_type]
      #   Specifies type of the source association used by <tt>has_one :through</tt> queries where the source
      #   association is a polymorphic +belongs_to+.
      # [:validate]
      #   If +false+, don't validate the associated object when saving the parent object. +false+ by default.;Fi[	@d8I"# [:inverse_of];Fi[[	@ÒiLI"4      #   may need to be explicitly saved in any user-defined before_save callbacks.
      #
      #   Note that <tt>accepts_nested_attributes_for</tt> sets <tt>:autosave</tt> to <tt>true</tt>.
      # [:inverse_of]
      #   Specifies the name of the <tt>belongs_to</tt> association on the associated object;Fi[	@Òi≤I"+      #   By default, only save the associated object if it's a new record.
      #
      #   Note that <tt>accepts_nested_attributes_for</tt> sets <tt>:autosave</tt> to <tt>true</tt>.
      # [:inverse_of]
      #   Specifies the name of the <tt>belongs_to</tt> association on the associated object;Fi[	@FSI"[#   Specifies the name of the <tt>belongs_to</tt> association on the associated object;Fi[[	@ÒiMI"A      #
      #   Note that <tt>accepts_nested_attributes_for</tt> sets <tt>:autosave</tt> to <tt>true</tt>.
      # [:inverse_of]
      #   Specifies the name of the <tt>belongs_to</tt> association on the associated object
      #   that is the inverse of this <tt>has_many</tt> association. Does not work in combination;Fi[	@Òi≥I"@      #
      #   Note that <tt>accepts_nested_attributes_for</tt> sets <tt>:autosave</tt> to <tt>true</tt>.
      # [:inverse_of]
      #   Specifies the name of the <tt>belongs_to</tt> association on the associated object
      #   that is the inverse of this <tt>has_one</tt> association. Does not work in combination;Fi[	I"8#   with <tt>:through</tt> or <tt>:as</tt> options.;F@sMi[[	@ÒiPI"r      #   Specifies the name of the <tt>belongs_to</tt> association on the associated object
      #   that is the inverse of this <tt>has_many</tt> association. Does not work in combination
      #   with <tt>:through</tt> or <tt>:as</tt> options.
      #   See ActiveRecord::Associations::ClassMethods's overview on Bi-directional associations for more detail.
      #;Fi[	@Òi∂I"q      #   Specifies the name of the <tt>belongs_to</tt> association on the associated object
      #   that is the inverse of this <tt>has_one</tt> association. Does not work in combination
      #   with <tt>:through</tt> or <tt>:as</tt> options.
      #   See ActiveRecord::Associations::ClassMethods's overview on Bi-directional associations for more detail.
      #;Fi[	@∞0@rIi[[	@ñiI"ú          when Array then
            var.array ? ("STRING") : (super)
          when Hash then
            case var.sql_type
            when "STRING" then;Fi[	@ñi]I"’            return super(var, var) unless ("STRING" == var.sql_type)
            { "LITERAL" => (var), "LITERAL" => "LITERAL" }
          when Hash then
            case var.sql_type
            when "STRING" then;Fi[	I"*# [association(force_reload = false)];FI"K#   Returns the associated object. +nil+ is returned if none is found.;Fi[[	@ÒigI"      # The following methods for retrieval and query of a single associated object will be added:
      #
      # [association(force_reload = false)]
      #   Returns the associated object. +nil+ is returned if none is found.
      # [association=(associate)];Fi[	@ÒiœI"√      # this object holds an id:
      #
      # [association(force_reload = false)]
      #   Returns the associated object. +nil+ is returned if none is found.
      # [association=(associate)];Fi[	@bSI" # [association=(associate)];Fi[[	@ÒihI"       #
      # [association(force_reload = false)]
      #   Returns the associated object. +nil+ is returned if none is found.
      # [association=(associate)]
      #   Assigns the associate object, extracts the primary key, sets it as the foreign key,;Fi[	@Òi–I"      #
      # [association(force_reload = false)]
      #   Returns the associated object. +nil+ is returned if none is found.
      # [association=(associate)]
      #   Assigns the associate object, extracts the primary key, and sets it as the foreign key.;Fi[	I"+# [build_association(attributes = {})];FI"O#   Returns a new object of the associated type that has been instantiated;Fi[[	@ÒilI"^      #   Assigns the associate object, extracts the primary key, sets it as the foreign key,
      #   and saves the associate object.
      # [build_association(attributes = {})]
      #   Returns a new object of the associated type that has been instantiated
      #   with +attributes+ and linked to this object through a foreign key, but has not;Fi[	@Òi”I"j      # [association=(associate)]
      #   Assigns the associate object, extracts the primary key, and sets it as the foreign key.
      # [build_association(attributes = {})]
      #   Returns a new object of the associated type that has been instantiated
      #   with +attributes+ and linked to this object through a foreign key, but has not yet been saved.;Fi[	@qSI"Q#   with +attributes+, linked to this object through a foreign key, and that;Fi[[	@ÒiqI"+      #   yet been saved.
      # [create_association(attributes = {})]
      #   Returns a new object of the associated type that has been instantiated
      #   with +attributes+, linked to this object through a foreign key, and that
      #   has already been saved (if it passed the validation).;Fi[	@Òi◊I"z      #   with +attributes+ and linked to this object through a foreign key, but has not yet been saved.
      # [create_association(attributes = {})]
      #   Returns a new object of the associated type that has been instantiated
      #   with +attributes+, linked to this object through a foreign key, and that
      #   has already been saved (if it passed the validation).;Fi[	I",# [create_association(attributes = {})];F@qSi[[	@ÒipI"D      #   with +attributes+ and linked to this object through a foreign key, but has not
      #   yet been saved.
      # [create_association(attributes = {})]
      #   Returns a new object of the associated type that has been instantiated
      #   with +attributes+, linked to this object through a foreign key, and that;Fi[	@Òi÷I"ã      #   Returns a new object of the associated type that has been instantiated
      #   with +attributes+ and linked to this object through a foreign key, but has not yet been saved.
      # [create_association(attributes = {})]
      #   Returns a new object of the associated type that has been instantiated
      #   with +attributes+, linked to this object through a foreign key, and that;Fi[	@xSI">#   has already been saved (if it passed the validation).;Fi[[	@ÒirI"@      # [create_association(attributes = {})]
      #   Returns a new object of the associated type that has been instantiated
      #   with +attributes+, linked to this object through a foreign key, and that
      #   has already been saved (if it passed the validation).
      # [create_association!(attributes = {})];Fi[	@ÒiÿI"@      # [create_association(attributes = {})]
      #   Returns a new object of the associated type that has been instantiated
      #   with +attributes+, linked to this object through a foreign key, and that
      #   has already been saved (if it passed the validation).
      # [create_association!(attributes = {})];Fi[	@ÜSI"-# [create_association!(attributes = {})];Fi[[	@ÒisI"z      #   Returns a new object of the associated type that has been instantiated
      #   with +attributes+, linked to this object through a foreign key, and that
      #   has already been saved (if it passed the validation).
      # [create_association!(attributes = {})]
      #   Does the same as <tt>create_association</tt>, but raises <tt>ActiveRecord::RecordInvalid</tt>;Fi[	@ÒiŸI"z      #   Returns a new object of the associated type that has been instantiated
      #   with +attributes+, linked to this object through a foreign key, and that
      #   has already been saved (if it passed the validation).
      # [create_association!(attributes = {})]
      #   Does the same as <tt>create_association</tt>, but raises <tt>ActiveRecord::RecordInvalid</tt>;Fi[	@çSI"f#   Does the same as <tt>create_association</tt>, but raises <tt>ActiveRecord::RecordInvalid</tt>;Fi[[	@ÒitI"M      #   with +attributes+, linked to this object through a foreign key, and that
      #   has already been saved (if it passed the validation).
      # [create_association!(attributes = {})]
      #   Does the same as <tt>create_association</tt>, but raises <tt>ActiveRecord::RecordInvalid</tt>
      #   if the record is invalid.;Fi[	@Òi⁄I"M      #   with +attributes+, linked to this object through a foreign key, and that
      #   has already been saved (if it passed the validation).
      # [create_association!(attributes = {})]
      #   Does the same as <tt>create_association</tt>, but raises <tt>ActiveRecord::RecordInvalid</tt>
      #   if the record is invalid.;Fi[	@îSI""#   if the record is invalid.;Fi[[	@ÒiuI"      #   has already been saved (if it passed the validation).
      # [create_association!(attributes = {})]
      #   Does the same as <tt>create_association</tt>, but raises <tt>ActiveRecord::RecordInvalid</tt>
      #   if the record is invalid.
      #;Fi[	@Òi€I"      #   has already been saved (if it passed the validation).
      # [create_association!(attributes = {})]
      #   Does the same as <tt>create_association</tt>, but raises <tt>ActiveRecord::RecordInvalid</tt>
      #   if the record is invalid.
      #;Fi[	@õS@i[[	@ÒivI"      # [create_association!(attributes = {})]
      #   Does the same as <tt>create_association</tt>, but raises <tt>ActiveRecord::RecordInvalid</tt>
      #   if the record is invalid.
      #
      # (+association+ is replaced with the symbol passed as the first argument, so;Fi[	@Òi‹I"      # [create_association!(attributes = {})]
      #   Does the same as <tt>create_association</tt>, but raises <tt>ActiveRecord::RecordInvalid</tt>
      #   if the record is invalid.
      #
      # (+association+ is replaced with the symbol passed as the first argument, so;Fi[	I"J#   By default, only save the associated object if it's a new record.;F@i[[	@Òi∞I"v      #   If true, always save the associated object or destroy it if marked for destruction,
      #   when saving the parent object. If false, never save or destroy the associated object.
      #   By default, only save the associated object if it's a new record.
      #
      #   Note that <tt>accepts_nested_attributes_for</tt> sets <tt>:autosave</tt> to <tt>true</tt>.;Fi[	@ÒiI"      #   saving the parent object.
      #   If false, never save or destroy the associated object.
      #   By default, only save the associated object if it's a new record.
      #
      #   Note that <tt>accepts_nested_attributes_for</tt> sets <tt>:autosave</tt> to <tt>true</tt>.;Fi[	@I"#   describe User do;Fi[[	@CiI"}      # given name.
      #
      # Example:
      #   describe User do
      #     it { should have_attached_file(:avatar) };Fi[	@JiI"ü      # the given attachment as specified.
      #
      # Example:
      #   describe User do
      #     it { should validate_attachment_content_type(:icon).;Fi[	I"S# * <tt>:unless</tt> - Specifies a method, proc or string to call to determine;FI"T#   if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,;Fi[[	@ÇiTI"ö      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The;Fi[	@ni8I"ü      #   <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method, proc
      #   or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The method,;Fi[	I"rescue ArgumentError;F@n
i[[	@ÿi
I"ë            begin
              var.force_encoding(document.encoding)
            rescue ArgumentError
              # do nothing
            end;Fi[	@]iI"|        trap("STRING", "STRING")
        trap("STRING", "STRING"))
      rescue ArgumentError
        # do nothing
      end;Fi[	I"(#   class Task < ActiveRecord::Base;F@i[[	@ÙiI"u      # typecasting and deserialization.
      #
      #   class Task < ActiveRecord::Base
      #   end
      #;Fi[	@¸i‹I"Å    # Note that it always returns +true+ with boolean attributes.
    #
    #   class Task < ActiveRecord::Base
    #   end
    #;Fi[	I"require("set");F@Æi[[	@˜i I"Arequire("set")
module ActiveRecord
  module AttributeMethods;Fi [	@giI"Ürequire("thread_safe")
require("monitor")
require("set")
module ActiveRecord
  class ConnectionTimeoutError < ConnectionNotEstablished;Fi[	@ÃS@,i[[	@i I"6require("set")
module Jekyll
  module Convertible;Fi [	@Z
i I".require("set")
module Jekyll
  class Site;Fi [	@M@Ï0i[[	@ÇiOI"c      # * <tt>:on</tt> - Specifies when this validation is active. Runs in all
      #   validation contexts by default (+nil+), other options are <tt>:create</tt>
      #   and <tt>:update</tt>.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,;Fi[	@ki(I"c      # * <tt>:on</tt> - Specifies when this validation is active. Runs in all
      #   validation contexts by default (+nil+), other options are <tt>:create</tt>
      #   and <tt>:update</tt>.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,;Fi[	I"class Type;F@£i[[	@∞i7I"U      end
      
      class Type
        def function(var)
          @var = var;Fi[	@≥iI"|  module AttributeMethods
    module TimeZoneConversion
      class Type
        def function(var)
          @var = var;Fi[	@ﬂS@:i[[	@Ã	iÈI"b      
      module Fields
        class Type
          def function
            # do nothing;Fi[	@si
I"Å    class PostgreSQLAdapter < AbstractAdapter
      module OID
        class Type
          def function
            # do nothing;Fi[	I"'# <tt>false.blank? # => true</tt>.;F@i[[	@iI"ú      #
      # This is due to the way Object#blank? handles boolean values:
      # <tt>false.blank? # => true</tt>.
      #
      # Configuration options:;Fi[	@ni'I"“      #
      # This is due to the way Object#blank? handles boolean values:
      # <tt>false.blank? # => true</tt>.
      #
      # This validator defers to the ActiveModel validation for presence, adding the;Fi[	I"C# This is due to the way Object#blank? handles boolean values:;F@ÏSi[[	@iI"≈      # <tt>validates_inclusion_of :field_name, in: [true, false]</tt>.
      #
      # This is due to the way Object#blank? handles boolean values:
      # <tt>false.blank? # => true</tt>.
      #;Fi[	@ni&I"≈      # <tt>validates_inclusion_of :field_name, in: [true, false]</tt>.
      #
      # This is due to the way Object#blank? handles boolean values:
      # <tt>false.blank? # => true</tt>.
      #;Fi[	@◊"I"Gself.data["STRING"] = "STRING" unless self.data.has_key?("STRING");Fi[[	@i'I"†    # Returns nothing.
    def function(var, var)
      super(var, var)
      self.data["STRING"] = "STRING" unless self.data.has_key?("STRING")
      self.data;Fi[	@
iEI"†    # Returns nothing.
    def function(var, var)
      super(var, var)
      self.data["STRING"] = "STRING" unless self.data.has_key?("STRING")
      self.data;Fi[	I"?#   # => ["id", "created_at", "updated_at", "name", "age"];F@:i[[	@¸ipI"…      #
      #   Person.attribute_names
      #   # => ["id", "created_at", "updated_at", "name", "age"]
      def function
        @var ||= abstract_class?.! and table_exists? ? (column_names) : ([]);Fi[	@¸iÆI"°    #   person = Person.new
    #   person.attribute_names
    #   # => ["id", "created_at", "updated_at", "name", "age"]
    def function
      @attributes.keys;Fi[	I"F# <tt>validates_inclusion_of :field_name, in: [true, false]</tt>.;F@i[[	@iI"!      # If you want to validate the presence of a boolean field (where the real
      # values are +true+ and +false+), you will want to use
      # <tt>validates_inclusion_of :field_name, in: [true, false]</tt>.
      #
      # This is due to the way Object#blank? handles boolean values:;Fi[	@ni$I"      # If you want to validate the presence of a boolean field (where the real values
      # are true and false), you will want to use
      # <tt>validates_inclusion_of :field_name, in: [true, false]</tt>.
      #
      # This is due to the way Object#blank? handles boolean values:;Fi[	I"require("thread");FI"require("thread_safe");Fi[[	@gi I"@require("thread")
require("thread_safe")
require("monitor");Fi [	@i I"Arequire("thread")
require("thread_safe")
module ActiveRecord;Fi [	@T@Æi[[	@iI"£require("active_support/core_ext/hash/indifferent_access")
require("active_support/core_ext/object/duplicable")
require("thread")
module ActiveRecord
  module Core;Fi[	@„	i I"@require("thread")
module ActiveRecord
  module Transactions;Fi [	@TI"require("mutex_m");Fi[[	@^%iI"crequire("redis")
require("redis-namespace")
require("thread")
require("mutex_m")
module Resque;Fi[	@iI"crequire("redis")
require("redis-namespace")
require("thread")
require("mutex_m")
module Resque;Fi[	@ÑI"$class PostgreSQLColumn < Column;Fi[[	@
iI"qmodule ActiveRecord
  module ConnectionAdapters
    class PostgreSQLColumn < Column
      module ArrayParser;Fi[	@ìiI"jmodule ActiveRecord
  module ConnectionAdapters
    class PostgreSQLColumn < Column
      module Cast;Fi[	@p=@Hi[[	@òi1I"      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(var, var)
        validates_with(BlockValidator, _merge_attributes(var), &var);Fi[	@òikI"      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(var, var)
        var = var.extract_options!;Fi[	@¸0@ri[[	@ÏiMI"c    def function
      @var = @var = false
      @var = "LITERAL"
      @var = nil
      yield;Fi[	@ iI"x      def function(var)
        @var = StringScanner.new(var)
        @var = "LITERAL"
        @var = nil
      end;Fi[	@I""((var + "STRING") + "STRING");Fi[[	@KiII"∞        var = "STRING" unless var =~ "LITERAL"
        case var.value["LITERAL"]
        when "LITERAL" then
          ((var + "STRING") + "STRING")
        when "LITERAL" then;Fi[	@KiKI"£        when "LITERAL" then
          ((var + "STRING") + "STRING")
        when "LITERAL" then
          ((var + "STRING") + "STRING")
        when "LITERAL" then;Fi[	@I"iif var.value["LITERAL"].is_a?(Nokogiri::CSS::Node) and (var.value["LITERAL"].type == "LITERAL") then;Fi[[	@KiI"Â        when "LITERAL" then
          "STRING"
        when "LITERAL" then
          if var.value["LITERAL"].is_a?(Nokogiri::CSS::Node) and (var.value["LITERAL"].type == "LITERAL") then
            an_plus_b(var.value["LITERAL"]);Fi[	@KiI"Ó            "STRING"
          end
        when "LITERAL" then
          if var.value["LITERAL"].is_a?(Nokogiri::CSS::Node) and (var.value["LITERAL"].type == "LITERAL") then
            an_plus_b(var.value["LITERAL"], "LITERAL" => (true));Fi[	@¸0I"@var = current_user;Fi[[	@Å!iI"]  
  def function
    @var = "LITERAL"
    @var = current_user
    @var = Hash.new(true);Fi[	@Å!ixI"[  
  def function
    @var = "LITERAL"
    @var = current_user
    @var = @user.person;Fi[	@1I" @reserved_connections.clear;Fi[[	@giŸI"∫      # Disconnects all connections in the pool, and clears the pool.
      def function
        synchronize do
          @reserved_connections.clear
          @connections.each do |var|;Fi[	@giÊI"°      # Clears the cache which maps classes.
      def function
        synchronize do
          @reserved_connections.clear
          @connections.each do |var|;Fi[	@1I"until var do;Fi[[	@^%i0I"¥        var = @queues.map { |var| var.redis_name }
        if var.any? then
          synchronize do
            until var do
              var = @redis.blpop(*(var + ["LITERAL"]));Fi[	@iKI"{        end
      else
        synchronize do
          until var do
            var = @redis.blpop(@redis_name, "LITERAL");Fi[	I"var = Time.now;FI"var = yield;Fi[[	@‘	iI"¶        begin
          (var = var["LITERAL"] = []
          var = Time.now
          var = yield
          logger.warn(exec_explain(var)) if ((Time.now - var) > var);Fi[	@\'iyI"V    
    def function
      var = Time.now
      var = yield
      var = Time.now;Fi[	@Y@|i[[	@iI"    if (var.length <= var) and var.! then
      var = "STRING"
      var = "LITERAL"
    else
      var = ("STRING" + Rails.application.routes.url_helpers.short_post_url(var, "LITERAL" => (AppConfig.pod_uri.scheme), "LITERAL" => (AppConfig.pod_uri.authority)));Fi[	@Ïi>I"Ω          var = ("STRING" + var) if var.!=("LITERAL") and @options["LITERAL"].!
          (var << "STRING")
          var = "LITERAL"
        else
          raise(SyntaxError.new("STRING"));Fi[	@I"var.bottle;Fi[[	@≈iI"á      var = SnowLeopardBottleSpecTestBall.new
      assert_equal(case MacOS.cat
      when "LITERAL" then
        var.bottle
      else;Fi[	@≈i!I"Ä      var = LionBottleSpecTestBall.new
      assert_equal(case MacOS.cat
      when "LITERAL" then
        var.bottle
      else;Fi[	@YI" Dir["STRING"].each do |var|;Fi[[	@ÊiDI"k  
  def function
    var = "LITERAL"
    Dir["STRING"].each do |var|
      if File.exist?(var).! then;Fi[	@˛FiI"¿      raise(ArgumentError, "STRING") unless File.directory?(var)
      FileUtils.mkdir_p("STRING")
      var = "LITERAL"
      Dir["STRING"].each do |var|
        next unless File.exists?(var);Fi[	@YI",while var = Resque::Failure.all(var) do;Fi[[	@ô*i7I"ß    
    def self.requeue_queue(var)
      var = "LITERAL"
      while var = Resque::Failure.all(var) do
        Resque::Failure.requeue(var) if (var["STRING"] == var);Fi[	@ô*i?I"é    
    def self.remove_queue(var)
      var = "LITERAL"
      while var = Resque::Failure.all(var) do
        if (var["STRING"] == var) then;Fi[	I"loop do;FI"var = eat("STRING", var);Fi[[	@˝iDI"∏      var[var] = var
      return [var, var["LITERAL"]] if (var["LITERAL"]["LITERAL"] == "STRING")
      loop do
        var = eat("STRING", var)
        var, var, var = pairparse(var);Fi[	@˝i_I"∞      (var << var)
      return [var, var["LITERAL"]] if (var["LITERAL"]["LITERAL"] == "STRING")
      loop do
        var = eat("STRING", var)
        var, var = valparse(var);Fi[	@I"(@var = (@patch_filename + "STRING");Fi[[	@ŸiSI"©    detect_compression!
    case @compression
    when "LITERAL" then
      @var = (@patch_filename + "STRING")
      FileUtils.mv(@patch_filename, @compressed_filename);Fi[	@ŸiVI"ﬂ      @var = (@patch_filename + "STRING")
      FileUtils.mv(@patch_filename, @compressed_filename)
    when "LITERAL" then
      @var = (@patch_filename + "STRING")
      FileUtils.mv(@patch_filename, @compressed_filename);Fi[	@I"(self / "STRING");Fi[[	@›
iKI"s  def function(var)
    var = case var
    when "LITERAL" then
      (self / "STRING")
    when "LITERAL" then;Fi[	@›
iMI"m    when "LITERAL" then
      (self / "STRING")
    when "LITERAL" then
      (self / "STRING")
    else;Fi[	@‰(@˜-i[[	@Í
i I"∞          @config["STRING"]["STRING"].each do |var|
            @redcarpet_extensions[var.to_sym] = true
          end)
        rescue LoadError
          STDERR.puts("STRING");Fi[	@Í
iGI"—            MaRuKu::Globals["LITERAL"] = @config["STRING"]["STRING"]
            MaRuKu::Globals["LITERAL"] = @config["STRING"]["STRING"]
          end)
        rescue LoadError
          STDERR.puts("STRING");Fi[	@‰(@∑Di[[	@Êi3I"É    else
      var.fails_with?("LITERAL").!
    end)
    var.select_compiler
    assert_equal(MacOS.default_compiler, ENV.compiler);Fi[	@ÊiVI"|    else
      var.fails_with?("LITERAL").!
    end)
    var.select_compiler
    assert_equal(case MacOS.clang_build_version;Fi[	@I"BazaarDownloadStrategy;Fi[[	@Èi˘I"~    when "LITERAL" then
      CVSDownloadStrategy
    when "LITERAL" then
      BazaarDownloadStrategy
    when "LITERAL" then;Fi[	@ÈiI"|  def self.detect_from_symbol(var)
    case var
    when "LITERAL" then
      BazaarDownloadStrategy
    when "LITERAL" then;Fi[	@LTI"@connections.each do |var|;Fi[[	@gi⁄I"ç      def function
        synchronize do
          @reserved_connections.clear
          @connections.each do |var|
            checkin(var);Fi[	@giÁI"ç      def function
        synchronize do
          @reserved_connections.clear
          @connections.each do |var|
            checkin(var);Fi[	@¶TI"checkin(var);Fi[[	@gi€I"ñ        synchronize do
          @reserved_connections.clear
          @connections.each do |var|
            checkin(var)
            var.disconnect!;Fi[	@giËI"±        synchronize do
          @reserved_connections.clear
          @connections.each do |var|
            checkin(var)
            var.disconnect! if var.requires_reloading?;Fi[	I"+# Clears the cache which maps classes.;F@:i[[	@gi‰I"l      end
      
      # Clears the cache which maps classes.
      def function
        synchronize do;Fi[	@giåI"~      end
      
      # Clears the cache which maps classes.
      def function
        connection_pool_list.each(&"LITERAL");Fi[	@I"CVSDownloadStrategy;Fi[[	@Èi˜I"{  def self.detect_from_url(var)
    case var
    when "LITERAL" then
      CVSDownloadStrategy
    when "LITERAL" then;Fi[	@Èi I"|    when "LITERAL" then
      CurlDownloadStrategy
    when "LITERAL" then
      CVSDownloadStrategy
    when "LITERAL" then;Fi[	@I"Xif @compilers.include?("LITERAL") and (MacOS.clang_build_version >= "LITERAL") then;Fi[[	@inI"”        @compilers.include?("LITERAL") ? ("LITERAL") : (ENV.compiler)
      end
    when "LITERAL" then
      if @compilers.include?("LITERAL") and (MacOS.clang_build_version >= "LITERAL") then
        "LITERAL";Fi[	@ixI"ô        end
      end
    when "LITERAL" then
      if @compilers.include?("LITERAL") and (MacOS.clang_build_version >= "LITERAL") then
        "LITERAL";Fi[	I"># Returns an array of arrays containing the field values.;FI"7# Order is the same as that returned by +columns+.;Fi[[	@i2I"¶      end
      
      # Returns an array of arrays containing the field values.
      # Order is the same as that returned by +columns+.
      def function(var, var);Fi[	@Åi•I"÷      #   execute(sql, name).map { |row| row.first }
      # end
      # Returns an array of arrays containing the field values.
      # Order is the same as that returned by +columns+.
      def function(var, var);Fi[	@ T@Hi[[	@i3I"±      
      # Returns an array of arrays containing the field values.
      # Order is the same as that returned by +columns+.
      def function(var, var)
        # do nothing;Fi[	@Åi¶I"¿      # end
      # Returns an array of arrays containing the field values.
      # Order is the same as that returned by +columns+.
      def function(var, var)
        execute(var, var).to_a;Fi[	@@#-i[[	@‘iwI"j  def function
    case @reason
    when "LITERAL" then
      "STRING".undent
    when "LITERAL" then;Fi[	@‘iyI"i    when "LITERAL" then
      "STRING".undent
    when "LITERAL" then
      "STRING".undent
    else;Fi[	@I"@Parallel.each(all_file_names, { "LITERAL" => (var) }, &var);Fi[[	@%iLI"“            when FalseClass then
              all_file_names.each(&var)
            when "LITERAL" then
              Parallel.each(all_file_names, { "LITERAL" => (var) }, &var)
            when "LITERAL" then;Fi[	@%iNI"‰            when "LITERAL" then
              Parallel.each(all_file_names, { "LITERAL" => (var) }, &var)
            when "LITERAL" then
              Parallel.each(all_file_names, { "LITERAL" => (var) }, &var)
            else;Fi[	@I"["STRING", true];Fi[[	@¢
iÖI"ä        when "LITERAL" then
          ["STRING", false]
        when "LITERAL" then
          ["STRING", true]
        when "LITERAL" then;Fi[	@¢
iáI"        when "LITERAL" then
          ["STRING", true]
        when "LITERAL" then
          ["STRING", true]
        else;Fi[	@I"0var["STRING"] = $1.gsub("STRING", "STRING");Fi[[	@XiXI"±          when "LITERAL" then
            var["STRING"] = nil
          when "LITERAL" then
            var["STRING"] = $1.gsub("STRING", "STRING")
          when "LITERAL" then;Fi[	@XiZI"∫          when "LITERAL" then
            var["STRING"] = $1.gsub("STRING", "STRING")
          when "LITERAL" then
            var["STRING"] = $1.gsub("STRING", "STRING")
          else;Fi[	I"#     # ...;F@i[[	@ißI"l      #
      #   Post.transaction(isolation: :serializable) do
      #     # ...
      #   end
      #;Fi[	@ãiI"`    #
    #   can :create Project do |project, remote_ip|
    #     # ...
    #   end
    #;Fi[	@I"=var.gsub!("LITERAL", "STRING").sub!("LITERAL", "STRING");Fi[[	@Ç
iMI"Œ              when "LITERAL" then
                var.gsub!("LITERAL", "STRING")
              when "LITERAL" then
                var.gsub!("LITERAL", "STRING").sub!("LITERAL", "STRING")
              else;Fi[	@si&I"ƒ            when "LITERAL" then
              var.gsub!("LITERAL", "STRING")
            when "LITERAL" then
              var.gsub!("LITERAL", "STRING").sub!("LITERAL", "STRING")
            else;Fi[	@«=I"Cpush_silent("STRING", "LITERAL") unless @node.value["LITERAL"];Fi[[	@ÏijI"œ        @node.value["LITERAL"] = @dont_indent_next_line
        @node.value["LITERAL"] = @dont_tab_up_next_text
        yield
        push_silent("STRING", "LITERAL") unless @node.value["LITERAL"]
      else;Fi[	@Ïi_I"•      flush_merged_text
      push_silent("STRING")
      yield
      push_silent("STRING", "LITERAL") unless @node.value["LITERAL"]
      (@precompiled << "STRING");Fi[	@I"#var.gsub!("LITERAL", "STRING");Fi[[	@Ç
iKI"¶              var = var[var]
              case var
              when "LITERAL" then
                var.gsub!("LITERAL", "STRING")
              when "LITERAL" then;Fi[	@si$I"†            return if var.nil?
            case var
            when "LITERAL" then
              var.gsub!("LITERAL", "STRING")
            when "LITERAL" then;Fi[	@LI"&$stderr.puts(var, *var.backtrace);Fi[[	@mi/I"≤        rescue DatabaseAlreadyExists
          $stderr.puts("STRING")
        rescue Exception => var
          $stderr.puts(var, *var.backtrace)
          $stderr.puts("STRING");Fi[	@miFI"¬          (var = var.first
          class_for_adapter(var["STRING"]).new(*var).drop)
        rescue Exception => var
          $stderr.puts(var, *var.backtrace)
          $stderr.puts("STRING");Fi[	@LI"(raise(var) if var.is_a?(SystemExit);Fi[[	@

iI"¬      begin
        return perform!
      rescue Exception => var
        raise(var) if var.is_a?(SystemExit)
        if (var.is_a?(::Compass::Error) or var.is_a?(OptionParser::ParseError)) then;Fi[	@
iI"ª      begin
        perform!
      rescue Exception => var
        raise(var) if var.is_a?(SystemExit)
        if (var.is_a?(::Compass::Error) or var.is_a?(OptionParser::ParseError)) then;Fi[	@I""RecordNotUnique.new(var, var);Fi[[	@UiQI"õ      def function(var, var)
        case error_number(var)
        when "LITERAL" then
          RecordNotUnique.new(var, var)
        when "LITERAL" then;Fi[	@XiI"Ü      def function(var, var)
        case var.message
        when "LITERAL" then
          RecordNotUnique.new(var, var)
        else;Fi[	@ß9@Æi[[	@i’I"y        rescue Exception => var
          rollback_transaction if var
          raise
        ensure
          begin;Fi[	@„	i^I"Å      rescue Exception
        restore_transaction_record_state
        raise
      ensure
        clear_transaction_record_state;Fi[	I"var = var.clone;FI"var.projections = [var];Fi[[	@ibI"®      # Return a subquery for the given key using the join information.
      def function(var, var)
        var = var.clone
        var.projections = [var]
        var;Fi[	@Ui1I"À      # to give it some prompting in the form of a subsubquery. Ugh!
      def function(var, var)
        var = var.clone
        var.projections = [var]
        var = Arel::SelectManager.new(var.engine);Fi[	I"6when String, ActiveSupport::Multibyte::Chars then;F@a6i[[	@KiI"√        return var.quoted_id if var.respond_to?("LITERAL")
        case var
        when String, ActiveSupport::Multibyte::Chars then
          var = var.to_s
          return "STRING" unless var;Fi[	@Ki8I"∑        return var.id if var.respond_to?("LITERAL")
        case var
        when String, ActiveSupport::Multibyte::Chars then
          var = var.to_s
          return var unless var;Fi[	I"return "STRING" unless var;F@4i[[	@õi+I"ì            end
          when "STRING" then
            return "STRING" unless var
            case var
            when "LITERAL", "LITERAL" then;Fi[	@õi?I"à            end
          when "STRING" then
            return "STRING" unless var
            case var
            when "LITERAL" then;Fi[	@I"var.to_i;Fi[[	@Ki>I"~          when "LITERAL" then
            var
          when "LITERAL" then
            var.to_i
          when "LITERAL" then;Fi[	@ziI"d    when "STRING", "STRING" then
      "STRING"
    when "LITERAL" then
      var.to_i
    else;Fi[	@I"target.destroy;Fi[[	@q
i2I"é          when "LITERAL" then
            target.delete
          when "LITERAL" then
            target.destroy
          when "LITERAL" then;Fi[	@q
iJI"z        when "LITERAL" then
          target.delete
        when "LITERAL" then
          target.destroy
        else;Fi[	@@ËQi[[	@q
i0I"Ñ        if load_target then
          case var
          when "LITERAL" then
            target.delete
          when "LITERAL" then;Fi[	@q
iHI"}      def function(var)
        case var
        when "LITERAL" then
          target.delete
        when "LITERAL" then;Fi[	@;@≤=i[[	@Ui“I"w          case var
          when "LITERAL" then
            "STRING"
          when nil then
            "STRING";Fi[	@˝iqI"a        "STRING"
      when false then
        "STRING"
      when nil then
        "STRING";Fi[	@@4i[[	@UiDI"        def function(var)
          case var
          when "LITERAL" then
            case var
            when "LITERAL" then;Fi[	@ñiAI"é            when "STRING" then
              "STRING"
            when "LITERAL" then
              case var
              when "LITERAL" then;Fi[	@ï;@;i[[	@õi-I"®            return "STRING" unless var
            case var
            when "LITERAL", "LITERAL" then
              "STRING"
            when "LITERAL", "LITERAL" then;Fi[	@õi/I"£            when "LITERAL", "LITERAL" then
              "STRING"
            when "LITERAL", "LITERAL" then
              "STRING"
            when "LITERAL" then;Fi[	@;@8i[[	@ziI"x    @var = case var
    when "STRING", "STRING" then
      "STRING"
    when "STRING", "STRING" then
      "STRING";Fi[	@KidI"ñ          case var.value.first
          when "STRING", "STRING" then
            "STRING"
          when "STRING", "STRING" then
            "STRING";Fi[	I":var.errors.add(var, "LITERAL", filtered_options(var));F@“2i[[	@|iI"…        return if options["LITERAL"] and var.nil?
        unless var = parse_raw_value_as_a_number(var) then
          var.errors.add(var, "LITERAL", filtered_options(var))
          return
        end;Fi[	@|iI"ƒ        if options["LITERAL"] then
          unless var = parse_raw_value_as_an_integer(var) then
            var.errors.add(var, "LITERAL", filtered_options(var))
            return
          end;Fi[	I"when true, false then;FI",if var and (var.type == "LITERAL") then;Fi[[	@KiI"ú            "STRING"
          end
        when true, false then
          if var and (var.type == "LITERAL") then
            var ? ("STRING") : ("STRING");Fi[	@KiEI"ô            var
          end
        when true, false then
          if var and (var.type == "LITERAL") then
            var ? ("LITERAL") : ("LITERAL");Fi[	I"O# * <tt>:allow_blank</tt> - If set to +true+, skips this validation if the;FI"1#   attribute is blank (default is +false+).;Fi[[	@{i(I"      # * <tt>:allow_nil</tt> - If set to +true+, skips this validation if the
      #   attribute is +nil+ (default is +false+).
      # * <tt>:allow_blank</tt> - If set to +true+, skips this validation if the
      #   attribute is blank (default is +false+).
      #;Fi[	@qiÇI"V      # * <tt>:allow_nil</tt> - If set to +true+, skips this validation if the
      #   attribute is +nil+ (default is +false+).
      # * <tt>:allow_blank</tt> - If set to +true+, skips this validation if the
      #   attribute is blank (default is +false+).
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine;Fi[	@≤=I"var.fails_with?("LITERAL");Fi[[	@Êi/I"è    assert(var.fails_with?("LITERAL").!)
    assert(case MacOS.gcc_42_build_version
    when nil then
      var.fails_with?("LITERAL")
    else;Fi[	@ÊiRI"ç    assert(var.fails_with?("LITERAL"))
    assert(case MacOS.gcc_42_build_version
    when nil then
      var.fails_with?("LITERAL")
    else;Fi[	I"when BigDecimal then;FI"var.to_s("STRING");Fi[[	@Ki#I"ï        when nil then
          "STRING"
        when BigDecimal then
          var.to_s("STRING")
        when Numeric, ActiveSupport::Duration then;Fi[	@KiMI"|        when nil then
          nil
        when BigDecimal then
          var.to_s("STRING")
        when Numeric then;Fi[	I"M# * <tt>:allow_nil</tt> - If set to +true+, skips this validation if the;FI"1#   attribute is +nil+ (default is +false+).;Fi[[	@{i&I"H      # * <tt>:message</tt> - Specifies a custom error message (default is: "is
      #   not included in the list").
      # * <tt>:allow_nil</tt> - If set to +true+, skips this validation if the
      #   attribute is +nil+ (default is +false+).
      # * <tt>:allow_blank</tt> - If set to +true+, skips this validation if the;Fi[	@qiÄI"L      # * <tt>:case_sensitive</tt> - Looks for an exact match. Ignored by
      #   non-text columns (+true+ by default).
      # * <tt>:allow_nil</tt> - If set to +true+, skips this validation if the
      #   attribute is +nil+ (default is +false+).
      # * <tt>:allow_blank</tt> - If set to +true+, skips this validation if the;Fi[	@ó@ï;i[[	@ﬁi4I"Ω      var = case read("LITERAL", (var + "LITERAL")).unpack("STRING")["LITERAL"]
      when "LITERAL", "LITERAL" then
        "LITERAL"
      when "LITERAL", "LITERAL" then
        "LITERAL";Fi[	@ﬁi6I"        "LITERAL"
      when "LITERAL", "LITERAL" then
        "LITERAL"
      when "LITERAL", "LITERAL" then
        "LITERAL";Fi[	@V"@|i[[	@ti.I"        var = var[var]
        if var and (var.is_a?(Regexp).! and var.respond_to?("LITERAL").!) then
          raise(ArgumentError, "STRING")
        else
          if var and (var.is_a?(Regexp) and (regexp_using_multiline_anchors?(var) and var["LITERAL"].!=(true))) then;Fi[	@6i[I"¿          if var then
            if (@at.is_a?(Time) or (@at.is_a?(Numeric) and (@at > "LITERAL"))) then
              raise(ArgumentError, "STRING")
            else
              return var;Fi[	I"var = var[var];FI"+next unless var.respond_to?("LITERAL");Fi[[	I"1projects//devise_proj/devise/param_filter.rb;TiI"∂      var = stringify_params(var.dup)
      @case_insensitive_keys.each do |var|
        var = var[var]
        next unless var.respond_to?("LITERAL")
        var[var] = var.downcase;Fi[	@©UiI"ó      end
      @strip_whitespace_keys.each do |var|
        var = var[var]
        next unless var.respond_to?("LITERAL")
        var[var] = var.strip;Fi[	@	+I""if supports_validations? then;Fi[[	@ÛiI"¨      
      # Adds a validation error to the given object 
      def function(var, var, var, var)
        if supports_validations? then
          var = self.attribute(var);Fi[	@	iI"—      
      # Adds a validation error to the given object
      def function(var, var, var, var)
        if supports_validations? then
          var.errors.add(self.attribute(var), generate_message(var, var));Fi[	I"require("bigdecimal");FI"require("bigdecimal/util");Fi[[	@iI"hrequire("date")
require("set")
require("bigdecimal")
require("bigdecimal/util")
module ActiveRecord;Fi[	@PiI"rrequire("date")
require("bigdecimal")
require("bigdecimal/util")
require("active_support/core_ext/benchmark");Fi[	@	+I"/var = var.exist? ? ("STRING") : ("STRING");Fi[[	@ÈiŸI"v  end
  
  def function(var, var, var, var)
    var = var.exist? ? ("STRING") : ("STRING")
    var = [@@svn, var];Fi[	@ÈiˆI"Œend
class UnsafeSubversionDownloadStrategy < SubversionDownloadStrategy
  def function(var, var, var, var)
    var = var.exist? ? ("STRING") : ("STRING")
    var = [@@svn, var, "STRING", "STRING", "STRING"];Fi[	I"|["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"].each do |var|;FI"<class_eval("STRING", "STRING", ("LITERAL" + "LITERAL"));Fi[[	@iÿI"›      end
      
      ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"].each do |var|
        class_eval("STRING", "STRING", ("LITERAL" + "LITERAL"))
      end;Fi[	@iòI"Û      alias "LITERAL" "LITERAL"
      
      ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"].each do |var|
        class_eval("STRING", "STRING", ("LITERAL" + "LITERAL"))
      end;Fi[	@	+@g#i[[	@¶iMI"á    end
    
    def function(var, var, var, var)
      assert_type(var, "LITERAL")
      var = var.value[(var.value - "LITERAL")].stop;Fi[	@4ióI"é  #
  #     background-position: 3px -36px;
  def function(var, var, var, var)
    assert_type(var, "LITERAL")
    assert_type(var, "LITERAL");Fi[	@	+I"8var ||= self.options if self.respond_to?("LITERAL");Fi[[	@_$iI"    
    # copy/process a template in the compass template directory to the project directory.
    def function(var, var, var, var)
      var ||= self.options if self.respond_to?("LITERAL")
      var ? (var = File.new(var, "STRING").read) : (var = File.new(var).read);Fi[	@_$i$I"µ    
    # Write a file given the file contents as a string
    def function(var, var, var, var)
      var ||= self.options if self.respond_to?("LITERAL")
      var = var["LITERAL"];Fi[	@	+@;i[[	@UiÕI"ù      
      # Maps logical Rails types to MySQL-specific data types.
      def function(var, var, var, var)
        case var.to_s
        when "STRING" then;Fi[	@õiI"¨        
        # Maps logical Rails types to PostgreSQL-specific data types.
        def function(var, var, var, var)
          case var.to_s
          when "STRING" then;Fi[	@OK@	+i[[	@Üi6I"Ω      
      # Adds a new column to the named table.
      # See TableDefinition#column for details of the options you can use.
      def function(var, var, var, var)
        var = "STRING";Fi[	@õiÊI"≈        
        # Adds a new column to the named table.
        # See TableDefinition#column for details of the options you can use.
        def function(var, var, var, var)
          clear_cache!;Fi[	I"D# Changes the column's definition according to the new options.;F@OKi[[	@iII"©      end
      
      # Changes the column's definition according to the new options.
      # See TableDefinition#column for details of the options you can use.
      #;Fi[	@ÜiPI"©      end
      
      # Changes the column's definition according to the new options.
      # See TableDefinition#column for details of the options you can use.
      #;Fi[	I"# Renames a column.;F@i[[	@iwI"^      end
      
      # Renames a column.
      #
      #  t.rename(:description, :name);Fi[	@ÜibI"o      end
      
      # Renames a column.
      #
      #  rename_column(:suppliers, :description, :name);Fi[	@	+@«-i[[	@ÃiI"        # Forces the change in state to be recognized regardless of whether the
        # state value actually changed
        def function(var, var, var, var)
          var = super
          if ((var == "LITERAL") or ((var == "LITERAL") and var)) and var.send("STRING").! then;Fi[	@JiI"—      # Forces the change in state to be recognized regardless of whether the
      # state value actually changed
      def function(var, var, var, var)
        var = super
        var = self.attribute.to_sym;Fi[	I"var["LITERAL"].to_s;F@|i[[	@Üi0I"õ        var = Array(var)
        var = if var.key?("LITERAL") then
          var["LITERAL"].to_s
        else
          index_name(var, "LITERAL" => (var));Fi[	@ÍilI"ï      var = var.styles[var.to_s.to_sym]
      if var and var["LITERAL"] then
        var["LITERAL"].to_s
      else
        if var.include?(var) then;Fi[	I"#    # Other fields here;F@3i[[	@ÜiaI"ä      #  create_table(:suppliers) do |t|
      #    t.column :name, :string, limit: 60
      #    # Other fields here
      #  end
      #;Fi[	@ÜihI"Å      #  create_table(:suppliers) do |t|
      #    t.string :name, limit: 60
      #    # Other fields here
      #  end
      #;Fi[	I"# [<tt>:options</tt>];FI"E#   Any extra options you want appended to the table definition.;Fi[[	@Üi}I"Ÿ      #   Models do NOT auto-detect the primary key from their table definition.
      #
      # [<tt>:options</tt>]
      #   Any extra options you want appended to the table definition.
      # [<tt>:temporary</tt>];Fi[	@Üi∑I"Ï      # [<tt>:column_options</tt>]
      #   Any extra options you want appended to the columns definition.
      # [<tt>:options</tt>]
      #   Any extra options you want appended to the table definition.
      # [<tt>:temporary</tt>];Fi[	@VI"# [<tt>:temporary</tt>];Fi[[	@Üi~I"™      #
      # [<tt>:options</tt>]
      #   Any extra options you want appended to the table definition.
      # [<tt>:temporary</tt>]
      #   Make a temporary table.;Fi[	@Üi∏I"Î      #   Any extra options you want appended to the columns definition.
      # [<tt>:options</tt>]
      #   Any extra options you want appended to the table definition.
      # [<tt>:temporary</tt>]
      #   Make a temporary table.;Fi[	@VI" #   Make a temporary table.;Fi[[	@ÜiI"º      # [<tt>:options</tt>]
      #   Any extra options you want appended to the table definition.
      # [<tt>:temporary</tt>]
      #   Make a temporary table.
      # [<tt>:force</tt>];Fi[	@ÜiπI"º      # [<tt>:options</tt>]
      #   Any extra options you want appended to the table definition.
      # [<tt>:temporary</tt>]
      #   Make a temporary table.
      # [<tt>:force</tt>];Fi[	@VI"# [<tt>:force</tt>];Fi[[	@Üi{I"‹      #   Any extra options you want appended to the table definition.
      # [<tt>:temporary</tt>]
      #   Make a temporary table.
      # [<tt>:force</tt>]
      #   Set to true to drop the table before creating it.;Fi[	@Üi∫I"‹      #   Any extra options you want appended to the table definition.
      # [<tt>:temporary</tt>]
      #   Make a temporary table.
      # [<tt>:force</tt>]
      #   Set to true to drop the table before creating it.;Fi[	@VI":#   Set to true to drop the table before creating it.;Fi[[	@Üi|I"≤      # [<tt>:temporary</tt>]
      #   Make a temporary table.
      # [<tt>:force</tt>]
      #   Set to true to drop the table before creating it.
      #   Defaults to false.;Fi[	@ÜiªI"≤      # [<tt>:temporary</tt>]
      #   Make a temporary table.
      # [<tt>:force</tt>]
      #   Set to true to drop the table before creating it.
      #   Defaults to false.;Fi[	@$V@$Ki[[	@Üi}I"ú      #   Make a temporary table.
      # [<tt>:force</tt>]
      #   Set to true to drop the table before creating it.
      #   Defaults to false.
      #;Fi[	@ÜiºI"ú      #   Make a temporary table.
      # [<tt>:force</tt>]
      #   Set to true to drop the table before creating it.
      #   Defaults to false.
      #;Fi[	@	+@4i[[	@XiâI"n      end
      
      def function(var, var, var, var)
        case var
        when Symbol, String then;Fi[	@·i7I"Z    #   evaluate_method(person, lambda {|person, age| "#{person.name} is #{age}"}, 21)          # => "John Smith is 21"
    #   evaluate_method(person, lambda {|person, age| "#{person.name} is #{age}"}, 21, 'male')  # => ArgumentError: wrong number of arguments (3 for 2)
    def function(var, var, var, var)
      case var
      when Symbol then;Fi[	I"	#  );F@i[[	@ÜièI"û      #    guid int(11) DEFAULT NULL auto_increment PRIMARY KEY,
      #    name varchar(80)
      #  )
      #
      # ====== Do not add a primary key column;Fi[	@ÜiöI"ó      #    category_id int,
      #    supplier_id int
      #  )
      #
      # See also TableDefinition#column for details on how to create columns.;Fi[	@íU@zUi[[	@{i'I"+      #   not included in the list").
      # * <tt>:allow_nil</tt> - If set to +true+, skips this validation if the
      #   attribute is +nil+ (default is +false+).
      # * <tt>:allow_blank</tt> - If set to +true+, skips this validation if the
      #   attribute is blank (default is +false+).;Fi[	@qiÅI"5      #   non-text columns (+true+ by default).
      # * <tt>:allow_nil</tt> - If set to +true+, skips this validation if the
      #   attribute is +nil+ (default is +false+).
      # * <tt>:allow_blank</tt> - If set to +true+, skips this validation if the
      #   attribute is blank (default is +false+).;Fi[	@∫ @öi[[	@iüI"z        (var << "STRING")
        (var << "STRING") if var["LITERAL"]
        (var << "STRING")
        var
      end;Fi[	@iØI"z        (var << "STRING")
        (var << "STRING") if var["LITERAL"]
        (var << "STRING")
        var
      end;Fi[	@íUI"M# * <tt>:allow_blank</tt> - If set to true, skips this validation if the;Fi[[	@qi(I"      #   reserved").
      # * <tt>:allow_nil</tt> - If set to true, skips this validation if the
      #   attribute is +nil+ (default is +false+).
      # * <tt>:allow_blank</tt> - If set to true, skips this validation if the
      #   attribute is blank(default is +false+).;Fi[	@ti_I"R      # * <tt>:message</tt> - A custom error message (default is: "is invalid").
      # * <tt>:allow_nil</tt> - If set to true, skips this validation if the
      #   attribute is +nil+ (default is +false+).
      # * <tt>:allow_blank</tt> - If set to true, skips this validation if the
      #   attribute is blank (default is +false+).;Fi[	I"K# * <tt>:allow_nil</tt> - If set to true, skips this validation if the;F@íUi[[	@qi'I"4      # * <tt>:message</tt> - Specifies a custom error message (default is: "is
      #   reserved").
      # * <tt>:allow_nil</tt> - If set to true, skips this validation if the
      #   attribute is +nil+ (default is +false+).
      # * <tt>:allow_blank</tt> - If set to true, skips this validation if the;Fi[	@ti^I">      # Configuration options:
      # * <tt>:message</tt> - A custom error message (default is: "is invalid").
      # * <tt>:allow_nil</tt> - If set to true, skips this validation if the
      #   attribute is +nil+ (default is +false+).
      # * <tt>:allow_blank</tt> - If set to true, skips this validation if the;Fi[	@∫ @Õ7i[[	@iùI"¢        var = "STRING"
        (var << "STRING") if var["LITERAL"]
        (var << "STRING")
        (var << "STRING") if var["LITERAL"]
        (var << "STRING");Fi[	@i≠I"¢        var = "STRING"
        (var << "STRING") if var["LITERAL"]
        (var << "STRING")
        (var << "STRING") if var["LITERAL"]
        (var << "STRING");Fi[	@∫ I",(var << "STRING") unless var.directory?;Fi[[	@i5I"∂      if var.file?.! and var.symlink?.! then
        if f.plist_startup then
          (var << "STRING")
          (var << "STRING") unless var.directory?
          (var << "STRING");Fi[	@i9I"í          (var << "STRING")
        else
          (var << "STRING")
          (var << "STRING") unless var.directory?
          (var << "STRING");Fi[	@∫ I"@f.plist_startup ? ((var << "STRING")) : ((var << "STRING"));Fi[[	@i=I"§          (var << "STRING")
        end
        (var << "STRING")
        f.plist_startup ? ((var << "STRING")) : ((var << "STRING"))
        if f.plist_manual then;Fi[	@iOI"à          end
        else
          (var << "STRING")
          f.plist_startup ? ((var << "STRING")) : ((var << "STRING"))
        end;Fi[	I"'#  change_table(:suppliers) do |t|;FI",#    t.column :name, :string, limit: 60;Fi[[	@Üi‡I"ª      #
      #  # change_table() yields a Table instance
      #  change_table(:suppliers) do |t|
      #    t.column :name, :string, limit: 60
      #    # Other column alterations here;Fi[	@ÜiÌI"á      #
      # ====== Add a column
      #  change_table(:suppliers) do |t|
      #    t.column :name, :string, limit: 60
      #  end;Fi[	I"$# particular enumerable object.;F@i[[	@qiI"∫    module HelperMethods
      # Validates that the value of the specified attribute is not in a
      # particular enumerable object.
      #
      #   class Person < ActiveRecord::Base;Fi[	@{iI"√    module HelperMethods
      # Validates whether the value of the specified attribute is available in a
      # particular enumerable object.
      #
      #   class Person < ActiveRecord::Base;Fi[	@Ã6I"execute(var);Fi[[	@Üi9I"Ç      def function(var, var, var, var)
        var = "STRING"
        add_column_options!(var, var)
        execute(var)
      end;Fi[	@õiÍI"          clear_cache!
          var = "STRING"
          add_column_options!(var, var)
          execute(var)
        end;Fi[	@Ã6I"#add_column_position!(var, var);Fi[[	@Ui\I"ñ      def function(var, var, var, var)
        var = "STRING"
        add_column_options!(var, var)
        add_column_position!(var, var)
        var;Fi[	@UifI"∞        var["LITERAL"] = var.null unless var.has_key?("LITERAL")
        var = "STRING"
        add_column_options!(var, var)
        add_column_position!(var, var)
        var;Fi[	I"var = Set.new;FI"3var.each { |var| (var << var.patch_filename) };Fi[[	@¸'i3I"µ    var = Patches.new(var)
    assert_equal("LITERAL", var.patches.length)
    var = Set.new
    var.each { |var| (var << var.patch_filename) }
    assert_equal("LITERAL", var.size);Fi[	@¸'i<I"µ    var = Patches.new(var)
    assert_equal("LITERAL", var.patches.length)
    var = Set.new
    var.each { |var| (var << var.patch_filename) }
    assert_equal("LITERAL", var.size);Fi[	I"2require("active_model/validations/clusivity");F@Ri[[	@qi I"Zrequire("active_model/validations/clusivity")
module ActiveModel
  module Validations;Fi [	@{i I"Zrequire("active_model/validations/clusivity")
module ActiveModel
  module Validations;Fi [	I"# attribute.;F@i[[	@i(I"ˇ      # as an in-memory attribute for validating the password. To achieve this,
      # the validation adds accessors to the model for the confirmation
      # attribute.
      #
      # NOTE: This check is performed only if +password_confirmation+ is not;Fi[	@ÌiI"ˇ    # class-level attribute acts like an inheritable attribute.  The attribute
    # is available to each subclass, each having a copy of its superclass's
    # attribute.
    # 
    # The hash of state machines maps <tt>:attribute</tt> => +machine+, e.g.;Fi[	I"5if var.is_a?(Hash) and var = var["LITERAL"] then;F@4i[[	@ÜiUI"ç      
      def function(var, var, var)
        if var.is_a?(Hash) and var = var["LITERAL"] then
          case var
          when Hash then;Fi[	@Ui9I"ç      
      def function(var, var, var)
        if var.is_a?(Hash) and var = var["LITERAL"] then
          case var
          when Hash then;Fi[	I",var.each { |var| var[var] += "STRING" };F@|i[[	@ÜiZI"ø            var.each { |var| var[var] += "STRING" if var.has_key?(var) }
          when String then
            var.each { |var| var[var] += "STRING" }
          else
            # do nothing;Fi[	@Ui@I"Ü            end
          when Fixnum then
            var.each { |var| var[var] += "STRING" }
          else
            # do nothing;Fi[	I"3var = var["LITERAL"] ? ("STRING") : ("STRING");FI"H(var["LITERAL"] == "LITERAL") ? (var = "STRING") : (var = "STRING");Fi[[	@iôI"‹      # @see Base#render_with_options
      def function(var, var)
        var = var["LITERAL"] ? ("STRING") : ("STRING")
        (var["LITERAL"] == "LITERAL") ? (var = "STRING") : (var = "STRING")
        var = "STRING";Fi[	@i©I"‹      # @see Base#render_with_options
      def function(var, var)
        var = var["LITERAL"] ? ("STRING") : ("STRING")
        (var["LITERAL"] == "LITERAL") ? (var = "STRING") : (var = "STRING")
        var = "STRING";Fi[	@\$I"each_value do |var|;Fi[[	@iI"Î      assert_valid_keys(var, "LITERAL", "LITERAL", "LITERAL")
      var = { "LITERAL" => (true), "LITERAL" => (true) }.merge(var)
      if var["LITERAL"] then
        each_value do |var|
          unless var.dynamic_initial_state? then;Fi[	@i'I"ë      end
      var = yield if block_given?
      if var["LITERAL"] then
        each_value do |var|
          if var.dynamic_initial_state? then;Fi[	@\$I",(var << clean_entities(var["LITERAL"]));Fi[[	@pi=I"         var[var].each do |var|
          if var["LITERAL"] and (var["LITERAL"] == "STRING") then
            if var["LITERAL"] then
              (var << clean_entities(var["LITERAL"]))
            else;Fi[	@piDI"¬          else
            if var["LITERAL"] and (var["LITERAL"] == "STRING") then
              if var["LITERAL"] then
                (var << clean_entities(var["LITERAL"]))
              else;Fi[	@\$I")if @user.update_attributes(var) then;Fi[[	@Å!i3I"°            end
          else
            if var["LITERAL"] then
              if @user.update_attributes(var) then
                I18n.locale = @user.language;Fi[	@Å!iDI"º                end
              else
                if var["LITERAL"] then
                  if @user.update_attributes(var) then
                    flash["LITERAL"] = I18n.t("STRING");Fi[	@˛9I"!#   person.valid? # => false;Fi[[	@liGI"ê        #
        #   person = Person.new
        #   person.name = ''
        #   person.valid? # => false
        #   person.status # => false;Fi[	@òi”I"~    #
    #   person = Person.new
    #   person.name = ''
    #   person.valid? # => false
    #   person.name = 'david';Fi[	I"records.uniq.each do |var|;F@ø	i[[	@∫iZI"}      
      def function
        records.uniq.each do |var|
          begin
            var.rolledback!(parent.closed?);Fi[	@∫idI"l      
      def function
        records.uniq.each do |var|
          begin
            var.committed!;Fi[	I"var = var.last;FI"/if var.is_a?(Hash) and var["LITERAL"] then;Fi[[	@li)I"ƒ        #   person.name   # => "bob"
        def function(var, var)
          var = var.last
          if var.is_a?(Hash) and var["LITERAL"] then
            var["LITERAL"] = Array(var["LITERAL"]);Fi[	@„	i8I"¢      
      def function(var)
        var = var.last
        if var.is_a?(Hash) and var["LITERAL"] then
          assert_valid_transaction_action(var["LITERAL"]);Fi[	I" autoload_under("STRING") do;F@Si[[	@Pi I"e    end
    
    autoload_under("STRING") do
      autoload("LITERAL")
      autoload("LITERAL");Fi[	@niSI"É    autoload("LITERAL")
    autoload("LITERAL")
    autoload_under("STRING") do
      autoload("LITERAL")
      autoload("LITERAL");Fi[	I"6#     include ActiveModel::Validations::Callbacks;F@i[[	@liI"≠        #   class Person
        #     include ActiveModel::Validations
        #     include ActiveModel::Validations::Callbacks
        #
        #     attr_accessor :name;Fi[	@li7I"∂        #   class Person
        #     include ActiveModel::Validations
        #     include ActiveModel::Validations::Callbacks
        #
        #     attr_accessor :name, :status;Fi[	I"A# CONNECTION MANAGEMENT ====================================;F@:i[[	@Åi@I"é      end
      
      # CONNECTION MANAGEMENT ====================================
      def function
        return false unless @connection;Fi[	@Ã	iüI"y      end
      
      # CONNECTION MANAGEMENT ====================================
      def function
        begin;Fi[	I"# happens.;F@i[[	@liI"ô      module ClassMethods
        # Defines a callback that will get called right before validation
        # happens.
        #
        #   class Person;Fi[	@li3I"á        
        # Defines a callback that will get called right after validation
        # happens.
        #
        #   class Person;Fi[	@ùI"S# * <tt>:message</tt> - A custom error message (default is: "can't be blank").;Fi[[	@iI"¨      # <tt>false.blank? # => true</tt>.
      #
      # Configuration options:
      # * <tt>:message</tt> - A custom error message (default is: "can't be blank").
      #;Fi[	@ni/I"Ÿ      # state.
      #
      # Configuration options:
      # * <tt>:message</tt> - A custom error message (default is: "can't be blank").
      # * <tt>:on</tt> - Specifies when this validation is active. Runs in all;Fi[	@ù@i[[	@ki#I"Õ      # guaranteed to be valid, you also need to use +validates_presence_of+.
      #
      # Configuration options:
      #
      # * <tt>:message</tt> - A custom error message (default is: "is invalid").;Fi[	@qizI"Ω      # the same check is made but disregarding the record itself.
      #
      # Configuration options:
      #
      # * <tt>:message</tt> - Specifies a custom error message (default is:;Fi[	@˛HI"## Parse a file with +filename+;Fi[[	@r&iI"k        end
        
        ###
        # Parse a file with +filename+
        def function(var, var);Fi[	@˝iII"f        end
        
        ###
        # Parse a file with +filename+
        def function(var);Fi[	@˛HI"2# Add +node_or_tags+ as a child of this Node.;Fi[[	@ÿiÓI"≈      end
      
      ###
      # Add +node_or_tags+ as a child of this Node.
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.;Fi[	@ÿiˇI"≈      end
      
      ###
      # Add +node_or_tags+ as a child of this Node.
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.;Fi[	@˛HI",# Called at the beginning of an element;Fi[[	@'iI"        end
        
        ###
        # Called at the beginning of an element
        # * +name+ is the name of the tag;Fi[	@'i+I"z        end
        
        ###
        # Called at the beginning of an element
        # +name+ is the element name;Fi[	@˛HI"&# Called at the end of an element;Fi[[	@'i$I"p        end
        
        ###
        # Called at the end of an element
        # +name+ is the tag name;Fi[	@'i:I"v        end
        
        ###
        # Called at the end of an element
        # +name+ is the element's name;Fi[	I"G# Returns true, since this connection adapter supports migrations.;F@:i[[	@UiÜI"~      end
      
      # Returns true, since this connection adapter supports migrations.
      def function
        true;Fi[	@Xi~I"~      end
      
      # Returns true, since this connection adapter supports migrations.
      def function
        true;Fi[	I"A# HELPER METHODS ===========================================;F@£i[[	@Åi*I"à      end
      
      # HELPER METHODS ===========================================
      def function(var)
        if block_given? then;Fi[	@Ã	iÅI"à      end
      
      # HELPER METHODS ===========================================
      def function(var)
        if block_given? then;Fi[	I"nif var.kind_of?(String) and (var and ((var.type == "LITERAL") and var.class.respond_to?("LITERAL"))) then;FI"Fvar = var.class.string_to_binary(var).unpack("STRING")["LITERAL"];Fi[[	@UiæI"0      # QUOTING ==================================================
      def function(var, var)
        if var.kind_of?(String) and (var and ((var.type == "LITERAL") and var.class.respond_to?("LITERAL"))) then
          var = var.class.string_to_binary(var).unpack("STRING")["LITERAL"]
          "STRING";Fi[	@Xi¡I"0      # QUOTING ==================================================
      def function(var, var)
        if var.kind_of?(String) and (var and ((var.type == "LITERAL") and var.class.respond_to?("LITERAL"))) then
          var = var.class.string_to_binary(var).unpack("STRING")["LITERAL"]
          "STRING";Fi[	@4W@;i[[	@UiøI"˙      def function(var, var)
        if var.kind_of?(String) and (var and ((var.type == "LITERAL") and var.class.respond_to?("LITERAL"))) then
          var = var.class.string_to_binary(var).unpack("STRING")["LITERAL"]
          "STRING"
        else;Fi[	@Xi¬I"˙      def function(var, var)
        if var.kind_of?(String) and (var and ((var.type == "LITERAL") and var.class.respond_to?("LITERAL"))) then
          var = var.class.string_to_binary(var).unpack("STRING")["LITERAL"]
          "STRING"
        else;Fi[	I"2# Object#blank?). Happens by default on save.;F@i[[	@fiI"…    module HelperMethods
      # Validates that the specified attributes are blank (as defined by
      # Object#blank?). Happens by default on save.
      #
      #   class Person < ActiveRecord::Base;Fi[	@iI"Õ    module HelperMethods
      # Validates that the specified attributes are not blank (as defined by
      # Object#blank?). Happens by default on save.
      #
      #   class Person < ActiveRecord::Base;Fi[	I"1rescue ActiveRecord::StatementInvalid => var;FI"J"LITERAL".===(var.message) ? (raise(DatabaseAlreadyExists)) : (raise);Fi[[	@`iI"%          connection.create_database(configuration["STRING"], creation_options)
          establish_connection(configuration))
        rescue ActiveRecord::StatementInvalid => var
          "LITERAL".===(var.message) ? (raise(DatabaseAlreadyExists)) : (raise)
        rescue error_class => var;Fi[	@ŒiI"*          connection.create_database(configuration["STRING"], configuration.merge("STRING" => (encoding)))
          establish_connection(configuration))
        rescue ActiveRecord::StatementInvalid => var
          "LITERAL".===(var.message) ? (raise(DatabaseAlreadyExists)) : (raise)
        end;Fi[	I"$#     <id type="integer">1</id>;FI",#     <rating type="integer">1</rating>;Fi[[	@hi<I"Æ    #   <?xml version="1.0" encoding="UTF-8"?>
    #   <firm>
    #     <id type="integer">1</id>
    #     <rating type="integer">1</rating>
    #     <name>37signals</name>;Fi[	@hicI"Æ    #   <?xml version="1.0" encoding="UTF-8"?>
    #   <firm>
    #     <id type="integer">1</id>
    #     <rating type="integer">1</rating>
    #     <name>37signals</name>;Fi[	I";# Drops the database specified on the +name+ attribute;FI"9# and creates it again using the provided +options+.;Fi[[	@UiII"•      end
      
      # Drops the database specified on the +name+ attribute
      # and creates it again using the provided +options+.
      def function(var, var);Fi[	@õi	I"Ê    class PostgreSQLAdapter < AbstractAdapter
      module SchemaStatements
        # Drops the database specified on the +name+ attribute
        # and creates it again using the provided +options+.
        def function(var, var);Fi[	@YW@Hi[[	@UiJI"∂      
      # Drops the database specified on the +name+ attribute
      # and creates it again using the provided +options+.
      def function(var, var)
        drop_database(var);Fi[	@õi
I"’      module SchemaStatements
        # Drops the database specified on the +name+ attribute
        # and creates it again using the provided +options+.
        def function(var, var)
          drop_database(var);Fi[	@(O@=i[[	@hi:I"õ    #   firm.to_xml include: [ :account, :clients ]
    #
    #   <?xml version="1.0" encoding="UTF-8"?>
    #   <firm>
    #     <id type="integer">1</id>;Fi[	@hiaI"∞    #
    #   firm.to_xml include: {account: {}, clients: {include: :address}}
    #   <?xml version="1.0" encoding="UTF-8"?>
    #   <firm>
    #     <id type="integer">1</id>;Fi[	@”KI"&var = option_call(var, "LITERAL");Fi[[	@ti	I"„    class FormatValidator < EachValidator
      def function(var, var, var)
        if options["LITERAL"] then
          var = option_call(var, "LITERAL")
          record_error(var, var, "LITERAL", var) unless var.to_s.=~(var);Fi[	@tiI"Ô          record_error(var, var, "LITERAL", var) unless var.to_s.=~(var)
        else
          if options["LITERAL"] then
            var = option_call(var, "LITERAL")
            record_error(var, var, "LITERAL", var) if var.to_s.=~(var);Fi[	@E@:i[[	@J
iI"q      case var
      when Array then
        if var.empty? then
          opoo("STRING")
          return [];Fi[	@J
iI"è        var.each { |var| (var << install_p(var)) }
      when Hash then
        if var.empty? then
          opoo("STRING")
          return [];Fi[	@EI"#var = @connection.prepare(var);Fi[[	@Ã	iõI"Ö        var = {}
        log(var, var, var) do
          if var.empty? then
            var = @connection.prepare(var)
          else;Fi[	@Xi˜I"•      def function(var, var, var)
        log(var, var, var) do
          if var.empty? then
            var = @connection.prepare(var)
            var = var.columns;Fi[	@;@i[[	@˙iêI"≤        def function(var, var, var)
          var = var.last.is_a?(Hash) ? (var.pop) : ({})
          case var.to_s
          when "LITERAL" then
            @node["STRING"] = $1;Fi[	@ciI"º        var = var.call(instance) if var.respond_to?("LITERAL")
        var.inject({}) do |var, var|
          case var.to_s
          when "LITERAL" then
            var[$1.downcase] = var;Fi[	@Q@îi[[	@3
i I"õ          break if var
          var, var, var = parse_old_attributes(var)
          var["LITERAL"] = var
        when "STRING" then
          break if var;Fi[	@3
iI"≠          break if var
          var, var, var = parse_new_attributes(var)
          var["LITERAL"] = var
        when "STRING" then
          break unless (var == "STRING");Fi[	@a6I"#if var.include?("STRING") then;Fi[[	@≥iI"í          end
        else
          var = var.to_s
          if var.include?("STRING") then
            var, var = var.split("STRING", "LITERAL");Fi[	@Ôi’I"Ñ      var = "STRING"
      if var.nil? then
        var = var.to_s
        if var.include?("STRING") then
          haml_concat(var);Fi[	@î@<"i[[	@¢
i¢I"ä        when "STRING" then
          { "LITERAL" => (@address), "LITERAL" => (@port), "LITERAL" => (@domain), "LITERAL" => (@user_name), "LITERAL" => (@password), "LITERAL" => (@authentication), "LITERAL" => (@enable_starttls_auto), "LITERAL" => (@openssl_verify_mode) }
        when "STRING" then
          var = {}
          var.merge!("LITERAL" => (File.expand_path(@sendmail))) if @sendmail;Fi[	@¢
ißI"«          var.merge!("LITERAL" => (@sendmail_args)) if @sendmail_args
          var
        when "STRING" then
          var = {}
          var.merge!("LITERAL" => (File.expand_path(@exim))) if @exim;Fi[	@a6@a6i[[	@J
i.I"ô      var = (self + File.basename(var))
    end
    var = var.to_s
    var = var.to_s
    raise("STRING") unless (File.symlink?(var) or File.exist?(var));Fi[	@J
iPI"e      var = (self + File.basename(var))
    end
    var = var.to_s
    var = var.to_s
    mkpath;Fi[	I"'#   person.age             # => 22;FI")#   person.awesome         # => true;Fi[[	@`izI"Ï      #   person.from_json(json) # => #<Person:0x007fec5e7a0088 @age=22, @awesome=true, @name="bob">
      #   person.name            # => "bob"
      #   person.age             # => 22
      #   person.awesome         # => true
      #;Fi[	@`iI"      #   person.from_json(json) # => #<Person:0x007fec5e7a0088 @age=22, @awesome=true, @name="bob">
      #   person.name            # => "bob"
      #   person.age             # => 22
      #   person.awesome         # => true
      def function(var, var);Fi[	@î@8Ui[[	@õi*I"ô              raise(ActiveRecordError, "STRING")
            end
          when "STRING" then
            return "STRING" unless var
            case var;Fi[	@õi>I"ô              raise(ActiveRecordError, "STRING")
            end
          when "STRING" then
            return "STRING" unless var
            case var;Fi[	I"*#   person.name            # => "bob";F@üWi[[	@`iyI"      #   person = Person.new
      #   person.from_json(json) # => #<Person:0x007fec5e7a0088 @age=22, @awesome=true, @name="bob">
      #   person.name            # => "bob"
      #   person.age             # => 22
      #   person.awesome         # => true;Fi[	@`i~I"      #   person = Person.new
      #   person.from_json(json) # => #<Person:0x007fec5e7a0088 @age=22, @awesome=true, @name="bob">
      #   person.name            # => "bob"
      #   person.age             # => 22
      #   person.awesome         # => true;Fi[	I"c#   person.from_json(json) # => #<Person:0x007fec5e7a0088 @age=22, @awesome=true, @name="bob">;F@≠Wi[[	@`ixI"      #   json = { name: 'bob', age: 22, awesome:true }.to_json
      #   person = Person.new
      #   person.from_json(json) # => #<Person:0x007fec5e7a0088 @age=22, @awesome=true, @name="bob">
      #   person.name            # => "bob"
      #   person.age             # => 22;Fi[	@`i}I"#      #   json = { person: { name: 'bob', age: 22, awesome:true } }.to_json
      #   person = Person.new
      #   person.from_json(json) # => #<Person:0x007fec5e7a0088 @age=22, @awesome=true, @name="bob">
      #   person.name            # => "bob"
      #   person.age             # => 22;Fi[	@îI"%add_item_to_array(var, var, var);Fi[[	@
iCI"∂                when "STRING" then
                  var = true
                when "STRING" then
                  add_item_to_array(var, var, var)
                  var = "STRING";Fi[	@
iMI"Ë                  var, var = parse_array_contents(var, var, (var + "LITERAL"))
                  var.push(var)
                when "STRING" then
                  add_item_to_array(var, var, var)
                  return [var, var];Fi[	@îI"("LITERAL" / "LITERAL");Fi[[	@ìiI"ú          return var unless String.===(var)
          case var
          when "STRING" then
            ("LITERAL" / "LITERAL")
          when "STRING" then;Fi[	@ìiI"ü          when "STRING" then
            ("LITERAL" / "LITERAL")
          when "STRING" then
            ("LITERAL" / "LITERAL")
          when "LITERAL" then;Fi[	I"#       instance_values;F@>i[[	@`irI"c      #
      #     def attributes
      #       instance_values
      #     end
      #   end;Fi[	@ciŒI"c      #
      #     def attributes
      #       instance_values
      #     end
      #   end;Fi[	@@i[[	@ãi0I"g      #       def some_complex_logic
      #         # ...
      #       end
      #   end
      #;Fi[	@≥i£I"U      #       else
      #         super
      #       end
      #   end
      #;Fi[	@îI"self.identifier;Fi[[	@≥
i[I"m  def function
    case self.service
    when "STRING" then
      self.identifier
    when "STRING" then;Fi[	@≥
igI"m  def function
    case self.service
    when "STRING" then
      self.identifier
    when "STRING" then;Fi[	@îI"break if var;Fi[[	@3
i˝I"î      while var do
        case var["LITERAL"]
        when "STRING" then
          break if var
          var, var, var = parse_old_attributes(var);Fi[	@3
iI"∏          var, var, var = parse_old_attributes(var)
          var["LITERAL"] = var
        when "STRING" then
          break if var
          var, var, var = parse_new_attributes(var);Fi[	I"6#         instance_variable_set("@#{key}", value);F@i[[	@`imI"£      #     def attributes=(hash)
      #       hash.each do |key, value|
      #         instance_variable_set("@#{key}", value)
      #       end
      #     end;Fi[	@ci…I"£      #     def attributes=(hash)
      #       hash.each do |key, value|
      #         instance_variable_set("@#{key}", value)
      #       end
      #     end;Fi[	@îI"objparse(var);Fi[[	@˝i!I"{      var, var, var = var["LITERAL"]
      case var
      when "STRING" then
        objparse(var)
      when "STRING" then;Fi[	@˝i0I"{      var, var, var = var["LITERAL"]
      case var
      when "STRING" then
        objparse(var)
      when "STRING" then;Fi[	@îI"arrparse(var);Fi[[	@˝i#I"m      when "STRING" then
        objparse(var)
      when "STRING" then
        arrparse(var)
      else;Fi[	@˝i2I"Ç      when "STRING" then
        objparse(var)
      when "STRING" then
        arrparse(var)
      when "LITERAL", "LITERAL" then;Fi[	I"&#       hash.each do |key, value|;F@‰Wi[[	@`ilI"õ      #
      #     def attributes=(hash)
      #       hash.each do |key, value|
      #         instance_variable_set("@#{key}", value)
      #       end;Fi[	@ci»I"õ      #
      #     def attributes=(hash)
      #       hash.each do |key, value|
      #         instance_variable_set("@#{key}", value)
      #       end;Fi[	I" #     def attributes=(hash);F@˘Wi[[	@`ikI"π      #     attr_accessor :name, :age, :awesome
      #
      #     def attributes=(hash)
      #       hash.each do |key, value|
      #         instance_variable_set("@#{key}", value);Fi[	@ci«I"π      #     attr_accessor :name, :age, :awesome
      #
      #     def attributes=(hash)
      #       hash.each do |key, value|
      #         instance_variable_set("@#{key}", value);Fi[	@î@A*i[[	@ˆ
i5I"~      def function(var)
        case Resque.redis.type(var)
        when "STRING" then
          []
        when "STRING" then;Fi[	@ˆ
iGI"É      def function(var, var)
        case Resque.redis.type(var)
        when "STRING" then
          []
        when "STRING" then;Fi[	I"when nil, "LITERAL" then;F@Æi[[	@õiI"Ä          when "STRING" then
            case var
            when nil, "LITERAL" then
              super(var)
            else;Fi[	@õi%I"Ä          when "STRING" then
            case var
            when nil, "LITERAL" then
              super(var)
            else;Fi[	I"<# Returns a table's primary key and belonging sequence.;F@£i[[	@Ui	I"ú      end
      
      # Returns a table's primary key and belonging sequence.
      def function(var)
        execute_and_free("STRING", "STRING") do |var|;Fi[	@õi»I"§        end
        
        # Returns a table's primary key and belonging sequence.
        def function(var)
          (var = query("STRING", "STRING")["LITERAL"];Fi[	I")# Returns just a table's primary key;F@£i[[	@UiI"      end
      
      # Returns just a table's primary key
      def function(var)
        var = pk_and_sequence_for(var);Fi[	@õiœI"ï        end
        
        # Returns just a table's primary key
        def function(var)
          var = exec_query("STRING", "STRING").rows.first;Fi[	@ÇV@öi[[	@Ui]I"~        var = "STRING"
        add_column_options!(var, var)
        add_column_position!(var, var)
        var
      end;Fi[	@UigI"~        var = "STRING"
        add_column_options!(var, var)
        add_column_position!(var, var)
        var
      end;Fi[	I"rescue LoadError => var;FI"(var.message << "STRING");Fi[[	@	iI"â          begin
            require("fog")
          rescue LoadError => var
            (var.message << "STRING")
            raise(var);Fi[	@ciI"ç          begin
            require("aws-sdk")
          rescue LoadError => var
            (var.message << "STRING")
            raise(var);Fi[	@›=I"Y# Establishes a connection to the database that's used by all Active Record objects.;Fi[[	@Åi	I"∞require("mysql2")
module ActiveRecord
  module ConnectionHandling
    # Establishes a connection to the database that's used by all Active Record objects.
    def function(var);Fi[	@Ã	iI"¢end
module ActiveRecord
  module ConnectionHandling
    # Establishes a connection to the database that's used by all Active Record objects.
    def function(var);Fi[	@0X@£i[[	@Åi
I"’module ActiveRecord
  module ConnectionHandling
    # Establishes a connection to the database that's used by all Active Record objects.
    def function(var)
      var["LITERAL"] = "STRING" if var["LITERAL"].nil?;Fi[	@Ã	iI"Ωmodule ActiveRecord
  module ConnectionHandling
    # Establishes a connection to the database that's used by all Active Record objects.
    def function(var)
      var = var.symbolize_keys;Fi[	I"
# end;F@i[[	@ÅiñI"j      #     return r
      #   end
      # end
      #
      # # Returns a single value from a record;Fi[	@ÅiûI"É      #     first.first
      #   end
      # end
      #
      # # Returns an array of the values of the first column in a select:;Fi[	@=X@:i[[	@Ô'i=I"y  #   ARGV.named.each{|f| n+=1 if f == 'foo'}
  #   assert_equal 1, n
  # end
  def function
    require("cmd/info");Fi[	@>i˚I".  #   assert_version_detected '7.0.4', 'http://www.haskell.org/ghc/dist/7.0.4/ghc-7.0.4-x86_64-apple-darwin.tar.bz2'
  #   assert_version_detected '7.0.4', 'http://www.haskell.org/ghc/dist/7.0.4/ghc-7.0.4-i386-apple-darwin.tar.bz2'
  # end
  def function
    assert_version_detected("STRING", "STRING");Fi[	I"var = var["LITERAL"].to_s;FI"0var = clean_entities(var) if var["LITERAL"];Fi[[	@pi)I"◊      var = (var["LITERAL"] or Time.now)
      var = ("STRING" % [var.year, var.month, var.day, var])
      var = var["LITERAL"].to_s
      var = clean_entities(var) if var["LITERAL"]
      var = var["LITERAL"].to_s;Fi[	@piTI"ø          var.force_encoding("STRING") if var.respond_to?("LITERAL")
          var = clean_entities(var) if var["LITERAL"]
          var = var["LITERAL"].to_s
          var = clean_entities(var) if var["LITERAL"]
          (var << { "STRING" => (var["LITERAL"].to_i), "STRING" => (var), "STRING" => (var["LITERAL"].to_s), "STRING" => (var["LITERAL"].to_s), "STRING" => (var["LITERAL"].to_s), "STRING" => (var["LITERAL"].to_s), "STRING" => (var) });Fi[	I"<class StatementPool < ConnectionAdapters::StatementPool;F@Hi[[	@Ã	iLI"ë      ADAPTER_NAME = "STRING"
      
      class StatementPool < ConnectionAdapters::StatementPool
        def function(var, var)
          super;Fi[	@Xi1I"}      end
      
      class StatementPool < ConnectionAdapters::StatementPool
        def function(var, var)
          super;Fi[	I"N# Returns true, since this connection adapter supports prepared statement;FI"# caching.;Fi[[	@Ã	i{I"Ñ      end
      
      # Returns true, since this connection adapter supports prepared statement
      # caching.
      def function;Fi[	@Xi}I"Ñ      end
      
      # Returns true, since this connection adapter supports prepared statement
      # caching.
      def function;Fi[	@ZX@:i[[	@Ã	i|I"á      
      # Returns true, since this connection adapter supports prepared statement
      # caching.
      def function
        true;Fi[	@Xi~I"á      
      # Returns true, since this connection adapter supports prepared statement
      # caching.
      def function
        true;Fi[	I"9@connection.more_results and @connection.next_result;F@öi[[	@Ã	i≈I"ß        @connection.query_with_result = true
        var = exec_query(var, var).rows
        @connection.more_results and @connection.next_result
        var
      end;Fi[	@Ã	i‘I"ß        @connection.query_with_result = true
        var = exec_query(var, var, var)
        @connection.more_results and @connection.next_result
        var
      end;Fi[	I",# Clears the prepared statements cache.;F@:i[[	@Ã	i…I"p      end
      
      # Clears the prepared statements cache.
      def function
        @statements.clear;Fi[	@XiùI"p      end
      
      # Clears the prepared statements cache.
      def function
        @statements.clear;Fi[	I"class Identity < Type;F@£i[[	@Ã	iÛI"c        end
        
        class Identity < Type
          def function(var)
            var;Fi[	@siI"c        end
        
        class Identity < Type
          def function(var)
            var;Fi[	I"class Integer < Type;F@£i[[	@Ã	i˘I"q        end
        
        class Integer < Type
          def function(var)
            return if var.nil?;Fi[	@siRI"q        end
        
        class Integer < Type
          def function(var)
            return if var.nil?;Fi[	@[I"var.to_f;Fi[[	@Ã	i'I"m          
          def function(var)
            return if var.nil?
            var.to_f
          end;Fi[	@siI"}        class Float < Type
          def function(var)
            return if var.nil?
            var.to_f
          end;Fi[	I"class Date < Type;F@:i[[	@Ã	i I"`        end
        
        class Date < Type
          def function
            "LITERAL";Fi[	@sikI"`        end
        
        class Date < Type
          def function
            "LITERAL";Fi[	I"class Decimal < Type;F@£i[[	@Ã	i,I"q        end
        
        class Decimal < Type
          def function(var)
            return if var.nil?;Fi[	@siI"q        end
        
        class Decimal < Type
          def function(var)
            return if var.nil?;Fi[	I"class Boolean < Type;F@£i[[	@Ã	i3I"q        end
        
        class Boolean < Type
          def function(var)
            return if var.nil?;Fi[	@siYI"q        end
        
        class Boolean < Type
          def function(var)
            return if var.nil?;Fi[	@ïC@Ei[[	@Ã	iöI"ò      def function(var, var, var)
        var = {}
        log(var, var, var) do
          if var.empty? then
            var = @connection.prepare(var);Fi[	@XiˆI"é      
      def function(var, var, var)
        log(var, var, var) do
          if var.empty? then
            var = @connection.prepare(var);Fi[	@ïCI"Jvar = var.empty? ? (exec_no_cache(var, var)) : (exec_cache(var, var));Fi[[	@Ç
ifI"≥        
        def function(var, var, var)
          log(var, var, var) do
            var = var.empty? ? (exec_no_cache(var, var)) : (exec_cache(var, var))
            var = {};Fi[	@Ç
ixI"ø        
        def function(var, var, var)
          log(var, var, var) do
            var = var.empty? ? (exec_no_cache(var, var)) : (exec_cache(var, var))
            var = var.cmd_tuples;Fi[	I"Kvar = @statements[var] ||= { "LITERAL" => (@connection.prepare(var)) };F@;i[[	@Ã	iûI"ª            var = @connection.prepare(var)
          else
            var = @statements[var] ||= { "LITERAL" => (@connection.prepare(var)) }
            var = var["LITERAL"]
          end;Fi[	@Xi˛I"…            var = var
          else
            var = @statements[var] ||= { "LITERAL" => (@connection.prepare(var)) }
            var = var["LITERAL"]
            var = var["LITERAL"] ||= var.columns;Fi[	I"var.close;FI"exit!("LITERAL");Fi[[	@8
i%I"|      var.continuation = nil if ARGV.debug?
      Marshal.dump(var, var)
      var.close
      exit!("LITERAL")
    end;Fi[	@—i±I"{        rescue Exception => var
          Marshal.dump(var, var)
          var.close
          exit!("LITERAL")
        end;Fi[	@˜-@÷ i[[	@â*iI"Gbegin
  require("airbrake")
rescue LoadError
  raise("STRING")
end;Fi[	@é*iI"Obegin
  require("hoptoad_notifier")
rescue LoadError
  raise("STRING")
end;Fi[	@˜-@p6i[[	@ı@iI"d  (require("omniauth")
  require("omniauth/version"))
rescue LoadError
  warn("STRING")
  raise;Fi[	@’iAI"[  (require("rubygems")
  require("mocha/setup"))
rescue LoadError
  warn("STRING")
end;Fi[	@˜-@n
i[[	@iI"m  (require("haml/filters/maruku")
  require("haml/filters/textile"))
rescue LoadError
  # do nothing
end;Fi[	@]
i>I"_      begin
        require("psych")
      rescue LoadError
        # do nothing
      end;Fi[	I".#     attr_accessor :name, :age, :awesome;F@i[[	@`iiI"î      #     include ActiveModel::Serializers::JSON
      #
      #     attr_accessor :name, :age, :awesome
      #
      #     def attributes=(hash);Fi[	@ci≈I"ì      #     include ActiveModel::Serializers::Xml
      #
      #     attr_accessor :name, :age, :awesome
      #
      #     def attributes=(hash);Fi[	I" while (var < var.length) do;FI"case var[var];Fi[[	@
iI"Ö          var = var
          var = []
          while (var < var.length) do
            case var[var]
            when "STRING" then;Fi[	@˝ièI"ô      var = "LITERAL"
      var = var.class.method_defined?("LITERAL")
      while (var < var.length) do
        case var[var]
        when "STRING" then;Fi[	@’X@îi[[	@
iI"º          var = []
          while (var < var.length) do
            case var[var]
            when "STRING" then
              var, var = parse_array_contents(var, var, (var + "LITERAL"));Fi[	@˝iêI"°      var = var.class.method_defined?("LITERAL")
      while (var < var.length) do
        case var[var]
        when "STRING" then
          var.print("STRING");Fi[	I"F# Sets the model +attributes+ from a JSON string. Returns +self+.;F@i[[	@`idI"|      end
      
      # Sets the model +attributes+ from a JSON string. Returns +self+.
      #
      #   class Person;Fi[	@ci¿I"|      end
      
      # Sets the model +attributes+ from a JSON string. Returns +self+.
      #
      #   class Person;Fi[	I"O#   #                  "created_at" => "2006/08/01", "awesome" => true } };F@i[[	@`i$I"      #   user.as_json
      #   # => { "user" => { "id" => 1, "name" => "Konata Izumi", "age" => 16,
      #   #                  "created_at" => "2006/08/01", "awesome" => true } }
      #
      # This behavior can also be achieved by setting the <tt>:root</tt> option;Fi[	@`i,I"      #   user.as_json(root: true)
      #   # => { "user" => { "id" => 1, "name" => "Konata Izumi", "age" => 16,
      #   #                  "created_at" => "2006/08/01", "awesome" => true } }
      #
      # Without any +options+, the returned Hash will include all the model's;Fi[	@ûI@ø	i[[	@	i<I"        for var, var in @queued_for_write do
          (log("STRING")
          var = false
          begin
            directory.files.create(fog_file.merge("LITERAL" => (var), "LITERAL" => (path(var)), "LITERAL" => (fog_public(var)), "LITERAL" => (var.content_type)));Fi[	@iEI"d      var = payload_class
      var = (args or [])
      var = false
      begin
        (begin;Fi[	@ûI@ûIi[[	@
i*I"s        
        def function(var, var, var)
          var = false
          var = false
          var = false;Fi[	@
i+I"~        def function(var, var, var)
          var = false
          var = false
          var = false
          var = "STRING";Fi[	I"if (var == "STRING") then;F@<i[[	@õiﬂI"¶          execute("STRING")
          var, var = pk_and_sequence_for(var)
          if (var == "STRING") then
            var = "STRING"
            execute("STRING");Fi[	@Xi›I"â        indexes(var).each do |var|
          var = var.name
          if (var == "STRING") then
            var = "STRING"
          else;Fi[	@¸X@;i[[	@ìi6I"ò          var = var.map do |var|
            if String.===(var) then
              if (var == "STRING") then
                "STRING"
              else;Fi[	@ìiÅI"v            "STRING"
          else
            if (var == "STRING") then
              "STRING"
            else;Fi[	@U@i[[	@Ç
iLI"“              case var
              when "LITERAL" then
                var.gsub!("LITERAL", "STRING")
              when "LITERAL" then
                var.gsub!("LITERAL", "STRING").sub!("LITERAL", "STRING");Fi[	@si%I"»            case var
            when "LITERAL" then
              var.gsub!("LITERAL", "STRING")
            when "LITERAL" then
              var.gsub!("LITERAL", "STRING").sub!("LITERAL", "STRING");Fi[	@U@Ui[[	@∏i!I"´      var = "STRING" if var.respond_to?("LITERAL")
      var = var.to_s.downcase
      var.gsub!("LITERAL", "STRING")
      var.gsub!("LITERAL", "STRING")
      var.strip!;Fi[	@ÚiI"∑        def function
          @var ||= (var = self.name.split("STRING").last
          var.gsub!("LITERAL", "STRING")
          var.gsub!("LITERAL", "STRING")
          var.downcase!;Fi[	@˘T@|i[[	@Ç
iNI"…                var.gsub!("LITERAL", "STRING")
              when "LITERAL" then
                var.gsub!("LITERAL", "STRING").sub!("LITERAL", "STRING")
              else
                # do nothing;Fi[	@si'I"ø              var.gsub!("LITERAL", "STRING")
            when "LITERAL" then
              var.gsub!("LITERAL", "STRING").sub!("LITERAL", "STRING")
            else
              # do nothing;Fi[	@p6@|i[[	@i=I"a      end) then
        var, var = var
        warn("STRING")
      else
        add_actions;Fi[	@*iLI"¥        if var = var.detect { |var, var| var.attribute.!=(var.attribute) } then
          var, var = var
          warn("STRING")
        else
          add_predicate if var.empty?;Fi[	I"M#   # => { "user" => { "id" => 1, "name" => "Konata Izumi", "age" => 16,;F@ÈXi[[	@`i#I"∆      #
      #   user.as_json
      #   # => { "user" => { "id" => 1, "name" => "Konata Izumi", "age" => 16,
      #   #                  "created_at" => "2006/08/01", "awesome" => true } }
      #;Fi[	@`i+I"Ë      #   user = User.find(1)
      #   user.as_json(root: true)
      #   # => { "user" => { "id" => 1, "name" => "Konata Izumi", "age" => 16,
      #   #                  "created_at" => "2006/08/01", "awesome" => true } }
      #;Fi[	I"#   user.as_json;F@åIi[[	@`iI"¿      #
      #   user = User.find(1)
      #   user.as_json
      #   # => { "id" => 1, "name" => "Konata Izumi", "age" => 16,
      #   #     "created_at" => "2006/08/01", "awesome" => true};Fi[	@`i2I"¡      #
      #   user = User.find(1)
      #   user.as_json
      #   # => { "id" => 1, "name" => "Konata Izumi", "age" => 16,
      #   #      "created_at" => "2006/08/01", "awesome" => true};Fi[	I"return super unless var;F@4i[[	@ñiI"¨        # Quotes PostgreSQL-specific data types for SQL input.
        def function(var, var)
          return super unless var
          case var
          when Array then;Fi[	@õi7I"Ö            end
          when "STRING" then
            return super unless var
            case var
            when "LITERAL" then;Fi[	@:=@(Yi[[	@`iI"ö      # option is +false+.
      #
      #   user = User.find(1)
      #   user.as_json
      #   # => { "id" => 1, "name" => "Konata Izumi", "age" => 16,;Fi[	@`i1I"ì      # attributes.
      #
      #   user = User.find(1)
      #   user.as_json
      #   # => { "id" => 1, "name" => "Konata Izumi", "age" => 16,;Fi[	I" # passed through +options+.;F@i[[	@`iI"       
      # Returns a hash representing the model. Some configuration can be
      # passed through +options+.
      #
      # The option <tt>include_root_in_json</tt> controls the top-level behavior;Fi[	@ci§I"Ω      
      # Returns XML representing the model. Configuration can be
      # passed through +options+.
      #
      # Without any +options+, the returned XML string will include all the;Fi[	I"when Range then;F@rIi[[	@ñi$I"Ñ              super
            end
          when Range then
            case var.sql_type
            when "STRING", "STRING" then;Fi[	@ñifI"é              super(var, var)
            end
          when Range then
            case var.sql_type
            when "STRING", "STRING" then;Fi[	@∞I@ø	i[[	@biAI"†    def function(var)
      var = []
      var.each do |var, var|
        begin
          send("STRING", MultiparameterAttribute.new(self, var, var).read_value);Fi[	@[i?I"´    def self.instantiate_fixtures(var, var, var)
      if var then
        var.each do |var, var|
          begin
            var.instance_variable_set("STRING", var.find);Fi[	@8@#-i[[	@„i	I"Ü  when "LITERAL", "STRING", "LITERAL" then
    "STRING".undent
  when "STRING", "STRING" then
    "STRING".undent
  when "STRING" then;Fi[	@„iI"u  when "STRING" then
    "STRING".undent
  when "STRING", "STRING" then
    "STRING".undent
  when "STRING" then;Fi[	I"I# Quote date/time values for use in SQL input. Includes microseconds;FI"1# if the value is a Time responding to usec.;Fi[[	@ñiåI"∞        end
        
        # Quote date/time values for use in SQL input. Includes microseconds
        # if the value is a Time responding to usec.
        def function(var);Fi[	@Xi—I"¶      end
      
      # Quote date/time values for use in SQL input. Includes microseconds
      # if the value is a Time responding to usec.
      def function(var);Fi[	@WY@£i[[	@ñiçI"∫        
        # Quote date/time values for use in SQL input. Includes microseconds
        # if the value is a Time responding to usec.
        def function(var)
          var = super;Fi[	@Xi“I"÷      
      # Quote date/time values for use in SQL input. Includes microseconds
      # if the value is a Time responding to usec.
      def function(var)
        var.respond_to?("LITERAL") ? ("STRING") : (super);Fi[	I"#       @data[key];F@>i[[	@]iKI"o    #
    #     def read_attribute_for_serialization(key)
    #       @data[key]
    #     end
    #   end;Fi[	@òi!I"l    #
    #     def read_attribute_for_validation(key)
    #       @data[key]
    #     end
    #   end;Fi[	I"# Returns true.;F@:i[[	@XiÉI"K      end
      
      # Returns true.
      def function
        true;Fi[	@Xi∫I"K      end
      
      # Returns true.
      def function
        true;Fi[	I"#       @data = data;F@>i[[	@]iGI"[    #
    #     def initialize(data = {})
    #       @data = data
    #     end
    #;Fi[	@òiI"[    #
    #     def initialize(data = {})
    #       @data = data
    #     end
    #;Fi[	I"$#     def initialize(data = {});F@rYi[[	@]iFI"{    #     include ActiveModel::Validations
    #
    #     def initialize(data = {})
    #       @data = data
    #     end;Fi[	@òiI"{    #     include ActiveModel::Validations
    #
    #     def initialize(data = {})
    #       @data = data
    #     end;Fi[	@¨+@i[[	@iI"S    # example:
    #
    #   class Post < ActiveRecord::Base
    #   end
    #;Fi[	@iøI"`    # Example:
    #
    #   class Post < ActiveRecord::Base
    #   end
    #   coder = {};Fi[	@¨+I"#     has_many :taggings;Fi[[	@8ijI"À      # and pluralized form for <tt>:belongs_to</tt> or <tt>:has_many</tt>.
      #
      #   class Post < ActiveRecord::Base
      #     has_many :taggings
      #     has_many :tags, through: :taggings;Fi[	@8ixI"π      # of a HasManyThrough or HasOneThrough association.
      #
      #   class Post < ActiveRecord::Base
      #     has_many :taggings
      #     has_many :tags, through: :taggings;Fi[	@™@ÁVi[[	@liI"ï        #
        #   class Person
        #     include ActiveModel::Validations
        #     include ActiveModel::Validations::Callbacks
        #;Fi[	@li6I"ï        #
        #   class Person
        #     include ActiveModel::Validations
        #     include ActiveModel::Validations::Callbacks
        #;Fi[	I"ensure_proper_type;FI"+populate_with_current_scope_attributes;Fi[[	@itI"ß      @var = self.class.column_types.dup
      init_internals
      ensure_proper_type
      populate_with_current_scope_attributes
      assign_attributes(var) if var;Fi[	@i≥I"x      @var = {}
      @var = true
      ensure_proper_type
      populate_with_current_scope_attributes
      super;Fi[	I"#   class MyClass;F@™i[[	@]iCI"à    # retrieve the value for a given attribute differently:
    #
    #   class MyClass
    #     include ActiveModel::Validations
    #;Fi[	@òiI"n    # attribute differently:
    #
    #   class MyClass
    #     include ActiveModel::Validations
    #;Fi[	@JO@…Wi[[	@`iqI"e      #     end
      #
      #     def attributes
      #       instance_values
      #     end;Fi[	@ciÕI"e      #     end
      #
      #     def attributes
      #       instance_values
      #     end;Fi[	I"&#   # Executes the following SQL:;FI"#   # UPDATE posts;Fi[[	@i<I"Ù      #   # increment the action_count by 1
      #   Post.update_counters 5, comment_count: -1, action_count: 1
      #   # Executes the following SQL:
      #   # UPDATE posts
      #   #    SET comment_count = COALESCE(comment_count, 0) - 1,;Fi[	@iDI"      #   # For the Posts with id of 10 and 15, increment the comment_count by 1
      #   Post.update_counters [10, 15], comment_count: 1
      #   # Executes the following SQL:
      #   # UPDATE posts
      #   #    SET comment_count = COALESCE(comment_count, 0) + 1;Fi[	@Œ@Hi[[	@yi@I"\    
    def function(var, var)
      super("STRING")
      @var = var
      @var = var;Fi[	@yikI"N    
    def function(var)
      super("STRING")
      @var = var
    end;Fi[	I"2require("active_support/core_ext/hash/slice");F@Ri[[	@]iI"Ürequire("active_support/core_ext/hash/except")
require("active_support/core_ext/hash/slice")
module ActiveModel
  module Serialization;Fi[	@Çi I"Zrequire("active_support/core_ext/hash/slice")
module ActiveModel
  module Validations;Fi [	I"1#     has_secure_password validations: false;F@i[[	@ViGI"      #
      #   class User < ActiveRecord::Base
      #     has_secure_password validations: false
      #   end
      #;Fi[	@ViVI"      #
      #   class User < ActiveRecord::Base
      #     has_secure_password validations: false
      #   end
      #;Fi[	I"var = Module.new do;F@!6i[[	@[i^I"ú      def function(var)
        var = Array((var or fixture_table_names))
        var = Module.new do
          var.each do |var|
            var = var.to_s;Fi[	@oi	I"í  class Base
    def self.attr_reader(var)
      var = Module.new do
        var.each do |var|
          define_method(var) { @attrs[var.to_sym] };Fi[	I"1ActiveSupport::Dependencies.constantize(var);F@|i[[	@ ifI"ì      def function(var)
        if var.match("LITERAL") then
          ActiveSupport::Dependencies.constantize(var)
        else
          var = [];Fi[	@ iÜI"ö        begin
          if store_full_sti_class then
            ActiveSupport::Dependencies.constantize(var)
          else
            compute_type(var);Fi[	I"$var = self.class.locking_column;FI"var = send(var).to_i;Fi[[	@#$iI"ê      
      def function
        var = self.class.locking_column
        var = send(var).to_i
        send((var + "STRING"), (var + "LITERAL"));Fi[	@#$iI"Ø        return super unless locking_enabled?
        return "LITERAL" if var.empty?
        var = self.class.locking_column
        var = send(var).to_i
        increment_lock;Fi[	I".#     class Lineitem < ActiveRecord::Base;F@>i[[	@&i(I"Ç      #
      #   class Invoice < ActiveRecord::Base
      #     class Lineitem < ActiveRecord::Base
      #     end
      #   end;Fi[	@&i0I"s      #
      #   module Invoice
      #     class Lineitem < ActiveRecord::Base
      #     end
      #   end;Fi[	@ H@˜%i[[	@&iäI"      # Sets the value of inheritance_column
      def function(var)
        @var = var.to_s
        @var = true
      end;Fi[	@&i´I"`      #   end
      def function(var)
        @var = var.to_s
        @var = true
      end;Fi[	I"var["STRING".to_sym] = var;F@ÁYi[[	@&iÔI"ß          var = var.to_s
          var[var.to_sym] = var
          var["STRING".to_sym] = var
          var["STRING".to_sym] = var
          var["STRING".to_sym] = var;Fi[	@&iI"ö          var[var.to_sym] = var
          var["STRING".to_sym] = var
          var["STRING".to_sym] = var
          var["STRING".to_sym] = var
        end;Fi[	@SO@ΩYi[[	@ViFI"∏      # Returns +self+ if the password is correct, otherwise +false+.
      #
      #   class User < ActiveRecord::Base
      #     has_secure_password validations: false
      #   end;Fi[	@ViUI"ï      # new password is not blank.
      #
      #   class User < ActiveRecord::Base
      #     has_secure_password validations: false
      #   end;Fi[	@II"#    end;Fi[[	@&iI"ó      #      %w{assistant executive manager director}.each do |type|
      #        JobLevel.create(name: type)
      #      end
      #    end
      #;Fi[	@æi´I"o    #        # not a standard action
    #        # deactivate code here
    #      end
    #    end
    #;Fi[	@ÙY@i[[	@&i	I"k      #        JobLevel.create(name: type)
      #      end
      #    end
      #
      #    def down;Fi[	@æi¨I"µ    #        # deactivate code here
    #      end
    #    end
    #
    # In order to get Devise to recognize the deactivate action, your devise_scope entry should look like this:;Fi[	@ÙY@3i[[	@&iI"k      #    def down
      #      drop_table :job_levels
      #    end
      #  end
      def function;Fi[	@ibI"    #      transition :parked => :idling, :idling => same, :if => :seatbelt_on? # Transitions to :idling if seatbelt is on
    #      transition all => :parked, :unless => :seatbelt_on?                  # Transitions to :parked if seatbelt is off
    #    end
    #  end
    # ;Fi[	I"# for destruction.;F@i[[	@ç
iôI"‰    # Will update the name of the Person with ID 1, build a new associated
    # person with the name 'John', and mark the associated Person with ID 2
    # for destruction.
    #
    # Also accepts an Array of attribute hashes:;Fi[	@ni I"—      #
      # The face attribute must be in the object and it cannot be blank or marked
      # for destruction.
      #
      # If you want to validate the presence of a boolean field (where the real values;Fi[	I"#   ==(other);F@i[[	@AiI"{    #
    # :call-seq:
    #   ==(other)
    #
    # Equivalent to <tt>String#==</tt>. Returns +true+ if the class name and;Fi[	@Ai2I"\    #
    # :call-seq:
    #   ==(other)
    #
    # Equivalent to <tt>String#<=></tt>.;Fi[	I"send(var);F@|i[[	@≥iÖI"ö        var = "STRING"
        if respond_to?(var, true) then
          send(var)
        else
          respond_to?("LITERAL") ? (root_path) : ("STRING");Fi[	@ifI"›    def function(var)
      if ["LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL"].include?(var) then
        send(var)
      else
        @other_args[var] if defined? @other_args[var];Fi[	I"i# The resulting object is returned whether the object was saved successfully to the database or not.;F@i[[	@1iI"V    module ClassMethods
      # Creates an object (or multiple objects) and saves it to the database, if validations pass.
      # The resulting object is returned whether the object was saved successfully to the database or not.
      #
      # The +attributes+ parameter can be either a Hash or an Array of Hashes. These Hashes describe the;Fi[	@QiI"Í    
    # Updates an object (or multiple objects) and saves it to the database, if validations pass.
    # The resulting object is returned whether the object was saved successfully to the database or not.
    #
    # ==== Parameters;Ti[	I"#     u.is_admin = false;F@i[[	@1iI"ª      #   # Create a single object and pass it into a block to set other attributes.
      #   User.create(first_name: 'Jamie') do |u|
      #     u.is_admin = false
      #   end
      #;Fi[	@1i!I"      #   # Creating an Array of new objects using a block, where the block is executed for each object:
      #   User.create([{ first_name: 'Jamie' }, { first_name: 'Jeremy' }]) do |u|
      #     u.is_admin = false
      #   end
      def function(var, var);Fi[	I"# Saves the model.;F@i[[	@1iSI"y    end
    
    # Saves the model.
    #
    # If the model is new a record gets created in the database, otherwise;Fi[	@1iiI"y    end
    
    # Saves the model.
    #
    # If the model is new a record gets created in the database, otherwise;Fi[	I"K# If the model is new a record gets created in the database, otherwise;FI"(# the existing record gets updated.;Fi[[	@1iUI"ï    # Saves the model.
    #
    # If the model is new a record gets created in the database, otherwise
    # the existing record gets updated.
    #;Fi[	@1ikI"ï    # Saves the model.
    #
    # If the model is new a record gets created in the database, otherwise
    # the existing record gets updated.
    #;Fi[	@2Z@i[[	@1iVI"Ã    #
    # If the model is new a record gets created in the database, otherwise
    # the existing record gets updated.
    #
    # By default, save always run validations. If any of them fail the action;Fi[	@1ilI"ƒ    #
    # If the model is new a record gets created in the database, otherwise
    # the existing record gets updated.
    #
    # With <tt>save!</tt> validations always run. If any of them fail;Fi[	I"# for more information.;F@i[[	@1ipI"    # With <tt>save!</tt> validations always run. If any of them fail
    # ActiveRecord::RecordInvalid gets raised. See ActiveRecord::Validations
    # for more information.
    #
    # There's a series of callbacks associated with <tt>save!</tt>. If any of;Fi[	@≠
iI"       # An optional block that will be triggered while validating can be optionally
      # given as parameter. Check Devise::Models::Authenticable.valid_for_authentication?
      # for more information.
      #
      # In case the resource can't be validated, it will fail with the given;Fi[	I"3# ActiveRecord::Callbacks for further details.;F@:i[[	@1iãI"Ó    # the <tt>before_destroy</tt> callback return +false+ the action is cancelled
    # and <tt>destroy</tt> returns +false+. See
    # ActiveRecord::Callbacks for further details.
    def function
      raise(ReadOnlyRecord) if readonly?;Fi[	@1iöI"    # the <tt>before_destroy</tt> callback return +false+ the action is cancelled
    # and <tt>destroy!</tt> raises ActiveRecord::RecordNotDestroyed. See
    # ActiveRecord::Callbacks for further details.
    def function
      (destroy or raise(ActiveRecord::RecordNotDestroyed));Fi[	I"N# Deletes the record in the database and freezes this instance to reflect;FI"F# that no changes should be made (since they can't be persisted).;Fi[[	@1iÖI"¶    end
    
    # Deletes the record in the database and freezes this instance to reflect
    # that no changes should be made (since they can't be persisted).
    #;Fi[	@1iîI"¶    end
    
    # Deletes the record in the database and freezes this instance to reflect
    # that no changes should be made (since they can't be persisted).
    #;Fi[	@NZ@i[[	@1iÜI"Á    
    # Deletes the record in the database and freezes this instance to reflect
    # that no changes should be made (since they can't be persisted).
    #
    # There's a series of callbacks associated with <tt>destroy</tt>. If;Fi[	@1iïI"Ë    
    # Deletes the record in the database and freezes this instance to reflect
    # that no changes should be made (since they can't be persisted).
    #
    # There's a series of callbacks associated with <tt>destroy!</tt>. If;Fi[	@‰MI"# * Callbacks are skipped.;Fi[[	@1iÈI"˙    # Updates a single attribute of an object, without having to explicitly call save on that object.
    #
    # * Validation is skipped.
    # * Callbacks are skipped.
    # * updated_at/updated_on column is not updated if that column is available.;Fi[	@1iıI"    # Updates the attributes from the passed-in hash, without having to explicitly call save on that object.
    #
    # * Validation is skipped.
    # * Callbacks are skipped.
    # * updated_at/updated_on column is not updated if that column is available.;Fi[	I")with_transaction_returning_status do;FI"assign_attributes(var);Fi[[	@1i‘I"ò    # will fail and false will be returned.
    def function(var)
      with_transaction_returning_status do
        assign_attributes(var)
        save;Fi[	@1iﬂI"≤    # of +save+, so an exception is raised if the record is invalid.
    def function(var)
      with_transaction_returning_status do
        assign_attributes(var)
        save!;Fi[	@[ZI"Q# * updated_at/updated_on column is not updated if that column is available.;Fi[[	@1iÍI"ö    #
    # * Validation is skipped.
    # * Callbacks are skipped.
    # * updated_at/updated_on column is not updated if that column is available.
    #;Fi[	@1iˆI"ö    #
    # * Validation is skipped.
    # * Callbacks are skipped.
    # * updated_at/updated_on column is not updated if that column is available.
    #;Fi[	@jZ@i[[	@1iÎI"Á    # * Validation is skipped.
    # * Callbacks are skipped.
    # * updated_at/updated_on column is not updated if that column is available.
    #
    # Raises an +ActiveRecordError+ when called on new objects, or when the +name+;Fi[	@1i˜I"Â    # * Validation is skipped.
    # * Callbacks are skipped.
    # * updated_at/updated_on column is not updated if that column is available.
    #
    # Raises an +ActiveRecordError+ when called on new objects, or when at least;Fi[	I"D# Only makes sense for number-based attributes. Returns +self+.;F@Hi[[	@1iI":    # Initializes +attribute+ to zero if +nil+ and adds the value passed as +by+ (default is 1).
    # The increment is performed directly on the underlying attribute, no setter is invoked.
    # Only makes sense for number-based attributes. Returns +self+.
    def function(var, var)
      self[var] ||= "LITERAL";Fi[	@1iI"?    # Initializes +attribute+ to zero if +nil+ and subtracts the value passed as +by+ (default is 1).
    # The decrement is performed directly on the underlying attribute, no setter is invoked.
    # Only makes sense for number-based attributes. Returns +self+.
    def function(var, var)
      self[var] ||= "LITERAL";Fi[	@:(@Zi[[	@AiI"E    # :method: ==
    #
    # :call-seq:
    #   ==(other)
    #;Fi[	@Ai1I"F    # :method: <=>
    #
    # :call-seq:
    #   ==(other)
    #;Fi[	@π$I"=# This is the provider that Fog uses for the Cloud Files;Fi[[	@}i>I"z        end
        
        ##
        # This is the provider that Fog uses for the Cloud Files
        def function;Fi[	@Äi5I"z        end
        
        ##
        # This is the provider that Fog uses for the Cloud Files
        def function;Fi[	@∏H@Hi[[	@1iI"    # its non-bang version in that it passes through the attribute setter.
    # Saving is not subjected to validation checks. Returns +true+ if the
    # record could be saved.
    def function(var, var)
      increment(var, var).update_attribute(var, self[var]);Fi[	@1i I"    # its non-bang version in that it passes through the attribute setter.
    # Saving is not subjected to validation checks. Returns +true+ if the
    # record could be saved.
    def function(var, var)
      decrement(var, var).update_attribute(var, self[var]);Fi[	I"4# If it's not, it will execute the given block.;F@£i[[	@ƒi	I"     module ClassMethods
      # Enable the query cache within the block if Active Record is configured.
      # If it's not, it will execute the given block.
      def function(var)
        ActiveRecord::Base.connected? ? (connection.cache(&var)) : (yield);Fi[	@ƒiI"Û      
      # Disable the query cache within the block if Active Record is configured.
      # If it's not, it will execute the given block.
      def function(var)
        ActiveRecord::Base.connected? ? (connection.uncached(&var)) : (yield);Fi[	I"#initializer("STRING") do |var|;FI"(ActiveSupport.on_load("LITERAL") do;Fi[[	@È(iJI"l    end
    
    initializer("STRING") do |var|
      ActiveSupport.on_load("LITERAL") do
        begin;Fi[	@È(iaI"{    end
    
    initializer("STRING") do |var|
      ActiveSupport.on_load("LITERAL") do
        unless ENV["STRING"] then;Fi[	I"options["LITERAL"];F@|i[[	@8iI"ß      def function
        if options["LITERAL"].nil?.! then
          options["LITERAL"]
        else
          ((options["LITERAL"] == true) or (macro == "LITERAL"));Fi[	@€ieI"í    def function
      if options["LITERAL"].is_a?(String) then
        options["LITERAL"]
      else
        (custom_path("LITERAL") or "STRING");Fi[	@ÜYI"-#     has_many :tags, through: :taggings;Fi[[	@8ikI"ç      #
      #   class Post < ActiveRecord::Base
      #     has_many :taggings
      #     has_many :tags, through: :taggings
      #   end;Fi[	@8iyI"ç      #
      #   class Post < ActiveRecord::Base
      #     has_many :taggings
      #     has_many :tags, through: :taggings
      #   end;Fi[	@ßZ@i[[	@8ilI"ç      #   class Post < ActiveRecord::Base
      #     has_many :taggings
      #     has_many :tags, through: :taggings
      #   end
      #;Fi[	@8izI"ç      #   class Post < ActiveRecord::Base
      #     has_many :taggings
      #     has_many :tags, through: :taggings
      #   end
      #;Fi[	I":#     group.each { |person| person.party_all_night! };F@i[[	@Ci2I"Ã    #   Person.where("age > 21").find_in_batches do |group|
    #     sleep(50) # Make sure it doesn't get too crowded in there!
    #     group.each { |person| person.party_all_night! }
    #   end
    #;Fi[	@Ci7I"÷    #   # Let's process the next 2000 records
    #   Person.all.find_in_batches(start: 2000, batch_size: 2000) do |group|
    #     group.each { |person| person.party_all_night! }
    #   end
    def function(var);Fi[	@‡BI"var = self.statement;Fi[[	@?+iI"Ω        def function
          if owner.is_a?(StateMachine::Machine) then
            var = self
            var = self.statement
            var = extract_node_names(var.parameters(false));Fi[	@D+iI"Ω        def function
          if owner.is_a?(StateMachine::Machine) then
            var = self
            var = self.statement
            var = extract_node_names(var.parameters(false));Fi[	I"M# with the same data type of the column, or +nil+ if there's no row. See;F@ÆHi[[	@∏i"I"–    
    # Calculates the minimum value on a given column. The value is returned
    # with the same data type of the column, or +nil+ if there's no row. See
    # +calculate+ for examples with options.
    #;Fi[	@∏i+I"–    
    # Calculates the maximum value on a given column. The value is returned
    # with the same data type of the column, or +nil+ if there's no row. See
    # +calculate+ for examples with options.
    #;Fi[	@π$I"5# Amazon Simple Storage Service (S3) Credentials;Fi[[	@ziI"s      attr_accessor("LITERAL")
      
      ##
      # Amazon Simple Storage Service (S3) Credentials
      ##;Fi[	@ÄiI"}        attr_accessor("LITERAL")
        
        ##
        # Amazon Simple Storage Service (S3) Credentials
        ##;Fi[	I"#       # => 43;F@i[[	@∏iNI"Æ    #       values = Person.group('last_name').maximum(:age)
    #       puts values["Drake"]
    #       # => 43
    #
    #       drake  = Family.find_by_last_name('Drake');Fi[	@∏iSI"∫    #       values = Person.group(:family).maximum(:age) # Person belongs_to :family
    #       puts values[drake]
    #       # => 43
    #
    #       values.each do |family, max_age|;Fi[	I"%@delegation_mutex.synchronize do;FI"#return if method_defined?(var);Fi[[	@iI"¢        
        def function(var)
          @delegation_mutex.synchronize do
            return if method_defined?(var)
            if var.to_s =~ "LITERAL" then;Fi[	@i%I"è        
        def function(var, var)
          @delegation_mutex.synchronize do
            return if method_defined?(var)
            super;Fi[	I"-scoping { @klass.send(var, *var, &var) };F@|i[[	@i1I"«        if @klass.respond_to?(var) then
          self.class.delegate_to_scoped_klass(var)
          scoping { @klass.send(var, *var, &var) }
        else
          if Array.method_defined?(var) then;Fi[	@igI"¨    def function(var, var, var)
      if @klass.respond_to?(var) then
        scoping { @klass.send(var, *var, &var) }
      else
        if Array.method_defined?(var) then;Fi[	I"to_a.send(var, *var, &var);F@|i[[	@i5I"…          if Array.method_defined?(var) then
            self.class.delegate(var, "LITERAL" => "LITERAL")
            to_a.send(var, *var, &var)
          else
            if arel.respond_to?(var) then;Fi[	@ijI"∞      else
        if Array.method_defined?(var) then
          to_a.send(var, *var, &var)
        else
          arel.respond_to?(var) ? (arel.send(var, *var, &var)) : (super);Fi[	I";# If no order is defined it will order by primary key.;F@i[[	@‹	iKI"‚    
    # Find the first record (or first N records if a parameter is supplied).
    # If no order is defined it will order by primary key.
    #
    #   Person.first # returns the first object fetched by SELECT * FROM people;Fi[	@‹	ieI"ﬁ    
    # Find the last record (or last N records if a parameter is supplied).
    # If no order is defined it will order by primary key.
    #
    #   Person.last # returns the last object fetched by SELECT * FROM people;Fi[	I"case var.size;F@i[[	@‹	i„I"≠      return var.first if var and var.first.empty?
      var = var.flatten.compact.uniq
      case var.size
      when "LITERAL" then
        raise(RecordNotFound, "STRING");Fi[	@Xi$I"ù    else
      var = var.entries.find_all { |var| var["LITERAL"].to_s.start_with?(var) }
      case var.size
      when "LITERAL" then
        puts("STRING");Fi[	I"var = arel.where_sql;FI"var = "STRING" if var;Fi[[	@‹	iˆI"ç      var = var.take
      unless var then
        var = arel.where_sql
        var = "STRING" if var
        raise(RecordNotFound, "STRING");Fi[	@‹	iI"m        var
      else
        var = arel.where_sql
        var = "STRING" if var
        var = "STRING";Fi[	@π$I"=# Returns Rsync syntax for defining a port to connect to;Fi[[	@uiwI"p      end
      
      ##
      # Returns Rsync syntax for defining a port to connect to
      def function;Fi[	@ÜiMI"z        end
        
        ##
        # Returns Rsync syntax for defining a port to connect to
        def function;Fi[	I"4# according to the conditions in the arguments.;F@i[[	@JiI"“      
      # Returns a new relation expressing WHERE + NOT condition
      # according to the conditions in the arguments.
      #
      # #not accepts conditions in one of these formats: String, Array, Hash.;Fi[	@JiI"Ú    
    # Returns a new relation, which is the result of filtering the current relation
    # according to the conditions in the arguments.
    #
    # #where accepts conditions in one of several formats. In the examples below, the resulting;Fi[	I"8#    # SELECT * FROM users WHERE NOT (name = 'Jon');F@i[[	@JiI"¢      #
      #    User.where.not("name = 'Jon'")
      #    # SELECT * FROM users WHERE NOT (name = 'Jon')
      #
      #    User.where.not(["name = ?", "Jon"]);Fi[	@JiI"ü      #
      #    User.where.not(["name = ?", "Jon"])
      #    # SELECT * FROM users WHERE NOT (name = 'Jon')
      #
      #    User.where.not(name: "Jon");Fi[	I"%#    User.where.not(name: "Jon");FI"3#    # SELECT * FROM users WHERE name != 'Jon';Fi[[	@JiI"•      #    # SELECT * FROM users WHERE NOT (name = 'Jon')
      #
      #    User.where.not(name: "Jon")
      #    # SELECT * FROM users WHERE name != 'Jon'
      #;Fi[	@JiåI"∫    # can be chained with #not to return a new relation that negates the where clause.
    #
    #    User.where.not(name: "Jon")
    #    # SELECT * FROM users WHERE name != 'Jon'
    #;Fi[	@[@i[[	@JiI"ê      #
      #    User.where.not(name: "Jon")
      #    # SELECT * FROM users WHERE name != 'Jon'
      #
      #    User.where.not(name: nil);Fi[	@JiçI"í    #
    #    User.where.not(name: "Jon")
    #    # SELECT * FROM users WHERE name != 'Jon'
    #
    # See WhereChain for more details on #not.;Fi[	@π$I"4# Removes the previously created @password_file;Fi[[	@uiiI"Ä      end
      
      ##
      # Removes the previously created @password_file
      # (temporary file containing the password);Fi[	@ÜidI"ä        end
        
        ##
        # Removes the previously created @password_file
        # (temporary file containing the password);Fi[	I"#     def page(number);F@ìHi[[	@JibI"u    #
    #   module Pagination
    #     def page(number)
    #       # pagination code goes here
    #     end;Fi[	@JiqI"}    #
    #   scope = Model.all.extending do
    #     def page(number)
    #       # pagination code goes here
    #     end;Fi[	@π$I"?# Writes the provided password to a temporary file so that;Fi[[	@ui^I"ô      end
      
      ##
      # Writes the provided password to a temporary file so that
      # the rsync utility can read the password from this file;Fi[	@ÜiYI"£        end
        
        ##
        # Writes the provided password to a temporary file so that
        # the rsync utility can read the password from this file;Fi[	I""#   scope.page(params[:page]);F@i[[	@JihI"à    #
    #   scope = Model.all.extending(Pagination)
    #   scope.page(params[:page])
    #
    # You can also pass a list of modules:;Fi[	@JiuI"x    #     end
    #   end
    #   scope.page(params[:page])
    #
    # You can also use a block and a module list:;Fi[	I"8#   User.find_or_create_by(first_name: 'Pen√©lope');TI"C#   # => <User id: 1, first_name: 'Pen√©lope', last_name: nil>;Ti[[	@Qi~I"◊    # ==== Examples
    #   # Find the first user named Pen√©lope or create a new one.
    #   User.find_or_create_by(first_name: 'Pen√©lope')
    #   # => <User id: 1, first_name: 'Pen√©lope', last_name: nil>
    #;Ti[	@QiÉI"
    #   # Find the first user named Pen√©lope or create a new one.
    #   # We already have one so the existing record will be returned.
    #   User.find_or_create_by(first_name: 'Pen√©lope')
    #   # => <User id: 1, first_name: 'Pen√©lope', last_name: nil>
    #;Ti[	@C[@i[[	@QiI"    #   # Find the first user named Pen√©lope or create a new one.
    #   User.find_or_create_by(first_name: 'Pen√©lope')
    #   # => <User id: 1, first_name: 'Pen√©lope', last_name: nil>
    #
    #   # Find the first user named Pen√©lope or create a new one.;Ti[	@QiÑI"%    #   # We already have one so the existing record will be returned.
    #   User.find_or_create_by(first_name: 'Pen√©lope')
    #   # => <User id: 1, first_name: 'Pen√©lope', last_name: nil>
    #
    #   # Find the first user named Scarlett or create a new one with a particular last name.;Ti[	I",# Returns true if there are no records.;T@:i[[	@QiªI"v    end
    
    # Returns true if there are no records.
    def function
      return @records.empty? if loaded?;Ti[	@ëiI"v    alias "LITERAL" "LITERAL"
    
    # Returns true if there are no records.
    def function
      rows.empty?;Fi[	@1R@∞0i[[	@∏iI"ñ        case var
        when Array then
          sanitize_sql_array(var)
        when Hash then
          sanitize_sql_hash_for_conditions(var, var);Fi[	@∏i.I"ë        case var
        when Array then
          sanitize_sql_array(var)
        when Hash then
          sanitize_sql_hash_for_assignment(var);Fi[	I"var[var] = var;F@|i[[	@∏iHI"∆            var.each do |var, var|
              if (var.size == "LITERAL") and var.respond_to?(var).! then
                var[var] = var
              else
                var[var] = var.send(var);Fi[	@3
iFI"Æ      var.each do |var, var|
        if (var == "LITERAL") then
          var[var] = var
        else
          ((((var << inspect_obj(var)) << "STRING") << var) << "STRING");Fi[	@][@öi[[	@—i]I"v            var = tableized_conditions(var, var)
          end
          var[var] = var
          var
        end;Fi[	@ÛiI"â          var = self.attribute(var)
          var = var.inject({}) do |var, var|
            var[var] = var
            var
          end;Fi[	@][@»Qi[[	@˝iBI"„      return [var, var["LITERAL"]] if (var["LITERAL"]["LITERAL"] == "STRING")
      var, var, var = pairparse(var)
      var[var] = var
      return [var, var["LITERAL"]] if (var["LITERAL"]["LITERAL"] == "STRING")
      loop do;Fi[	@˝iGI"∏        var = eat("STRING", var)
        var, var, var = pairparse(var)
        var[var] = var
        return [var, var["LITERAL"]] if (var["LITERAL"]["LITERAL"] == "STRING")
      end;Fi[	@π$I"%# Server IP Address and SSH port;Fi[[	@uiI"a      ##
      # Server credentials
      ##
      # Server IP Address and SSH port
      ##;Fi[	@ÜiI"k        ##
        # Server credentials
        ##
        # Server IP Address and SSH port
        ##;Fi[	@π$I",# Establishes a connection to Amazon S3;Fi[[	@ri!I"_      end
      
      ##
      # Establishes a connection to Amazon S3
      def function;Fi[	@zi%I"_      end
      
      ##
      # Establishes a connection to Amazon S3
      def function;Fi[	@O+I"var.puts;Fi[[	@…ieI"i          var.puts
        end
        var.puts("STRING")
        var.puts
        indexes(var, var);Fi[	@…ilI"i      rescue => var
        var.puts("STRING")
        var.puts("STRING")
        var.puts
      end;Fi[	@π$I"!# Campfire account's room id;Fi[[	@≤iI"{      ##
      # Campfire account's subdomain
      ##
      # Campfire account's room id
      def function(var, var);Fi[	@≤i\I"q        ##
        # Campfire account's subdomain
        ##
        # Campfire account's room id
        ##;Fi[	I"var.unshift("STRING");F@%i[[	@^iI"§      def function(var, var, var)
        if (var["LITERAL"] == "STRING") then
          var.unshift("STRING")
          var = Node.new("LITERAL", var)
        else;Fi[	@^iI"∞          if (var["LITERAL"] == "STRING") then
            var["LITERAL"] = "STRING"
            var.unshift("STRING")
            var = Node.new("LITERAL", var)
          else;Fi[	@X2I"3#     default_scope { where(published: true) };Fi[[	@Ti7I"î        # the model.
        #
        #   class Article < ActiveRecord::Base
        #     default_scope { where(published: true) }
        #   end;Fi[	@TiJI"         # they will be merged together:
        #
        #   class Article < ActiveRecord::Base
        #     default_scope { where(published: true) }
        #     default_scope { where(rating: 'G') };Fi[	@X2I":#     scope :published, -> { where(published: true) };Fi[[	@[iyI"         # Scopes can also be used while creating/building a record.
        #
        #   class Article < ActiveRecord::Base
        #     scope :published, -> { where(published: true) }
        #   end;Fi[	@[i~I"Â        # on scopes. Assuming the following setup:
        #
        #   class Article < ActiveRecord::Base
        #     scope :published, -> { where(published: true) }
        #     scope :featured, -> { where(featured: true) };Fi[	I"Bif (var.is_a?(Relation) or var.respond_to?("LITERAL").!) then;F@=i[[	@Ti_I"Œ        def function(var)
          var = Proc.new if block_given?
          if (var.is_a?(Relation) or var.respond_to?("LITERAL").!) then
            ActiveSupport::Deprecation.warn("STRING")
          end;Fi[	@[iëI"◊        def function(var, var, var)
          var = Module.new(&var) if var
          if (var.is_a?(Relation) or var.respond_to?("LITERAL").!) then
            ActiveSupport::Deprecation.warn("STRING")
          end;Fi[	I"var = relation;FI"var.default_scoped = true;Fi[[	@[iI"            current_scope.clone
          else
            var = relation
            var.default_scoped = true
            var;Fi[	@[i+I"õ            current_scope.scope_for_create
          else
            var = relation
            var.default_scoped = true
            var.scope_for_create;Fi[	I"#   <topic>;FI")#     <title>The First Topic</title>;Fi[[	@hiI"ò    #
    #   <?xml version="1.0" encoding="UTF-8"?>
    #   <topic>
    #     <title>The First Topic</title>
    #     <author-name>David</author-name>;Fi[	@hi,I"Œ    #   topic.to_xml(skip_instruct: true, except: [ :id, :bonus_time, :written_on, :replies_count ])
    #
    #   <topic>
    #     <title>The First Topic</title>
    #     <author-name>David</author-name>;Fi[	@±[I"+#     <author-name>David</author-name>;Fi[[	@hiI"∂    #   <?xml version="1.0" encoding="UTF-8"?>
    #   <topic>
    #     <title>The First Topic</title>
    #     <author-name>David</author-name>
    #     <id type="integer">1</id>;Fi[	@hi-I"ù    #
    #   <topic>
    #     <title>The First Topic</title>
    #     <author-name>David</author-name>
    #     <approved type="boolean">false</approved>;Fi[	I"-#     <content>Have a nice day</content>;FI"N#     <author-email-address>david@loudthinking.com</author-email-address>;Fi[[	@hiI"5    #     <bonus-time type="dateTime">2000-01-01T08:28:00+12:00</bonus-time>
    #     <written-on type="dateTime">2003-07-16T09:28:00+1200</written-on>
    #     <content>Have a nice day</content>
    #     <author-email-address>david@loudthinking.com</author-email-address>
    #     <parent-id></parent-id>;Fi[	@hi0I"˚    #     <author-name>David</author-name>
    #     <approved type="boolean">false</approved>
    #     <content>Have a nice day</content>
    #     <author-email-address>david@loudthinking.com</author-email-address>
    #     <parent-id></parent-id>;Fi[	@¿[I""#     <parent-id></parent-id>;Fi[[	@hiI"     #     <written-on type="dateTime">2003-07-16T09:28:00+1200</written-on>
    #     <content>Have a nice day</content>
    #     <author-email-address>david@loudthinking.com</author-email-address>
    #     <parent-id></parent-id>
    #     <last-read type="date">2004-04-15</last-read>;Fi[	@hi1I"    #     <approved type="boolean">false</approved>
    #     <content>Have a nice day</content>
    #     <author-email-address>david@loudthinking.com</author-email-address>
    #     <parent-id></parent-id>
    #     <last-read type="date">2004-04-15</last-read>;Fi[	@«[I"8#     <last-read type="date">2004-04-15</last-read>;Fi[[	@hiI"Â    #     <content>Have a nice day</content>
    #     <author-email-address>david@loudthinking.com</author-email-address>
    #     <parent-id></parent-id>
    #     <last-read type="date">2004-04-15</last-read>
    #   </topic>;Fi[	@hi2I"Â    #     <content>Have a nice day</content>
    #     <author-email-address>david@loudthinking.com</author-email-address>
    #     <parent-id></parent-id>
    #     <last-read type="date">2004-04-15</last-read>
    #   </topic>;Fi[	@Œ[I"#   </topic>;Fi[[	@hiI"æ    #     <author-email-address>david@loudthinking.com</author-email-address>
    #     <parent-id></parent-id>
    #     <last-read type="date">2004-04-15</last-read>
    #   </topic>
    #;Fi[	@hi3I"æ    #     <author-email-address>david@loudthinking.com</author-email-address>
    #     <parent-id></parent-id>
    #     <last-read type="date">2004-04-15</last-read>
    #   </topic>
    #;Fi[	@’[@i[[	@hiI"Ω    #     <parent-id></parent-id>
    #     <last-read type="date">2004-04-15</last-read>
    #   </topic>
    #
    # This behavior can be controlled with <tt>:only</tt>, <tt>:except</tt>,;Fi[	@hi4I"±    #     <parent-id></parent-id>
    #     <last-read type="date">2004-04-15</last-read>
    #   </topic>
    #
    # To include first level associations use <tt>:include</tt>:;Fi[	@=@PWi[[	@hi;I"ì    #
    #   <?xml version="1.0" encoding="UTF-8"?>
    #   <firm>
    #     <id type="integer">1</id>
    #     <rating type="integer">1</rating>;Fi[	@hibI"÷    #   firm.to_xml include: {account: {}, clients: {include: :address}}
    #   <?xml version="1.0" encoding="UTF-8"?>
    #   <firm>
    #     <id type="integer">1</id>
    #     <rating type="integer">1</rating>;Fi[	@π$I"## Campfire account's subdomain;Fi[[	@≤iI"n      ##
      # Campfire api authentication token
      ##
      # Campfire account's subdomain
      ##;Fi[	@≤iZI"|        ##
        # Campfire api authentication api_token
        ##
        # Campfire account's subdomain
        ##;Fi[	@QWI"!#     <name>37signals</name>;Fi[[	@hi=I"†    #   <firm>
    #     <id type="integer">1</id>
    #     <rating type="integer">1</rating>
    #     <name>37signals</name>
    #     <clients type="array">;Fi[	@hidI"†    #   <firm>
    #     <id type="integer">1</id>
    #     <rating type="integer">1</rating>
    #     <name>37signals</name>
    #     <clients type="array">;Fi[	@Ô[I"!#     <clients type="array">;Fi[[	@hi>I"¶    #     <id type="integer">1</id>
    #     <rating type="integer">1</rating>
    #     <name>37signals</name>
    #     <clients type="array">
    #       <client>;Fi[	@hieI"¶    #     <id type="integer">1</id>
    #     <rating type="integer">1</rating>
    #     <name>37signals</name>
    #     <clients type="array">
    #       <client>;Fi[	@ˆ[@.=i[[	@hi?I"≤    #     <rating type="integer">1</rating>
    #     <name>37signals</name>
    #     <clients type="array">
    #       <client>
    #         <rating type="integer">1</rating>;Fi[	@hifI"≤    #     <rating type="integer">1</rating>
    #     <name>37signals</name>
    #     <clients type="array">
    #       <client>
    #         <rating type="integer">1</rating>;Fi[	@π$I"C# This is called as part of the procedure run by the Packager.;Fi[[	@ziPI"†      end
      
      ##
      # This is called as part of the procedure run by the Packager.
      # It sets up the needed options to pass to the gpg command,;Fi[	@1i$I"§      end
      
      ##
      # This is called as part of the procedure run by the Packager.
      # It sets up the needed options to pass to the openssl command,;Fi[	@/=I""#         <name>Summit</name>;Fi[[	@hiAI"ù    #     <clients type="array">
    #       <client>
    #         <rating type="integer">1</rating>
    #         <name>Summit</name>
    #       </client>;Fi[	@hihI"ü    #     <clients type="array">
    #       <client>
    #         <rating type="integer">1</rating>
    #         <name>Summit</name>
    #         <address>;Fi[	@/=I"%#         <name>Microsoft</name>;Fi[[	@hiEI"ï    #       </client>
    #       <client>
    #         <rating type="integer">1</rating>
    #         <name>Microsoft</name>
    #       </client>;Fi[	@hioI"ó    #       </client>
    #       <client>
    #         <rating type="integer">1</rating>
    #         <name>Microsoft</name>
    #         <address>;Fi[	I"#       </client>;F@.=i[[	@hiCI"¨    #         <rating type="integer">1</rating>
    #         <name>Summit</name>
    #       </client>
    #       <client>
    #         <rating type="integer">1</rating>;Fi[	@himI"á    #           ...
    #         </address>
    #       </client>
    #       <client>
    #         <rating type="integer">1</rating>;Fi[	@\I"#     </clients>;Fi[[	@hiGI"ì    #         <rating type="integer">1</rating>
    #         <name>Microsoft</name>
    #       </client>
    #     </clients>
    #     <account>;Fi[	@hitI"p    #           ...
    #         </address>
    #       </client>
    #     </clients>
    #     <account>;Fi[	@\I"#     <account>;Fi[[	@hiHI"â    #         <name>Microsoft</name>
    #       </client>
    #     </clients>
    #     <account>
    #       <id type="integer">1</id>;Fi[	@hiuI"}    #         </address>
    #       </client>
    #     </clients>
    #     <account>
    #       <id type="integer">1</id>;Fi[	@&\I"&#       <id type="integer">1</id>;Fi[[	@hiII"ü    #       </client>
    #     </clients>
    #     <account>
    #       <id type="integer">1</id>
    #       <credit-limit type="integer">50</credit-limit>;Fi[	@hivI"ü    #       </client>
    #     </clients>
    #     <account>
    #       <id type="integer">1</id>
    #       <credit-limit type="integer">50</credit-limit>;Fi[	@-\I";#       <credit-limit type="integer">50</credit-limit>;Fi[[	@hiJI"û    #     </clients>
    #     <account>
    #       <id type="integer">1</id>
    #       <credit-limit type="integer">50</credit-limit>
    #     </account>;Fi[	@hiwI"û    #     </clients>
    #     <account>
    #       <id type="integer">1</id>
    #       <credit-limit type="integer">50</credit-limit>
    #     </account>;Fi[	@4\I"#     </account>;Fi[[	@hiKI"ô    #     <account>
    #       <id type="integer">1</id>
    #       <credit-limit type="integer">50</credit-limit>
    #     </account>
    #   </firm>;Fi[	@hixI"ô    #     <account>
    #       <id type="integer">1</id>
    #       <credit-limit type="integer">50</credit-limit>
    #     </account>
    #   </firm>;Fi[	@;\@ì1i[[	@hiLI"ã    #       <id type="integer">1</id>
    #       <credit-limit type="integer">50</credit-limit>
    #     </account>
    #   </firm>
    #;Fi[	@hiyI"ã    #       <id type="integer">1</id>
    #       <credit-limit type="integer">50</credit-limit>
    #     </account>
    #   </firm>
    #;Fi[	@π$I"D# Tables to dump, tables that aren't specified won't get dumped;Fi[[	@i!I"í      ##
      # Tables to skip while dumping the database
      ##
      # Tables to dump, tables that aren't specified won't get dumped
      ##;Fi[	@i I"í      ##
      # Tables to skip while dumping the database
      ##
      # Tables to dump, tables that aren't specified won't get dumped
      ##;Fi[	I"$#   firm.to_xml procs: [ proc ];F@i[[	@hiWI"®    #
    #   proc = Proc.new { |options, record| options[:builder].tag!('name-reverse', record.name.reverse) }
    #   firm.to_xml procs: [ proc ]
    #
    #   <firm>;Fi[	@hiÖI"â    #
    #   proc = Proc.new { |options| options[:builder].tag!('abc', 'def') }
    #   firm.to_xml procs: [ proc ]
    #
    #   <firm>;Fi[	I"#         <address>;FI"#           ...;Fi[[	@hijI"ñ    #         <rating type="integer">1</rating>
    #         <name>Summit</name>
    #         <address>
    #           ...
    #         </address>;Fi[	@hiqI"ô    #         <rating type="integer">1</rating>
    #         <name>Microsoft</name>
    #         <address>
    #           ...
    #         </address>;Fi[	@W\I"#         </address>;Fi[[	@hikI"|    #         <name>Summit</name>
    #         <address>
    #           ...
    #         </address>
    #       </client>;Fi[	@hirI"    #         <name>Microsoft</name>
    #         <address>
    #           ...
    #         </address>
    #       </client>;Fi[	@^\@\i[[	@hilI"t    #         <address>
    #           ...
    #         </address>
    #       </client>
    #       <client>;Fi[	@hisI"t    #         <address>
    #           ...
    #         </address>
    #       </client>
    #     </clients>;Fi[	@5@S.i[[	@a"iYI"ƒ      # When called without a block, returns the block that was previously set.
      def function(var)
        @var ||= {}
        if block_given? then
          @set_attributes["LITERAL"] = true;Fi[	@a"itI"û      #     asset_cache_buster :none
      def function(var, var)
        @var ||= {}
        if block_given? then
          @set_attributes["LITERAL"] = true;Fi[	@π$I"0# Tables to skip while dumping the database;Fi[[	@iI"n      ##
      # Connectivity options
      ##
      # Tables to skip while dumping the database
      ##;Fi[	@iI"n      ##
      # Connectivity options
      ##
      # Tables to skip while dumping the database
      ##;Fi[	@¡&I"-@var ||= File.join(var, "STRING") if var;Fi[[	@
iI"∑        self.path = var = (var["LITERAL"] or var.shift)
        @var = var
        @var = var["LITERAL"]
        @var ||= File.join(var, "STRING") if var
        @var = var["LITERAL"];Fi[	@
iI"ß        @var = var["LITERAL"]
        @var ||= File.join(var, "STRING") if var
        @var = var["LITERAL"]
        @var ||= File.join(var, "STRING") if var
      end;Fi[	@¡&I";@var = var["LITERAL"].nil? ? (true) : (var["LITERAL"]);Fi[[	@b
i%I"À      @var = (var["LITERAL"] or Geometry).from_file(@file)
      @var = var["LITERAL"]
      @var = var["LITERAL"]
      @var = var["LITERAL"].nil? ? (true) : (var["LITERAL"])
      @var = var["LITERAL"];Fi[	@b
i'I"Ó      @var = var["LITERAL"]
      @var = var["LITERAL"].nil? ? (true) : (var["LITERAL"])
      @var = var["LITERAL"]
      @var = var["LITERAL"].nil? ? (true) : (var["LITERAL"])
      @var = var["LITERAL"].nil? ? (true) : (var["LITERAL"]);Fi[	@yD@q6i[[	@ˇiI"¨          $stderr.print("STRING") unless (var.class == RuntimeError)
          $stderr.puts("STRING")
          $stderr.puts("STRING")
          exit("LITERAL")
        end;Fi[	@ˇióI"∏        var = var.message["LITERAL", "LITERAL"]
        raise(var) if (@options["LITERAL"] or (var.nil? or var.empty?))
        $stderr.puts("STRING")
        exit("LITERAL")
      end;Fi[	@U@yDi[[	@mi0I"ô          $stderr.puts("STRING")
        rescue Exception => var
          $stderr.puts(var, *var.backtrace)
          $stderr.puts("STRING")
        end;Fi[	@miGI"≥          class_for_adapter(var["STRING"]).new(*var).drop)
        rescue Exception => var
          $stderr.puts(var, *var.backtrace)
          $stderr.puts("STRING")
        end;Fi[	I")establish_connection(configuration));F@HWi[[	@`iI"C          (establish_connection(configuration_without_database)
          connection.create_database(configuration["STRING"], creation_options)
          establish_connection(configuration))
        rescue ActiveRecord::StatementInvalid => var
          "LITERAL".===(var.message) ? (raise(DatabaseAlreadyExists)) : (raise);Fi[	@ŒiI"P          (establish_master_connection unless var
          connection.create_database(configuration["STRING"], configuration.merge("STRING" => (encoding)))
          establish_connection(configuration))
        rescue ActiveRecord::StatementInvalid => var
          "LITERAL".===(var.message) ? (raise(DatabaseAlreadyExists)) : (raise);Fi[	I",var = prepare_command_options("STRING");FI"%var.concat(["STRING", "STRING"]);Fi[[	@`i<I"ñ      
      def function(var)
        var = prepare_command_options("STRING")
        var.concat(["STRING", "STRING"])
        var.concat(["STRING"]);Fi[	@`iDI"†      
      def function(var)
        var = prepare_command_options("STRING")
        var.concat(["STRING", "STRING"])
        var.concat(["STRING", "STRING"]);Fi[	I"$stdout.print("STRING");FI"$stdout.flush;Fi[[	@
i£I"©          (puts("STRING")
          var = Classifier::LSI.new("LITERAL" => (false))
          $stdout.print("STRING")
          $stdout.flush
          var.each do |var|;Fi[	@
i¶I"è          $stdout.flush
          var.each do |var|
            $stdout.print("STRING")
            $stdout.flush
            var.add_item(var);Fi[	I"LENV["STRING"] = configuration["STRING"].to_s if configuration["STRING"];F@©\i[[	@ŒiLI"M      def function
        ENV["STRING"] = configuration["STRING"] if configuration["STRING"]
        ENV["STRING"] = configuration["STRING"].to_s if configuration["STRING"]
        ENV["STRING"] = configuration["STRING"].to_s if configuration["STRING"]
        ENV["STRING"] = configuration["STRING"].to_s if configuration["STRING"];Fi[	@ŒiMI"D        ENV["STRING"] = configuration["STRING"] if configuration["STRING"]
        ENV["STRING"] = configuration["STRING"].to_s if configuration["STRING"]
        ENV["STRING"] = configuration["STRING"].to_s if configuration["STRING"]
        ENV["STRING"] = configuration["STRING"].to_s if configuration["STRING"]
      end;Fi[	I"O# See ActiveRecord::Transactions::ClassMethods for detailed documentation.;F@Hi[[	@„	iI"¥    
    module ClassMethods
      # See ActiveRecord::Transactions::ClassMethods for detailed documentation.
      def function(var, var)
        connection.transaction(var, &var);Fi[	@„	iEI"û    end
    
    # See ActiveRecord::Transactions::ClassMethods for detailed documentation.
    def function(var, var)
      self.class.transaction(var, &var);Fi[	I"# state.;F@i[[	@ni-I"‚      # prevents the parent object from validating successfully and saving, which then
      # deletes the associated object, thus putting the parent object into an invalid
      # state.
      #
      # Configuration options:;Fi[	@isI"Î    # an edge between every state this branch matches *from* to either the
    # configured to state or, if none specified, then a loopback to the from
    # state.
    # 
    # For example, if the following from states are configured:;Fi[	I"var.save!;F@öi[[	@”iI"p          var = new(var)
          yield(var) if block_given?
          var.save!
          var
        end;Fi[	@”iYI"r    var.actors = var.actors.|([var])
    var.unread = false if var.is_a?(Request)
    var.save!
    var
  end;Fi[	I".require("rails/generators/active_record");F@Æi[[	@ö
i I"Vrequire("rails/generators/active_record")
module ActiveRecord
  module Generators;Fi [	@?i I"Vrequire("rails/generators/active_record")
module ActiveRecord
  module Generators;Fi [	@?I"9class DeviseGenerator < Rails::Generators::NamedBase;Fi[[	@MiI"åmodule Devise
  module Generators
    class DeviseGenerator < Rails::Generators::NamedBase
      include(Rails::Generators::ResourceHelpers);Fi[	@≠iI"≤require("generators/devise/orm_helpers")
module Mongoid
  module Generators
    class DeviseGenerator < Rails::Generators::NamedBase
      include(Devise::Generators::OrmHelpers);Fi[	@ÎI"module CLI;Fi[[	@î8i I"2module Backup
  module CLI
    module Helpers;Fi [	@Ë	i I"8module Backup
  module CLI
    class Utility < Thor;Fi [	@π$I"<# Creates a new instance of the MongoDB database object;Fi[[	@ŸiI"±      include(Backup::Configuration::Helpers)
      
      ##
      # Creates a new instance of the MongoDB database object
      # * Called using super(model) from subclasses *;Fi[	@ci.I"≠      ##
      # 'lock' dump meaning wrapping mongodump with fsync & lock
      ##
      # Creates a new instance of the MongoDB database object
      def function(var, var);Fi[	@π$I"!# Used only within the specs;Fi[[	@iI"^        end
        
        ##
        # Used only within the specs
        def function;Fi[	@ŸGiI"T      end
      
      ##
      # Used only within the specs
      def function;Fi[	@π$I"/# Specify the level of compression to use.;Fi[[	@-*iI"Ÿ      attr_deprecate("LITERAL", "LITERAL" => "STRING", "LITERAL" => "STRING", "LITERAL" => (lambda { |var, var| var.level = "LITERAL" if var }))
      
      ##
      # Specify the level of compression to use.
      #;Fi[	@0*iI"Ÿ      attr_deprecate("LITERAL", "LITERAL" => "STRING", "LITERAL" => "STRING", "LITERAL" => (lambda { |var, var| var.level = "LITERAL" if var }))
      
      ##
      # Specify the level of compression to use.
      #;Fi[	I"3require("active_support/core_ext/hash/except");F@∂Yi[[	@]i I"trequire("active_support/core_ext/hash/except")
require("active_support/core_ext/hash/slice")
module ActiveModel;Fi [	@9i I"Örequire("active_support/core_ext/hash/except")
require("active_support/core_ext/hash/slice")
require("active_record/relation/merger");Fi [	@3I"# generates:;Fi[[	@ÜiäI"©      #  create_table(:objects, primary_key: 'guid') do |t|
      #    t.column :name, :string, limit: 80
      #  end
      # generates:
      #  CREATE TABLE objects (;Fi[	@ÜiïI"¢      #    t.column :category_id, :integer
      #    t.column :supplier_id, :integer
      #  end
      # generates:
      #  CREATE TABLE categories_suppliers (;Fi[	I"def (model).persisted?;F@ni[[	@44iI"Ñ      def function
        assert(model.respond_to?("LITERAL"), "STRING")
        def (model).persisted?
          false
        end;Fi[	@44i%I"a          ["LITERAL"]
        end
        def (model).persisted?
          false
        end;Fi[	I"var.call;F@|i[[	@9ikI"        generate_message(var, var, var.except(*CALLBACKS_OPTIONS))
      when Proc then
        var.call
      else
        var;Fi[	@ç
i™I"]          send(var)
        when Proc then
          var.call
        else
          var;Fi[	I"FileUtils.mkdir_p(var);FI"if overwrite?(var) then;Fi[[	@Ë	iSI"∏        var = File.join(var, "STRING")
        var = File.join(var, "STRING")
        FileUtils.mkdir_p(var)
        if overwrite?(var) then
          File.open(var, "STRING") do |var|;Fi[	@Ë	imI"ù        end
        var = File.join(var, "STRING")
        FileUtils.mkdir_p(var)
        if overwrite?(var) then
          File.open(var, "STRING") do |var|;Fi[	I"var = Pipeline.new;F@<i[[	@i8I"r      def function
        super
        var = Pipeline.new
        var = "STRING"
        (var << mysqldump);Fi[	@i8I"o      def function
        super
        var = Pipeline.new
        var = "STRING"
        (var << pgdump);Fi[	I"when Proc then;F@]i[[	@9ijI"ä      when Symbol then
        generate_message(var, var, var.except(*CALLBACKS_OPTIONS))
      when Proc then
        var.call
      else;Fi[	@ç
i©I"h        when Symbol then
          send(var)
        when Proc then
          var.call
        else;Fi[	@4I"when File then;Fi[[	@	iëI"      
      def function(var)
        case var
        when File then
          YAML.load(ERB.new(File.read(var.path)).result);Fi[	@ci˜I"      
      def function(var)
        case var
        when File then
          YAML.load(ERB.new(File.read(var.path)).result);Fi[	@4I""when Sass::Script::Color then;Fi[[	@¶i¶I"¢      var = var = nil
      var = Sass::Script::Parser.parse(var.value, "LITERAL", "LITERAL")
      case var
      when Sass::Script::Color then
        var = var;Fi[	@4i√I"É  
  def function(var)
    case var
    when Sass::Script::Color then
      Sass::Script::String.new(reversed_color_names[var.rgb]);Fi[	@4I"when Relation then;Fi[[	@JiŸI"r    def function
      var, var = from_value
      case var
      when Relation then
        var ||= "STRING";Fi[	@Qi‘I"á    # Compares two relations for equality.
    def function(var)
      case var
      when Relation then
        (var.to_sql == to_sql);Ti[	@4I"9when "LITERAL", "LITERAL", "LITERAL", "LITERAL" then;Fi[[	@8iI"‡    module ClassMethods
      def function(var, var, var, var, var)
        case var
        when "LITERAL", "LITERAL", "LITERAL", "LITERAL" then
          var = var["LITERAL"] ? (ThroughReflection) : (AssociationReflection);Fi[	@ i{I"ó  satisfy do
    @lang_list.each do |var|
      case var
      when "LITERAL", "LITERAL", "LITERAL", "LITERAL" then
        var = ("STRING" + var.to_s);Fi[	@4@Xi[[	@õiI"á          case var.to_s
          when "STRING" then
            case var
            when nil, "LITERAL" then
              super(var);Fi[	@õi$I"            end
          when "STRING" then
            case var
            when nil, "LITERAL" then
              super(var);Fi[	@†B@:i[[	@ƒi	I"g    @var = false
    
    module Helpers
      def function
        @var ||= default_configuration;Fi[	@Õ*iI"Ymodule Paperclip
  module Helpers
    def function
      yield(self) if block_given?;Fi[	@†BI"module CaptureHelper;Fi[[	@⁄i,I"T  end
  
  module Helpers
    module CaptureHelper
      def function(var, var);Fi[	@;iiI"aend
module ActionView
  module Helpers
    module CaptureHelper
      def function(var, var);Fi[	I"#var = File.join(var, "STRING");F@]i[[	@Ë	iRI"≥        var = File.join(var, "STRING")
        var = File.join(var, "STRING")
        var = File.join(var, "STRING")
        FileUtils.mkdir_p(var)
        if overwrite?(var) then;Fi[	@Ë	ilI"å          Config.root_path
        end
        var = File.join(var, "STRING")
        FileUtils.mkdir_p(var)
        if overwrite?(var) then;Fi[	@P]@P]i[[	@Ë	iPI"T        var = options.merge("LITERAL" => (options["LITERAL"].gsub("LITERAL", "STRING")), "LITERAL" => (options["LITERAL"] ? (File.expand_path(options["LITERAL"])) : (nil)))
        var = (var["LITERAL"] or Config.root_path)
        var = File.join(var, "STRING")
        var = File.join(var, "STRING")
        var = File.join(var, "STRING");Fi[	@Ë	iQI"∆        var = (var["LITERAL"] or Config.root_path)
        var = File.join(var, "STRING")
        var = File.join(var, "STRING")
        var = File.join(var, "STRING")
        FileUtils.mkdir_p(var);Fi[	@]I"&File.open(var, "STRING") do |var|;Fi[[	@Ë	iTI"‚        var = File.join(var, "STRING")
        FileUtils.mkdir_p(var)
        if overwrite?(var) then
          File.open(var, "STRING") do |var|
            var.write(Backup::Template.new("LITERAL" => (var)).result("STRING"));Fi[	@Ë	inI"Œ        var = File.join(var, "STRING")
        FileUtils.mkdir_p(var)
        if overwrite?(var) then
          File.open(var, "STRING") do |var|
            var.write(Backup::Template.new.result("STRING"));Fi[	@4@1Ui[[	@KiI"ª      def function(var, var)
        return var.quoted_id if var.respond_to?("LITERAL")
        case var
        when String, ActiveSupport::Multibyte::Chars then
          var = var.to_s;Fi[	@Ki7I"¥      def function(var, var)
        return var.id if var.respond_to?("LITERAL")
        case var
        when String, ActiveSupport::Multibyte::Chars then
          var = var.to_s;Fi[	@4I"when TrueClass then;Fi[[	@ÇiñI"]      
      def function(var)
        case var
        when TrueClass then
          {};Fi[	@Îi7I"å    (NO_INPUT << var) if var["LITERAL"]
    if var = var["LITERAL"] then
      case var
      when TrueClass then
        var, var = var, [];Fi[	@/6I"validate_order_args(var);Fi[[	@JiÍI"Å    
    def function(var)
      var.flatten!
      validate_order_args(var)
      var = var.reject { |var| Arel::Node.===(var) };Fi[	@JiI"t    
    def function(var)
      var.flatten!
      validate_order_args(var)
      self.reordering_value = true;Fi[	I"Array(var).each do |var|;FI"%var = @base.send("LITERAL", var);Fi[[	@9i˛I"Õ    #   # => {:name=>["can't be empty"]}
    def function(var, var)
      Array(var).each do |var|
        var = @base.send("LITERAL", var)
        var = var.respond_to?("LITERAL") ? (var.empty?) : (false);Fi[	@9iI"∫    #   # => {:name=>["can't be blank"]}
    def function(var, var)
      Array(var).each do |var|
        var = @base.send("LITERAL", var)
        add(var, "LITERAL", var) if var.blank?;Fi[	I"!if var = var["LITERAL"] then;FI"(var = (var == true) ? (var) : (var);Fi[[	@Îi-I"»    (ALL << var)
    var.assert_valid_keys("LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL")
    if var = var["LITERAL"] then
      var = (var == true) ? (var) : (var)
      STRATEGIES[var] = var;Fi[	@Îi1I"ã      STRATEGIES[var] = var
    end
    if var = var["LITERAL"] then
      var = (var == true) ? (var) : (var)
      CONTROLLERS[var] = var;Fi[	@<"I"var = var.map do |var|;Fi[[	@Xi3I"å      def function(var)
        var = join_base.aliased_primary_key
        var = {}
        var = var.map do |var|
          var = var[var];Fi[	@[iXI"Ë      unless var.empty? then
        var.disable_referential_integrity do
          var = {}
          var = var.map do |var|
            var[var] = new(var, var, (var[var] or default_fixture_model_name(var)), ::File.join(var, var));Fi[	@M%I"7var = "STRING" unless (var["LITERAL"] == "STRING");Fi[[	@f6iaI"         File.join(Compass.configuration.project_path, Compass.configuration.images_dir, var)
      end
      if var then
        var = "STRING" unless (var["LITERAL"] == "STRING")
        var = "STRING";Fi[	@f6iéI"‘        File.join(Compass.configuration.project_path, Compass.configuration.generated_images_dir, var)
      end
      if var then
        var = "STRING" unless (var["LITERAL"] == "STRING")
        var = "STRING";Fi[	@	I"	next;Fi[[	@niI"c      if var.linked? then
        opoo("STRING")
        puts("STRING")
        next
      end;Fi[	@Äi-I"j          puts("STRING")
          puts("STRING")
          puts("STRING")
          next
        end;Fi[	@	@“2i[[	@ˇi›I"ü          (var = ::Haml::Engine.new(var, @options["LITERAL"])
          if @options["LITERAL"] then
            puts("STRING")
            return
          end;Fi[	@—iˆI"b        puts("STRING")
        puts("STRING")
        puts("STRING")
        return
      end;Fi[	@	I"puts("STRING") if xcode;Fi[[	@¯ilI"ì    puts("STRING") if HOMEBREW_CELLAR.to_s.!=("STRING")
    puts(hardware)
    puts("STRING")
    puts("STRING") if xcode
    puts("STRING") if clt;Fi[	@¯iÜI"s    puts("STRING")
    puts(hardware)
    puts("STRING")
    puts("STRING") if xcode
    puts("STRING") if clt;Fi[	@	I"Dir.chdir(@clone) do;Fi[[	@ÈiI"Ü    end
    if @clone.exist? then
      puts("STRING")
      Dir.chdir(@clone) do
        safe_system(@@git, "STRING", "STRING", @url);Fi[	@ÈiîI"Ç    ohai("STRING")
    if @clone.exist? then
      puts("STRING")
      Dir.chdir(@clone) do
        safe_system(hgpath, "STRING");Fi[	@M%I"0if order_values.empty? and primary_key then;Fi[[	@‹	iSI"˙    #   Person.first(3) # returns the first three objects fetched by SELECT * FROM people LIMIT 3
    def function(var)
      if var then
        if order_values.empty? and primary_key then
          order(arel_table[primary_key].asc).limit(var).to_a;Fi[	@‹	itI"’    #   [#<Person id:4>, #<Person id:3>, #<Person id:2>]
    def function(var)
      if var then
        if order_values.empty? and primary_key then
          order(arel_table[primary_key].desc).limit(var).reverse;Fi[	@	I"+var.backtrace.each { |var| puts(var) };Fi[[	@iFI"ø        self.content = Liquid::Template.parse(self.content).render!(var, var)
      rescue => var
        puts("STRING")
        var.backtrace.each { |var| puts(var) }
        abort("STRING");Fi[	@iSI"«          self.output = Liquid::Template.parse(var.content).render!(var, var)
        rescue => var
          puts("STRING")
          var.backtrace.each { |var| puts(var) }
          abort("STRING");Fi[	@	@q6i[[	@}i.I"}      unless var["STRING"] then
        trap("STRING") do
          puts("STRING")
          exit("LITERAL")
        end;Fi[	@ui*I"          puts(Whenever.cron(@options))
          puts("STRING")
          puts("STRING")
          exit("LITERAL")
        end;Fi[	@M%@w,i[[	@⁄inI"•        if is_haml? then
          var = (block_given? and block_is_haml?(var))
          if var then
            var = var
            var = haml_bind_proc do |var|;Fi[	@⁄iÄI"‘      def function(var, var, var)
        var = (block_given? and (is_haml? and block_is_haml?(var)))
        if var then
          var = var
          var = proc { |var| with_tabs("LITERAL") { var.call(*var) } };Fi[	@M%@1i[[	@^%i!I"{    # pop, a ThreadError is raised.
    def function(var)
      if var then
        synchronize do
          var = nil;Fi[	@iDI"ã    # pop, a ThreadError is raised.
    def function(var)
      if var then
        synchronize do
          var = @redis.lpop(@redis_name);Fi[	@Ë\@i[[	@-*iI"}      
      ##
      # Specify the level of compression to use.
      #
      # Values should be a single digit from 1 to 9.;Fi[	@0*iI"}      
      ##
      # Specify the level of compression to use.
      #
      # Values should be a single digit from 1 to 9.;Fi[	I"3# Values should be a single digit from 1 to 9.;FI"C# Note that setting the level to either extreme may or may not;Fi[[	@-*iI"ˆ      # Specify the level of compression to use.
      #
      # Values should be a single digit from 1 to 9.
      # Note that setting the level to either extreme may or may not
      # give the desired result. Be sure to check the documentation;Fi[	@0*iI"ˆ      # Specify the level of compression to use.
      #
      # Values should be a single digit from 1 to 9.
      # Note that setting the level to either extreme may or may not
      # give the desired result. Be sure to check the documentation;Fi[	@ÿ]I"B# give the desired result. Be sure to check the documentation;Fi[[	@-*iI"Ï      #
      # Values should be a single digit from 1 to 9.
      # Note that setting the level to either extreme may or may not
      # give the desired result. Be sure to check the documentation
      # for the compressor being used.;Fi[	@0*iI"Ï      #
      # Values should be a single digit from 1 to 9.
      # Note that setting the level to either extreme may or may not
      # give the desired result. Be sure to check the documentation
      # for the compressor being used.;Fi[	@ﬂ]I"%# for the compressor being used.;Fi[[	@-*iI"Ï      # Values should be a single digit from 1 to 9.
      # Note that setting the level to either extreme may or may not
      # give the desired result. Be sure to check the documentation
      # for the compressor being used.
      #;Fi[	@0*iI"Ï      # Values should be a single digit from 1 to 9.
      # Note that setting the level to either extreme may or may not
      # give the desired result. Be sure to check the documentation
      # for the compressor being used.
      #;Fi[	@Ê]@i[[	@-*iI"Ÿ      # Note that setting the level to either extreme may or may not
      # give the desired result. Be sure to check the documentation
      # for the compressor being used.
      #
      # The default `level` is 9.;Fi[	@0*iI"Ÿ      # Note that setting the level to either extreme may or may not
      # give the desired result. Be sure to check the documentation
      # for the compressor being used.
      #
      # The default `level` is 6.;Fi[	@M%@•Qi[[	@¡iI"ê      def function(var, var, var)
        if var.new_record? then
          if var then
            var.save!("LITERAL" => (var))
          else;Fi[	@Xi2I"à        ensure_not_nested
        if var.new_record? then
          if var then
            var.save!("LITERAL" => (var))
          else;Fi[	@M%@<"i[[	@9i«I"§    #   person.to_hash(true) # => {:name=>["name can not be nil"]}
    def function(var)
      if var then
        var = {}
        self.messages.each do |var, var|;Fi[	@Ã	ieI"¶          var = @connection.query(var)
          var = @connection.affected_rows
          if var then
            var = {}
            var.fetch_fields.each do |var|;Fi[	I",# Returns the number of error messages.;F@i[[	@9itI"v    end
    
    # Returns the number of error messages.
    #
    #   person.errors.add(:name, "can't be blank");Fi[	@9iíI"v    end
    
    # Returns the number of error messages.
    #
    #   person.errors.add(:name, "can't be blank");Fi[	I"1#   person.errors.each do |attribute, error|;FI"2#     # Will yield :name and "can't be blank";Fi[[	@9igI"ß    #
    #   person.errors.add(:name, "can't be blank")
    #   person.errors.each do |attribute, error|
    #     # Will yield :name and "can't be blank"
    #   end;Fi[	@9ilI"”    #
    #   person.errors.add(:name, "must be specified")
    #   person.errors.each do |attribute, error|
    #     # Will yield :name and "can't be blank"
    #     # then yield :name and "must be specified";Fi[	@**I" @var ||= utility("LITERAL");Fi[[	@ci6I"°        @var ||= false
        @var ||= false
        instance_eval(&var) if block_given?
        @var ||= utility("LITERAL")
        @var ||= utility("LITERAL");Fi[	@i/I"è        @var ||= Array.new
        @var ||= Array.new
        instance_eval(&var) if block_given?
        @var ||= utility("LITERAL")
      end;Fi[	@**@´7i[[	@i.I"†        @var ||= Array.new
        @var ||= Array.new
        instance_eval(&var) if block_given?
        @var ||= "LITERAL"
        @var ||= utility("LITERAL");Fi[	@ziLI"{      def function(var)
        super
        instance_eval(&var) if block_given?
        @var ||= "LITERAL"
      end;Fi[	@q>I"6# better (-9) rather than faster when set to true;Fi[[	@3*iI"É      
      ##
      # Tells Backup::Compressor::Lzma to compress
      # better (-9) rather than faster when set to true
      ##;Fi[	@6*iI"É      
      ##
      # Tells Backup::Compressor::Lzma to compress
      # better (-9) rather than faster when set to true
      ##;Fi[	@q>I"6# faster (-1) rather than better when set to true;Fi[[	@3*iI"¥      # better (-9) rather than faster when set to true
      ##
      # Tells Backup::Compressor::Lzma to compress
      # faster (-1) rather than better when set to true
      ##;Fi[	@6*iI"¥      # better (-9) rather than faster when set to true
      ##
      # Tells Backup::Compressor::Lzma to compress
      # faster (-1) rather than better when set to true
      ##;Fi[	@^@π$i[[	@3*iI"Ø      ##
      # Tells Backup::Compressor::Lzma to compress
      # better (-9) rather than faster when set to true
      ##
      # Tells Backup::Compressor::Lzma to compress;Fi[	@6*iI"Ø      ##
      # Tells Backup::Compressor::Lzma to compress
      # better (-9) rather than faster when set to true
      ##
      # Tells Backup::Compressor::Lzma to compress;Fi[	@"^@π$i[[	@3*iI"∑      ##
      # Tells Backup::Compressor::Lzma to compress
      # faster (-1) rather than better when set to true
      ##
      # Creates a new instance of Backup::Compressor::Lzma;Fi[	@6*iI"¡      ##
      # Tells Backup::Compressor::Lzma to compress
      # faster (-1) rather than better when set to true
      ##
      # Tells Backup::Compressor::Pbzip2 how many processors to use.;Fi[	I"IBackup::Logger.warn(((("STRING" + "STRING") + "STRING") + "STRING"));F@ˆi[[	@3*i I"¬      # Yields to the block the compressor command and filename extension.
      def function
        Backup::Logger.warn(((("STRING" + "STRING") + "STRING") + "STRING"))
        super
      end;Fi[	@6*i&I"¬      # Yields to the block the compressor command and filename extension.
      def function
        Backup::Logger.warn(((("STRING" + "STRING") + "STRING") + "STRING"))
        super
      end;Fi[	@·\@:i[[	@iI"l        
        ##
        # Used only within the specs
        def function
          defaults.reset!;Fi[	@ŸGiI"_      
      ##
      # Used only within the specs
      def function
        @table.clear;Fi[	@~3I"6#   person.errors.add(:name, "must be specified");Fi[[	@9iãI"    # Returns an array of error messages, with the attribute name included.
    #
    #   person.errors.add(:name, "can't be blank")
    #   person.errors.add(:name, "must be specified")
    #   person.errors.to_a # => ["name can't be blank", "name must be specified"];Fi[	@9i™I"Õ    # Returns an xml formatted representation of the Errors hash.
    #
    #   person.errors.add(:name, "can't be blank")
    #   person.errors.add(:name, "must be specified")
    #   person.errors.to_xml;Fi[	@ËG@π$i[[	@ciI"}      
      ##
      # Name of the database that needs to get dumped
      ##
      # Credentials for the specified database;Fi[	@iI"}      
      ##
      # Name of the database that needs to get dumped
      ##
      # Credentials for the specified database;Fi[	@HI"5@var = @subject.new if (@subject.class == Class);Fi[[	@Ji'I"€        
        def function(var)
          @var = var
          @var = @subject.new if (@subject.class == Class)
          @allowed_types and (@rejected_types and (allowed_types_allowed? and rejected_types_rejected?));Fi[	@Vi+I"–        
        def function(var)
          @var = var
          @var = @subject.new if (@subject.class == Class)
          lower_than_low? and (higher_than_low? and (lower_than_high? and higher_than_high?));Fi[	@H@£4i[[	@ŸiI"Å      # * Called using super(model) from subclasses *
      def function(var)
        @var = var
        load_defaults!
      end;Fi[	@‹i"I"ô      # Called with super(model) from subclasses
      def function(var)
        @var = var
        load_defaults!
        @var = true if on_success.nil?;Fi[	@H@¡&i[[	@
iI"œ        var = var.last.is_a?(Hash) ? (var.pop) : ({})
        self.path = var = (var["LITERAL"] or var.shift)
        @var = var
        @var = var["LITERAL"]
        @var ||= File.join(var, "STRING") if var;Fi[	@$iI"å      assert_valid_keys(var, "LITERAL", "LITERAL")
      @var = var
      @var = var
      @var = var["LITERAL"]
      @var = var["LITERAL"];Fi[	@H@ Hi[[	@÷iI"ù    # Takes the name of the archive and the configuration block
    def function(var, var, var)
      @var = var
      @var = var.to_s
      @var = Array.new;Fi[	@qiI"I  
  def function(var, var)
    @var = var
    @var = var.to_s
  end;Fi[	@H@g7i[[	@ViI"W        
        def function(var)
          @var = var
          self
        end;Fi[	@Vi!I"W        
        def function(var)
          @var = var
          self
        end;Fi[	@H@Æi[[	@äiI"f    # The object that failed
    def function(var, var)
      @var = var
      super(var)
    end;Fi[	@ìiI"X      
      def function(var, var)
        @var = var
        super(var)
      end;Fi[	@HI"if var.is_a?(Hash) then;Fi[[	@NiI"ì      raise(ArgumentError, "STRING") unless var.kind_of?(Symbol)
      @var = var
      @var = var
      if var.is_a?(Hash) then
        @var = nil;Fi[	@iI"Ñ    def function(var, var, var)
      @var = var
      @var = var
      if var.is_a?(Hash) then
        @var = var.delete("LITERAL");Fi[	@r7I"&"STRING".gsub("STRING", "STRING");Fi[[	@i]I"≥      def function
        ["STRING", "STRING"].map do |var|
          next if send(var).to_s.empty?
          "STRING".gsub("STRING", "STRING")
        end.compact.join("STRING");Fi[	@ieI"Ω      def function
        ["STRING", "STRING", "STRING"].map do |var|
          next if send(var).to_s.empty?
          "STRING".gsub("STRING", "STRING")
        end.compact.join("STRING");Fi[	I"/# additional options specified by the user;F@:i[[	@ci†I"™      ##
      # Builds a MongoDB compatible string for the
      # additional options specified by the user
      def function
        @additional_options.join("STRING");Fi[	@finI"®      ##
      # Builds a Redis compatible string for the
      # additional options specified by the user
      def function
        @additional_options.join("STRING");Fi[	@q\@π$i[[	@i I"¶      # Connectivity options
      ##
      # Tables to skip while dumping the database
      ##
      # Tables to dump, tables that aren't specified won't get dumped;Fi[	@iI"¶      # Connectivity options
      ##
      # Tables to skip while dumping the database
      ##
      # Tables to dump, tables that aren't specified won't get dumped;Fi[	@H\@π$i[[	@i"I"∞      # Tables to skip while dumping the database
      ##
      # Tables to dump, tables that aren't specified won't get dumped
      ##
      # Additional "mysqldump" options;Fi[	@i!I"Æ      # Tables to skip while dumping the database
      ##
      # Tables to dump, tables that aren't specified won't get dumped
      ##
      # Additional "pg_dump" options;Fi[	@H@˜%i[[	@®iI"n      def function(var, var)
        @var = []
        @var = var
        @var = true
        @var = true;Fi[	@i/I"z      @var = var
      var = self.class.default_options.merge(var)
      @var = var
      @var = true
      @var = [];Fi[	@ø	I"#post_retweet(var, var.options);Fi[[	@iëI"≈        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |var|
          begin
            post_retweet(var, var.options)
          rescue Twitter::Error::Forbidden => var;Fi[	@i¨I"≈        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |var|
          begin
            post_retweet(var, var.options)
          rescue Twitter::Error::Forbidden => var;Fi[	@{^@“=i[[	@i^I"™        ["STRING", "STRING"].map do |var|
          next if send(var).to_s.empty?
          "STRING".gsub("STRING", "STRING")
        end.compact.join("STRING")
      end;Fi[	@ifI"¥        ["STRING", "STRING", "STRING"].map do |var|
          next if send(var).to_s.empty?
          "STRING".gsub("STRING", "STRING")
        end.compact.join("STRING")
      end;Fi[	@ø	I"eobject_from_response(Twitter::Tweet, "LITERAL", "STRING", var.options.merge("LITERAL" => (var)));Fi[[	@~iYI"        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |var|
          begin
            object_from_response(Twitter::Tweet, "LITERAL", "STRING", var.options.merge("LITERAL" => (var)))
          rescue Twitter::Error::Forbidden => var;Fi[	@~i{I"        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |var|
          begin
            object_from_response(Twitter::Tweet, "LITERAL", "STRING", var.options.merge("LITERAL" => (var)))
          rescue Twitter::Error::Forbidden => var;Fi[	I"# specified by the user;F@:i[[	@inI"ß      ##
      # Builds a MySQL compatible string for the additional options
      # specified by the user
      def function
        additional_options.join("STRING");Fi[	@ilI"¨      ##
      # Builds a PostgreSQL compatible string for the additional options
      # specified by the user
      def function
        additional_options.join("STRING");Fi[	@ø	I"(var = nil;Fi[[	@B
iI"F  
  def function
    begin
      (var = nil
      require("keg");Fi[	@J
iI"R  
  def function
    begin
      (var = nil
      unless writable_real? then;Fi[	@ø	I"(@var = true;Fi[[	@,
i0I"Å      # @see Haml::Util#rails_xss_safe?
      def function
        begin
          (@var = true
          var = @_haml_concat_raw;Fi[	@ˆ
igI"ó      attr_reader :function
      def function(var, var)
        begin
          (@var = true
          erb(var.to_sym, { "LITERAL" => (false) }, var));Fi[	@ø	@ÕPi[[	@
i I"w    
    def function
      begin
        ($stderr.write(color("LITERAL"))
        $stdout.write(color("LITERAL"));Fi[	@
i+I"w    
    def function
      begin
        ($stderr.write(color("LITERAL"))
        $stdout.write(color("LITERAL"));Fi[	@Ÿ-@Ÿ-i[[	@ü
i,I"}        @var ||= false
        @var ||= []
        @var ||= "STRING"
        @var ||= "STRING"
        @var ||= "STRING";Fi[	@ü
i-I"ç        @var ||= []
        @var ||= "STRING"
        @var ||= "STRING"
        @var ||= "STRING"
        instance_eval(&var) if block_given?;Fi[	@Ÿ-I"$@var = @original_filename.strip;Fi[[	@DiI"€    def function
      @var = @target.original_filename if @target.respond_to?("LITERAL")
      @var ||= "STRING"
      @var = @original_filename.strip
      @var = @target.content_type if @target.respond_to?("LITERAL");Fi[	@JiI"√    def function
      @var = @target.path.split("STRING").last
      @var ||= "STRING"
      @var = @original_filename.strip
      @var = @content.content_type if @content.respond_to?("LITERAL");Fi[	@ø	I"require("sass");Fi[[	@i I"-begin
  require("sass")
rescue LoadError;Fi [	@i	I"Zrescue LoadError
  require("rubygems")
  begin
    require("sass")
  rescue LoadError;Fi[	@ø	I"W(var, Compass.configuration.project_path = Compass.configuration.project_path, nil;Fi[[	@
i I"π        
        def function
          begin
            (var, Compass.configuration.project_path = Compass.configuration.project_path, nil
            Compass.configuration.serialize);Fi[	@
iI"Ø      
      def function
        begin
          (var, Compass.configuration.project_path = Compass.configuration.project_path, nil
          Compass.configuration.serialize);Fi[	@ø	I"(write_password_file!;Fi[[	@ˇ	iI"ã        # debug options: -vhP
        def function
          begin
            (write_password_file!
            @directories.each do |var|;Fi[	@Üi/I"©        # debug options: -vhP
        def function
          begin
            (write_password_file!
            Logger.message(("STRING" + @directories.join("STRING")));Fi[	@ø	I"(var = var.first;Fi[[	@mi*I"Ñ      
      def function(var)
        begin
          (var = var.first
          class_for_adapter(var["STRING"]).new(*var).create);Fi[	@miCI"Ç      
      def function(var)
        begin
          (var = var.first
          class_for_adapter(var["STRING"]).new(*var).drop);Fi[	@ø	I"(var = Thread.current;Fi[[	@‘	i.I"~    # :nodoc:
    def function
      begin
        (var = Thread.current
        var, var["LITERAL"] = var["LITERAL"], [];Fi[	@‘	iRI"ª    # EXPLAINs, manual calls to <tt>ActiveRecord::Relation#explain</tt> run.
    def function
      begin
        (var = Thread.current
        var, var["LITERAL"] = var["LITERAL"], false;Fi[	I"#       =8gNa;FI"/#       -----END PGP PUBLIC KEY BLOCK-----;Fi[[	@ziÇI"´      #       [...]
      #       SkQEHOxhMiFjAN9q4LuirSOu65uR1bnTmF+Z92++qMIuEkH4/LnN
      #       =8gNa
      #       -----END PGP PUBLIC KEY BLOCK-----
      #     EOS;Fi[	@ziéI"£      #       [...]
      #       AN9q4LSkQEHOxhMiFjuirSOu65u++qMIuEkH4/LnNR1bnTmF+Z92
      #       =8gNa
      #       -----END PGP PUBLIC KEY BLOCK-----
      #;Fi[	@˚^I"#     EOS;Fi[[	@ziÉI"ü      #       SkQEHOxhMiFjAN9q4LuirSOu65uR1bnTmF+Z92++qMIuEkH4/LnN
      #       =8gNa
      #       -----END PGP PUBLIC KEY BLOCK-----
      #     EOS
      #;Fi[	@zi!I"£      #       mLekS3xntUhhgHKc4lhf4IVBqG4cFmwSZ0tZEJJUSESb3TqkkdnNLjE=
      #       =KEW+
      #       -----END PGP PUBLIC KEY BLOCK-----
      #     EOS
      #;Fi[	@_@i[[	@ziÑI"é      #       =8gNa
      #       -----END PGP PUBLIC KEY BLOCK-----
      #     EOS
      #
      #     enc.keys['mary@example.com'] = <<-EOS;Fi[	@zi"I"ë      #       =KEW+
      #       -----END PGP PUBLIC KEY BLOCK-----
      #     EOS
      #
      #     encryptor.recipients = 'joe@example.com';Fi[	@ø	@ûIi[[	@ï#iBI"r          fast_fit
          var = []
          begin
            var = false
            catch("LITERAL") do;Fi[	@Xi_I"R  puts("STRING")
  puts("STRING")
  begin
    var = false
    choose do |var|;Fi[	@E-@:i[[	@j,i1I"ø    private
    
    # @return [Hash]
    def function
      { "LITERAL" => (@consumer_key), "LITERAL" => (@consumer_secret), "LITERAL" => (@oauth_token), "LITERAL" => (@oauth_token_secret) };Fi[	@j,i6I"j    end
    
    # @return [Hash]
    def function
      Hash[Twitter::Configurable.keys.map do |var|;Fi[	@E-@Ÿi[[	@iI"⁄      # @param hash [Hash]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen_name, or object.
      # @return [Hash]
      def function(var, var, var)
        merge_user!(var.dup, var, var);Fi[	@iàI"ƒ      # @param hash [Hash]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen_name, or object.
      # @return [Hash]
      def function(var, var, var)
        case var;Fi[	I"C#     uid                  John Smith <john.smith@example.com>;FI"*#     sub   1024R/92C8DFD8 2012-07-20;Fi[[	@ziΩI"ı      #     pub   1024R/4E5E8D8A 2012-07-20
      #     Key fingerprint = FFEA D1DB 201F B214 873E  7399 4A83 569F 4E5E 8D8A
      #     uid                  John Smith <john.smith@example.com>
      #     sub   1024R/92C8DFD8 2012-07-20
      #;Fi[	@zi“I"–      #     $ gpg -k john.smith@example.com
      #     pub   1024R/4E5E8D8A 2012-07-20
      #     uid                  John Smith <john.smith@example.com>
      #     sub   1024R/92C8DFD8 2012-07-20
      #;Fi[	@"_@i[[	@ziæI"ﬂ      #     Key fingerprint = FFEA D1DB 201F B214 873E  7399 4A83 569F 4E5E 8D8A
      #     uid                  John Smith <john.smith@example.com>
      #     sub   1024R/92C8DFD8 2012-07-20
      #
      # [Long Key ID];Fi[	@zi”I"º      #     pub   1024R/4E5E8D8A 2012-07-20
      #     uid                  John Smith <john.smith@example.com>
      #     sub   1024R/92C8DFD8 2012-07-20
      #
      # [Email Address];Fi[	I"I# then yields the command to use as part of the packaging procedure.;FI"?# Once the packaging procedure is complete, it will return;Fi[[	@ziSI"Q      # This is called as part of the procedure run by the Packager.
      # It sets up the needed options to pass to the gpg command,
      # then yields the command to use as part of the packaging procedure.
      # Once the packaging procedure is complete, it will return
      # so that any clean-up may be performed after the yield.;Fi[	@1i'I"U      # This is called as part of the procedure run by the Packager.
      # It sets up the needed options to pass to the openssl command,
      # then yields the command to use as part of the packaging procedure.
      # Once the packaging procedure is complete, it will return
      # so that any clean-up may be performed after the yield.;Fi[	@0_I"=# so that any clean-up may be performed after the yield.;Fi[[	@ziTI"Y      # It sets up the needed options to pass to the gpg command,
      # then yields the command to use as part of the packaging procedure.
      # Once the packaging procedure is complete, it will return
      # so that any clean-up may be performed after the yield.
      # Cleanup is also ensured, as temporary files may hold sensitive data.;Fi[	@1i(I"#      # It sets up the needed options to pass to the openssl command,
      # then yields the command to use as part of the packaging procedure.
      # Once the packaging procedure is complete, it will return
      # so that any clean-up may be performed after the yield.
      def function;Fi[	I"2var = Dir.mktmpdir("STRING", Config.tmp_path);FI"(@tempdirs << var);Fi[[	@ziµI"π        begin
          (return false unless gpg_config
          var = Dir.mktmpdir("STRING", Config.tmp_path)
          (@tempdirs << var)
          var = Tempfile.open("STRING", var);Fi[	@ziÛI"¡        begin
          (return false if passphrase.to_s.empty?
          var = Dir.mktmpdir("STRING", Config.tmp_path)
          (@tempdirs << var)
          var = Tempfile.open("STRING", var);Fi[	@?_I"'var = Tempfile.open("STRING", var);Fi[[	@zi∂I"Â          (return false unless gpg_config
          var = Dir.mktmpdir("STRING", Config.tmp_path)
          (@tempdirs << var)
          var = Tempfile.open("STRING", var)
          var.write(gpg_config.gsub("LITERAL", "STRING"));Fi[	@ziÙI"ÿ          (return false if passphrase.to_s.empty?
          var = Dir.mktmpdir("STRING", Config.tmp_path)
          (@tempdirs << var)
          var = Tempfile.open("STRING", var)
          var.write(passphrase.to_s);Fi[	I"var.path);F@ë9i[[	@ziªI"y          var.close
          check_gpg_config(var.path)
          var.path)
        rescue => var
          cleanup;Fi[	@zi¯I"µ          var.write(passphrase.to_s)
          var.close
          var.path)
        rescue => var
          Logger.warn(Errors::Encryptor::GPG::PassphraseError.wrap(var, "STRING"));Fi[	@ø	@±Pi[[	@„	ifI"u    # Call the after_commit callbacks
    def function
      begin
        run_callbacks("LITERAL")
      ensure;Fi[	@„	ipI"°    # state should be rolled back to the beginning or just to the last savepoint.
    def function(var)
      begin
        run_callbacks("LITERAL")
      ensure;Fi[	@â@@Qi[[	@≤irI"¶      # *without* calling their +destroy+ method.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :delete_all
      #   end;Ti[	@≤iÁI"¶      # *without* calling their +destroy+ method.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :delete_all
      #   end;Ti[	@â@2Qi[[	@≤iYI"Ü      # information.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :destroy
      #   end;Ti[	@≤iÀI"µ      # their +destroy+ method. See +destroy+ for more information.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :destroy
      #   end;Ti[	@n
I",rescue CannotInstallFormulaError => var;Fi[[	@»
iZI"ù      var.finish)
    rescue FormulaInstallationAlreadyAttemptedError
      # do nothing
    rescue CannotInstallFormulaError => var
      ofail(var.message);Fi[	@âiAI"ï      var.finish)
    rescue FormulaInstallationAlreadyAttemptedError
      # do nothing
    rescue CannotInstallFormulaError => var
      ofail(var);Fi[	@n
I"(end, var.bottle.checksum.hexdigest);Fi[[	@3iaI"ç      "STRING"
    else
      # do nothing
    end, var.bottle.checksum.hexdigest)
    assert_match("LITERAL", var.stable.checksum.hexdigest);Fi[	@3i¯I"]      "STRING"
    else
      # do nothing
    end, var.bottle.checksum.hexdigest)
  end;Fi[	I"raise("STRING") unless var;F@Ii[[	@ziLI"ì          var.delete
          var = var.match("LITERAL").to_a["LITERAL"]
          raise("STRING") unless var
          var)
        rescue => var;Fi[	@∫2iI"{      def function
        @var ||= (var = Devise.mappings[scope]
        raise("STRING") unless var
        var)
      end;Fi[	I"if var =~ "LITERAL" then;F@öi[[	@Õi"I"o  def function(var)
    var.gsub("LITERAL") do |var|
      if var =~ "LITERAL" then
        var
      else;Fi[	@ÿidI"{        xpath(*(var.map do |var|
          var = var.to_s
          if var =~ "LITERAL" then
            var
          else;Fi[	I"var = ["STRING"];FI"-(var << "STRING") if @options["LITERAL"];Fi[[	@ui=I"≤    def function
      return @current_crontab if @current_crontab
      var = ["STRING"]
      (var << "STRING") if @options["LITERAL"]
      var = `#{var.join("STRING")}STRING`;Fi[	@uiGI"Ä      (var << var)
      var.fsync
      var = ["STRING"]
      (var << "STRING") if @options["LITERAL"]
      (var << var.path);Fi[	I"@orig_err.send("LITERAL");F@|i[[	@Ωi;I"ß        return unless @orig_err
        @var ||= if @orig_err.is_a?(Errors::Error) then
          @orig_err.send("LITERAL")
        else
          @orig_err.class.to_s;Fi[	@ΩiEI"µ        return @orig_err_msg unless @orig_err_msg.nil?
        var = if @orig_err.is_a?(Errors::Error) then
          @orig_err.send("LITERAL")
        else
          @orig_err.to_s;Fi[	@â@Qi[[	@≤i8I"≤      # the default strategy is +delete_all+.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets # dependent: :nullify option by default
      #   end;Ti[	@≤iØI"¶      # strategy is +delete_all+.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets # dependent: :nullify option by default
      #   end;Ti[	I"*#     include ActiveModel::Conversion;F@i[[	@0iI"[    #
    #   class Person
    #     include ActiveModel::Conversion
    #   end
    #;Fi[	@0i8I"[    #
    #   class Person
    #     include ActiveModel::Conversion
    #   end
    #;Fi[	@Ë[@π$i[[	@≤iI"É      # Campfire api authentication token
      ##
      # Campfire account's subdomain
      ##
      # Campfire account's room id;Fi[	@≤i[I"ë        # Campfire api authentication api_token
        ##
        # Campfire account's subdomain
        ##
        # Campfire account's room id;Fi[	@!6I"&unless ASPECTS.include?(var) then;Fi[[	@î!iI"¥    # waiting for a new compass release.
    def function(var, var)
      var.each do |var|
        unless ASPECTS.include?(var) then
          Compass::Util.compass_warn("STRING");Fi[	@î!i/I"≈    # a prefix without waiting for a new compass release.
    def function(var, var)
      var.each do |var|
        unless ASPECTS.include?(var) then
          Compass::Util.compass_warn("STRING");Fi[	@!6I"var = var.new(var, &var);Fi[[	@ãiZI"¥      def function(var, var)
        var = var.extract_options!
        var.each do |var|
          var = var.new(var, &var)
          var.setup(self) if var.respond_to?("LITERAL");Fi[	@ãiàI"è    def function(var, var)
      var = var.extract_options!
      var.each do |var|
        var = var.new(var, &var)
        var.validate(self);Fi[	@!6@a6i[[	@[i_I"∏        var = Array((var or fixture_table_names))
        var = Module.new do
          var.each do |var|
            var = var.to_s
            var = var.tr("STRING", "STRING").to_sym;Fi[	@1ibI"¢        var = current_time_from_proper_timezone
        var = {}
        var.each do |var|
          var = var.to_s
          var[var] = write_attribute(var, var);Fi[	@¢%@v1i[[	@≥iFI"ñ      #
      def function(var, var)
        var = var.extract_options!
        var = Devise::Mapping.find_scope!(var)
        var = (var.last or var);Fi[	@≥i∏I"∏      # parameters as the sign_in method.
      def function(var, var)
        var = var.extract_options!
        var = Devise::Mapping.find_scope!(var)
        var = (var.last or var);Fi[	@¢%I"var["LITERAL"] = true;Fi[[	@liNI"∏        #   person.status # => true
        def function(var, var)
          var = var.extract_options!
          var["LITERAL"] = true
          var["LITERAL"] = Array(var["LITERAL"]);Fi[	@ÇiáI"¡      #   # => ActiveModel::StrictValidationFailed: Name can't be blank
      def function(var)
        var = var.extract_options!
        var["LITERAL"] = true
        validates(*(var << var));Fi[	@¢%@!6i[[	@ãiYI"ä      #   end
      def function(var, var)
        var = var.extract_options!
        var.each do |var|
          var = var.new(var, &var);Fi[	@ãiáI"≠    # class version of this method for more information.
    def function(var, var)
      var = var.extract_options!
      var.each do |var|
        var = var.new(var, &var);Fi[	I"if super then;F@hi[[	@ ivI"o    # which will all return +true+.
    def function(var, var)
      if super then
        true
      else;Fi[	@»i≥I"_        
        def function(var)
          if super then
            true
          else;Fi[	I"X# A Person object with a name attribute can ask <tt>person.respond_to?(:name)</tt>,;FI"S# <tt>person.respond_to?(:name=)</tt>, and <tt>person.respond_to?(:name?)</tt>;Fi[[	@ irI"Û    (alias "LITERAL" "LITERAL")
    
    # A Person object with a name attribute can ask <tt>person.respond_to?(:name)</tt>,
    # <tt>person.respond_to?(:name=)</tt>, and <tt>person.respond_to?(:name?)</tt>
    # which will all return +true+.;Fi[	@¸iÉI"    end
    
    # A Person object with a name attribute can ask <tt>person.respond_to?(:name)</tt>,
    # <tt>person.respond_to?(:name=)</tt>, and <tt>person.respond_to?(:name?)</tt>
    # which will all return +true+. It also define the attribute methods if they have;Fi[	@ˆI"@var = var.strip;Fi[[	@–iI"p  class IncludeTag < Liquid::Tag
    def function(var, var, var)
      super
      @var = var.strip
    end;Fi[	@61iI"ä  class PostUrl < Liquid::Tag
    def function(var, var, var)
      super
      @var = var.strip
      @var = PostComparer.new(@orig_post);Fi[	@ˆ@)*i[[	@1iI"ã      # sets the password attribute to what was provided
      def function(var)
        super
        @var ||= false
        @var ||= true;Fi[	@%i(I"ô        # any block provided in the user's configuration file.
        def function
          super
          @var ||= false
          @var ||= "LITERAL";Fi[	@ˆ@]i[[	@i7I"å      # data to the specified path based on the 'trigger'
      def function
        super
        var = Pipeline.new
        var = "STRING";Fi[	@i7I"å      # data to the specified path based on the 'trigger'
      def function
        super
        var = Pipeline.new
        var = "STRING";Fi[	@ˆI"disconnect!;Fi[[	@ÅiGI"P      
      def function
        super
        disconnect!
        connect;Fi[	@Ã	iÆI"P      
      def function
        super
        disconnect!
        connect;Fi[	@ˆI"1@var = Hash.new { |var, var| var[var] = {} };Fi[[	@Ã	iNI"Ø      class StatementPool < ConnectionAdapters::StatementPool
        def function(var, var)
          super
          @var = Hash.new { |var, var| var[var] = {} }
        end;Fi[	@Xi3I"Ø      class StatementPool < ConnectionAdapters::StatementPool
        def function(var, var)
          super
          @var = Hash.new { |var, var| var[var] = {} }
        end;Fi[	@ˆ@LCi[[	@ki?I"r    
    def function
      super
      mixin.class_eval("STRING", "STRING", ("LITERAL" + "LITERAL"))
    end;Fi[	@kiDI"r    
    def function
      super
      mixin.class_eval("STRING", "STRING", ("LITERAL" + "LITERAL"))
    end;Fi[	I"K# One of :yellow, :red, :green, :purple, or :random. (default: yellow);F@π$i[[	@ü
i!I"ƒ      ##
      # The background color of a success message.
      # One of :yellow, :red, :green, :purple, or :random. (default: yellow)
      ##
      # The background color of a warning message.;Fi[	@ü
i$I"√      ##
      # The background color of a warning message.
      # One of :yellow, :red, :green, :purple, or :random. (default: yellow)
      ##
      # The background color of an error message.;Fi[	I"var, var = case var;F@i[[	@ü
iHI"{      #
      def function(var)
        var, var = case var
        when "LITERAL" then
          ["STRING", success_color];Fi[	@¢
iÇI"x      #
      def function(var)
        var, var = case var
        when "LITERAL" then
          ["STRING", false];Fi[	I"Y# Note that this will override the defaults set by the Mail gem (currently: '-i -t');FI"E# So, if set here, be sure to set all the arguments you require.;Fi[[	@¢
i\I"      ##
      # Optional arguments to pass to `sendmail`
      # Note that this will override the defaults set by the Mail gem (currently: '-i -t')
      # So, if set here, be sure to set all the arguments you require.
      # Example: '-i -t -X/tmp/traffic.log';Fi[	@¢
ieI"      ##
      # Optional arguments to pass to `exim`
      # Note that this will override the defaults set by the Mail gem (currently: '-i -t')
      # So, if set here, be sure to set all the arguments you require.
      # Example: '-i -t -X/tmp/traffic.log';Fi[	@`I"*# Example: '-i -t -X/tmp/traffic.log';Fi[[	@¢
i]I"      # Optional arguments to pass to `sendmail`
      # Note that this will override the defaults set by the Mail gem (currently: '-i -t')
      # So, if set here, be sure to set all the arguments you require.
      # Example: '-i -t -X/tmp/traffic.log'
      ##;Fi[	@¢
ifI"      # Optional arguments to pass to `exim`
      # Note that this will override the defaults set by the Mail gem (currently: '-i -t')
      # So, if set here, be sure to set all the arguments you require.
      # Example: '-i -t -X/tmp/traffic.log'
      ##;Fi[	@`@π$i[[	@¢
i^I"      # Note that this will override the defaults set by the Mail gem (currently: '-i -t')
      # So, if set here, be sure to set all the arguments you require.
      # Example: '-i -t -X/tmp/traffic.log'
      ##
      # When using the `:exim` `delivery_method` option,;Fi[	@¢
igI".      # Note that this will override the defaults set by the Mail gem (currently: '-i -t')
      # So, if set here, be sure to set all the arguments you require.
      # Example: '-i -t -X/tmp/traffic.log'
      ##
      # Folder where mail will be kept when using the `:file` `delivery_method` option.;Fi[	@ŸI"return self unless var;Fi[[	@h&iI"j      end
      
      def function(var, var, var)
        return self unless var
        if var then;Fi[	@iI"≤      #  subtree created, e.g., namespaces will be resolved relative
      #  to +ctx+.
      def function(var, var, var)
        return self unless var
        var = if var then;Fi[	@t(@¡;i[[	@oi0I"ﬁ      # Transfers the archived file to the specified Cloud Files container
      def function
        var = remote_path_for(@package)
        files_to_transfer_for(@package) do |var, var|
          Logger.message("STRING");Fi[	@¯	iRI"◊      # Transfers the archived file to the specified Dropbox folder
      def function
        var = remote_path_for(@package)
        files_to_transfer_for(@package) do |var, var|
          Logger.message("STRING");Fi[	@ŸI"&var = [var.first, var["LITERAL"]];Fi[[	@^iEI"m      end
      
      def function(var, var, var)
        var = [var.first, var["LITERAL"]]
        var;Fi[	@^iJI"m      end
      
      def function(var, var, var)
        var = [var.first, var["LITERAL"]]
        var;Fi[	@ŸI"Kvar = Node.new("LITERAL", ([var["LITERAL"]] + (var["LITERAL"] or [])));Fi[[	@^i¶I"ù      
      # reduce 27 omitted
      def function(var, var, var)
        var = Node.new("LITERAL", ([var["LITERAL"]] + (var["LITERAL"] or [])))
        var;Fi[	@^i´I"ç      end
      
      def function(var, var, var)
        var = Node.new("LITERAL", ([var["LITERAL"]] + (var["LITERAL"] or [])))
        var;Fi[	@ŸI"Nvar = Node.new("LITERAL", [[var.first, var.last].compact.join("STRING")]);Fi[[	@^iïI"ê      end
      
      def function(var, var, var)
        var = Node.new("LITERAL", [[var.first, var.last].compact.join("STRING")])
        var;Fi[	@^iµI"ê      end
      
      def function(var, var, var)
        var = Node.new("LITERAL", [[var.first, var.last].compact.join("STRING")])
        var;Fi[	@ŸI"var = "STRING".to_sym;Fi[[	@Õ<iI"|      end
      
      def function(var, var, var)
        var = "STRING".to_sym
        var = var.send("LITERAL", var);Fi[	@EiI"|      end
      
      def function(var, var, var)
        var = "STRING".to_sym
        var = var.send("LITERAL", var);Fi[	@ŸI"$if @klass.respond_to?(var) then;Fi[[	@i.I"ì      protected
      
      def function(var, var, var)
        if @klass.respond_to?(var) then
          self.class.delegate_to_scoped_klass(var);Fi[	@ieI"â    protected
    
    def function(var, var, var)
      if @klass.respond_to?(var) then
        scoping { @klass.send(var, *var, &var) };Fi[	@Ÿ@èJi[[	@õi¸I"ñ        
        # Changes the default value of a table column.
        def function(var, var, var)
          clear_cache!
          execute("STRING");Fi[	@õiI"Ü        
        # Renames a column in a table.
        def function(var, var, var)
          clear_cache!
          execute("STRING");Fi[	@Ÿ@Æi[[	@∫i/I"p      attr_writer("LITERAL")
      
      def function(var, var, var)
        super(var)
        @var = var;Fi[	@yiXI"q    attr_reader("LITERAL", "LITERAL")
    
    def function(var, var, var)
      super(var)
      @var = var;Fi[	@W)@Di[[	@‡"iHI"Õ      # and a warning will be logged, containing the error message.
      def function(var)
        var = remote_path_for(var)
        connection do |var|
          transferred_files_for(var) do |var, var|;Fi[	@i<I"Õ      # and a warning will be logged, containing the error message.
      def function(var)
        var = remote_path_for(var)
        connection do |var|
          transferred_files_for(var) do |var, var|;Fi[	@Ÿ@üVi[[	@ÜiTI"Ñ      protected
      
      def function(var, var, var)
        if var.is_a?(Hash) and var = var["LITERAL"] then
          case var;Fi[	@Ui8I"~      end
      
      def function(var, var, var)
        if var.is_a?(Hash) and var = var["LITERAL"] then
          case var;Fi[	@`RI"'Logger.message(var.join("STRING"));Fi[[	@¯	ibI"”        var = remote_path_for(var)
        var = []
        transferred_files_for(var) { |var, var| (var << ("STRING" + "STRING")) }
        Logger.message(var.join("STRING"))
        connection.file_delete(var);Fi[	@i@I"¿        var = remote_path_for(var)
        var = []
        transferred_files_for(var) { |var, var| (var << ("STRING" + "STRING")) }
        Logger.message(var.join("STRING"))
        var = [];Fi[	@Ÿ@N i[[	@Ui»I"[      end
      
      def function(var, var, var)
        execute("STRING")
      end;Fi[	@õiI"e        end
        
        def function(var, var, var)
          execute("STRING")
        end;Fi[	@ŸI".var = find_join_table_name(var, var, var);Fi[[	@Üi∆I"Œ      #    part_id int NOT NULL,
      #  ) ENGINE=InnoDB DEFAULT CHARSET=utf8
      def function(var, var, var)
        var = find_join_table_name(var, var, var)
        var = (var.delete("LITERAL") or {});Fi[	@ÜiÿI"˝      # to provide one in a migration's +change+ method so it can be reverted.
      # In that case, the block will be used by create_join_table.
      def function(var, var, var)
        var = find_join_table_name(var, var, var)
        drop_table(var);Fi[	@à<@:i[[	@ui1I"¥      
      ##
      # Establishes a connection to the remote server
      def function
        Net::SSH.start(ip, username, "LITERAL" => (password), "LITERAL" => (port)) do |var|;Fi[	@i#I"µ      
      ##
      # Establishes a connection to the remote server
      def function
        Net::SFTP.start(ip, username, "LITERAL" => (password), "LITERAL" => (port)) do |var|;Fi[	@ŸI"var = Array(var);Fi[[	@Üi-I"ﬂ      #  # Check an index with a custom name exists
      #  index_exists?(:suppliers, :company_id, name: "idx_company_id"
      def function(var, var, var)
        var = Array(var)
        var = if var.key?("LITERAL") then;Fi[	@ÜimI"}      end
      
      def function(var, var, var)
        var = Array(var)
        var = index_name(var, "LITERAL" => (var));Fi[	@D@4i[[	@‡"iII"ª      def function(var)
        var = remote_path_for(var)
        connection do |var|
          transferred_files_for(var) do |var, var|
            Logger.message(("STRING" + "STRING"));Fi[	@i=I"ª      def function(var)
        var = remote_path_for(var)
        connection do |var|
          transferred_files_for(var) do |var, var|
            Logger.message(("STRING" + "STRING"));Fi[	@DI"!create_remote_path(var, var);Fi[[	@‡"i:I"µ      def function
        var = remote_path_for(@package)
        connection do |var|
          create_remote_path(var, var)
          files_to_transfer_for(@package) do |var, var|;Fi[	@i.I"µ      def function
        var = remote_path_for(@package)
        connection do |var|
          create_remote_path(var, var)
          files_to_transfer_for(@package) do |var, var|;Fi[	@ì`@¡;i[[	@‡"i;I"‘        var = remote_path_for(@package)
        connection do |var|
          create_remote_path(var, var)
          files_to_transfer_for(@package) do |var, var|
            Logger.message(("STRING" + "STRING"));Fi[	@i/I"‘        var = remote_path_for(@package)
        connection do |var|
          create_remote_path(var, var)
          files_to_transfer_for(@package) do |var, var|
            Logger.message(("STRING" + "STRING"));Fi[	I"B# paths to directories that don't yet exist when creating new;FI"K# directories. Instead, we split the parts up in to an array (for each;Fi[[	@‡"iUI"r      # Creates (if they don't exist yet) all the directories on the remote
      # server in order to upload the backup file. Net::FTP does not support
      # paths to directories that don't yet exist when creating new
      # directories. Instead, we split the parts up in to an array (for each
      # '/') and loop through that to create the directories one by one.;Fi[	@iII"s      # Creates (if they don't exist yet) all the directories on the remote
      # server in order to upload the backup file. Net::SFTP does not support
      # paths to directories that don't yet exist when creating new
      # directories. Instead, we split the parts up in to an array (for each
      # '/') and loop through that to create the directories one by one.;Fi[	@°`I"G# '/') and loop through that to create the directories one by one.;Fi[[	@‡"iVI"t      # server in order to upload the backup file. Net::FTP does not support
      # paths to directories that don't yet exist when creating new
      # directories. Instead, we split the parts up in to an array (for each
      # '/') and loop through that to create the directories one by one.
      # Net::FTP raises an exception when the directory it's trying to create;Fi[	@iJI"v      # server in order to upload the backup file. Net::SFTP does not support
      # paths to directories that don't yet exist when creating new
      # directories. Instead, we split the parts up in to an array (for each
      # '/') and loop through that to create the directories one by one.
      # Net::SFTP raises an exception when the directory it's trying to create;Fi[	I"+# already exists, so we have rescue it;F@Hi[[	@‡"iYI"¯      # '/') and loop through that to create the directories one by one.
      # Net::FTP raises an exception when the directory it's trying to create
      # already exists, so we have rescue it
      def function(var, var)
        var = Array.new;Fi[	@iMI"˘      # '/') and loop through that to create the directories one by one.
      # Net::SFTP raises an exception when the directory it's trying to create
      # already exists, so we have rescue it
      def function(var, var)
        var = Array.new;Fi[	I"var = Array.new;FI"&var.split("STRING").each do |var|;Fi[[	@‡"i[I"¢      # already exists, so we have rescue it
      def function(var, var)
        var = Array.new
        var.split("STRING").each do |var|
          (var << var);Fi[	@iOI"¢      # already exists, so we have rescue it
      def function(var, var)
        var = Array.new
        var.split("STRING").each do |var|
          (var << var);Fi[	@∑`@6i[[	@‡"i\I"Ö      def function(var, var)
        var = Array.new
        var.split("STRING").each do |var|
          (var << var)
          begin;Fi[	@iPI"Ö      def function(var, var)
        var = Array.new
        var.split("STRING").each do |var|
          (var << var)
          begin;Fi[	@w[@:i[[	@ri"I"»      
      ##
      # Establishes a connection to Amazon S3
      def function
        @var ||= Fog::Storage.new("LITERAL" => (provider), "LITERAL" => (storage_token), "LITERAL" => (storage_secret));Fi[	@zi&I"‚      
      ##
      # Establishes a connection to Amazon S3
      def function
        @var ||= Fog::Storage.new("LITERAL" => (provider), "LITERAL" => (access_key_id), "LITERAL" => (secret_access_key), "LITERAL" => (region));Fi[	@p[@π$i[[	@uiI"y      # Server credentials
      ##
      # Server IP Address and SSH port
      ##
      # Path to store backups to;Fi[	@ÜiI"Ä        # Server credentials
        ##
        # Server IP Address and SSH port
        ##
        # The SSH port to connect to;Fi[	I"XNet::SSH.start(ip, username, "LITERAL" => (password), "LITERAL" => (port)) do |var|;FI"yield(var);Fi[[	@ui3I"≈      # Establishes a connection to the remote server
      def function
        Net::SSH.start(ip, username, "LITERAL" => (password), "LITERAL" => (port)) do |var|
          yield(var)
        end;Fi[	@i'I"Õ      # Net::SCP will use this connection to transfer backups
      def function
        Net::SSH.start(ip, username, "LITERAL" => (password), "LITERAL" => (port)) do |var|
          yield(var)
        end;Fi[	@4[I"=# the rsync utility can read the password from this file;Fi[[	@ui_I"¢      
      ##
      # Writes the provided password to a temporary file so that
      # the rsync utility can read the password from this file
      def function;Fi[	@ÜiZI"¨        
        ##
        # Writes the provided password to a temporary file so that
        # the rsync utility can read the password from this file
        def function;Fi[	@ÿ`@:i[[	@ui`I"Ω      ##
      # Writes the provided password to a temporary file so that
      # the rsync utility can read the password from this file
      def function
        unless password.nil? then;Fi[	@Üi[I"»        ##
        # Writes the provided password to a temporary file so that
        # the rsync utility can read the password from this file
        def function
          unless @password.nil? then;Fi[	@&[I"/# (temporary file containing the password);Fi[[	@uijI"â      
      ##
      # Removes the previously created @password_file
      # (temporary file containing the password)
      def function;Fi[	@ÜieI"ì        
        ##
        # Removes the previously created @password_file
        # (temporary file containing the password)
        def function;Fi[	@Â`@:i[[	@uikI"≤      ##
      # Removes the previously created @password_file
      # (temporary file containing the password)
      def function
        @password_file.delete if @password_file;Fi[	@ÜifI"º        ##
        # Removes the previously created @password_file
        # (temporary file containing the password)
        def function
          @password_file.delete if @password_file;Fi[	I",@password_file.delete if @password_file;F@ri[[	@uimI"ê      # (temporary file containing the password)
      def function
        @password_file.delete if @password_file
        @var = nil
      end;Fi[	@ÜihI"ö        # (temporary file containing the password)
        def function
          @password_file.delete if @password_file
          @var = nil
        end;Fi[	@[@:i[[	@uixI"w      
      ##
      # Returns Rsync syntax for defining a port to connect to
      def function
        "STRING";Fi[	@ÜiNI"|        
        ##
        # Returns Rsync syntax for defining a port to connect to
        def function
          "STRING";Fi[	@…Z@π$i[[	@ziI"{      
      ##
      # Amazon Simple Storage Service (S3) Credentials
      ##
      # Amazon S3 bucket name and path;Fi[	@ÄiI"Å        
        ##
        # Amazon Simple Storage Service (S3) Credentials
        ##
        # The S3 bucket to store files to;Fi[	@Ÿ@ß?i[[	@PiDI"p      alias "LITERAL" "LITERAL"
      
      def function(var, var, var)
        super()
        @var = var;Fi[	@iI"Ÿ    # Create a new Queue object with +name+ on +redis+ connection, and using
    # the +coder+ for encoding and decoding objects that are stored in redis.
    def function(var, var, var)
      super()
      @var = var;Fi[	@Ÿ@YPi[[	@^i4I"]      end
      
      def function(var, var, var)
        var = var.flatten
        var;Fi[	@^i9I"]      end
      
      def function(var, var, var)
        var = var.flatten
        var;Fi[	I"1# are set via a super() call to Cloud::Base,;F@e=i[[	@}i#I"“        # Pre-configured defaults specified in
        # Configuration::Syncer::Cloud::CloudFiles
        # are set via a super() call to Cloud::Base,
        # which in turn will invoke Syncer::Base.
        #;Fi[	@ÄiI"         # Pre-configured defaults specified in
        # Configuration::Syncer::Cloud::S3
        # are set via a super() call to Cloud::Base,
        # which in turn will invoke Syncer::Base.
        #;Fi[	@Ÿ@æ_i[[	@	iÜI"Ω      # it's configured to bind to the object as this is the convention for
      # DataMapper/Extlib callbacks
      def function(var, var, var)
        var["LITERAL"] = true
        super;Fi[	@JiõI"Ê      # it's configured to bind to the object as this is the convention for
      # Sequel callbacks
      def function(var, var, var)
        var["LITERAL"] = true
        var["LITERAL"] = @var ||= lambda { |var| (var == false) };Fi[	I"H# Once pre-configured defaults and Cloud specific defaults are set,;F@ë=i[[	@}i&I"Ê        # which in turn will invoke Syncer::Base.
        #
        # Once pre-configured defaults and Cloud specific defaults are set,
        # the block from the user's configuration file is evaluated.
        def function(var);Fi[	@ÄiI"Ê        # which in turn will invoke Syncer::Base.
        #
        # Once pre-configured defaults and Cloud specific defaults are set,
        # the block from the user's configuration file is evaluated.
        def function(var);Fi[	@ŸI"+var = normalize_message(var, var, var);Fi[[	@9iÓI"ú    #
    #   person.errors.messages # => {}
    def function(var, var, var)
      var = normalize_message(var, var, var)
      if var = var["LITERAL"] then;Fi[	@9iI"«    #   person.errors.add :name, :blank
    #   person.errors.added? :name, :blank # => true
    def function(var, var, var)
      var = normalize_message(var, var, var)
      self[var].include?(var);Fi[	I"D# otherwise it will create it first and fetch use that instead.;F@:i[[	@}i9I"F        # Creates a new @repository_object (container).
        # Fetches it from Cloud Files if it already exists,
        # otherwise it will create it first and fetch use that instead.
        def function
          @var ||= (connection.directories.get(container) or connection.directories.create("LITERAL" => (container)));Fi[	@Äi0I"K        # Creates a new @repository_object (bucket).
        # Fetches it from S3 if it already exists,
        # otherwise it will create it first and fetch use that instead.
        def function
          @var ||= (connection.directories.get(bucket) or connection.directories.create("LITERAL" => (bucket), "LITERAL" => (region)));Fi[	@ÑZ@:i[[	@}i?I"|        
        ##
        # This is the provider that Fog uses for the Cloud Files
        def function
          "STRING";Fi[	@Äi6I"|        
        ##
        # This is the provider that Fog uses for the Cloud Files
        def function
          "STRING";Fi[	I"1# are set via a super() call to RSync::Base,;F@e=i[[	@8iI"Õ        # Pre-configured defaults specified in
        # Configuration::Syncer::RSync::Local
        # are set via a super() call to RSync::Base,
        # which in turn will invoke Syncer::Base.
        #;Fi[	@ÜiI"Õ        # Configuration::Syncer::RSync::Push or
        # Configuration::Syncer::RSync::Pull
        # are set via a super() call to RSync::Base,
        # which in turn will invoke Syncer::Base.
        #;Fi[	I"H# Once pre-configured defaults and RSync specific defaults are set,;F@ë=i[[	@8iI"Ê        # which in turn will invoke Syncer::Base.
        #
        # Once pre-configured defaults and RSync specific defaults are set,
        # the block from the user's configuration file is evaluated.
        def function(var);Fi[	@Üi"I"Ê        # which in turn will invoke Syncer::Base.
        #
        # Once pre-configured defaults and RSync specific defaults are set,
        # the block from the user's configuration file is evaluated.
        def function(var);Fi[	@Ÿ@<"i[[	@UikI"å      end
      
      def function(var, var, var)
        var = {}
        if var = columns(var).find { |var| (var.name == var.to_s) } then;Fi[	@Ã	iòI"j      private
      
      def function(var, var, var)
        var = {}
        log(var, var, var) do;Fi[	I"&# concatenated, ready for the CLI;F@:i[[	@8i*I"€        ##
        # Returns all the specified Rsync::Local options,
        # concatenated, ready for the CLI
        def function
          ([archive_option, mirror_option] + additional_options).compact.join("STRING");Fi[	@ÜiBI"        ##
        # Returns all the specified Rsync::[Push/Pull] options,
        # concatenated, ready for the CLI
        def function
          ([archive_option, mirror_option, compress_option, port_option, password_option] + additional_options).compact.join("STRING");Fi[	@Æ'@ ,i[[	I"$projects//backup_proj/backup.rb;Ti I"Arequire("rubygems")
require("fileutils")
require("tempfile");Fi [	@8iI"f  Dir[var].each { |var| require(f) }
end
require("rubygems")
require("fileutils")
require("time");Fi[	@Ÿ@<i[[	@UiqI"o      end
      
      def function(var, var, var)
        var = "STRING"
        (var << "STRING") if var;Fi[	I"Aprojects//diaspora_proj/mailers/notification_mailers/base.rb;Ti-I"ä    end
    
    def function(var, var, var)
      var = "STRING"
      @recipient and @sender ? ((var << "STRING")) : ((var << "STRING"));Fi[	@ŒBI",var = [var, var].compact.join("STRING");Fi[[	@'i2I"F        # +uri+ is the associated namespace URI
        # +ns+ is a hash of namespace prefix:urls associated with the element
        def function(var, var, var, var, var)
          var = [var, var].compact.join("STRING")
          var = (var.map { |var, var| [["STRING", var].compact.join("STRING"), var] } + var.map do |var|;Fi[	@Mi0I"”      end
      
      def function(var, var, var, var, var)
        var = [var, var].compact.join("STRING")
        var = (var.map { |var, var| [["STRING", var].compact.join("STRING"), var] } + var.map do |var|;Fi[	@ ,@Æ'i[[	@¥'i I"?require("fileutils")
require("rubygems")
require("sequel");Fi [	@ø'i I"?require("fileutils")
require("rubygems")
require("sequel");Fi [	@ ,I"require("tempfile");Fi[[	@VaiI"Qrequire("rubygems")
require("fileutils")
require("tempfile")
require("yaml");Fi[	@ui I"=require("fileutils")
require("tempfile")
module Whenever;Fi [	@ŒB@=Ji[[	@Ç
i%I"Ã        
        # Executes an INSERT query and returns the new record's ID
        def function(var, var, var, var, var)
          unless var then
            var = extract_table_ref_from_insert_sql(var);Fi[	@Ç
i}I"≠        (alias "LITERAL" "LITERAL")
        
        def function(var, var, var, var, var)
          unless var then
            var = extract_table_ref_from_insert_sql(var);Fi[	I" #   can? :destroy, @project;F@i[[	@ãi	I"“    # Check if the user has permission to perform a given action on an object.
    #
    #   can? :destroy, @project
    #
    # You can also pass the class instead of an instance (if you don't have one handy).;Fi[	@ñi`I"ï    # and object.
    #
    #   can? :destroy, @project
    #
    # You can also pass the class instead of an instance (if you don't have one handy).;Fi[	I"X# You can also pass the class instead of an instance (if you don't have one handy).;F@i[[	@ãiI"°    #   can? :destroy, @project
    #
    # You can also pass the class instead of an instance (if you don't have one handy).
    #
    #   can? :create, Project;Fi[	@ñibI"™    #   can? :destroy, @project
    #
    # You can also pass the class instead of an instance (if you don't have one handy).
    #
    #   <% if can? :create, Project %>;Fi[	I"X# Convenience method which works the same as "can?" but returns the opposite value.;F@i[[	@ãi3I"ç    end
    
    # Convenience method which works the same as "can?" but returns the opposite value.
    #
    #   cannot? :destroy, @project;Fi[	@ñitI"ç    end
    
    # Convenience method which works the same as "can?" but returns the opposite value.
    #
    #   cannot? :destroy, @project;Fi[	I"##   cannot? :destroy, @project;F@i[[	@ãi5I"ú    # Convenience method which works the same as "can?" but returns the opposite value.
    #
    #   cannot? :destroy, @project
    #
    def function(var);Fi[	@ñivI"ú    # Convenience method which works the same as "can?" but returns the opposite value.
    #
    #   cannot? :destroy, @project
    #
    def function(var);Fi[	I"9# Call this method directly on the controller class.;F@i[[	@ñiI"§      # the ability restrictions.
      #
      # Call this method directly on the controller class.
      #
      #   class BooksController < ApplicationController;Fi[	@ñiI"ƒ      #   authorize!(params[:action].to_sym, @article || Article)
      #
      # Call this method directly on the controller class.
      #
      #   class BooksController < ApplicationController;Fi[	I"_# That first argument is optional and will default to the singular name of the controller.;FI"_# A hash of options (see below) can also be passed to this method to further customize it.;Fi[[	@ñi<I"      # will then be loaded through the @author instance variable.
      #
      # That first argument is optional and will default to the singular name of the controller.
      # A hash of options (see below) can also be passed to this method to further customize it.
      #;Fi[	@ñiäI"0      # Here it will authorize :+show+, @+author+ on every action before authorizing the book.
      #
      # That first argument is optional and will default to the singular name of the controller.
      # A hash of options (see below) can also be passed to this method to further customize it.
      #;Fi[	@†a@i[[	@ñi=I"&      #
      # That first argument is optional and will default to the singular name of the controller.
      # A hash of options (see below) can also be passed to this method to further customize it.
      #
      # See load_and_authorize_resource to automatically authorize the resource too.;Fi[	@ñiãI"!      #
      # That first argument is optional and will default to the singular name of the controller.
      # A hash of options (see below) can also be passed to this method to further customize it.
      #
      # See load_and_authorize_resource to automatically load the resource too.;Fi[	@”MI"5#   Only applies before filter to given actions.;Fi[[	@ñiBI"n      #
      # Options:
      # [:+only+]
      #   Only applies before filter to given actions.
      #;Fi[	@ñiêI"n      #
      # Options:
      # [:+only+]
      #   Only applies before filter to given actions.
      #;Fi[	@≠a@i[[	@ñiCI"z      # Options:
      # [:+only+]
      #   Only applies before filter to given actions.
      #
      # [:+except+];Fi[	@ñiëI"z      # Options:
      # [:+only+]
      #   Only applies before filter to given actions.
      #
      # [:+except+];Fi[	@YMI"7#   Does not apply before filter to given actions.;Fi[[	@ñiEI"ì      #   Only applies before filter to given actions.
      #
      # [:+except+]
      #   Does not apply before filter to given actions.
      #;Fi[	@ñiìI"ì      #   Only applies before filter to given actions.
      #
      # [:+except+]
      #   Does not apply before filter to given actions.
      #;Fi[	@∫a@i[[	@ñiFI"v      #
      # [:+except+]
      #   Does not apply before filter to given actions.
      #
      # [:+through+];Fi[	@ñiîI"x      #
      # [:+except+]
      #   Does not apply before filter to given actions.
      #
      # [:+singleton+];Fi[	I"# [:+singleton+];FI"U#   Pass +true+ if this is a singleton resource through a +has_one+ association.;Fi[[	@ñiRI"Î      #   Pass +true+ to allow this resource to be loaded directly when parent is +nil+. Defaults to +false+.
      #
      # [:+singleton+]
      #   Pass +true+ if this is a singleton resource through a +has_one+ association.
      #;Fi[	@ñiñI"∂      #   Does not apply before filter to given actions.
      #
      # [:+singleton+]
      #   Pass +true+ if this is a singleton resource through a +has_one+ association.
      #;Fi[	@»a@i[[	@ñiSI"ë      #
      # [:+singleton+]
      #   Pass +true+ if this is a singleton resource through a +has_one+ association.
      #
      # [:+parent+];Fi[	@ñióI"ë      #
      # [:+singleton+]
      #   Pass +true+ if this is a singleton resource through a +has_one+ association.
      #
      # [:+parent+];Fi[	I"# [:+parent+];FI"z#   True or false depending on if the resource is considered a parent resource. This defaults to +true+ if a resource;Fi[[	@ñiUI"+      #   Pass +true+ if this is a singleton resource through a +has_one+ association.
      #
      # [:+parent+]
      #   True or false depending on if the resource is considered a parent resource. This defaults to +true+ if a resource
      #   name is given which does not match the controller.;Fi[	@ñiôI"+      #   Pass +true+ if this is a singleton resource through a +has_one+ association.
      #
      # [:+parent+]
      #   True or false depending on if the resource is considered a parent resource. This defaults to +true+ if a resource
      #   name is given which does not match the controller.;Fi[	@÷aI";#   name is given which does not match the controller.;Fi[[	@ñiVI"‹      #
      # [:+parent+]
      #   True or false depending on if the resource is considered a parent resource. This defaults to +true+ if a resource
      #   name is given which does not match the controller.
      #;Fi[	@ñiöI"‹      #
      # [:+parent+]
      #   True or false depending on if the resource is considered a parent resource. This defaults to +true+ if a resource
      #   name is given which does not match the controller.
      #;Fi[	@›a@i[[	@ñiWI"Á      # [:+parent+]
      #   True or false depending on if the resource is considered a parent resource. This defaults to +true+ if a resource
      #   name is given which does not match the controller.
      #
      # [:+class+];Fi[	@ñiõI"Á      # [:+parent+]
      #   True or false depending on if the resource is considered a parent resource. This defaults to +true+ if a resource
      #   name is given which does not match the controller.
      #
      # [:+class+];Fi[	I"# [:+prepend+];FI"Y#   Passing +true+ will use prepend_before_filter instead of a normal before_filter.;Fi[[	@ñiqI"®      #     load_resource :new => :build
      #
      # [:+prepend+]
      #   Passing +true+ will use prepend_before_filter instead of a normal before_filter.
      #;Fi[	@ñißI"’      #   Authorize conditions on this parent resource when instance isn't available.
      #
      # [:+prepend+]
      #   Passing +true+ will use prepend_before_filter instead of a normal before_filter.
      #;Fi[	@Îa@i[[	@ñirI"ó      #
      # [:+prepend+]
      #   Passing +true+ will use prepend_before_filter instead of a normal before_filter.
      #
      def function(var);Fi[	@ñi®I"ó      #
      # [:+prepend+]
      #   Passing +true+ will use prepend_before_filter instead of a normal before_filter.
      #
      def function(var);Fi[	@ŒB@ˆi[[	@ÅiæI"t      end
      
      def function(var, var, var, var, var)
        super
        (var or @connection.last_id);Fi[	@Xi!I"      end
      
      def function(var, var, var, var, var)
        super
        (var or @connection.last_insert_row_id);Fi[	I"D# skip the effects on. It will apply to all actions by default.;F@i[[	@ñiæI"n      # Skip the loading behavior of CanCan. This is useful when using +load_and_authorize_resource+ but want to
      # only do authorization on certain actions. You can pass :only and :except options to specify which actions to
      # skip the effects on. It will apply to all actions by default.
      #
      #   class ProjectsController < ApplicationController;Fi[	@ñiŒI"n      # Skip the authorization behavior of CanCan. This is useful when using +load_and_authorize_resource+ but want to
      # only do loading on certain actions. You can pass :only and :except options to specify which actions to
      # skip the effects on. It will apply to all actions by default.
      #
      #   class ProjectsController < ApplicationController;Fi[	I"9#   class ProjectsController < ApplicationController;FI"&#     load_and_authorize_resource;Fi[[	@ñi¿I"ﬂ      # skip the effects on. It will apply to all actions by default.
      #
      #   class ProjectsController < ApplicationController
      #     load_and_authorize_resource
      #     skip_load_resource :only => :index;Fi[	@ñi–I"‰      # skip the effects on. It will apply to all actions by default.
      #
      #   class ProjectsController < ApplicationController
      #     load_and_authorize_resource
      #     skip_authorize_resource :only => :index;Fi[	@/MI"#     devise:;Fi[[	@'iGI"j      # based on the current mapping:
      #
      #   en:
      #     devise:
      #       mailer:;Fi[	@'iOI"Ñ      # If one does not exist, it fallbacks to ActionMailer default:
      #
      #   en:
      #     devise:
      #       mailer:;Fi[	I"9#     <%= link_to "New Project", new_project_path %>;FI"#   <% end %>;Fi[[	@ñieI"}    #
    #   <% if can? :create, Project %>
    #     <%= link_to "New Project", new_project_path %>
    #   <% end %>
    #;Fi[	@ñilI"ä    #
    #   <% if can? :create, @category => Project %>
    #     <%= link_to "New Project", new_project_path %>
    #   <% end %>
    #;Fi[	@b@i[[	@ñifI"’    #   <% if can? :create, Project %>
    #     <%= link_to "New Project", new_project_path %>
    #   <% end %>
    #
    # If it's a nested resource, you can pass the parent instance in a hash. This way it will;Fi[	@ñimI"Õ    #   <% if can? :create, @category => Project %>
    #     <%= link_to "New Project", new_project_path %>
    #   <% end %>
    #
    # This simply calls "can?" on the current_ability. See Ability#can?.;Fi[	I"Jraise(CanCan::ImplementationRemoved, "STRING") if @options["LITERAL"];F@"bi[[	@
iI"      @var = var.extract_options!
      @var = var.first
      raise(CanCan::ImplementationRemoved, "STRING") if @options["LITERAL"]
      raise(CanCan::ImplementationRemoved, "STRING") if @options["LITERAL"]
      raise(CanCan::ImplementationRemoved, "STRING") if @options["LITERAL"];Fi[	@
iI"      @var = var.first
      raise(CanCan::ImplementationRemoved, "STRING") if @options["LITERAL"]
      raise(CanCan::ImplementationRemoved, "STRING") if @options["LITERAL"]
      raise(CanCan::ImplementationRemoved, "STRING") if @options["LITERAL"]
    end;Fi[	@ BI"resource_class;Fi[[	@
iøI"ë      if @options["LITERAL"] then
        if parent_resource then
          if @options["LITERAL"] then
            resource_class
          else;Fi[	@
i≈I"o          end
        else
          if @options["LITERAL"] then
            resource_class
          else;Fi[	@)b@|i[[	@
i¿I"æ        if parent_resource then
          if @options["LITERAL"] then
            resource_class
          else
            parent_resource.send((@options["LITERAL"] or name.to_s.pluralize));Fi[	@
i∆I"´        else
          if @options["LITERAL"] then
            resource_class
          else
            raise(AccessDenied.new(nil, authorization_action, resource_class));Fi[	I"0@controller.instance_variable_get("STRING");F@|i[[	@
i€I"◊    def function(var)
      if @controller.instance_variable_defined?("STRING") then
        @controller.instance_variable_get("STRING")
      else
        @controller.send(var) if @controller.respond_to?(var, true);Fi[	I"7projects//cancan_proj/cancan/inherited_resource.rb;Ti
I"∏      if parent? then
        @controller.send("LITERAL")
        @controller.instance_variable_get("STRING")
      else
        if new_actions.include?(@params["LITERAL"].to_sym) then;Fi[	@:I".return unless @output.has_key?("LITERAL");Fi[[	@|iI"ü      protected
      
      def function
        return unless @output.has_key?("LITERAL")
        @output["LITERAL"].nil? ? ("STRING") : (@output["LITERAL"]);Fi[	@|i!I"ô      end
      
      def function
        return unless @output.has_key?("LITERAL")
        @output["LITERAL"].nil? ? ("STRING") : (@output["LITERAL"]);Fi[	@:I"var = @attrs["LITERAL"];Fi[[	@…i#I"f    
    # @return [Integer]
    def function
      var = @attrs["LITERAL"]
      var.to_i if var;Fi[	@…i^I"f    
    # @return [Integer]
    def function
      var = @attrs["LITERAL"]
      var.to_i if var;Fi[	@:I"/if owner.is_a?(StateMachine::Machine) then;Fi[[	@?+iI"ë        handles(method_call("LITERAL"))
        
        def function
          if owner.is_a?(StateMachine::Machine) then
            var = self;Fi[	@D+iI"ë        handles(method_call("LITERAL"))
        
        def function
          if owner.is_a?(StateMachine::Machine) then
            var = self;Fi[	@:I"(Stat << "STRING");Fi[[	@]i≠I"t    
    # Tell Redis we've processed a job.
    def function
      (Stat << "STRING")
      (Stat << "STRING");Fi[	@]i∏I"r    
    # Tells Redis we've failed a job.
    def function
      (Stat << "STRING")
      (Stat << "STRING");Fi[	@:I"!Resque.logger.info("STRING");Fi[[	@]i%I"ú    # Schedule this worker for shutdown. Will finish processing the
    # current job.
    def function
      Resque.logger.info("STRING")
      @var = true;Fi[	@]i^I"¨    # Stop processing jobs after the current one has completed (if we're
    # currently running one).
    def function
      Resque.logger.info("STRING")
      @var = true;Fi[	@:I"%@queued_for_delete.each do |var|;Fi[[	@^i$I"f      
      #:nodoc:
      def function
        @queued_for_delete.each do |var|
          begin;Fi[	@ci€I"f      
      #:nodoc:
      def function
        @queued_for_delete.each do |var|
          begin;Fi[	@:I"G@var = @target.original_filename if @target.respond_to?("LITERAL");Fi[[	@AiI"ï    private
    
    def function
      @var = @target.original_filename if @target.respond_to?("LITERAL")
      @var ||= File.basename(@target.path);Fi[	@DiI"Ç    private
    
    def function
      @var = @target.original_filename if @target.respond_to?("LITERAL")
      @var ||= "STRING";Fi[	@B@öi[[	@Ài,I"±              Sass::Script::Number.new(("LITERAL" - var.value), ["STRING"])
            else
              Compass::Util.compass_warn("STRING")
              var
            end;Fi[	@Ài0I"r            end
          else
            Compass::Util.compass_warn("STRING")
            var
          end;Fi[	@B@ñ]i[[	@î!iI"ã      var.each do |var|
        unless ASPECTS.include?(var) then
          Compass::Util.compass_warn("STRING")
          next
        end;Fi[	@î!i1I"ã      var.each do |var|
        unless ASPECTS.include?(var) then
          Compass::Util.compass_warn("STRING")
          next
        end;Fi[	@¢1I"class Base;Fi[[	@
iI">module Compass
  module Installers
    class Base
    end;Fi[	@õiI"Mmodule Compass
  module Installers
    class Base
      include(Actions);Fi[	@ﬁ^I"%Compass.configuration.serialize);Fi[[	@
i!I"¡        def function
          begin
            (var, Compass.configuration.project_path = Compass.configuration.project_path, nil
            Compass.configuration.serialize)
          ensure;Fi[	@
iI"∑      def function
        begin
          (var, Compass.configuration.project_path = Compass.configuration.project_path, nil
          Compass.configuration.serialize)
        ensure;Fi[	@Çb@Æi[[	@
i"I"·          begin
            (var, Compass.configuration.project_path = Compass.configuration.project_path, nil
            Compass.configuration.serialize)
          ensure
            Compass.configuration.project_path = var;Fi[	@
iI"◊        begin
          (var, Compass.configuration.project_path = Compass.configuration.project_path, nil
          Compass.configuration.serialize)
        ensure
          Compass.configuration.project_path = var;Fi[	@/@|i[[	@Ú>iI"õ      def function(var)
        if @project_types[var].nil? then
          raise(Compass::Error, "STRING")
        else
          eval(@project_types[var]);Fi[	@É$iI"ú        else
          if (var.size > "LITERAL") then
            raise(Compass::Error, "STRING")
          else
            raise(Compass::Error, "STRING");Fi[	I"F#   # => Adds support for moz and webkit to the image() function.;F@i[[	@î!iI"Ê    #
    #   Compass::BrowserSupport.add_support("image", "moz", "webkit")
    #   # => Adds support for moz and webkit to the image() function.
    #
    # This function can be called one or more times in a compass configuration;Fi[	@î!i)I"„    #
    #   Compass::BrowserSupport.remove_support("image", "o", "ms")
    #   # => Adds support for moz and webkit to the image() function.
    #
    # This function can be called one or more times in a compass configuration;Fi[	@§_@Bi[[	@î!iI"ö    def function(var, var)
      var.each do |var|
        unless ASPECTS.include?(var) then
          Compass::Util.compass_warn("STRING")
          next;Fi[	@î!i0I"ö    def function(var, var)
      var.each do |var|
        unless ASPECTS.include?(var) then
          Compass::Util.compass_warn("STRING")
          next;Fi[	I"add_project_configuration;FI"1Compass.add_configuration(options, "STRING");Fi[[	@dBiI"ï      
      def function
        add_project_configuration
        Compass.add_configuration(options, "STRING")
        Compass.discover_extensions!;Fi[	@*iI"∂      
      def function
        add_project_configuration
        Compass.add_configuration(options, "STRING")
        Compass.discover_extensions! unless skip_extension_discovery?;Fi[	@:I"%@var = @target.original_filename;Fi[[	@Û
iI"o    private
    
    def function
      @var = @target.original_filename
      @var = @target.content_type;Fi[	@GiI"q    private
    
    def function
      @var = @target.original_filename
      @var = determine_content_type;Fi[	I"var = (var + "LITERAL");F@|i[[	@Êi8I"ö        if $?.success? then
          (var << var.basename.to_s)
          var = (var + "LITERAL")
        else
          var = var.realpath if var.exist?;Fi[	@˝iI"≠            if var then
              var[var] = ("STRING" << var)
              var = (var + "LITERAL")
            else
              var = (var + ucharenc(var, var, var));Fi[	@±b@±bi[[	@˝iI"Á          when "STRING", "STRING", "STRING", "STRING" then
            var[var] = var[var]
            var = (var + "LITERAL")
            var = (var + "LITERAL")
          when "STRING", "STRING", "STRING", "STRING", "STRING" then;Fi[	@˝iÙI"–          when "STRING", "STRING", "STRING", "STRING", "STRING" then
            var[var] = Unesc[var[var]]
            var = (var + "LITERAL")
            var = (var + "LITERAL")
          when "STRING" then;Fi[	@±bI"next_line;Fi[[	@3
i"I"◊        if (var.strip["LITERAL"] == "STRING") and (var.message == Error.message("LITERAL")) then
          ((var << "STRING") << @next_line.text)
          var = (var + "LITERAL")
          next_line
          retry;Fi[	@3
i=I"ù        if var.eos? then
          ((var << "STRING") << @next_line.text)
          var = (var + "LITERAL")
          next_line
          var.scan("LITERAL");Fi[	I"2var["LITERAL"] = output_style if output_style;FI"#var["LITERAL"] = line_comments;Fi[[	@&iI"æ        end
        var = { "LITERAL" => (var) }
        var["LITERAL"] = output_style if output_style
        var["LITERAL"] = line_comments
        var["LITERAL"] = cache unless cache.nil?;Fi[	@&i6I"ø      def function
        var = { "LITERAL" => (sass_load_paths) }
        var["LITERAL"] = output_style if output_style
        var["LITERAL"] = line_comments
        var["LITERAL"] = cache;Fi[	@P@Hi[[	@a"i[I"~        @var ||= {}
        if block_given? then
          @set_attributes["LITERAL"] = true
          @var = var
        else;Fi[	@a"ivI"~        @var ||= {}
        if block_given? then
          @set_attributes["LITERAL"] = true
          @var = var
        else;Fi[	@‰/@|i[[	@a"i¨I"À        var = ((var.keys - ATTRIBUTES) - ARRAY_ATTRIBUTES)
        if (var.size == "LITERAL") then
          raise(Error, "STRING")
        else
          raise(Error, "STRING") if (var.size > "LITERAL");Fi[	@˝iI"Ü          end
        when (var == "STRING"), (var < Spc) then
          raise(Error, "STRING")
        else
          (var[var] = var;Fi[	I"inherited_reader(*var);FI"inherited_writer(*var);Fi[[	@»i!I"u        
        def function(var)
          inherited_reader(*var)
          inherited_writer(*var)
        end;Fi[	@»iPI"Ä        
        def function(var)
          inherited_reader(*var)
          inherited_writer(*var)
          var.each do |var|;Fi[	@F`I"#var = var.send("LITERAL", var);Fi[[	@Õ<iI"»      
      def function(var, var, var)
        var = "STRING".to_sym
        var = var.send("LITERAL", var)
        if ((var.nil? and options["LITERAL"]) or (var.blank? and options["LITERAL"])) then;Fi[	@EiI"å      
      def function(var, var, var)
        var = "STRING".to_sym
        var = var.send("LITERAL", var)
        unless var.blank? then;Fi[	@è]@<i[[	@f6ibI"|      end
      if var then
        var = "STRING" unless (var["LITERAL"] == "STRING")
        var = "STRING"
      end;Fi[	@f6ièI"|      end
      if var then
        var = "STRING" unless (var["LITERAL"] == "STRING")
        var = "STRING"
      end;Fi[	@◊^@˜-i[[	@iI"Cbegin
  require("sass")
rescue LoadError
  require("rubygems");Fi[	@i
I"\  require("rubygems")
  begin
    require("sass")
  rescue LoadError
    puts("STRING");Fi[	@:I"footer;Fi[[	@.iNI";    end
    
    def function
      footer
      @html;Fi[	@.iSI"V    end
    
    def function
      footer
      Rack::Response.new(@html).finish;Fi[	I"Mvar.on("STRING", "LITERAL", "STRING") { self.options["LITERAL"] = true };F@˚bi[[	@=iI"      self.options["LITERAL"] = true
    end
    var.on("STRING", "LITERAL", "STRING") { self.options["LITERAL"] = true }
    var.on("STRING", "LITERAL", "STRING") { self.options["LITERAL"] = true }
    var.on("STRING", "LITERAL", "STRING") { self.options["LITERAL"] = true };Fi[	@=iI"<    end
    var.on("STRING", "LITERAL", "STRING") { self.options["LITERAL"] = true }
    var.on("STRING", "LITERAL", "STRING") { self.options["LITERAL"] = true }
    var.on("STRING", "LITERAL", "STRING") { self.options["LITERAL"] = true }
    var.on("STRING", "LITERAL", "STRING") { self.options["LITERAL"] = false };Fi[	@˚bI"Nvar.on("STRING", "LITERAL", "STRING") { self.options["LITERAL"] = false };Fi[[	@=i I"o    var.on("STRING", "LITERAL", "STRING") { self.options["LITERAL"] = true }
    var.on("STRING", "LITERAL", "STRING") { self.options["LITERAL"] = true }
    var.on("STRING", "LITERAL", "STRING") { self.options["LITERAL"] = true }
    var.on("STRING", "LITERAL", "STRING") { self.options["LITERAL"] = false }
    var.on_tail("STRING", "STRING", "STRING", "STRING") do;Fi[	@@i!I"Ã      self.options["LITERAL"] = var
    end
    var.on("STRING", "LITERAL", "STRING") { self.options["LITERAL"] = true }
    var.on("STRING", "LITERAL", "STRING") { self.options["LITERAL"] = false }
  end;Fi[	I";var.on_tail("STRING", "STRING", "STRING", "STRING") do;F@›8i[[	@=i"I"    var.on("STRING", "LITERAL", "STRING") { self.options["LITERAL"] = true }
    var.on("STRING", "LITERAL", "STRING") { self.options["LITERAL"] = false }
    var.on_tail("STRING", "STRING", "STRING", "STRING") do
      puts(var)
      exit;Fi[	@ˇiPI"Ω          @options["LITERAL"] = true if RbConfig::CONFIG["STRING"] =~ "LITERAL"
        end
        var.on_tail("STRING", "STRING", "STRING", "STRING") do
          puts(var)
          exit;Fi[	@:I")return "STRING" unless env["STRING"];Fi[[	@/i I"\    end
    
    def function
      return "STRING" unless env["STRING"]
      "STRING";Fi[	@/i%I"\    end
    
    def function
      return "STRING" unless env["STRING"]
      "STRING";Fi[	I"2require("compass/exec/global_options_parser");FI"3require("compass/exec/project_options_parser");Fi[[	@

i I"vrequire("compass/exec/global_options_parser")
require("compass/exec/project_options_parser")
module Compass::Exec;Fi [	@
i I"vrequire("compass/exec/global_options_parser")
require("compass/exec/project_options_parser")
module Compass::Exec;Fi [	@cI"module Compass::Exec;Fi[[	@

iI"Ürequire("compass/exec/global_options_parser")
require("compass/exec/project_options_parser")
module Compass::Exec
  class SubCommandUI;Fi[	@
iI"Çrequire("compass/exec/global_options_parser")
require("compass/exec/project_options_parser")
module Compass::Exec
  class SwitchUI;Fi[	@UI"Qif (var.is_a?(::Compass::Error) or var.is_a?(OptionParser::ParseError)) then;Fi[[	@

iI"⁄        return perform!
      rescue Exception => var
        raise(var) if var.is_a?(SystemExit)
        if (var.is_a?(::Compass::Error) or var.is_a?(OptionParser::ParseError)) then
          $stderr.puts(var.message);Fi[	@
iI"”        perform!
      rescue Exception => var
        raise(var) if var.is_a?(SystemExit)
        if (var.is_a?(::Compass::Error) or var.is_a?(OptionParser::ParseError)) then
          $stderr.puts(var.message);Fi[	@&cI"$stderr.puts(var.message);Fi[[	@

iI"œ      rescue Exception => var
        raise(var) if var.is_a?(SystemExit)
        if (var.is_a?(::Compass::Error) or var.is_a?(OptionParser::ParseError)) then
          $stderr.puts(var.message)
        else;Fi[	@
iI"œ      rescue Exception => var
        raise(var) if var.is_a?(SystemExit)
        if (var.is_a?(::Compass::Error) or var.is_a?(OptionParser::ParseError)) then
          $stderr.puts(var.message)
        else;Fi[	@-c@|i[[	@

iI"¯        raise(var) if var.is_a?(SystemExit)
        if (var.is_a?(::Compass::Error) or var.is_a?(OptionParser::ParseError)) then
          $stderr.puts(var.message)
        else
          ::Compass::Exec::Helpers.report_error(var, (@options or {}));Fi[	@
iI"        raise(var) if var.is_a?(SystemExit)
        if (var.is_a?(::Compass::Error) or var.is_a?(OptionParser::ParseError)) then
          $stderr.puts(var.message)
        else
          ::Compass::Exec::Helpers.report_error(var, @options);Fi[	@:I"(return nil if (length == "LITERAL");Fi[[	@(iI"≤      # Removes the last element from set and returns it, or +nil+ if
      # the set is empty
      def function
        return nil if (length == "LITERAL")
        delete(last);Fi[	@(iI"¡      # Returns the first element of the NodeSet and removes it.  Returns
      # +nil+ if the set is empty.
      def function
        return nil if (length == "LITERAL")
        delete(first);Fi[	I"Avar.on("STRING", "STRING", "LITERAL", "STRING", "STRING") do;FI"(self.options["LITERAL"] = "LITERAL";Fi[[	@
i<I"¥      var.separator("STRING")
      var.separator("STRING")
      var.on("STRING", "STRING", "LITERAL", "STRING", "STRING") do
        self.options["LITERAL"] = "LITERAL"
      end;Fi[	@
i?I"Æ        self.options["LITERAL"] = "LITERAL"
      end
      var.on("STRING", "STRING", "LITERAL", "STRING", "STRING") do
        self.options["LITERAL"] = "LITERAL"
      end;Fi[	I"var = File.new(var).read;F@ÒAi[[	@õiOI"“            copy(var, var, nil, var)
          else
            var = File.new(var).read
            if var.delete("LITERAL") then
              var = TemplateContext.ctx("LITERAL" => (var), "LITERAL" => (var));Fi[	@õi^I"Û        var = templatize(var)
        var = targetize(install_location_for_stylesheet(var, var))
        var = File.new(var).read
        if var.delete("LITERAL") then
          var = TemplateContext.ctx("LITERAL" => (var), "LITERAL" => (var));Fi[	@:I"("STRING" + "STRING");Fi[[	@ci`I"Ñ      ##
      # Builds the full mongodump string based on all attributes
      def function
        ("STRING" + "STRING")
      end;Fi[	@iNI"Ñ      ##
      # Builds the full mysqldump string based on all attributes
      def function
        ("STRING" + "STRING")
      end;Fi[	I"S# Paths can use unix style "/" and will be corrected for the current platform.;F@£i[[	@õiîI"      
      # returns an absolute path given a path relative to the current installation target.
      # Paths can use unix style "/" and will be corrected for the current platform.
      def function(var)
        strip_trailing_separator(File.join(target_path, separate(var)));Fi[	@õiöI"      
      # returns an absolute path given a path relative to the current template.
      # Paths can use unix style "/" and will be corrected for the current platform.
      def function(var)
        strip_trailing_separator(File.join(template_path, separate(var)));Fi[	@ÕPI"$$stdout.write(color("LITERAL"));Fi[[	@
i!I"|    def function
      begin
        ($stderr.write(color("LITERAL"))
        $stdout.write(color("LITERAL"))
        yield);Fi[	@
i,I"|    def function
      begin
        ($stderr.write(color("LITERAL"))
        $stdout.write(color("LITERAL"))
        yield);Fi[	@^c@≠i[[	@
i"I"}      begin
        ($stderr.write(color("LITERAL"))
        $stdout.write(color("LITERAL"))
        yield)
      ensure;Fi[	@
i-I"}      begin
        ($stderr.write(color("LITERAL"))
        $stdout.write(color("LITERAL"))
        yield)
      ensure;Fi[	@:I"&var = self.site.posts.index(self);Fi[[	@
i„I"à    end
    
    def function
      var = self.site.posts.index(self)
      if var and (var < (self.site.posts.length - "LITERAL")) then;Fi[	@
iÏI"î    end
    
    def function
      var = self.site.posts.index(self)
      var and (var > "LITERAL") ? (self.site.posts[(var - "LITERAL")]) : (nil);Fi[	@g#I"Evar = Sass::Script::Color.new(["LITERAL", "LITERAL", "LITERAL"]);Fi[[	@j#i(I"¥  def function(var, var)
    assert_type(var, "LITERAL")
    assert_type(var, "LITERAL")
    var = Sass::Script::Color.new(["LITERAL", "LITERAL", "LITERAL"])
    mix(var, var, var);Fi[	@j#i/I"¥  def function(var, var)
    assert_type(var, "LITERAL")
    assert_type(var, "LITERAL")
    var = Sass::Script::Color.new(["LITERAL", "LITERAL", "LITERAL"])
    mix(var, var, var);Fi[	@g#I"<raise(Sass::SyntaxError, "STRING") unless var.unitless?;Fi[[	@{#i&I"  def function(var, var)
    assert_type(var, "LITERAL")
    assert_type(var, "LITERAL")
    raise(Sass::SyntaxError, "STRING") unless var.unitless?
    var = Math.log(var.value, var.value) rescue (Math.log(var.value) / Math.log(var.value));Fi[	@{#i<I"˜  def function(var, var)
    assert_type(var, "LITERAL")
    assert_type(var, "LITERAL")
    raise(Sass::SyntaxError, "STRING") unless var.unitless?
    Sass::Script::Number.new((var.value ** var.value), var.numerator_units, var.denominator_units);Fi[	I"9# returns the opposite position of a side or corner.;F@£i[[	@ÀiI"¸      Sass::Script::Bool.new((var.is_a?(Sass::Script::List) and var.value.all? { |var| is_position(var).to_bool }))
    end
    # returns the opposite position of a side or corner.
    def function(var)
      var = if var.is_a?(Sass::Script::List) then;Fi[	@Ài@I"ë    end
  else
    # returns the opposite position of a side or corner.
    def function(var)
      var = var.value.split("LITERAL").map do |var|;Fi[	I"0var = if var.is_a?(Sass::Script::List) then;F@ﬁAi[[	@ÀiI"»    # returns the opposite position of a side or corner.
    def function(var)
      var = if var.is_a?(Sass::Script::List) then
        Sass::Script::List.new(var.value.dup, var.separator)
      else;Fi[	@¶iπI"ü    def function(var)
      var = var
      var = if var.is_a?(Sass::Script::List) then
        Sass::Script::List.new(var.value.dup, var.separator)
      else;Fi[	@:I"return @url if @url;Fi[[	@iKI"q    #
    # Returns the String url.
    def function
      return @url if @url
      var = if permalink then;Fi[	@
iÑI"q    #
    # Returns the String URL.
    def function
      return @url if @url
      var = if permalink then;Fi[	I",if var.is_a?(Sass::Script::String) then;FI"var = (var + "STRING");Fi[[	@f6iiI"Å      end
      if var.to_bool then
        if var.is_a?(Sass::Script::String) then
          var = (var + "STRING")
        else;Fi[	@f6iñI"Å      end
      if var.to_bool then
        if var.is_a?(Sass::Script::String) then
          var = (var + "STRING")
        else;Fi[	I"#(var << color_stops.to_s(var));F@∫ i[[	@¶i`I"»      ((var << position.to_s(var)) << "STRING") if position
      ((var << shape_and_size.to_s(var)) << "STRING") if shape_and_size
      (var << color_stops.to_s(var))
      (var << "STRING")
    end;Fi[	@¶iãI"ß      var = "STRING"
      ((var << position_or_angle.to_s(var)) << "STRING") if position_or_angle
      (var << color_stops.to_s(var))
      (var << "STRING")
    end;Fi[	@9L@i[[	@¶iŒI"¬        case var.value
        when "LITERAL" then
          Sass::Script::Number.new("LITERAL", ["STRING"])
        when "LITERAL" then
          Sass::Script::Number.new("LITERAL", ["STRING"]);Fi[	@¶i–I"Â          Sass::Script::Number.new("LITERAL", ["STRING"])
        when "LITERAL" then
          Sass::Script::Number.new("LITERAL", ["STRING"])
        when "LITERAL" then
          Sass::Script::Number.new("LITERAL", ["STRING"]);Fi[	I"ColorStop.new(var);F@|i[[	@¶i‡I"ô        else
          if Sass::Script::Color.===(var) then
            ColorStop.new(var)
          else
            if Sass::Script::List.===(var) then;Fi[	@¶iÊI"…            else
              if Sass::Script::String.===(var) and (var.value == "STRING") then
                ColorStop.new(var)
              else
                raise(Sass::SyntaxError, "STRING");Fi[	@:I"var = fixture("STRING");Fi[[	@Ï iAI"V  end
  
  def function
    var = fixture("STRING")
    HOMEBREW_REPOSITORY.cd do;Fi[	@Ï iUI"V  end
  
  def function
    var = fixture("STRING")
    HOMEBREW_REPOSITORY.cd do;Fi[	@:I"0ENV.expects("LITERAL").yields.returns(true);Fi[[	@ô:i/I"g  end
  
  def function
    ENV.expects("LITERAL").yields.returns(true)
    ENV.expects("LITERAL");Fi[	@ô:i9I"g  end
  
  def function
    ENV.expects("LITERAL").yields.returns(true)
    ENV.expects("LITERAL");Fi[	@:I"-var = Patches.new("LITERAL" => "STRING");Fi[[	@¸'i!I"y  end
  
  def function
    var = Patches.new("LITERAL" => "STRING")
    assert_equal("LITERAL", var.patches.length);Fi[	@¸'i(I"y  end
  
  def function
    var = Patches.new("LITERAL" => "STRING")
    assert_equal("LITERAL", var.patches.length);Fi[	@:I"@keg.link;Fi[[	@˘'iI"S  end
  
  def function
    @keg.link
    assert_equal("LITERAL", @keg.unlink);Fi[	@˘'i(I"a  end
  
  def function
    @keg.link
    assert_raise(RuntimeError, "STRING") { @keg.link };Fi[	I"var.value.first;F@|i[[	@1i#I"à    assert_type(var, "LITERAL")
    if (var.value == "STRING") then
      var.value.first
    else
      if (var.value == "STRING") then;Fi[	@1i]I"É    else
      if defined? Sass::Script::List and var.is_a?(Sass::Script::List) then
        var.value.first
      else
        var;Fi[	@0HI"var.generate;Fi[[	@4i$I"u  #      }
  def function(var)
    verify_map(var, "STRING")
    var.generate
    inline_image(sprite_path(var));Fi[	@4i}I"•  # Returns a url to the sprite image.
  def function(var)
    verify_map(var, "STRING")
    var.generate
    generated_image_url(Sass::Script::String.new("STRING"));Fi[	@zA@0Hi[[	@4i]I"√  # Returns the path to the original image file for the sprite with the given name
  def function(var, var)
    var = convert_sprite_name(var)
    verify_map(var, "STRING")
    verify_sprite(var);Fi[	@4iöI"∏    assert_type(var, "LITERAL")
    assert_type(var, "LITERAL")
    var = convert_sprite_name(var)
    verify_map(var, "STRING")
    unless var and var.is_a?(Sass::Script::String) then;Fi[	@:I"+var = IncompleteStableSpecTestBall.new;Fi[[	@3iæI"d  end
  
  def function
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head);Fi[	@3iÕI"d  end
  
  def function
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head);Fi[	@{AI"verify_sprite(var);Fi[[	@4ilI"ß  def function(var, var)
    var = convert_sprite_name(var)
    verify_map(var)
    verify_sprite(var)
    Sass::Script::Bool.new(var.image_for(var.value).parent.nil?);Fi[	@4ivI"ü  def function(var, var, var)
    var = convert_sprite_name(var)
    verify_map(var)
    verify_sprite(var)
    unless VALID_SELECTORS.include?(var.value) then;Fi[	@:I"ARGV.push("STRING");Fi[[	@3iyI"O  end
  
  def function
    ARGV.push("STRING")
    var = SpecTestBall.new;Fi[	@3iI"O  end
  
  def function
    ARGV.push("STRING")
    var = SpecTestBall.new;Fi[	@gA@ïci[[	@f6ihI"ß        Compass.configuration.asset_host.call(var)
      end
      if var.to_bool then
        if var.is_a?(Sass::Script::String) then
          var = (var + "STRING");Fi[	@f6iïI"ß        Compass.configuration.asset_host.call(var)
      end
      if var.to_bool then
        if var.is_a?(Sass::Script::String) then
          var = (var + "STRING");Fi[	@:I""@d.add("LITERAL" => "STRING");Fi[[	@ñ:i5I"a  end
  
  def function
    @d.add("LITERAL" => "STRING")
    @d.add("LITERAL" => "LITERAL");Fi[	@ñ:iAI"Ñ  end
  
  def function
    @d.add("LITERAL" => "STRING")
    assert_equal("STRING", @d.find_requirement(X11Dependency).min_version);Fi[	@:I"@d.add("LITERAL");Fi[[	@ñ:i+I"i  end
  
  def function
    @d.add("LITERAL")
    assert_not_nil(@d.find_requirement(X11Dependency));Fi[	@ñ:i<I"l  end
  
  def function
    @d.add("LITERAL")
    assert_empty(@d.find_requirement(X11Dependency).tags);Fi[	I"var = $1;F@|i[[	@f6iQI"—      var = var.value
      if var =~ /^#{Regexp.escape(Compass.configuration.http_images_path)}STRING/ then
        var = $1
      else
        return Sass::Script::String.new("STRING") if absolute_path?(var);Fi[	@f6i~I"€      var = var.value
      if var =~ /^#{Regexp.escape(Compass.configuration.http_generated_images_path)}STRING/ then
        var = $1
      else
        return Sass::Script::String.new("STRING") if absolute_path?(var);Fi[	@ñc@|i[[	@f6ijI"£      if var.to_bool then
        if var.is_a?(Sass::Script::String) then
          var = (var + "STRING")
        else
          var = cache_busted_path(var, var);Fi[	@f6ióI"£      if var.to_bool then
        if var.is_a?(Sass::Script::String) then
          var = (var + "STRING")
        else
          var = cache_busted_path(var, var);Fi[	@:I"((@deps << Dependency.new("STRING"));Fi[[	@ê:iI"w  end
  
  def function
    (@deps << Dependency.new("STRING"))
    (@deps << Dependency.new("STRING", "LITERAL"));Fi[	@ê:iI"l  end
  
  def function
    (@deps << Dependency.new("STRING"))
    (@deps << Dependency.new("STRING"));Fi[	@:I"var = mock("STRING");Fi[[	@;Ai&I"a  end
  
  def function
    var = mock("STRING")
    (@env << Proc.new { var.some_message });Fi[	@;Ai-I"g  end
  
  def function
    var = mock("STRING")
    (@env << Proc.new { |var| var.some_message });Fi[	I"require("forwardable");F@Ä#i[[	@è#i I"Brequire("forwardable")
module Compass
  module SassExtensions;Fi [	@ï#i I"Brequire("forwardable")
module Compass
  module SassExtensions;Fi [	I"-# Calculates the overal image dimensions;FI"@# collects image sizes and input parameters for each sprite;Fi[[	@í#i%I"û        end
        
        # Calculates the overal image dimensions
        # collects image sizes and input parameters for each sprite
        def function;Fi[	@ûiI"-        # Changing this string will invalidate all previously generated sprite images.
        # We should do so only when the packing algorithm changes
        # Calculates the overal image dimensions
        # collects image sizes and input parameters for each sprite
        # Calculates the height;Fi[	I"next if (var == "LITERAL");FI"%var = @images[(var - "LITERAL")];Fi[[	@í#iÄI"’              var.position.value
            end
            next if (var == "LITERAL")
            var = @images[(var - "LITERAL")]
            var.left = ((var.left + var.width) + [var.spacing, var.spacing].max);Fi[	@í#içI"⁄              var.position.value
            end).to_i
            next if (var == "LITERAL")
            var = @images[(var - "LITERAL")]
            var.top = ((var.top + var.height) + [var.spacing, var.spacing].max);Fi[	I""var, var = path_and_name(var);F@öi[[	@*iEI"]    
    def self.sprite_name(var)
      var, var = path_and_name(var)
      var
    end;Fi[	@*iJI"V    
    def self.path(var)
      var, var = path_and_name(var)
      var
    end;Fi[	@:I"case @language;Fi[[	@ iI"G  end
  
  def function
    case @language
    when "LITERAL" then;Fi[	@ i-I"G  end
  
  def function
    case @language
    when "LITERAL" then;Fi[	@:I"#return unless f.lib.directory?;Fi[[	@—i)I"  end
  
  def function
    return unless f.lib.directory?
    var = f.lib.children.select { |var| var.to_s =~ "LITERAL" };Fi[	@—i8I"≥  end
  
  def function
    return unless f.lib.directory?
    var = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"];Fi[	@:I"-if (f.prefix + "STRING").directory? then;Fi[[	@—iI"^  end
  
  def function
    if (f.prefix + "STRING").directory? then
      opoo("STRING");Fi[	@—i I"^  end
  
  def function
    if (f.prefix + "STRING").directory? then
      opoo("STRING");Fi[	@:I")raise("STRING") unless self.symlink?;Fi[[	@J
iI"ä  end
  
  def function
    raise("STRING") unless self.symlink?
    system("STRING", "STRING", self.to_s, (self.dirname + "STRING").to_s);Fi[	@J
i"I"î  end
  
  def function
    raise("STRING") unless self.symlink?
    system("STRING", "STRING", "STRING", self.to_s, (self.dirname + "STRING").to_s);Fi[	@:I"nostdout do;Fi[[	@Ô'imI"K  end
  
  def function
    nostdout do
      assert_nothing_raised do;Fi[	@3iI"d  include(VersionAssertions)
  
  def function
    nostdout do
      TestBall.new.brew do |var|;Fi[	@:I"var = Dir.getwd;Fi[[	@Èi:I"I  end
  
  def function
    var = Dir.getwd
    Dir.chdir(@clone) do;Fi[	@ÈiüI"I  end
  
  def function
    var = Dir.getwd
    Dir.chdir(@clone) do;Fi[	@v1I"var = (var.last or var);Fi[[	@≥iGI"π      def function(var, var)
        var = var.extract_options!
        var = Devise::Mapping.find_scope!(var)
        var = (var.last or var)
        expire_session_data_after_sign_in!;Fi[	@≥iπI"≠      def function(var, var)
        var = var.extract_options!
        var = Devise::Mapping.find_scope!(var)
        var = (var.last or var)
        sign_in(var, var, var);Fi[	I"-#   sign_out :user     # sign_out(scope);FI"0#   sign_out @user     # sign_out(resource);Fi[[	@≥i[I"Ç      # Examples:
      #
      #   sign_out :user     # sign_out(scope)
      #   sign_out @user     # sign_out(resource)
      #;Fi[	@Qi1I"}    # Examples:
    #
    #   sign_out :user     # sign_out(scope)
    #   sign_out @user     # sign_out(resource)
    #;Fi[	@ud@i[[	@≥i\I"à      #
      #   sign_out :user     # sign_out(scope)
      #   sign_out @user     # sign_out(resource)
      #
      def function(var);Fi[	@Qi2I"~    #
    #   sign_out :user     # sign_out(scope)
    #   sign_out @user     # sign_out(resource)
    #
    def function(var);Fi[	I"(var = var ? ("STRING") : ("STRING");F@<i[[	@P@iI"·          ["LITERAL", "LITERAL"].each do |var|
            var.each do |var|
              var = var ? ("STRING") : ("STRING")
              var = "STRING"
              class_eval("STRING", "STRING", ("LITERAL" + "LITERAL"));Fi[	@>-iI"m  
  def function(var, var)
    var = var ? ("STRING") : ("STRING")
    var = "STRING"
    var.html_safe;Fi[	@bI"#       mailer:;Fi[[	@'iHI"o      #
      #   en:
      #     devise:
      #       mailer:
      #         confirmation_instructions:;Fi[	@'iPI"o      #
      #   en:
      #     devise:
      #       mailer:
      #         confirmation_instructions:;Fi[	@âdI")#         confirmation_instructions:;Fi[[	@'iII"à      #   en:
      #     devise:
      #       mailer:
      #         confirmation_instructions:
      #           user_subject: '...';Fi[	@'iQI"É      #   en:
      #     devise:
      #       mailer:
      #         confirmation_instructions:
      #           subject: '...';Fi[	@:@¡Ci[[	@i.I"ä  private
  
  def function
    HOMEBREW_REPOSITORY.cd do
      `git rev-list --abbrev-commit HEAD -- Library/Formula/#{name}STRING`.split;Fi[	@Ï i0I"V  end
  
  def function
    HOMEBREW_REPOSITORY.cd do
      var = UpdaterMock.new;Fi[	@:@KLi[[	@i	I"í  extend(self)
  
  def function
    raise("STRING") unless which("STRING")
    raise("STRING") unless (HOMEBREW_REPOSITORY / "STRING").directory?;Fi[	@ÈiI"Z  end
  
  def function
    raise("STRING") unless which("STRING")
    ohai("STRING");Fi[	I"4#   confirmation_period_valid?   # returns true;F@i[[	@0ixI"Ô      #
      #   # allow_unconfirmed_access_for = 1.day and confirmation_sent_at = today
      #   confirmation_period_valid?   # returns true
      #
      #   # allow_unconfirmed_access_for = 5.days and confirmation_sent_at = 4.days.ago;Fi[	@0i{I"ı      #
      #   # allow_unconfirmed_access_for = 5.days and confirmation_sent_at = 4.days.ago
      #   confirmation_period_valid?   # returns true
      #
      #   # allow_unconfirmed_access_for = 5.days and confirmation_sent_at = 5.days.ago;Fi[	I"*self.errors.add("LITERAL", "LITERAL");F@ni[[	@0ióI"m          yield
        else
          self.errors.add("LITERAL", "LITERAL")
          false
        end;Fi[	@i|I"m          yield
        else
          self.errors.add("LITERAL", "LITERAL")
          false
        end;Fi[	I"*# Options must contain the user email;F@£i[[	@0i¿I"L        # confirmation instructions to it. If not, try searching for a user by unconfirmed_email
        # field. If no user is found, returns a new user with an email not found error.
        # Options must contain the user email
        def function(var)
          var = find_by_unconfirmed_email_with_errors(var) if reconfirmable;Fi[	@iÖI"
        # unlock instructions to it. If not user is found, returns a new user
        # with an email not found error.
        # Options must contain the user email
        def function(var)
          var = find_or_initialize_with_errors(unlock_keys, var, "LITERAL");Fi[	@:I"4raise(KegUnspecifiedError) if ARGV.named.empty?;Fi[[	@ni	I"†  extend(self)
  
  def function
    raise(KegUnspecifiedError) if ARGV.named.empty?
    if Process.uid.zero? and File.stat(HOMEBREW_BREW_FILE).uid.zero?.! then;Fi[	I"*projects//homebrew_proj/cmd/unlink.rb;TiI"u  extend(self)
  
  def function
    raise(KegUnspecifiedError) if ARGV.named.empty?
    ARGV.kegs.each do |var|;Fi[	I"var.delete("LITERAL");F@¿di[[	@ªiJI"ã      #
      def function(var, var)
        var.delete("LITERAL")
        var.delete("LITERAL")
        var = update_attributes(var, *var);Fi[	@i)I"ı        @var = [{ "LITERAL" => (build_matcher(var, "LITERAL", "LITERAL")), "LITERAL" => (build_matcher(var, "LITERAL", "LITERAL")) }]
      else
        var.delete("LITERAL")
        var.delete("LITERAL")
        @var = var.collect do |var, var|;Fi[	I"clean_up_passwords;F@öi[[	@ªi9I"Q          false
        end
        clean_up_passwords
        var
      end;Fi[	@ªiMI"~        var.delete("LITERAL")
        var = update_attributes(var, *var)
        clean_up_passwords
        var
      end;Fi[	I"self.password = var;FI"%self.password_confirmation = var;Fi[[	@iI"√      # the passwords are valid and the record was saved, false otherwise.
      def function(var, var)
        self.password = var
        self.password_confirmation = var
        if valid? then;Fi[	@'
i∫I"•    self["LITERAL"] = "STRING"
    var = SecureRandom.hex("LITERAL")
    self.password = var
    self.password_confirmation = var
    self.save("LITERAL" => (false));Fi[	I"6#   reset_password_period_valid?   # returns true;F@i[[	@i)I"Á      #
      #   # reset_password_within = 1.day and reset_password_sent_at = today
      #   reset_password_period_valid?   # returns true
      #
      #   # reset_password_within = 5.days and reset_password_sent_at = 4.days.ago;Fi[	@i,I"Ì      #
      #   # reset_password_within = 5.days and reset_password_sent_at = 4.days.ago
      #   reset_password_period_valid?   # returns true
      #
      #   # reset_password_within = 5.days and reset_password_sent_at = 5.days.ago;Fi[	I"&var = [nil, "LITERAL", "LITERAL"];FI"]var.add_module("LITERAL", "LITERAL" => "LITERAL", "LITERAL" => ({ "LITERAL" => (var) }));Fi[[	I",projects//devise_proj/devise/modules.rb;TiI"WDevise.with_options("LITERAL" => (true)) do |var|
  var.with_options("LITERAL" => (true)) do |var|
    var = [nil, "LITERAL", "LITERAL"]
    var.add_module("LITERAL", "LITERAL" => "LITERAL", "LITERAL" => ({ "LITERAL" => (var) }))
    var.add_module("LITERAL", "LITERAL" => "LITERAL", "LITERAL" => ({ "LITERAL" => (var) }), "LITERAL" => (true));Fi[	@·diI":  end
  var.add_module("LITERAL", "LITERAL" => "LITERAL", "LITERAL" => "LITERAL")
  var = [nil, "LITERAL", "LITERAL"]
  var.add_module("LITERAL", "LITERAL" => "LITERAL", "LITERAL" => ({ "LITERAL" => (var) }))
  var.add_module("LITERAL", "LITERAL" => "LITERAL", "LITERAL" => ({ "LITERAL" => ((var << "LITERAL")) }));Fi[	@:I"2if instance_variable_defined?("LITERAL") then;Fi[[	@¯i!I"[  end
  
  def function
    if instance_variable_defined?("LITERAL") then
      @xcode;Fi[	@¯i-I"Y  end
  
  def function
    if instance_variable_defined?("LITERAL") then
      @clt;Fi[	I"#     devise_for :users;F@i[[	@æiâI"O    #
    #   scope "/my" do
    #     devise_for :users
    #   end
    #;Fi[	@æiêI"S    #
    #   scope ":locale" do
    #     devise_for :users
    #   end
    #;Fi[	I"Gvar["LITERAL"] ||= @scope["LITERAL"] if @scope["LITERAL"].present?;F@Ùdi[[	@æi∑I"      @var = false
      var = var.extract_options!
      var["LITERAL"] ||= @scope["LITERAL"] if @scope["LITERAL"].present?
      var["LITERAL"] ||= @scope["LITERAL"] if @scope["LITERAL"].present?
      var["LITERAL"] ||= @scope["LITERAL"] if @scope["LITERAL"].present?;Fi[	@æi∏I"J      var = var.extract_options!
      var["LITERAL"] ||= @scope["LITERAL"] if @scope["LITERAL"].present?
      var["LITERAL"] ||= @scope["LITERAL"] if @scope["LITERAL"].present?
      var["LITERAL"] ||= @scope["LITERAL"] if @scope["LITERAL"].present?
      var["LITERAL"] = (@scope["LITERAL"] or {}).merge((var["LITERAL"] or {}));Fi[	I"Mvar["LITERAL"] = (@scope["LITERAL"] or {}).merge((var["LITERAL"] or {}));F@˚di[[	@æi∫I"~      var["LITERAL"] ||= @scope["LITERAL"] if @scope["LITERAL"].present?
      var["LITERAL"] ||= @scope["LITERAL"] if @scope["LITERAL"].present?
      var["LITERAL"] = (@scope["LITERAL"] or {}).merge((var["LITERAL"] or {}))
      var["LITERAL"] = (@scope["LITERAL"] or {}).merge((var["LITERAL"] or {}))
      var["LITERAL"] = (@scope["LITERAL"] or {}).merge((var["LITERAL"] or {}));Fi[	@æiªI"f      var["LITERAL"] ||= @scope["LITERAL"] if @scope["LITERAL"].present?
      var["LITERAL"] = (@scope["LITERAL"] or {}).merge((var["LITERAL"] or {}))
      var["LITERAL"] = (@scope["LITERAL"] or {}).merge((var["LITERAL"] or {}))
      var["LITERAL"] = (@scope["LITERAL"] or {}).merge((var["LITERAL"] or {}))
      var["LITERAL"] = (@scope["LITERAL"] or {});Fi[	@ñ]@|i[[	@Ÿi5I"s      else
        if var.file?.! then
          next
        else
          if (var.extname == "STRING") then;Fi[	@niI"â      if var.dry_run and var.overwrite then
        print("STRING") { var.link(var) }
        next
      else
        if var.dry_run then;Fi[	I"-#     root :to => "admin/dashboard#show";F@i[[	@æiËI"Ç    #
    #   authenticate :user, lambda {|u| u.role == "admin"} do
    #     root :to => "admin/dashboard#show"
    #   end
    #;Fi[	@æiˇI"É    #
    #   authenticated :user, lambda {|u| u.role == "admin"} do
    #     root :to => "admin/dashboard#show"
    #   end
    #;Fi[	I"&require("devise/strategies/base");F@
i[[	@≠
i I"Hrequire("devise/strategies/base")
module Devise
  module Strategies;Fi [	@±i I"Hrequire("devise/strategies/base")
module Devise
  module Strategies;Fi [	@µ2@”i[[	@Îi&I"H  end
  
  module Strategies
    autoload("LITERAL", "STRING")
    ;Fi[	@3iI"I  end
  
  module Strategies
    autoload("LITERAL", "STRING")
  end;Fi[	I"2#   * If all authentication keys are present;;F@i[[	@≠
i>I"À      #   * Validating if the model allows params authentication;
      #   * If any of the authorization headers were sent;
      #   * If all authentication keys are present;
      #
      def function;Fi[	@≠
iII"÷      #   * If the request hits the sessions controller through POST;
      #   * If the params[scope] returns a hash with credentials;
      #   * If all authentication keys are present;
      #
      def function;Fi[	I"1require("devise/strategies/authenticatable");F@
i[[	@Ω2i I"Srequire("devise/strategies/authenticatable")
module Devise
  module Strategies;Fi [	@Æi I"Srequire("devise/strategies/authenticatable")
module Devise
  module Strategies;Fi [	@;2@<i[[	@
iNI"ù        end
      when "STRING" then
        var = var["STRING"]
        var = "STRING"
        (var << ("STRING" + var["STRING"])) unless var["STRING"].nil?;Fi[	@
iRI"“        (var << ("STRING" + var["STRING"])) unless var["STRING"].nil?
      when "STRING" then
        var = var["STRING"]
        var = "STRING"
        var["STRING"]["STRING"].each { |var| (var << "STRING") };Fi[	@;2@	i[[	@}iI"v    def self.build(var, var)
      var = var["STRING"]
      var = var["STRING"]
      puts("STRING")
      begin;Fi[	@}i!I"ë      require("directory_watcher")
      var = var["STRING"]
      var = var["STRING"]
      puts("STRING")
      var = DirectoryWatcher.new(var);Fi[	@:I"if superenv? then;Fi[[	@º
i
I"~  extend(self)
  
  def function
    if superenv? then
      ENV.deps = ARGV.formulae.map(&"LITERAL") unless ARGV.named.empty?;Fi[	@¢+i
I"P  extend(self)
  
  def function
    if superenv? then
      ENV.x11 = true;Fi[	I"require("securerandom");F@
i[[	@Îi
I"prequire("orm_adapter")
require("set")
require("securerandom")
module Devise
  autoload("LITERAL", "STRING");Fi[	@@@i I">require("securerandom")
module Devise
  module Generators;Fi [	@:I"system("STRING");Fi[[	@ÏiPI"7  end
  
  def function
    system("STRING")
  end;Fi[	@€i/I"7  end
  
  def function
    system("STRING")
  end;Fi[	I"@var = t("STRING");F@îi[[	I"=projects//diaspora_proj/controllers/admins_controller.rb;Ti3I"}    when "STRING" then
      var = "LITERAL".week
      @var = t("STRING")
    when "STRING" then
      var = "LITERAL".weeks;Fi[	@Nei6I"~    when "STRING" then
      var = "LITERAL".weeks
      @var = t("STRING")
    when "STRING" then
      var = "LITERAL".month;Fi[	@>D@2i[[	@“inI"‚    if var then
      if current_user.update_post(var, params["LITERAL"]) then
        flash.now["LITERAL"] = I18n.t("STRING")
        respond_to do |var|
          var.js { render("LITERAL" => (var), "LITERAL" => "LITERAL") };Fi[	@“isI"ó        end
      else
        flash.now["LITERAL"] = I18n.t("STRING")
        respond_to do |var|
          var.html { redirect_to(["LITERAL", var]) };Fi[	@:I"var = @options["LITERAL"];Fi[[	@iöI"}    end
    
    def function
      var = @options["LITERAL"]
      var.respond_to?("LITERAL") ? (var.call(instance)) : (var);Fi[	@ciRI"z      end
      
      def function
        var = @options["LITERAL"]
        var = var.call(self) if var.is_a?(Proc);Fi[	@€@I"-var.html { redirect_to("LITERAL", var) };Fi[[	I"=projects//diaspora_proj/controllers/blocks_controller.rb;TiI"¬      var = { "LITERAL" => (t("STRING")) }
    end
    respond_with do |var|
      var.html { redirect_to("LITERAL", var) }
      var.json { render("LITERAL" => (true), "LITERAL" => "LITERAL") };Fi[	@ceiI"¬      var = { "LITERAL" => (t("STRING")) }
    end
    respond_with do |var|
      var.html { redirect_to("LITERAL", var) }
      var.json { render("LITERAL" => (true), "LITERAL" => "LITERAL") };Fi[	@:I"manipulate! do |var|;Fi[[	@„i(I"E  end
  
  def function
    manipulate! do |var|
      var.strip;Fi[	@ÊiI"Z  process("LITERAL")
  
  def function
    manipulate! do |var|
      var.auto_orient;Fi[	@:I"case self.service;Fi[[	@≥
iYI"X  
  # @return [String]
  def function
    case self.service
    when "STRING" then;Fi[	@≥
ieI"X  
  # @return [String]
  def function
    case self.service
    when "STRING" then;Fi[	@2I"Bvar.js { render("LITERAL" => (var), "LITERAL" => "LITERAL") };Fi[[	@B!iI"ˆ      flash.now["LITERAL"] = I18n.t("STRING")
      var = var ? (var.errors.full_messages) : (t("STRING"))
      respond_to do |var|
        var.js { render("LITERAL" => (var), "LITERAL" => "LITERAL") }
        var.html { redirect_to("LITERAL") };Fi[	@“ioI"ﬁ      if current_user.update_post(var, params["LITERAL"]) then
        flash.now["LITERAL"] = I18n.t("STRING")
        respond_to do |var|
          var.js { render("LITERAL" => (var), "LITERAL" => "LITERAL") }
        end;Fi[	@:I"self.person.lock_access!;Fi[[	I"6projects//diaspora_proj/models/account_deleter.rb;TiUI"X  end
  
  def function
    self.person.lock_access!
    self.person.clear_profile!;Fi[	@'
iØI"O  end
  
  def function
    self.person.lock_access!
    self.lock_access!;Fi[	@:I".find_current_user_post(params["LITERAL"]);Fi[[	@Y#iII"j  end
  
  def function
    find_current_user_post(params["LITERAL"])
    current_user.retract(@post);Fi[	@Y#iSI"p  end
  
  def function
    find_current_user_post(params["LITERAL"])
    @post.favorite = @post.favorite.!;Fi[	@2@Ai[[	@b#i I"Á    var = current_user.tag_followings.find_by_tag_id(params["STRING"])
    if var and var.destroy then
      respond_to do |var|
        var.any("LITERAL", "LITERAL") do
          render("LITERAL" => (true), "LITERAL" => "LITERAL");Fi[	@b#i&I"ì      end
    else
      respond_to do |var|
        var.any("LITERAL", "LITERAL") do
          render("LITERAL" => (true), "LITERAL" => "LITERAL");Fi[	@2I"-var.html { redirect_to(post_path(var)) };Fi[[	@Y#i7I"  def function
    var = Post.visible_from_author(@post.author, current_user).newer(@post)
    respond_to do |var|
      var.html { redirect_to(post_path(var)) }
      var.json { render("LITERAL" => (PostPresenter.new(var, current_user))) };Fi[	@Y#i?I"  def function
    var = Post.visible_from_author(@post.author, current_user).older(@post)
    respond_to do |var|
      var.html { redirect_to(post_path(var)) }
      var.json { render("LITERAL" => (PostPresenter.new(var, current_user))) };Fi[	@2I"(var.html { redirect_to("LITERAL") };Fi[[	@B5i5I"˜      current_user.participate!(@status_message)
      flash["LITERAL"] = successful_mention_message if coming_from_profile_page?
      respond_to do |var|
        var.html { redirect_to("LITERAL") }
        var.mobile { redirect_to(stream_path) };Fi[	@B5i=I"à      end
    else
      respond_to do |var|
        var.html { redirect_to("LITERAL") }
        var.mobile { redirect_to(stream_path) };Fi[	@"RI"@var = @contact.aspects;Fi[[	@“iI"£      @var = (@person.!=(current_user.person) and @contact)
      @var = []
      if @contact then
        @var = @contact.aspects
        @var = @contact.contacts;Fi[	@B5iI"Æ      @var = current_user.contact_for(@person)
      @var = []
      if @contact then
        @var = @contact.aspects
        @var = @aspects_with_person.map { |var| var.id };Fi[	I"var.html do;F@n!i[[	@=5iI"œ      respond_to do |var|
        var.js { render("LITERAL" => (I18n.t("STRING")), "LITERAL" => "LITERAL") }
        var.html do
          flash["LITERAL"] = I18n.t("STRING")
          redirect_to("LITERAL");Fi[	@“iTI"Í      respond_to do |var|
        var.json { render("LITERAL" => (true), "LITERAL" => "LITERAL") }
        var.html do
          flash["LITERAL"] = I18n.t("STRING")
          if StatusMessage.find_by_guid(var.status_message_guid) then;Fi[	@:I"Lvar = current_user.photos.where("LITERAL" => (params["LITERAL"])).first;Fi[[	@“iNI"x  end
  
  def function
    var = current_user.photos.where("LITERAL" => (params["LITERAL"])).first
    if var then;Fi[	@“ijI"x  end
  
  def function
    var = current_user.photos.where("LITERAL" => (params["LITERAL"])).first
    if var then;Fi[	@n!I"redirect_to("LITERAL");Fi[[	@=5iI"¡        var.js { render("LITERAL" => (I18n.t("STRING")), "LITERAL" => "LITERAL") }
        var.html do
          flash["LITERAL"] = I18n.t("STRING")
          redirect_to("LITERAL")
        end;Fi[	@EiFI"í  def function
    unless AppConfig.settings.invitations.open? then
      flash["LITERAL"] = I18n.t("STRING")
      redirect_to("LITERAL")
    end;Fi[	I")var = { "LITERAL" => (t("STRING")) };F@|i[[	@ceiI"õ    if var.save then
      disconnect_if_contact(var.person)
      var = { "LITERAL" => (t("STRING")) }
    else
      var = { "LITERAL" => (t("STRING")) };Fi[	@ceiI"¨  def function
    if current_user.blocks.find(params["LITERAL"]).delete then
      var = { "LITERAL" => (t("STRING")) }
    else
      var = { "LITERAL" => (t("STRING")) };Fi[	@`e@Ai[[	@ceiI"ü    end
    respond_with do |var|
      var.html { redirect_to("LITERAL", var) }
      var.json { render("LITERAL" => (true), "LITERAL" => "LITERAL") }
    end;Fi[	@ceiI"ü    end
    respond_with do |var|
      var.html { redirect_to("LITERAL", var) }
      var.json { render("LITERAL" => (true), "LITERAL" => "LITERAL") }
    end;Fi[	@:I"2@var = Person.find_by_guid(params["LITERAL"]);Fi[[	@w!iÑI"b  end
  
  def function
    @var = Person.find_by_guid(params["LITERAL"])
    if @person then;Fi[	@w!iìI"{  end
  
  def function
    @var = Person.find_by_guid(params["LITERAL"])
    if (@person == current_user.person) then;Fi[	I" render("LITERAL" => (true));F@|i[[	@q!iMI"ü    end
    if (session["LITERAL"] == true) and request.format.html? then
      render("LITERAL" => (true))
    else
      if render("LITERAL" => (false)) then;Fi[	@w!i~I"»    if params["LITERAL"] then
      Webfinger.in_background(params["LITERAL"], "LITERAL" => (true))
      render("LITERAL" => (true))
    else
      render("LITERAL" => (true), "LITERAL" => "LITERAL");Fi[	I"#flash["LITERAL"] = t("STRING");F@|i[[	@Ei3I"j    end
    if var.empty? then
      flash["LITERAL"] = t("STRING")
    else
      if var.empty? then;Fi[	@Å!ibI"¥    else
      if params["LITERAL"].present? and params["LITERAL"]["LITERAL"].present? then
        flash["LITERAL"] = t("STRING")
      else
        flash["LITERAL"] = t("STRING");Fi[	@—2@|i[[	@3iI"ï      @user.seed_aspects
      sign_in_and_redirect("LITERAL", @user)
      Rails.logger.info("STRING")
    else
      @user.errors.delete("LITERAL");Fi[	@Ÿ2i>I"ò    else
      if (self.target.nil? or self.target.author.!=(self.person)) then
        Rails.logger.info("STRING")
      else
        self.perform(var);Fi[	@:I"5@var = Person.find_from_guid_or_username(params);Fi[[	@w!iII"Ø  
  # renders the persons user profile page
  def function
    @var = Person.find_from_guid_or_username(params)
    authenticate_user! if remote_profile_with_no_user_session?;Fi[	@w!izI"ú  end
  
  def function
    @var = Person.find_from_guid_or_username(params)
    var = Post.visible_from_author(@person, current_user).order("STRING").first;Fi[	I"-@var = current_user.contact_for(@person);F@(i[[	@w!iUI"ÿ      if current_user then
        @var = current_user.blocks.where("LITERAL" => (@person.id)).first
        @var = current_user.contact_for(@person)
        @var = []
        if @contact and params["LITERAL"].! then;Fi[	@B5iI"     if params["LITERAL"] and @var = Person.where("LITERAL" => (params["LITERAL"])).first then
      @var = "LITERAL"
      @var = current_user.contact_for(@person)
      @var = []
      if @contact then;Fi[	@†eI"0@var = @aspects_with_person.map(&"LITERAL");Fi[[	@w!iXI"√        @var = []
        if @contact and params["LITERAL"].! then
          @var = @contact.aspects
          @var = @aspects_with_person.map(&"LITERAL")
          @var = @contact.contacts.count;Fi[	@w!iãI"      @var = @contact.contacts.paginate("LITERAL" => (params["LITERAL"]), "LITERAL" => ((params["LITERAL"] or "LITERAL")))
      @var = hashes_for_people(@contacts_of_contact, @aspects)
      @var = @contact.aspects
      @var = @aspects_with_person.map(&"LITERAL")
    else;Fi[	@:@—2i[[	@~!i1I"_  end
  
  def function
    Rails.logger.info("STRING")
    flash["LITERAL"] = t("STRING");Fi[	I".projects//diaspora_proj/models/mention.rb;TiI"õ  after_destroy("LITERAL")
  
  def function
    Rails.logger.info("STRING")
    Notification.notify(person.owner, self, post.author) unless person.remote?;Fi[	@:@2i[[	@	&iI"l  before_filter("LITERAL")
  
  def function
    respond_to do |var|
      var.html { set_up_contacts };Fi[	@b#i.I"~  end
  
  def function
    respond_to do |var|
      var.json { render("LITERAL" => (tags.to_json), "LITERAL" => "LITERAL") };Fi[	@…eI"if @person then;Fi[[	@w!iÖI"Ü  
  def function
    @var = Person.find_by_guid(params["LITERAL"])
    if @person then
      @var = current_user.contact_for(@person);Fi[	@“iI"Ü  def function
    @var = "LITERAL"
    @var = Person.find_by_guid(params["LITERAL"])
    if @person then
      @var = @person.profile;Fi[	I"A@var = current_user.build_post("LITERAL", params["LITERAL"]);FI"if @photo.save then;Fi[[	@“i+I"ø    rescuing_photo_errors do
      if remotipart_submitted? then
        @var = current_user.build_post("LITERAL", params["LITERAL"])
        if @photo.save then
          respond_to do |var|;Fi[	@“iùI"‡    end
    params["LITERAL"]["LITERAL"] = file_handler(params)
    @var = current_user.build_post("LITERAL", params["LITERAL"])
    if @photo.save then
      var = current_user.aspects_from_ids(params["LITERAL"]["LITERAL"]);Fi[	@Æe@M%i[[	@“iOI"ç  
  def function
    var = current_user.photos.where("LITERAL" => (params["LITERAL"])).first
    if var then
      current_user.retract(var);Fi[	@“ikI"¨  
  def function
    var = current_user.photos.where("LITERAL" => (params["LITERAL"])).first
    if var then
      if current_user.update_post(var, params["LITERAL"]) then;Fi[	@:I"if model_exists? then;Fi[[	@≠iI"è      end
      
      def function
        if model_exists? then
          inject_into_file(model_path, migration_data, "LITERAL" => "STRING");Fi[	@≠iI"è      end
      
      def function
        if model_exists? then
          inject_into_file(model_path, model_contents, "LITERAL" => "STRING");Fi[	@:I"Cgenerate_reset_password_token! if should_generate_reset_token?;Fi[[	@iI"ﬁ      
      # Resets reset password token and send reset password instructions by email
      def function
        generate_reset_password_token! if should_generate_reset_token?
        send_devise_notification("LITERAL");Fi[	@'
i£I"ã  end
  
  def function
    generate_reset_password_token! if should_generate_reset_token?
    Resque.enqueue(Jobs::ResetPassword, self.id);Fi[	@
AI"params["LITERAL"];Fi[[	@I*iI"≤  ##### These methods need to go away once we pass publisher object into the partial ######
  def function
    if params["LITERAL"].present? then
      params["LITERAL"]
    else;Fi[	@I*iI"^  
  def function
    if params["LITERAL"].present? then
      params["LITERAL"]
    else;Fi[	@ôeI",var.mobile { redirect_to(stream_path) };Fi[[	@B5i6I"⁄      flash["LITERAL"] = successful_mention_message if coming_from_profile_page?
      respond_to do |var|
        var.html { redirect_to("LITERAL") }
        var.mobile { redirect_to(stream_path) }
        var.json do;Fi[	@B5i>I"«    else
      respond_to do |var|
        var.html { redirect_to("LITERAL") }
        var.mobile { redirect_to(stream_path) }
        var.json { render("LITERAL" => (true), "LITERAL" => "LITERAL") };Fi[	@√V@n!i[[	@Å!i-I"µ        else
          if (var["LITERAL"] or var["LITERAL"]) then
            if @user.update_attributes(var) then
              flash["LITERAL"] = I18n.t("STRING")
            else;Fi[	@Å!iEI"ø              else
                if var["LITERAL"] then
                  if @user.update_attributes(var) then
                    flash["LITERAL"] = I18n.t("STRING")
                  else;Fi[	I"0(var << [javascript_include_tag("STRING")]);FI"((var << [javascript_tag("STRING")]);Fi[[	@∏i?I"∏    if AppConfig.privacy.jquery_cdn? then
      var = Jquery::Rails::JQUERY_VERSION
      (var << [javascript_include_tag("STRING")])
      (var << [javascript_tag("STRING")])
    else;Fi[	@∏iDI"Ã      (var << [javascript_include_tag("STRING")])
    end
    (var << [javascript_include_tag("STRING")])
    (var << [javascript_tag("STRING")])
    (var << [javascript_tag("STRING")]) if Rails.env.test?;Fi[	@)f@|i[[	@I*iI"ê  def function
    if params["LITERAL"].present? then
      params["LITERAL"]
    else
      defined? @stream ? (@stream.publisher.text) : (nil);Fi[	@I*iI"ì  def function
    if params["LITERAL"].present? then
      params["LITERAL"]
    else
      defined? @stream ? (@stream.publisher.prefill) : (nil);Fi[	@:I" pending_any_confirmation do;Fi[[	@0iI"       # is already confirmed, add an error to email field. If the user is invalid
      # add errors
      def function
        pending_any_confirmation do
          if confirmation_period_expired? then;Fi[	@0iBI"€      
      # Resend confirmation token. This method does not need to generate a new token.
      def function
        pending_any_confirmation do
          self.confirmation_token = nil if confirmation_period_expired?;Fi[	I"2var = process_newlines(var) if var["LITERAL"];F@öi[[	@–iI"Õ    if var.respond_to?("LITERAL") then
      var = truncate(var.formatted_message("LITERAL" => (true)), "LITERAL" => (var["LITERAL"]))
      var = process_newlines(var) if var["LITERAL"]
      var
    else;Fi[	@–iI"ú    var["LITERAL"] ||= "LITERAL"
    var = truncate(var.text, "LITERAL" => (var["LITERAL"]))
    var = process_newlines(var) if var["LITERAL"]
    var
  end;Fi[	@<I"<var = unescape_interpolation(var["LITERAL"].strip, var);Fi[[	@3
iOI"∞      when "STRING" then
        var = true
        if (var["LITERAL"] == "STRING") then
          var = unescape_interpolation(var["LITERAL"].strip, var)
          var = false;Fi[	@3
iWI"Ã          var = true
          var = (var["LITERAL"] == "STRING")
          if (var["LITERAL"] == "STRING") then
            var = unescape_interpolation(var["LITERAL"].strip, var)
            var = false;Fi[	@<I"3var = ["STRING", "STRING", "STRING", "STRING"];Fi[[	@^iÍI"       # reduce 42 omitted
      def function(var, var, var)
        if (var["LITERAL"] == "STRING") then
          var = ["STRING", "STRING", "STRING", "STRING"]
          var = Node.new("LITERAL", var);Fi[	@^iÓI"           var = Node.new("LITERAL", var)
        else
          if (var["LITERAL"] == "STRING") then
            var = ["STRING", "STRING", "STRING", "STRING"]
            var = Node.new("LITERAL", var);Fi[	I"#@headers["LITERAL"] = "STRING";FI"b@headers["LITERAL"] = truncate(@comment.comment_email_subject, "LITERAL" => (TRUNCATION_LEN));Fi[[	I"Kprojects//diaspora_proj/mailers/notification_mailers/also_commented.rb;TiI"Ï      @var = Comment.find_by_id(var)
      if mail? then
        @headers["LITERAL"] = "STRING"
        @headers["LITERAL"] = truncate(@comment.comment_email_subject, "LITERAL" => (TRUNCATION_LEN))
        @headers["LITERAL"] = "STRING";Fi[	I"Lprojects//diaspora_proj/mailers/notification_mailers/comment_on_post.rb;TiI"‚    def function(var)
      @var = Comment.find(var)
      @headers["LITERAL"] = "STRING"
      @headers["LITERAL"] = truncate(@comment.comment_email_subject, "LITERAL" => (TRUNCATION_LEN))
      @headers["LITERAL"] = "STRING";Fi[	@hf@gfi[[	@kfiI"—      if mail? then
        @headers["LITERAL"] = "STRING"
        @headers["LITERAL"] = truncate(@comment.comment_email_subject, "LITERAL" => (TRUNCATION_LEN))
        @headers["LITERAL"] = "STRING"
      end;Fi[	@nfiI"‘      @var = Comment.find(var)
      @headers["LITERAL"] = "STRING"
      @headers["LITERAL"] = truncate(@comment.comment_email_subject, "LITERAL" => (TRUNCATION_LEN))
      @headers["LITERAL"] = "STRING"
    end;Fi[	I"var.text;FI"var.html;Fi[[	@∏i I"U    var.merge!(var)
    mail(var) do |var|
      var.text
      var.html
    end;Fi[	@∏iYI"x    with_recipient_locale do
      mail(@notification.headers) do |var|
        var.text
        var.html
      end;Fi[	@:I"%self.file_size = File.size(path);Fi[[	@AiEI"~      end
      
      def function
        self.file_size = File.size(path)
        css.each_selector do |var, var, var|;Fi[	@AikI"e      end
      
      def function
        self.file_size = File.size(path)
        visit_tree!;Fi[	@:I"*@images.each_with_index do |var, var|;Fi[[	@í#i~I"õ        end
        
        def function
          @images.each_with_index do |var, var|
            var.top = if (var.position.unit_str == "STRING") then;Fi[	@í#iÜI"ù        end
        
        def function
          @images.each_with_index do |var, var|
            var.left = (if (var.position.unit_str == "STRING") then;Fi[	@:@¢bi[[	@dBiI"ì      include(Compass::Installers)
      
      def function
        add_project_configuration
        Compass.add_configuration(options, "STRING");Fi[	@*iI"Ä      protected
      
      def function
        add_project_configuration
        Compass.add_configuration(options, "STRING");Fi[	@:I"#directory(targetize("STRING"));Fi[[	@
iI"¢    module StandAlone
      class Installer < Compass::Installers::ManifestInstaller
        def function
          directory(targetize("STRING"))
          super;Fi[	@
iI"á      end
      
      def function
        directory(targetize("STRING"))
        directory(targetize(Compass.configuration.sass_dir));Fi[	@oe@îi[[	@≥
iZI"k  # @return [String]
  def function
    case self.service
    when "STRING" then
      self.identifier;Fi[	@≥
ifI"k  # @return [String]
  def function
    case self.service
    when "STRING" then
      self.identifier;Fi[	@÷W@îi[[	@≥
i\I"u    case self.service
    when "STRING" then
      self.identifier
    when "STRING" then
      I18n.t("STRING");Fi[	@≥
ihI"j    case self.service
    when "STRING" then
      self.identifier
    when "STRING" then
      false;Fi[	@:I" @controller.send("LITERAL");Fi[[	@
i·I"L    end
    
    def function
      @controller.send("LITERAL")
    end;Fi[	@;biI"L    end
    
    def function
      @controller.send("LITERAL")
    end;Fi[	@:@à5i[[	@8i˛I"d      alias "LITERAL" "LITERAL"
      
      def function
        @options["LITERAL"]
      end;Fi[	@iÑI"D    end
    
    def function
      @options["LITERAL"]
    end;Fi[	I"def self.perform(var);FI"var = Invitation.find(var);Fi[[	@õ&i
I"ë      @var = "LITERAL"
      
      def self.perform(var)
        var = Invitation.find(var)
        I18n.with_locale(var.language) { var.send! };Fi[	I"=projects//diaspora_proj/models/jobs/resend_invitation.rb;Ti	I"j    @var = "LITERAL"
    
    def self.perform(var)
      var = Invitation.find(var)
      var.resend;Fi[	@:I"!unless skip?("LITERAL") then;Fi[[	@
iI"d    end
    
    def function
      unless skip?("LITERAL") then
        if load_instance? then;Fi[	@
i)I"®    end
    
    def function
      unless skip?("LITERAL") then
        @controller.authorize!(authorization_action, (resource_instance or resource_class_with_parent));Fi[	@:@Ú`i[[	@uilI"º      # Removes the previously created @password_file
      # (temporary file containing the password)
      def function
        @password_file.delete if @password_file
        @var = nil;Fi[	@ÜigI"∆        # Removes the previously created @password_file
        # (temporary file containing the password)
        def function
          @password_file.delete if @password_file
          @var = nil;Fi[	I""# NOTE API V1 to be extracted;F@:i[[	@“i*I"å  before_validation("LITERAL")
  
  # NOTE API V1 to be extracted
  def function
    diaspora_handle.downcase! unless diaspora_handle.blank?;Fi[	@∫i;I"√  after_create { queue_processing_job if self.author.local? }
  
  # NOTE API V1 to be extracted
  def function
    if self.status_message_guid and self.status_message.text_and_photos_blank? then;Fi[	I"%scope("LITERAL", lambda do |var|;FI"Ejoins("LITERAL").where("LITERAL" => ({ "LITERAL" => (var.id) }));Fi[[	@’i&I"}  end)
  
  scope("LITERAL", lambda do |var|
    joins("LITERAL").where("LITERAL" => ({ "LITERAL" => (var.id) }))
  end);Fi[	@P)i"I"£  after_create("LITERAL", "LITERAL" => "LITERAL")
  
  scope("LITERAL", lambda do |var|
    joins("LITERAL").where("LITERAL" => ({ "LITERAL" => (var.id) }))
  end);Fi[	I"&def self.diaspora_initialize(var);FI" var = self.new(var.to_hash);Fi[[	@∫iMI"q  end
  
  def self.diaspora_initialize(var)
    var = self.new(var.to_hash)
    var.author = var["LITERAL"];Fi[	@’imI"q  end
  
  def self.diaspora_initialize(var)
    var = self.new(var.to_hash)
    var.author = var["LITERAL"];Fi[	@ŸfI" var.author = var["LITERAL"];Fi[[	@∫iNI"ò  
  def self.diaspora_initialize(var)
    var = self.new(var.to_hash)
    var.author = var["LITERAL"]
    var.public = var["LITERAL"] if var["LITERAL"];Fi[	@’inI"ò  
  def self.diaspora_initialize(var)
    var = self.new(var.to_hash)
    var.author = var["LITERAL"]
    var.public = var["LITERAL"] if var["LITERAL"];Fi[	@‡fI"2var.public = var["LITERAL"] if var["LITERAL"];Fi[[	@∫iOI"»  def self.diaspora_initialize(var)
    var = self.new(var.to_hash)
    var.author = var["LITERAL"]
    var.public = var["LITERAL"] if var["LITERAL"]
    var.pending = var["LITERAL"] if var["LITERAL"];Fi[	@’ioI"»  def self.diaspora_initialize(var)
    var = self.new(var.to_hash)
    var.author = var["LITERAL"]
    var.public = var["LITERAL"] if var["LITERAL"]
    var.pending = var["LITERAL"] if var["LITERAL"];Fi[	@ÁfI"3var.pending = var["LITERAL"] if var["LITERAL"];Fi[[	@∫iPI"Ÿ    var = self.new(var.to_hash)
    var.author = var["LITERAL"]
    var.public = var["LITERAL"] if var["LITERAL"]
    var.pending = var["LITERAL"] if var["LITERAL"]
    var.diaspora_handle = var.author.diaspora_handle;Fi[	@’ipI"Ÿ    var = self.new(var.to_hash)
    var.author = var["LITERAL"]
    var.public = var["LITERAL"] if var["LITERAL"]
    var.pending = var["LITERAL"] if var["LITERAL"]
    var.diaspora_handle = var.author.diaspora_handle;Fi[	@ÓfI"5var.diaspora_handle = var.author.diaspora_handle;Fi[[	@∫iQI"Ì    var.author = var["LITERAL"]
    var.public = var["LITERAL"] if var["LITERAL"]
    var.pending = var["LITERAL"] if var["LITERAL"]
    var.diaspora_handle = var.author.diaspora_handle
    var.random_string = SecureRandom.hex("LITERAL");Fi[	@’iqI"¡    var.author = var["LITERAL"]
    var.public = var["LITERAL"] if var["LITERAL"]
    var.pending = var["LITERAL"] if var["LITERAL"]
    var.diaspora_handle = var.author.diaspora_handle
    var;Fi[	@—f@‰(i[[	@’i'I"y  
  scope("LITERAL", lambda do |var|
    joins("LITERAL").where("LITERAL" => ({ "LITERAL" => (var.id) }))
  end)
  ;Fi[	@P)i#I"y  
  scope("LITERAL", lambda do |var|
    joins("LITERAL").where("LITERAL" => ({ "LITERAL" => (var.id) }))
  end)
  ;Fi[	I"self["LITERAL"];F@|i[[	@_'i[I"†  def function(var)
    var = if (var == "LITERAL") and self["LITERAL"] then
      self["LITERAL"]
    else
      if (var == "LITERAL") and self["LITERAL"] then;Fi[	@_'i^I"}    else
      if (var == "LITERAL") and self["LITERAL"] then
        self["LITERAL"]
      else
        self["LITERAL"];Fi[	@:@–`i[[	@ui2I"¬      ##
      # Establishes a connection to the remote server
      def function
        Net::SSH.start(ip, username, "LITERAL" => (password), "LITERAL" => (port)) do |var|
          yield(var);Fi[	@i&I"Ì      # and yields the Net::SSH connection.
      # Net::SCP will use this connection to transfer backups
      def function
        Net::SSH.start(ip, username, "LITERAL" => (password), "LITERAL" => (port)) do |var|
          yield(var);Fi[	@:I"@var = @model.package;Fi[[	@òi#I"Â    # final @package.basename, plus a '-' separator. This `prefix` will then
    # be suffixed using 'aa', 'ab', and so on... for each file.
    def function
      @var = @model.package
      Logger.message(("STRING" + "STRING"));Fi[	@õi!I"u      ##
      # Performs the backup transfer
      def function
        @var = @model.package
        transfer!;Fi[	I"if self.target.nil? then;F@—2i[[	@Ωi.I"l  
  def function(var, var)
    if self.target.nil? then
      Rails.logger.info("STRING")
      return;Fi[	@ÓiTI"l  
  def function(var, var)
    if self.target.nil? then
      Rails.logger.info("STRING")
      return;Fi[	@:I"@var ||= [];Fi[[	@ãiI"<    end
    
    def function
      @var ||= []
    end;Fi[	@Úi,I"Å        
        # Tracks the various version overrides for an integration
        def function
          @var ||= []
        end;Fi[	I"%# @note Used for XML marshalling;F@å"i[[	@ì"i&I"T  end
  
  # @note Used for XML marshalling
  # @return [String]
  def function;Fi[	@ì"i0I"T  end
  
  # @note Used for XML marshalling
  # @return [String]
  def function;Fi[	@;F@Qi[[	@H-iI"ì  # @return [Array<Integer>]
  def function(var, var)
    var = prep_opts(var, var)
    var["LITERAL"] = var
    var["LITERAL"] ||= self.aspect_ids;Fi[	@H-i$I"ù  def function(var, var)
    var = var.table_name
    var = prep_opts(var, var)
    var["LITERAL"] = var
    var = construct_shareable_from_others_query(var);Fi[	I"(var["LITERAL"] = var.url("LITERAL");F@1gi[[	@'
iEI"Ê    if var = var.delete("LITERAL") then
      var.update_attributes("LITERAL" => (false)) if var.pending
      var["LITERAL"] = var.url("LITERAL")
      var["LITERAL"] = var.url("LITERAL")
      var["LITERAL"] = var.url("LITERAL");Fi[	@'
iFI"∆      var.update_attributes("LITERAL" => (false)) if var.pending
      var["LITERAL"] = var.url("LITERAL")
      var["LITERAL"] = var.url("LITERAL")
      var["LITERAL"] = var.url("LITERAL")
    end;Fi[	I"9self.aspects.create("LITERAL" => (I18n.t("STRING")));F@8gi[[	@'
ipI"º  
  def function
    self.aspects.create("LITERAL" => (I18n.t("STRING")))
    self.aspects.create("LITERAL" => (I18n.t("STRING")))
    self.aspects.create("LITERAL" => (I18n.t("STRING")));Fi[	@'
iqI"¯  def function
    self.aspects.create("LITERAL" => (I18n.t("STRING")))
    self.aspects.create("LITERAL" => (I18n.t("STRING")))
    self.aspects.create("LITERAL" => (I18n.t("STRING")))
    var = self.aspects.create("LITERAL" => (I18n.t("STRING")));Fi[	@:I"return unless @orig_err;Fi[[	@Ωi8I"{      end
      
      def function
        return unless @orig_err
        @var ||= if @orig_err.is_a?(Errors::Error) then;Fi[	@ΩiAI"      end
      
      def function
        return unless @orig_err
        return @orig_err_msg unless @orig_err_msg.nil?;Fi[	@:I"-var = "STRING".gsub("LITERAL", "STRING");Fi[[	@ci∞I"´      # and ensure no 'write operations' are performed during the
      # dump process
      def function
        var = "STRING".gsub("LITERAL", "STRING")
        run(var);Fi[	@ci∑I"É      ##
      # Unlocks the (locked) database
      def function
        var = "STRING".gsub("LITERAL", "STRING")
        run(var);Fi[	@üBI"class Compiler;Fi[[	@ÏiI"Hrequire("cgi")
module Haml
  class Compiler
    include(Haml::Util);Fi[	@Úi
I"}require("haml/helpers/action_view_extensions")
require("haml/helpers/xss_mods")
module Haml
  class Compiler
    def function;Fi[	@üBI"module Filters;Fi[[	@iI"Brequire("tilt")
module Haml
  module Filters
    extend(self);Fi[	@√i I"[module Haml
  module Filters
    class SassRailsTemplate < ::Sass::Rails::SassTemplate;Fi [	I"<# @return [Boolean] Whether or not the format is HTML5.;F@:i[[	@Èi7I"Ç    end
    
    # @return [Boolean] Whether or not the format is HTML5.
    def function
      (@options["LITERAL"] == "LITERAL");Fi[	@x/i≠I"z    end
    
    # @return [Boolean] Whether or not the format is HTML5.
    def function
      (format == "LITERAL");Fi[	I"I# @param tab_change [Fixnum] The number of tabs by which to increase;FI"/#   or decrease the document's indentation;Fi[[	@ÈibI"˝    #
    # @param text [String] The text to append
    # @param tab_change [Fixnum] The number of tabs by which to increase
    #   or decrease the document's indentation
    # @param dont_tab_up [Boolean] If true, don't indent the first line of `text`;Fi[	@ÈipI"√    # Modifies the indentation of the document.
    #
    # @param tab_change [Fixnum] The number of tabs by which to increase
    #   or decrease the document's indentation
    def function(var);Fi[	I"&if (RUBY_VERSION < "STRING") then;F@£i[[	@i—I"h    private
    
    if (RUBY_VERSION < "STRING") then
      def function(var)
        # do nothing;Fi[	@iúI"j    end
    
    if (RUBY_VERSION < "STRING") then
      def function(var)
        return var.inspect;Fi[	I"1if (@node.value["LITERAL"] == "STRING") then;F@;i[[	@ÏiÓI"Ö      else
        if @options.xhtml? then
          if (@node.value["LITERAL"] == "STRING") then
            "STRING"
          else;Fi[	@ÏiÒI"Ñ            "STRING"
          else
            if (@node.value["LITERAL"] == "STRING") then
              "STRING"
            else;Fi[	I" case @node.value["LITERAL"];F@îi[[	@ÏiÙI"ã              "STRING"
            else
              case @node.value["LITERAL"]
              when "STRING" then
                "STRING";Fi[	@ÏiI"å        else
          if @options.html4? then
            case @node.value["LITERAL"]
            when "STRING" then
              "STRING";Fi[	I"F# See {file:REFERENCE.md#options the Haml options documentation}.;F@i[[	@iI"é    
    # The Haml::Options instance.
    # See {file:REFERENCE.md#options the Haml options documentation}.
    #
    # @return Haml::Options;Fi[	@x/i‹I"¬    # it can be `Kernel#eval`ed to get the same result back.
    #
    # See {file:REFERENCE.md#options the Haml options documentation}.
    #
    # @return [{Symbol => Object}] The options hash;Fi[	I"5# Note that Haml modifies the evaluation context;FI"K# (either the scope object or the `self` object of the scope binding).;Fi[[	@iAI"    # otherwise, Haml just uses its `#instance_eval` context.
    #
    # Note that Haml modifies the evaluation context
    # (either the scope object or the `self` object of the scope binding).
    # It extends {Haml::Helpers}, and various instance variables are set;Fi[	@i¬I"-    #     obj.render(:foo => "Hello!") #=> NameError: undefined local variable or method `foo'
    #
    # Note that Haml modifies the evaluation context
    # (either the scope object or the `self` object of the scope binding).
    # It extends {Haml::Helpers}, and various instance variables are set;Fi[	@ágI"I# It extends {Haml::Helpers}, and various instance variables are set;Fi[[	@iBI"Ò    #
    # Note that Haml modifies the evaluation context
    # (either the scope object or the `self` object of the scope binding).
    # It extends {Haml::Helpers}, and various instance variables are set
    # (all prefixed with `haml_`).;Fi[	@i√I"Ò    #
    # Note that Haml modifies the evaluation context
    # (either the scope object or the `self` object of the scope binding).
    # It extends {Haml::Helpers}, and various instance variables are set
    # (all prefixed with `haml_`).;Fi[	@égI"## (all prefixed with `haml_`).;Fi[[	@iCI"˛    # Note that Haml modifies the evaluation context
    # (either the scope object or the `self` object of the scope binding).
    # It extends {Haml::Helpers}, and various instance variables are set
    # (all prefixed with `haml_`).
    # For example:;Fi[	@iƒI"Ò    # Note that Haml modifies the evaluation context
    # (either the scope object or the `self` object of the scope binding).
    # It extends {Haml::Helpers}, and various instance variables are set
    # (all prefixed with `haml_`).
    #;Fi[	I"4if (var.is_a?(Binding) or var.is_a?(Proc)) then;FI"var = eval("STRING", var);Fi[[	@ikI"‘      end
      var = Haml::Buffer.new(var, @options.for_buffer)
      if (var.is_a?(Binding) or var.is_a?(Proc)) then
        var = eval("STRING", var)
        var = var.instance_eval { binding } if block_given?;Fi[	@ióI"∂    # @return [Proc] The proc that will run the template
    def function(var, var)
      if (var.is_a?(Binding) or var.is_a?(Proc)) then
        var = eval("STRING", var)
      else;Fi[	I" rescue ::SyntaxError => var;FI"$raise(SyntaxError, var.message);Fi[[	@iyI"≈      begin
        eval(@compiler.precompiled_with_return_value, var, @options["LITERAL"], @options["LITERAL"])
      rescue ::SyntaxError => var
        raise(SyntaxError, var.message)
      end);Fi[	@iüI"‹      begin
        eval((("STRING" + compiler.precompiled_with_ambles(var)) + "STRING"), var, @options["LITERAL"], @options["LITERAL"])
      rescue ::SyntaxError => var
        raise(SyntaxError, var.message)
      end;Fi[	I"1# However, due to an unfortunate Ruby quirk,;FI"F# the local variables which can be assigned must be pre-declared.;Fi[[	@iÑI"    #
    # The first argument of the returned proc is a hash of local variable names to values.
    # However, due to an unfortunate Ruby quirk,
    # the local variables which can be assigned must be pre-declared.
    # This is done with the `local_names` argument.;Fi[	@i≥I"    #
    # The first argument of the defined method is a hash of local variable names to values.
    # However, due to an unfortunate Ruby quirk,
    # the local variables which can be assigned must be pre-declared.
    # This is done with the `local_names` argument.;Fi[	@≠gI"4# This is done with the `local_names` argument.;Fi[[	@iÖI"    # The first argument of the returned proc is a hash of local variable names to values.
    # However, due to an unfortunate Ruby quirk,
    # the local variables which can be assigned must be pre-declared.
    # This is done with the `local_names` argument.
    # For example:;Fi[	@i¥I"    # The first argument of the defined method is a hash of local variable names to values.
    # However, due to an unfortunate Ruby quirk,
    # the local variables which can be assigned must be pre-declared.
    # This is done with the `local_names` argument.
    # For example:;Fi[	@¥g@i[[	@iÜI"√    # However, due to an unfortunate Ruby quirk,
    # the local variables which can be assigned must be pre-declared.
    # This is done with the `local_names` argument.
    # For example:
    #;Fi[	@iµI"√    # However, due to an unfortunate Ruby quirk,
    # the local variables which can be assigned must be pre-declared.
    # This is done with the `local_names` argument.
    # For example:
    #;Fi[	I"=# @param args [Array<String>] The command-line arguments;F@£i[[	@ˇiI"â  module Exec
    class Generic
      # @param args [Array<String>] The command-line arguments
      def function(var)
        @var = var;Fi[	@ˇiùI"Ç    
    class Haml < Generic
      # @param args [Array<String>] The command-line arguments
      def function(var)
        super;Fi[	I"!# @param opts [OptionParser];F@£i[[	@ˇiGI"®      # so they can add their own options.
      #
      # @param opts [OptionParser]
      def function(var)
        var.on("STRING", "STRING", "LITERAL", "STRING") do;Fi[	@ˇißI"É      # Tells optparse how to parse the arguments.
      #
      # @param opts [OptionParser]
      def function(var)
        super;Fi[	I"E# @param text [String] The source text for the filter to process;FI"+# @return [String] The filtered result;Fi[[	@iNI"˝      # If \{#compile} is overridden, however, \{#render} doesn't need to be.
      #
      # @param text [String] The source text for the filter to process
      # @return [String] The filtered result
      # @raise [Haml::Error] if it's not overridden;Fi[	@iYI"“      #
      # @see #render
      # @param text [String] The source text for the filter to process
      # @return [String] The filtered result
      # @raise [Haml::Error] if it or \{#render} isn't overridden;Fi[	I")if contains_interpolation?(var) then;FI"+var = unescape_interpolation(var, var);Fi[[	@3
i^I"ì          end
        else
          if contains_interpolation?(var) then
            var = unescape_interpolation(var, var)
            var = true;Fi[	@3
ieI"â        end
      else
        if contains_interpolation?(var) then
          var = unescape_interpolation(var, var)
          var = true;Fi[	@:@5^i[[	@3*iI"¡      ##
      # Yields to the block the compressor command and filename extension.
      def function
        Backup::Logger.warn(((("STRING" + "STRING") + "STRING") + "STRING"))
        super;Fi[	@6*i%I"¡      ##
      # Yields to the block the compressor command and filename extension.
      def function
        Backup::Logger.warn(((("STRING" + "STRING") + "STRING") + "STRING"))
        super;Fi[	I"$# @see Base#render_with_options;F@Hi[[	@ióI"î      include(Base)
      
      # @see Base#render_with_options
      def function(var, var)
        var = var["LITERAL"] ? ("STRING") : ("STRING");Fi[	@ißI"î      include(Base)
      
      # @see Base#render_with_options
      def function(var, var)
        var = var["LITERAL"] ? ("STRING") : ("STRING");Fi[	@ÆV@<i[[	@iöI"‚      def function(var, var)
        var = var["LITERAL"] ? ("STRING") : ("STRING")
        (var["LITERAL"] == "LITERAL") ? (var = "STRING") : (var = "STRING")
        var = "STRING"
        (var << "STRING") if var["LITERAL"];Fi[	@i™I"‚      def function(var, var)
        var = var["LITERAL"] ? ("STRING") : ("STRING")
        (var["LITERAL"] == "LITERAL") ? (var = "STRING") : (var = "STRING")
        var = "STRING"
        (var << "STRING") if var["LITERAL"];Fi[	I"module ActionView;F@†Bi[[	I"?projects//haml_proj/haml/helpers/rails_323_textarea_fix.rb;Ti I"@module ActionView
  module Helpers
    module FormTagHelper;Fi [	@;ihI"J  end
end
module ActionView
  module Helpers
    module CaptureHelper;Fi[	@I]@Hi[[	@⁄i-I"{  
  module Helpers
    module CaptureHelper
      def function(var, var)
        if Haml::Helpers.block_is_haml?(var) then;Fi[	@;ijI"ñmodule ActionView
  module Helpers
    module CaptureHelper
      def function(var, var)
        var = with_output_buffer_without_haml_xss(*var, &var);Fi[	@:@£4i[[	@û>iI"m      include(Backup::Configuration::Helpers)
      
      def function
        load_defaults!
      end;Fi[	@•)iI"}      ##
      # Flag for mirroring the files/directories
      def function
        load_defaults!
        @var ||= "STRING";Fi[	I"3# Input is escaped, output is always HTML safe;F@Hi[[	@;i+I"∫      end
      
      # Input is escaped, output is always HTML safe
      def function(var, var)
        Haml::Util.html_safe(precede_without_haml_xss(haml_xss_html_escape(var), &var));Fi[	@;i0I"∫      end
      
      # Input is escaped, output is always HTML safe
      def function(var, var)
        Haml::Util.html_safe(succeed_without_haml_xss(haml_xss_html_escape(var), &var));Fi[	I"*#   Escapes newlines within a string.;F@i[[	@ÔiXI"Œ    #
    # @overload find_and_preserve(input, tags = haml_buffer.options[:preserve])
    #   Escapes newlines within a string.
    #
    #   @param input [String] The string within which to escape newlines;Fi[	@ÔimI"¢    #
    # @overload perserve(input)
    #   Escapes newlines within a string.
    #
    #   @param input [String] The string within which to escape all newlines;Fi[	I"6#   Escapes newlines within a block of Haml code.;F@i[[	@Ôi\I"    #   @param input [String] The string within which to escape newlines
    # @overload find_and_preserve(tags = haml_buffer.options[:preserve])
    #   Escapes newlines within a block of Haml code.
    #
    #   @yield The block within which to escape newlines;Fi[	@ÔiqI"⁄    #   @param input [String] The string within which to escape all newlines
    # @overload perserve
    #   Escapes newlines within a block of Haml code.
    #
    #   @yield The block within which to escape newlines;Fi[	@:I"	log!;Fi[[	@”1iI"ç      ##
      # Yields to the block the compressor command and filename extension.
      def function
        log!
        yield(@cmd, @ext);Fi[	@1i*I"¡      # Once the packaging procedure is complete, it will return
      # so that any clean-up may be performed after the yield.
      def function
        log!
        yield("STRING", "STRING");Fi[	@≤B@i[[	@ÔiîI"w    #       <h3>Description</h3>
    #       <p>A book about all the stuff.</p>
    #     </li>
    #
    # While:;Fi[	@Ôi®I"    #     <li class='nav' role='nav'>
    #       <a href='#'>FAQ</a>
    #     </li>
    #
    #  `[[class", "nav"], [role", "nav"]]` could have been used instead of `{class: "nav", role: "nav"}` (or any enumerable collection where each pair of items responds to #to_s);Fi[	@:@5i[[	I"5projects//activemodel_proj/active_model/dirty.rb;Ti6I"Ç    #   person.name = 'robert'
    #   person.changed_attributes # => {"name" => "bob"}
    def function
      @var ||= {}
    end;Fi[	@iI"P        end
        
        def function
          @var ||= {}
        end;Fi[	@:I"if current_scope then;Fi[[	@[iI"Ã        # You can define a scope that applies to all finders using
        # <tt>ActiveRecord::Base.default_scope</tt>.
        def function
          if current_scope then
            current_scope.clone;Fi[	@[i'I"∂        # an AR instance for the particular class this is called on.
        # :nodoc:
        def function
          if current_scope then
            current_scope.scope_for_create;Fi[	I"#     %strong baz;F@i[[	@Ôi€I"V    #     %p bar
    #     - tab_down
    #     %strong baz
    #
    # Produces:;Fi[	@Ôi˙I"_    #     - with_tabs(2) do
    #       %p bar
    #     %strong baz
    #
    # Produces:;Fi[	I"#     <strong>baz</strong>;F@i[[	@Ôi·I"¢    #     <h1>foo</h1>
    #       <p>bar</p>
    #     <strong>baz</strong>
    #
    # @param i [Fixnum] The number of tabs by which to increase the indentation;Fi[	@Ôi I"_    #     <h1>foo</h1>
    #         <p>bar</p>
    #     <strong>baz</strong>
    #
    #;Fi[	I""# with no whitespace between.;F@i[[	@Ôi,I"~    
    # Prepends a string to the beginning of a Haml block,
    # with no whitespace between.
    # For example:
    #;Fi[	@Ôi=I"w    
    # Appends a string to the end of a Haml block,
    # with no whitespace between.
    # For example:
    #;Fi[	I"haml_concat(var);FI"tab_up;Fi[[	@Ôi◊I"Ñ        var = var.to_s
        if var.include?("STRING") then
          haml_concat(var)
          tab_up
          haml_concat(var);Fi[	@ÔiËI"T        return var
      end
      haml_concat(var)
      tab_up
      var.call;Fi[	I"tab_down;FI"haml_concat("STRING");Fi[[	@Ôi⁄I"p          tab_up
          haml_concat(var)
          tab_down
          haml_concat("STRING")
        else;Fi[	@ÔiÎI"U      tab_up
      var.call
      tab_down
      haml_concat("STRING")
      var;Fi[	I"2# @param text [String] The string to sanitize;FI",# @return [String] The sanitized string;Fi[[	@Ôi˙I"™    # this won't escape text declared as "safe".
    #
    # @param text [String] The string to sanitize
    # @return [String] The sanitized string
    def function(var);Fi[	@Ôi	I"™    # that is already part of an escaped entity.
    #
    # @param text [String] The string to sanitize
    # @return [String] The sanitized string
    def function(var);Fi[	@\h@£i[[	@Ôi˚I"é    #
    # @param text [String] The string to sanitize
    # @return [String] The sanitized string
    def function(var)
      var = "STRING";Fi[	@Ôi
I"é    #
    # @param text [String] The string to sanitize
    # @return [String] The sanitized string
    def function(var)
      var = "STRING";Fi[	I"-var = if (RUBY_VERSION >= "STRING") then;FI"HRegexp.new(var.force_encoding(var.encoding), Regexp::FIXEDENCODING);Fi[[	@Ôi˛I"∞    def function(var)
      var = "STRING"
      var = if (RUBY_VERSION >= "STRING") then
        Regexp.new(var.force_encoding(var.encoding), Regexp::FIXEDENCODING)
      else;Fi[	@ÔiI"∞    def function(var)
      var = "STRING"
      var = if (RUBY_VERSION >= "STRING") then
        Regexp.new(var.force_encoding(var.encoding), Regexp::FIXEDENCODING)
      else;Fi[	@jh@|i[[	@ÔiˇI"≤      var = "STRING"
      var = if (RUBY_VERSION >= "STRING") then
        Regexp.new(var.force_encoding(var.encoding), Regexp::FIXEDENCODING)
      else
        Regexp.new(var);Fi[	@ÔiI"≤      var = "STRING"
      var = if (RUBY_VERSION >= "STRING") then
        Regexp.new(var.force_encoding(var.encoding), Regexp::FIXEDENCODING)
      else
        Regexp.new(var);Fi[	I"require("strscan");F@üBi[[	@3
i I"2require("strscan")
module Haml
  class Parser;Fi [	@iI"Trequire("set")
require("stringio")
require("strscan")
module Haml
  module Util;Fi[	I"case var["LITERAL"];F@îi[[	@3
i¸I"t      var = {}
      while var do
        case var["LITERAL"]
        when "STRING" then
          break if var;Fi[	@˝iÇI"©    # it is the lexeme.
    def function(var)
      case var["LITERAL"]
      when "STRING" then
        ["STRING", var["LITERAL", "LITERAL"], var["LITERAL", "LITERAL"]];Fi[	I"var = block_keyword(var);FI"!check_push_script_stack(var);Fi[[	@3
iI"      var = handle_ruby_multiline(var)
      var = @options["LITERAL"] if var.nil?
      var = block_keyword(var)
      check_push_script_stack(var)
      ParseNode.new("LITERAL", @index, "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => (var));Fi[	@3
i!I"≠      end
      var = handle_ruby_multiline(var)
      var = block_keyword(var)
      check_push_script_stack(var)
      if ["STRING", "STRING", "STRING"].include?(var) then;Fi[	@Yf@ûIi[[	@3
iPI"£        var = true
        if (var["LITERAL"] == "STRING") then
          var = unescape_interpolation(var["LITERAL"].strip, var)
          var = false
        end;Fi[	@3
iXI"∆          var = (var["LITERAL"] == "STRING")
          if (var["LITERAL"] == "STRING") then
            var = unescape_interpolation(var["LITERAL"].strip, var)
            var = false
          else;Fi[	@ÿg@Ì2i[[	@3
i_I"ù        else
          if contains_interpolation?(var) then
            var = unescape_interpolation(var, var)
            var = true
            var = false;Fi[	@3
ifI"ì      else
        if contains_interpolation?(var) then
          var = unescape_interpolation(var, var)
          var = true
          var = false;Fi[	I"!var = StringScanner.new(var);FI",while var.skip_until(HIGH_BIT_RANGE) do;Fi[[	@¬0i
I"Å  
  def self.valid?(var)
    var = StringScanner.new(var)
    while var.skip_until(HIGH_BIT_RANGE) do
      var.pos -= "LITERAL";Fi[	@¬0iI"í  
  def self.clean!(var)
    var = StringScanner.new(var)
    while var.skip_until(HIGH_BIT_RANGE) do
      var = var.pos = (var.pos - "LITERAL");Fi[	I"+((var << "STRING") << @next_line.text);F@±bi[[	@3
i!I"Á      rescue SyntaxError => var
        if (var.strip["LITERAL"] == "STRING") and (var.message == Error.message("LITERAL")) then
          ((var << "STRING") << @next_line.text)
          var = (var + "LITERAL")
          next_line;Fi[	@3
i<I"õ        var.scan("LITERAL")
        if var.eos? then
          ((var << "STRING") << @next_line.text)
          var = (var + "LITERAL")
          next_line;Fi[	I" break if (var == "LITERAL");FI"next if var.strip.empty?;Fi[[	@3
iíI"º      var.text.slice!("LITERAL")
      while var = raw_next_line.first do
        break if (var == "LITERAL")
        next if var.strip.empty?
        break unless is_multiline?(var.strip);Fi[	@3
i•I"õ      begin
        var = raw_next_line.first
        break if (var == "LITERAL")
        next if var.strip.empty?
        ((var << "STRING") << var.strip);Fi[	@X1@i[[	@€iAI"ë      # @param value [Object] The value your object defaults to. Nil if not provided.
      #
      # @example
      #
      #   class MyStrategy;Fi[	@€i>I"û    # evaluates to true when you would like to skip info.
    #
    # @example
    #
    #   use MyStrategy, :skip_info => lambda{|uid| User.find_by_uid(uid)};Fi[	I"E# @yield [msg] A block in which an encoding error can be raised.;FI"2#   Only yields if there is an encoding error;Fi[[	@icI"      #
      # @param str [String] The string of which to check the encoding
      # @yield [msg] A block in which an encoding error can be raised.
      #   Only yields if there is an encoding error
      # @yieldparam msg [String] The error message to be raised;Fi[	@iãI"      #
      # @param str [String] The Haml template of which to check the encoding
      # @yield [msg] A block in which an encoding error can be raised.
      #   Only yields if there is an encoding error
      # @yieldparam msg [String] The error message to be raised;Fi[	@∑hI"># @yieldparam msg [String] The error message to be raised;Fi[[	@idI"T      # @param str [String] The string of which to check the encoding
      # @yield [msg] A block in which an encoding error can be raised.
      #   Only yields if there is an encoding error
      # @yieldparam msg [String] The error message to be raised
      # @return [String] `str`, potentially with encoding gotchas like BOMs removed;Fi[	@iåI"E      # @param str [String] The Haml template of which to check the encoding
      # @yield [msg] A block in which an encoding error can be raised.
      #   Only yields if there is an encoding error
      # @yieldparam msg [String] The error message to be raised
      # @return [String] The original string encoded properly;Fi[	I"%if var.include?("STRING").! then;F@<i[[	@i#I"±    # @return [String] The name of the indentation (e.g. `"12 spaces"`, `"1 tab"`)
    def function(var)
      if var.include?("STRING").! then
        var = "STRING"
      else;Fi[	@i&I"u        var = "STRING"
      else
        if var.include?("STRING").! then
          var = "STRING"
        else;Fi[	@#-@|i[[	@„iI"R    "STRING"
  when "STRING" then
    "STRING".undent
  else
    # do nothing;Fi[	@‘izI"_      "STRING".undent
    when "LITERAL" then
      "STRING".undent
    else
      @reason;Fi[	@#-@i[[	@„iI"d    "STRING".undent
  when "STRING" then
    "STRING".undent
  when "LITERAL" then
    "STRING";Fi[	@‘ixI"q    case @reason
    when "LITERAL" then
      "STRING".undent
    when "LITERAL" then
      "STRING".undent;Fi[	@:I"if values["LITERAL"] then;Fi[[	@äiXI"ã      end
      
      def function
        if values["LITERAL"] then
          (relation.bind_values + values["LITERAL"]).uniq(&"LITERAL");Fi[	@äi`I"Å      end
      
      def function
        if values["LITERAL"] then
          var = (relation.where_values + values["LITERAL"]);Fi[	@#-@8i[[	@„iI"Ö  case var.downcase
  when "LITERAL", "STRING", "LITERAL" then
    "STRING".undent
  when "STRING", "STRING" then
    "STRING".undent;Fi[	@„iI"t    "STRING".undent
  when "STRING" then
    "STRING".undent
  when "STRING", "STRING" then
    "STRING".undent;Fi[	I"require("hardware");F@&>i[[	@8
iI"u    raise($!) if $!
    trap("STRING", STD_TRAP)
    require("hardware")
    require("keg")
    system("STRING");Fi[	@*5iI"Mrequire("extend/ENV")
require("hardware")
require("keg")
module Homebrew;Fi[	@Âh@ô+i[[	@¯i I"7require("hardware")
module Homebrew
  extend(self);Fi [	@º
iI"Krequire("superenv")
require("hardware")
module Homebrew
  extend(self);Fi[	@:I"if loaded? then;Fi[[	@‹	iI"O    end
    
    def function
      if loaded? then
        @records.first;Fi[	@‹	iI"N    end
    
    def function
      if loaded? then
        @records.last;Fi[	@&>@ò+i[[	@;
i I"6require("keg")
require("formula")
module Homebrew;Fi [	@B
iI"    begin
      (var = nil
      require("keg")
      require("formula")
      @var ||= downcased_unique_named.collect do |var|;Fi[	I"Marshal.dump(var, var);F@≥Xi[[	@8
i$I"}    else
      var.continuation = nil if ARGV.debug?
      Marshal.dump(var, var)
      var.close
      exit!("LITERAL");Fi[	@—i∞I"ˆ          exec("STRING", "STRING", "STRING", "STRING", Pathname.new("STRING").dirname, "STRING", "STRING", f.path, *var.options_only))
        rescue Exception => var
          Marshal.dump(var, var)
          var.close
          exit!("LITERAL");Fi[	@:I"5var = (eager_load_values + includes_values).uniq;Fi[[	@‹	i∫I"ö    end
    
    def function
      var = (eager_load_values + includes_values).uniq
      ActiveRecord::Associations::JoinDependency.new(@klass, var, []);Fi[	@‹	iøI"Æ    end
    
    def function
      var = (eager_load_values + includes_values).uniq
      var = ActiveRecord::Associations::JoinDependency.new(@klass, var, arel.froms.first);Fi[	@:I"'raise(ReadOnlyRecord) if readonly?;Fi[[	@1iåI"∑    # and <tt>destroy</tt> returns +false+. See
    # ActiveRecord::Callbacks for further details.
    def function
      raise(ReadOnlyRecord) if readonly?
      destroy_associations;Fi[	@1iÅI"Ç    end
    
    def function
      raise(ReadOnlyRecord) if readonly?
      var = new_record? ? (create_record) : (update_record);Fi[	@:I"	case;Fi[[	@#i1I"ﬁ    #   Product.find(5).cache_key # => "products/5" (updated_at not available)
    #   Person.find(5).cache_key  # => "people/5-20071224150000" (updated_at available)
    def function
      case
      when new_record? then;Fi[	@|i&I"w      end
      
      def function
        case
        when ((stdout == "STRING") and (stderr == "STRING")) then;Fi[	@∑DI"0assert_equal(case MacOS.clang_build_version;Fi[[	@ÊiI"Ø    assert(var.fails_with?("LITERAL"))
    assert(var.fails_with?("LITERAL").!)
    var.select_compiler
    assert_equal(case MacOS.clang_build_version
    when "LITERAL" then;Fi[	@ÊiWI"ã      var.fails_with?("LITERAL").!
    end)
    var.select_compiler
    assert_equal(case MacOS.clang_build_version
    when "LITERAL" then;Fi[	@;>@	i[[	@8
i]I"l    end
    if ARGV.flag?("STRING") then
      ohai("STRING")
      puts("STRING")
      puts("STRING");Fi[	@IiI"\      puts("STRING")
    else
      ohai("STRING")
      puts("STRING")
      IRB.start;Fi[	@:I"7return if ActiveRecord::Base.configurations.blank?;Fi[[	@[iÖI"ô    end
    
    def function
      return if ActiveRecord::Base.configurations.blank?
      if pre_loaded_fixtures and use_transactional_fixtures.! then;Fi[	@[i†I"}    end
    
    def function
      return if ActiveRecord::Base.configurations.blank?
      if run_in_transaction? then;Fi[	@:I"!var = self.class.primary_key;Fi[[	@iI"    end
    
    def function
      var = self.class.primary_key
      @attributes[var] = nil unless @attributes.key?(var);Fi[	@1ixI"n    end
    
    def function
      var = self.class.primary_key
      var = self.class.columns_hash[var];Fi[	I"if f.plist_startup then;F@∫ i[[	@i4I"≤      var = (var / var)
      if var.file?.! and var.symlink?.! then
        if f.plist_startup then
          (var << "STRING")
          (var << "STRING") unless var.directory?;Fi[	@iFI"°        if Kernel.system("STRING") then
          (var << "STRING")
          if f.plist_startup then
            (var << "STRING")
            (var << "STRING");Fi[	@^V@∫ i[[	@i6I"ñ        if f.plist_startup then
          (var << "STRING")
          (var << "STRING") unless var.directory?
          (var << "STRING")
        else;Fi[	@i:I"Ç        else
          (var << "STRING")
          (var << "STRING") unless var.directory?
          (var << "STRING")
        end;Fi[	@w:@|i[[	@¿BiI"≤    var.sort.reverse_each { |var| var.rmdir_if_possible }
    if ($n == "LITERAL") and ($d == "LITERAL") then
      puts("STRING") if ARGV.verbose?
    else
      print("STRING");Fi[	@›
iøI"≤  def function(var, var, var)
    if var.exist? and (var.realpath == var.realpath) then
      puts("STRING") if ARGV.verbose?
    else
      if var.dry_run and var.overwrite then;Fi[	I"*var.unlink unless @f.skip_clean?(var);F@|i[[	@Ÿi8I"™        else
          if (var.extname == "STRING") then
            var.unlink unless @f.skip_clean?(var)
          else
            if (var == (@f.lib + "STRING")) then;Fi[	@Ÿi;I"¿          else
            if (var == (@f.lib + "STRING")) then
              var.unlink unless @f.skip_clean?(var)
            else
              clean_file_permissions(var) if var.symlink?.!;Fi[	I"puts(hardware);F@	i[[	@¯ikI"±    puts("STRING") if HOMEBREW_PREFIX.to_s.!=("STRING")
    puts("STRING") if HOMEBREW_CELLAR.to_s.!=("STRING")
    puts(hardware)
    puts("STRING")
    puts("STRING") if xcode;Fi[	@¯iÖI"l    puts("STRING")
    puts("STRING")
    puts(hardware)
    puts("STRING")
    puts("STRING") if xcode;Fi[	@£]I"puts("STRING") if clt;Fi[[	@¯imI"ë    puts(hardware)
    puts("STRING")
    puts("STRING") if xcode
    puts("STRING") if clt
    puts("STRING") if RUBY_VERSION.to_f.!=("LITERAL");Fi[	@¯iáI"}    puts(hardware)
    puts("STRING")
    puts("STRING") if xcode
    puts("STRING") if clt
    puts("STRING") if gcc_40;Fi[	I"puts("STRING") if gcc_40;FI"puts("STRING") if gcc_42;Fi[[	@¯iqI"≤    puts("STRING") if RUBY_VERSION.to_f.!=("LITERAL")
    unless MacOS.compilers_standard? then
      puts("STRING") if gcc_40
      puts("STRING") if gcc_42
      puts("STRING");Fi[	@¯iâI"Ç    puts("STRING") if xcode
    puts("STRING") if clt
    puts("STRING") if gcc_40
    puts("STRING") if gcc_42
    puts("STRING");Fi[	@_i@	i[[	@¯irI"ë    unless MacOS.compilers_standard? then
      puts("STRING") if gcc_40
      puts("STRING") if gcc_42
      puts("STRING")
      puts("STRING");Fi[	@¯iäI"~    puts("STRING") if clt
    puts("STRING") if gcc_40
    puts("STRING") if gcc_42
    puts("STRING")
    puts("STRING");Fi[	I"'puts("STRING") if macports_or_fink;F@	i[[	@¯ivI"a      puts("STRING")
    end
    puts("STRING") if macports_or_fink
    puts("STRING")
  end;Fi[	@¯içI"w    puts("STRING")
    puts("STRING")
    puts("STRING") if macports_or_fink
    puts("STRING")
    puts("STRING");Fi[	@:@g7i[[	@0iI"ß    # define <tt>:to_model</tt> yourself returning a proxy object that wraps
    # your object with Active Model compliant methods.
    def function
      self
    end;Fi[	@iWI"S      
      # A reference to +self+
      def function
        self
      end;Fi[	@:I"if (self == Base) then;Fi[[	@i1I"í      
      # Returns a string like 'Post(id:integer, title:string, body:text)'
      def function
        if (self == Base) then
          super;Fi[	@ iI"ï      
      # True if this isn't a concrete subclass needing a STI type condition.
      def function
        if (self == Base) then
          false;Fi[	@ò+@Ci[[	@i I"<require("formula")
require("blacklist")
module Homebrew;Fi [	@7i I"<require("formula")
require("blacklist")
module Homebrew;Fi [	@ò+@Í'i[[	@Ì,iI"Vrequire("testing_env")
require("formula")
require("test/testball")
require("keg");Fi[	@>iI"Zrequire("testing_env")
require("formula")
require("test/testball")
require("version");Fi[	@:@ûIi[[	@¯	iBI"{      ##
      # Attempt to load a cached session
      def function
        var = false
        if cache_exists? then;Fi[	@Å!iI"D  end
  
  def function
    var = false
    @var = current_user;Fi[	@:@èJi[[	@PiæI"ø      # new connection with the database. Implementors should call super if they
      # override the default implementation.
      def function
        clear_cache!
        reset_transaction;Fi[	@Pi≈I"™      # Disconnects from the database if already connected. Otherwise, this
      # method does nothing.
      def function
        clear_cache!
        reset_transaction;Fi[	@:@—Vi[[	@∫iYI"[      end
      
      def function
        records.uniq.each do |var|
          begin;Fi[	@∫icI"[      end
      
      def function
        records.uniq.each do |var|
          begin;Fi[	@:@÷ i[[	@õi+I"t      
      # The install method override this to install
      def function
        raise("STRING")
      end;Fi[	@zi§I":  private
  
  def function
    raise("STRING")
  end;Fi[	I"if ARGV.dry_run? then;F@	i[[	@Ïi(I"£          if var.can_cleanup? then
            if Keg.new(var).linked?.! then
              if ARGV.dry_run? then
                puts("STRING")
              else;Fi[	@ÏiEI"Î        var = bottle_file_outdated?(var, var)
        if ((var and (var.version > var)) or ((ARGV.switch?("STRING") and (var and var.installed?.!)) or var)) then
          if ARGV.dry_run? then
            puts("STRING")
          else;Fi[	@:I"self.state = "LITERAL";Fi[[	@∞iNI"x        end
        
        def function
          self.state = "LITERAL"
          self.value = coder.load(value);Fi[	@∞iSI"x        end
        
        def function
          self.state = "LITERAL"
          self.value = coder.dump(value);Fi[	@:I"3associated_records_by_owner.each do |var, var|;Fi[[	@ﬁiI"ï        end
        
        def function
          associated_records_by_owner.each do |var, var|
            var = var.association(reflection.name);Fi[	@ÔiI"Ç        private
        
        def function
          associated_records_by_owner.each do |var, var|
            var = var.first;Fi[	@:@¨Qi[[	@ƒiI"§  module Associations
    class HasManyAssociation < CollectionAssociation
      def function
        case options["LITERAL"]
        when "LITERAL", "LITERAL" then;Fi[	@q
iI"°  module Associations
    class HasOneAssociation < SingularAssociation
      def function
        case options["LITERAL"]
        when "LITERAL", "LITERAL" then;Fi[	@:I"load_target.size;Fi[[	@Øi–I"œ      # equivalent. If not and you are going to need the records anyway this
      # method will take one less query. Otherwise +size+ is more efficient.
      def function
        load_target.size
      end;Fi[	@¡i"I"O      private
      
      def function
        load_target.size
      end;Fi[	I"*var = if ARGV.include?("STRING") then;FI"ARGV.next;Fi[[	@–)i
I"o  def function
    var = Pathname.getwd
    var = if ARGV.include?("STRING") then
      ARGV.next
    else;Fi[	@–)iI"å      var.version.to_s.empty? ? (raise("STRING")) : (var.version)
    end
    var = if ARGV.include?("STRING") then
      ARGV.next
    else;Fi[	@«i@|i[[	@–)iI"ù    var = Pathname.getwd
    var = if ARGV.include?("STRING") then
      ARGV.next
    else
      var.version.to_s.empty? ? (raise("STRING")) : (var.version);Fi[	@–)iI"z    end
    var = if ARGV.include?("STRING") then
      ARGV.next
    else
      var.basename.to_s =~ /(.*?)-?#{var}/;Fi[	I"Lif Process.uid.zero? and File.stat(HOMEBREW_BREW_FILE).uid.zero?.! then;F@÷ i[[	@»
iI"{      end
    end
    if Process.uid.zero? and File.stat(HOMEBREW_BREW_FILE).uid.zero?.! then
      raise("STRING")
    end;Fi[	@niI"¨  def function
    raise(KegUnspecifiedError) if ARGV.named.empty?
    if Process.uid.zero? and File.stat(HOMEBREW_BREW_FILE).uid.zero?.! then
      raise("STRING")
    end;Fi[	@:@S.i[[	@ØiËI"Õ      # Returns true if the collection has more than 1 record.
      # Equivalent to +collection.size > 1+.
      def function
        if block_given? then
          load_target.many? { |var| yield(*var) };Fi[	@Qi»I"é    
    # Returns true if there is more than one record.
    def function
      if block_given? then
        to_a.many? { |var| yield(*var) };Ti[	@:CI"4rescue FormulaInstallationAlreadyAttemptedError;Fi[[	@»
iXI"|      var.install
      var.caveats
      var.finish)
    rescue FormulaInstallationAlreadyAttemptedError
      # do nothing;Fi[	@âi?I"|      var.install
      var.caveats
      var.finish)
    rescue FormulaInstallationAlreadyAttemptedError
      # do nothing;Fi[	@·i@n
i[[	@»
iYI"ñ      var.caveats
      var.finish)
    rescue FormulaInstallationAlreadyAttemptedError
      # do nothing
    rescue CannotInstallFormulaError => var;Fi[	@âi@I"ñ      var.caveats
      var.finish)
    rescue FormulaInstallationAlreadyAttemptedError
      # do nothing
    rescue CannotInstallFormulaError => var;Fi[	I"class String;F@:i[[	@IiI"D  end
end
class String
  def function
    Formula.factory(self);Fi[	@$i I"Zclass String
  def function
    gsub(/^.{#{slice("LITERAL").length}STRING/, "STRING");Fi [	I"var = OpenStruct.new;FI"var.overwrite = true;Fi[[	@˘'i4I"û  def function
    FileUtils.touch((HOMEBREW_PREFIX / "STRING"))
    var = OpenStruct.new
    var.overwrite = true
    assert_equal("LITERAL", @keg.link(var));Fi[	@˘'i;I"â  def function
    FileUtils.touch((HOMEBREW_PREFIX / "STRING"))
    var = OpenStruct.new
    var.overwrite = true
    var.dry_run = true;Fi[	I"&print("STRING") { var.link(var) };F@ñ]i[[	@niI"|      end
      if var.dry_run and var.overwrite then
        print("STRING") { var.link(var) }
        next
      else;Fi[	@niI"r      else
        if var.dry_run then
          print("STRING") { var.link(var) }
          next
        end;Fi[	@:I"var = klass.unscoped;Fi[[	@´iI"å      end
      
      def function
        var = klass.unscoped
        var.merge!(eval_scope(klass, reflection.scope)) if reflection.scope;Fi[	@[iaI"q        end
        
        def function
          var = klass.unscoped
          var.default_scoped = true;Fi[	@:@”Ki[[	@¸iFI"{      end
      
      def function
        if options["LITERAL"] then
          owner.send(reflection.name).try("LITERAL");Fi[	@Øi-I"y      private
      
      def function
        if options["LITERAL"] then
          interpolate(options["LITERAL"]);Fi[	@:@I1i[[	@Ô'iI"pend
class TestZip < Formula
  def function
    @var = "STRING"
    var = (HOMEBREW_CACHE.parent + "STRING");Fi[	@Ì,iI"R  version("STRING")
  
  def function
    @var = "STRING"
    @var = "STRING";Fi[	I"require("open-uri");F@ ,i[[	@
,iI"crequire("rss/1.0")
require("rss/2.0")
require("open-uri")
require("fileutils")
require("yaml");Fi[	@
iI"Urequire("rubygems")
require("open-uri")
require("fileutils")
require("nokogiri");Fi[	I"ENV["STRING"] = "STRING";F@ji[[	@¢+iI"Ω      ENV["STRING"] = ENV["STRING"].split("STRING").insert("LITERAL", "STRING").join("STRING")
    end
    ENV["STRING"] = "STRING"
    ENV["STRING"] = "STRING"
    ENV["STRING"] = "STRING";Fi[	@¢+iI"≥    end
    ENV["STRING"] = "STRING"
    ENV["STRING"] = "STRING"
    ENV["STRING"] = "STRING"
    puts("STRING".undent_________________________________________________________72);Fi[	I"+when /^#{HOMEBREW_LIBRARY}STRING/ then;F@;i[[	@Êi`I"Ü  def function
    case self.to_s
    when /^#{HOMEBREW_LIBRARY}STRING/ then
      "STRING"
    when /^#{HOMEBREW_LIBRARY}STRING/ then;Fi[	@ÊibI"|    when /^#{HOMEBREW_LIBRARY}STRING/ then
      "STRING"
    when /^#{HOMEBREW_LIBRARY}STRING/ then
      "STRING"
    else;Fi[	I"ofail("STRING");F@ñ]i[[	@*5iI"t    ARGV.formulae.each do |var|
      unless var.installed? then
        ofail("STRING")
        next
      end;Fi[	@*5iI"a      end
      unless var.test_defined? then
        ofail("STRING")
        next
      end;Fi[	I"var.unlink;FI"var.uninstall;Fi[[	@;
iI"Ü        ARGV.kegs.each do |var|
          puts("STRING")
          var.unlink
          var.uninstall
          rm_opt_link(var.fname);Fi[	@Ì,i#I"f    yield
    var = Keg.new(var.prefix)
    var.unlink
    var.uninstall
    assert(var.exist?.!);Fi[	@:@83i[[	@„	iÄI"õ    # This method is available within the context of an ActiveRecord::Base
    # instance.
    def function
      var = nil
      self.class.transaction do;Fi[	@í#ioI"r        end
        
        def function
          var = nil
          @images.each_with_index do |var, var|;Fi[	@|I""job_type("LITERAL", "STRING");Fi[[	I".projects//whenever_proj/whenever/setup.rb;TiI"Ñ  job_type("LITERAL", "STRING")
  job_type("LITERAL", "STRING")
else
  job_type("LITERAL", "STRING")
  job_type("LITERAL", "STRING");Fi[	@DjiI"fif Whenever.rails3? then
  job_type("LITERAL", "STRING")
else
  job_type("LITERAL", "STRING")
end;Fi[	@|@pHi[[	@¬0i#I"à        var.pos -= "LITERAL"
      end
    else
      if ((var >> "LITERAL") == "LITERAL") then
        if check_next_sequence(var) then;Fi[	@¬0i.I"í          var.pos -= "LITERAL"
        end
      else
        if ((var >> "LITERAL") == "LITERAL") then
          if check_next_sequence(var) then;Fi[	@|@Zbi[[	@]i´I"]        end
        failed!
      else
        Resque.logger.info("STRING")
      ensure;Fi[	@]iœI"m          sleep(var)
          retry
        else
          Resque.logger.info("STRING")
          raise;Fi[	@|I"Mif env["STRING"] and env["STRING"].match(/#{request_path}STRING/).! then;Fi[[	@€i≤I"          if request.params["STRING"] then
            env["STRING"]["STRING"] = request.params["STRING"]
          else
            if env["STRING"] and env["STRING"].match(/#{request_path}STRING/).! then
              env["STRING"]["STRING"] = env["STRING"];Fi[	@€iÚI"Ò      if request.params["STRING"] then
        @env["STRING"]["STRING"] = request.params["STRING"]
      else
        if env["STRING"] and env["STRING"].match(/#{request_path}STRING/).! then
          @env["STRING"]["STRING"] = env["STRING"];Fi[	I" fetch(var, []).map do |var|;F@4i[[	@Êi}I"d  
  def function(var)
    fetch(var, []).map do |var|
      case var
      when "LITERAL" then;Fi[	@ÊiãI"d  
  def function(var)
    fetch(var, []).map do |var|
      case var
      when "LITERAL" then;Fi[	@|I"!var.fails_with?("LITERAL").!;Fi[[	@Êi1I"l    when nil then
      var.fails_with?("LITERAL")
    else
      var.fails_with?("LITERAL").!
    end);Fi[	@ÊiTI"l    when nil then
      var.fails_with?("LITERAL")
    else
      var.fails_with?("LITERAL").!
    end);Fi[	I"oh1("STRING");FI"var.unlink if var;Fi[[	@âi;I"©      var.show_header = false
      var.install_bottle = (install_bottle?(var) and var.used_options.empty?)
      oh1("STRING")
      var.unlink if var
      var.install;Fi[	@—iqI"}      var.ignore_deps = true
      var.show_header = false
      oh1("STRING")
      var.unlink if var
      var.install;Fi[	I"6var = Keg.new(var.linked_keg.realpath) rescue nil;FI")var = FormulaInstaller.new(var, var);Fi[[	@âi7I"•        Tab.dummy_tab(var)
      end
      var = Keg.new(var.linked_keg.realpath) rescue nil
      var = FormulaInstaller.new(var, var)
      var.show_header = false;Fi[	@—imI"´    begin
      (var = Tab.for_formula(var)
      var = Keg.new(var.linked_keg.realpath) rescue nil
      var = FormulaInstaller.new(var, var)
      var.ignore_deps = true;Fi[	@kj@ÛBi[[	@âi<I"ù      var.install_bottle = (install_bottle?(var) and var.used_options.empty?)
      oh1("STRING")
      var.unlink if var
      var.install
      var.caveats;Fi[	@—irI"r      var.show_header = false
      oh1("STRING")
      var.unlink if var
      var.install
      var.caveats;Fi[	@|I"var.stable;Fi[[	@≈iI"k      when "LITERAL" then
        var.bottle
      else
        var.stable
      end, var.active_spec);Fi[	@≈i#I"k      when "LITERAL" then
        var.bottle
      else
        var.stable
      end, var.active_spec);Fi[	@|@GDi[[	@·iI"w    if (version == "LITERAL") then
      "LITERAL"
    else
      if (version == "LITERAL") then
        "LITERAL";Fi[	@·iI"|      if (version == "LITERAL") then
        "LITERAL"
      else
        if (version == "LITERAL") then
          "LITERAL";Fi[	@¬T@ói[[	@ioI"ò      end
    when "LITERAL" then
      if @compilers.include?("LITERAL") and (MacOS.clang_build_version >= "LITERAL") then
        "LITERAL"
      else;Fi[	@iyI"ò      end
    when "LITERAL" then
      if @compilers.include?("LITERAL") and (MacOS.clang_build_version >= "LITERAL") then
        "LITERAL"
      else;Fi[	@|@ÀCi[[	@iqI"π      if @compilers.include?("LITERAL") and (MacOS.clang_build_version >= "LITERAL") then
        "LITERAL"
      else
        if @compilers.include?("LITERAL") then
          "LITERAL";Fi[	@i{I"π      if @compilers.include?("LITERAL") and (MacOS.clang_build_version >= "LITERAL") then
        "LITERAL"
      else
        if @compilers.include?("LITERAL") then
          "LITERAL";Fi[	@|I"if var.dry_run then;Fi[[	@niI"â        print("STRING") { var.link(var) }
        next
      else
        if var.dry_run then
          print("STRING") { var.link(var) };Fi[	@›
iƒI"n        puts(var) if var.exist?
        return
      else
        if var.dry_run then
          puts(var);Fi[	I"&var = (HOMEBREW_CACHE / "STRING");FI"(assert_equal("STRING", var.extname);Fi[[	@Ô'iáI"Ñ  
  def function
    var = (HOMEBREW_CACHE / "STRING")
    assert_equal("STRING", var.extname)
    assert_equal("STRING", var.stem);Fi[	@Ô'iãI"«    assert_equal("STRING", var.stem)
    assert_version_equal("STRING", var.version)
    var = (HOMEBREW_CACHE / "STRING")
    assert_equal("STRING", var.extname)
    assert_equal("STRING", var.stem);Fi[	I"!(var << var) if var.exist?.!;F@6i[[	@ÈiﬂI"|      (var << "STRING")
    end
    (var << var) if var.exist?.!
    (var << var)
    ((var << "STRING") << var) if var;Fi[	@Èi˘I"ª    var = var.exist? ? ("STRING") : ("STRING")
    var = [@@svn, var, "STRING", "STRING", "STRING"]
    (var << var) if var.exist?.!
    (var << var)
    ((var << "STRING") << var) if var;Fi[	@’Q@¬7i[[	@Èi·I"ê    (var << var) if var.exist?.!
    (var << var)
    ((var << "STRING") << var) if var
    (var << "STRING") if var
    quiet_safe_system(*var);Fi[	@Èi˚I"ê    (var << var) if var.exist?.!
    (var << var)
    ((var << "STRING") << var) if var
    (var << "STRING") if var
    quiet_safe_system(*var);Fi[	@|@ 5i[[	@
iI"÷          puts
        end
      else
        raise(FormulaUnspecifiedError) if ARGV.named.empty?
        var = ARGV.formulae.map { |var| ARGV.one? ? (var.deps) : (var.recursive_deps) }.intersection.map(&"LITERAL");Fi[	@ä2iI"ﬂ      var = Homebrew.outdated_brews.collect { |var| var.name }
      Formula.select { |var| (var.installed? or var.include?(var.name)) }
    else
      raise(FormulaUnspecifiedError) if ARGV.named.empty?
      ARGV.formulae;Fi[	@™]@˜Ci[[	@Èi<I"t  def function
    var = Dir.getwd
    Dir.chdir(@clone) do
      if @spec and @ref then
        ohai("STRING");Fi[	@Èi°I"t  def function
    var = Dir.getwd
    Dir.chdir(@clone) do
      if @spec and @ref then
        ohai("STRING");Fi[	@fd@™]i[[	@Èi;I"`  
  def function
    var = Dir.getwd
    Dir.chdir(@clone) do
      if @spec and @ref then;Fi[	@Èi†I"`  
  def function
    var = Dir.getwd
    Dir.chdir(@clone) do
      if @spec and @ref then;Fi[	@|I"if var.directory? then;Fi[[	@.!iAI"»          ((var.extname == "STRING") or (var.extname == "STRING")) and var.symlink?.!
        end
      else
        if var.directory? then
          var.symlink? ? (puts("STRING")) : (print_dir(var));Fi[	@›
i‰I"ò          make_relative_symlink(var, var, var)
        end
      else
        if var.directory? then
          next if var.directory? and var.symlink?.!;Fi[	@_dI"assert_nothing_raised do;Fi[[	@Ô'iBI"Ö    require("cmd/prune")
    require("cleaner")
    nostdout do
      assert_nothing_raised do
        var = TestBallWithRealPath.new;Fi[	@Ô'inI"x  
  def function
    nostdout do
      assert_nothing_raised do
        assert(Pathname.getwd.rmdir_if_possible.!);Fi[	I"Find.prune;F@i[[	@›
i‹I"¥        case yield(var.relative_path_from(var))
        when "LITERAL", nil then
          Find.prune
        when "LITERAL" then
          next if (File.basename(var) == "STRING");Fi[	@›
iÍI"Ω          case yield(var.relative_path_from(var))
          when "LITERAL" then
            Find.prune
          when "LITERAL" then
            var.mkpath unless resolve_any_conflicts(var);Fi[	@ªT@i[[	@Èi¯I"x    case var
    when "LITERAL" then
      CVSDownloadStrategy
    when "LITERAL" then
      BazaarDownloadStrategy;Fi[	@Èi!I"~      CurlDownloadStrategy
    when "LITERAL" then
      CVSDownloadStrategy
    when "LITERAL" then
      GitDownloadStrategy;Fi[	@üT@i[[	@Èi˙I"Ä      CVSDownloadStrategy
    when "LITERAL" then
      BazaarDownloadStrategy
    when "LITERAL" then
      GitDownloadStrategy;Fi[	@ÈiI"y    case var
    when "LITERAL" then
      BazaarDownloadStrategy
    when "LITERAL" then
      CurlDownloadStrategy;Fi[	@|@◊gi[[	@3
i]I"£            var = var["LITERAL"].strip
          end
        else
          if contains_interpolation?(var) then
            var = unescape_interpolation(var, var);Fi[	@3
idI"Ç          end
        end
      else
        if contains_interpolation?(var) then
          var = unescape_interpolation(var, var);Fi[	@|@<i[[	@^iÌI"ÿ          var = ["STRING", "STRING", "STRING", "STRING"]
          var = Node.new("LITERAL", var)
        else
          if (var["LITERAL"] == "STRING") then
            var = ["STRING", "STRING", "STRING", "STRING"];Fi[	@^iI"™          var.unshift("STRING")
          var = Node.new("LITERAL", var)
        else
          if (var["LITERAL"] == "STRING") then
            var["LITERAL"] = "STRING";Fi[	@|I"if var.is_a?(Reshare) then;Fi[[	@L8i	I"›    if var.is_a?(Photo) then
      I18n.t("STRING", "LITERAL" => "LITERAL", "LITERAL" => (var.status_message_author_name))
    else
      if var.is_a?(Reshare) then
        I18n.t("STRING", "LITERAL" => (var.author_name));Fi[	@”iI"Û        if (var.is_a?(Comment) or var.is_a?(Like)) then
          var = var.concatenate_or_create(var, var.parent, var, var)
        else
          if var.is_a?(Reshare) then
            var = var.concatenate_or_create(var, var.root, var, var);Fi[	I"## Request a 32-bit only build.;FI"L# This is needed for some use-cases though we prefer to build Universal;Fi[[	@B
iI"ò  end
  
  # Request a 32-bit only build.
  # This is needed for some use-cases though we prefer to build Universal
  # when a 32-bit version is needed.;Fi[	@‘i»I"ò  end
  
  # Request a 32-bit only build.
  # This is needed for some use-cases though we prefer to build Universal
  # when a 32-bit version is needed.;Fi[	@¸jI"'# when a 32-bit version is needed.;Fi[[	@B
i{I"°  
  # Request a 32-bit only build.
  # This is needed for some use-cases though we prefer to build Universal
  # when a 32-bit version is needed.
  def function;Fi[	@‘i…I"°  
  # Request a 32-bit only build.
  # This is needed for some use-cases though we prefer to build Universal
  # when a 32-bit version is needed.
  def function;Fi[	@k@:i[[	@B
i|I"µ  # Request a 32-bit only build.
  # This is needed for some use-cases though we prefer to build Universal
  # when a 32-bit version is needed.
  def function
    include?("STRING");Fi[	@‘i I"ª  # Request a 32-bit only build.
  # This is needed for some use-cases though we prefer to build Universal
  # when a 32-bit version is needed.
  def function
    @args.include?("STRING");Fi[	@|@)fi[[	@EiI"í      var = User.find_by_invitation_token(params["LITERAL"])
      var.ugly_accept_invitation_code if var
    else
      params["LITERAL"]
    end;Fi[	@B5iJI"•    if (params["LITERAL"]["LITERAL"] or (params["LITERAL"]["LITERAL"].first == "STRING")) then
      current_user.aspect_ids
    else
      params["LITERAL"]
    end;Fi[	I"raise("STRING".undent);F@|i[[	@J
i I"ê      if $?.success?.! then
        if self.exist? then
          raise("STRING".undent)
        else
          if dirname.writable_real?.! then;Fi[	@J
iI"å        else
          if dirname.writable_real?.! then
            raise("STRING".undent)
          else
            raise("STRING".undent);Fi[	I"+var = [var] unless var.kind_of?(Array);F@!6i[[	@$i;I"∫  # Removes variable assignments completely.
  def function(var)
    var = [var] unless var.kind_of?(Array)
    var.each do |var|
      var = gsub!(Regexp.new("STRING"), "STRING", false);Fi[	@ŸiI"¬    var = "LITERAL"
    normalize_patches(var).each do |var, var|
      var = [var] unless var.kind_of?(Array)
      var.each do |var|
        (@patches << Patch.new(var, ("STRING" % var), var));Fi[	@|@◊ei[[	@Ei#I"ú    if @invitation_code.present? then
      render("STRING", "LITERAL" => (false))
    else
      flash["LITERAL"] = t("STRING")
      redirect_to(root_url);Fi[	@Å!icI"µ      if params["LITERAL"].present? and params["LITERAL"]["LITERAL"].present? then
        flash["LITERAL"] = t("STRING")
      else
        flash["LITERAL"] = t("STRING")
      end;Fi[	@Qd@:i[[	@—iI"m  
  def function
    if (f.prefix + "STRING").directory? then
      opoo("STRING")
      puts("STRING");Fi[	@—i!I"m  
  def function
    if (f.prefix + "STRING").directory? then
      opoo("STRING")
      puts("STRING");Fi[	@Ö0@Hi[[	@‘i)I"h    @var = var
    unless var.nil? then
      @var = var.delete("LITERAL")
      @var = var
    end;Fi[	@iI"å        @var = var.delete("LITERAL")
        @var = var.delete("LITERAL")
        @var = var.delete("LITERAL")
        @var = var
      else;Fi[	@|@ºei[[	@ceiI"é      disconnect_if_contact(var.person)
      var = { "LITERAL" => (t("STRING")) }
    else
      var = { "LITERAL" => (t("STRING")) }
    end;Fi[	@ceiI"•    if current_user.blocks.find(params["LITERAL"]).delete then
      var = { "LITERAL" => (t("STRING")) }
    else
      var = { "LITERAL" => (t("STRING")) }
    end;Fi[	I";var = (HOMEBREW_PREFIX + var.relative_path_from(self));FI"*var.extend(ObserverPathnameExtension);Fi[[	@›
i0I"Ú      var.find do |var|
        next if (var == self)
        var = (HOMEBREW_PREFIX + var.relative_path_from(self))
        var.extend(ObserverPathnameExtension)
        next if (var.symlink?.! or (var.exist?.! or var.!=(var.resolved_path)));Fi[	@›
i÷I"±    var.find do |var|
      next if (var == var)
      var = (HOMEBREW_PREFIX + var.relative_path_from(self))
      var.extend(ObserverPathnameExtension)
      if var.file? then;Fi[	@|@pAi[[	@	&i&I"ó    when "STRING" then
      current_user.contacts
    else
      if params["LITERAL"] then
        @var = current_user.aspects.find(params["LITERAL"]);Fi[	@q!iGI"Ì    if params["LITERAL"] then
      @var = current_user.contacts.find(params["LITERAL"]).id
    else
      if params["LITERAL"] then
        @var = current_user.aspects.find(params["LITERAL"]).contacts.map { |var| var.id }.join("STRING");Fi[	I"%link_dir("STRING", var) do |var|;F@;i[[	@›
ipI"Ø      link_dir("STRING", var) { "LITERAL" }
      link_dir("STRING", var) { "LITERAL" }
      link_dir("STRING", var) do |var|
        case var.to_s
        when "STRING" then;Fi[	@›
i{I"r        end
      end
      link_dir("STRING", var) do |var|
        case var.to_s
        when "STRING" then;Fi[	I"Asystem(MacOS.locate("STRING"), "STRING", var, "STRING", var);F@|i[[	@iI"          var.each do |var|
            if (var.dylib? or var.mach_o_bundle?) and (var.parent + var).exist? then
              system(MacOS.locate("STRING"), "STRING", var, "STRING", var)
            else
              if var.mach_o_executable? and (lib / var).exist? then;Fi[	@iI"Ò            else
              if var.mach_o_executable? and (lib / var).exist? then
                system(MacOS.locate("STRING"), "STRING", var, "STRING", var)
              else
                var = find_dylib(Pathname.new(var).basename);Fi[	@|@™di[[	@0iñI"ñ        if (confirmed?.! or pending_reconfirmation?) then
          yield
        else
          self.errors.add("LITERAL", "LITERAL")
          false;Fi[	@i{I"{        if access_locked? then
          yield
        else
          self.errors.add("LITERAL", "LITERAL")
          false;Fi[	I"case MacOS.version;F@i[[	@ıiI"T  
  def function
    case MacOS.version
    when "LITERAL" then
      "STRING";Fi[	@iI"    else
      if (prefix.to_s == "STRING") then
        case MacOS.version
        when "LITERAL" then
          "STRING";Fi[	@|I"return false;Fi[[	@ÓiEI"∆      if self.post.comments.where("LITERAL" => (var.person.id)).!=([]) and self.author_id.!=(var.person.id) then
        return Notifications::AlsoCommented
      else
        return false
      end;Fi[	@'
iI"c      if self.like_for(var) then
        return true
      else
        return false
      end;Fi[	@|I"var.position.value;Fi[[	@í#i}I"Õ            var.top = if (var.position.unit_str == "STRING") then
              ((@height - var.height) * (var.position.value / "LITERAL"))
            else
              var.position.value
            end;Fi[	@í#iäI"”            var.left = (if (var.position.unit_str == "STRING") then
              ((@width - var.width) * (var.position.value / "LITERAL"))
            else
              var.position.value
            end).to_i;Fi[	@|I"Ereturn Sass::Script::String.new("STRING") if absolute_path?(var);Fi[[	@f6iRI"≈      if var =~ /^#{Regexp.escape(Compass.configuration.http_images_path)}STRING/ then
        var = $1
      else
        return Sass::Script::String.new("STRING") if absolute_path?(var)
      end;Fi[	@f6iI"œ      if var =~ /^#{Regexp.escape(Compass.configuration.http_generated_images_path)}STRING/ then
        var = $1
      else
        return Sass::Script::String.new("STRING") if absolute_path?(var)
      end;Fi[	I"class Patch;FI"attr_reader("LITERAL");Fi[[	@Ÿi8I"6  end
end
class Patch
  attr_reader("LITERAL")
  ;Fi[	@¸'iI"I  attr_reader("LITERAL")
end
class Patch
  attr_reader("LITERAL")
  ;Fi[	@ÖTI"8FileUtils.mv(@patch_filename, @compressed_filename);Fi[[	@ŸiTI"©    case @compression
    when "LITERAL" then
      @var = (@patch_filename + "STRING")
      FileUtils.mv(@patch_filename, @compressed_filename)
    when "LITERAL" then;Fi[	@ŸiWI"æ      FileUtils.mv(@patch_filename, @compressed_filename)
    when "LITERAL" then
      @var = (@patch_filename + "STRING")
      FileUtils.mv(@patch_filename, @compressed_filename)
    else;Fi[	@Cd@i[[	@ iI"z  
  def function
    case @language
    when "LITERAL" then
      ["STRING", "STRING", "STRING", "STRING", "STRING"];Fi[	@ i.I"P  
  def function
    case @language
    when "LITERAL" then
      "STRING";Fi[	@|@±bi[[	@¶iàI"Ó              var[var].stop = var[(var - "LITERAL")].stop.plus(var[var].stop.minus(var[(var - "LITERAL")].stop).div(Sass::Script::Number.new(var)))
              break
            else
              var = (var + "LITERAL")
            end;Fi[	@ô*iCI"á        if (var["STRING"] == var) then
          Resque::Failure.remove(var)
        else
          var = (var + "LITERAL")
        end;Fi[	@|@Bi[[	@Ài+I"˚            if (var.numerator_units == ["STRING"]) and (var.denominator_units == []) then
              Sass::Script::Number.new(("LITERAL" - var.value), ["STRING"])
            else
              Compass::Util.compass_warn("STRING")
              var;Fi[	@Ài/I"v              var
            end
          else
            Compass::Util.compass_warn("STRING")
            var;Fi[	@È'@Âhi[[	I"-projects//homebrew_proj/test/test_ENV.rb;Ti I"]require("testing_env")
require("hardware")
class EnvironmentTests < Test::Unit::TestCase;Fi [	I"2projects//homebrew_proj/test/test_hardware.rb;Ti I"Zrequire("testing_env")
require("hardware")
class HardwareTests < Test::Unit::TestCase;Fi [	@|@)bi[[	@
i£I"~      if parent_resource then
        { parent_resource => (resource_class) }
      else
        resource_class
      end;Fi[	@
iÀI"J          end
        end
      else
        resource_class
      end;Fi[	@|I"3MUTEX.synchronize { Logger.message("STRING") };Fi[[	@%iàI"˚              if var and (var.etag == var.md5) then
                MUTEX.synchronize { Logger.message("STRING") }
              else
                MUTEX.synchronize { Logger.message("STRING") }
                File.open(var.path, "STRING") do |var|;Fi[	@%iìI"»                  MUTEX.synchronize { Logger.message("STRING") }
                  var.destroy
                else
                  MUTEX.synchronize { Logger.message("STRING") }
                end;Fi[	@|@?Ei[[	@ziÂI"        if var and File.exist?(var) then
          "STRING"
        else
          Logger.warn("STRING")
          # do nothing;Fi[	@zi!I"ä            if var then
              import_key(var, var)
            else
              Logger.warn("STRING")
              # do nothing;Fi[	@È'I"require("extend/string");Fi[[	@\i I"_require("testing_env")
require("extend/string")
class InreplaceTest < Test::Unit::TestCase;Fi [	I"0projects//homebrew_proj/test/test_string.rb;Ti I"\require("testing_env")
require("extend/string")
class StringTest < Test::Unit::TestCase;Fi [	I"ARGV.unshift("STRING");F@æki[[	@†i"I"g  
  def function
    ARGV.unshift("STRING")
    ARGV.unshift("STRING")
    ARGV.unshift("STRING");Fi[	@†i#I"Ç  def function
    ARGV.unshift("STRING")
    ARGV.unshift("STRING")
    ARGV.unshift("STRING")
    assert(ARGV.switch?("STRING"));Fi[	I"#assert(ARGV.switch?("STRING"));F@≈ki[[	@†i%I"û    ARGV.unshift("STRING")
    ARGV.unshift("STRING")
    assert(ARGV.switch?("STRING"))
    assert(ARGV.switch?("STRING"))
    assert(ARGV.switch?("STRING"));Fi[	@†i&I"®    ARGV.unshift("STRING")
    assert(ARGV.switch?("STRING"))
    assert(ARGV.switch?("STRING"))
    assert(ARGV.switch?("STRING"))
    assert(ARGV.switch?("STRING").!);Fi[	@|@®[i[[	@[iI"è          if current_scope then
            current_scope.clone
          else
            var = relation
            var.default_scoped = true;Fi[	@[i*I"ö          if current_scope then
            current_scope.scope_for_create
          else
            var = relation
            var.default_scoped = true;Fi[	@Í'@&>i[[	@Ì,iI"Årequire("testing_env")
require("formula")
require("test/testball")
require("keg")
class TestScriptFileFormula < ScriptFileFormula;Fi[	@˘'iI"Wrequire("testing_env")
require("test/testball")
require("keg")
require("stringio");Fi[	@|@][i[[	@∏iMI"^              end
            end
          else
            var[var] = var
          end;Fi[	@—i•I"ó          if var[var].is_a?(Hash) then
            merge_joins(var[var], var) unless var.empty?
          else
            var[var] = var
          end;Fi[	@hT@|i[[	@≈iI"q      assert_equal(case MacOS.cat
      when "LITERAL" then
        var.bottle
      else
        var.stable;Fi[	@≈i"I"q      assert_equal(case MacOS.cat
      when "LITERAL" then
        var.bottle
      else
        var.stable;Fi[	@ÄjI"end, var.active_spec);Fi[[	@≈iI"x        var.bottle
      else
        var.stable
      end, var.active_spec)
      var = LionBottleSpecTestBall.new;Fi[	@≈i$I"{        var.bottle
      else
        var.stable
      end, var.active_spec)
      var = AllCatsBottleSpecTestBall.new;Fi[	I"&@var = SoftwareSpec.new("STRING");F@Œi[[	@Ô'iI"Æ    var = (HOMEBREW_CACHE.parent + "STRING")
    Kernel.system("STRING", "STRING", "STRING", var, ABS__FILE__)
    @var = SoftwareSpec.new("STRING")
    super("STRING")
  end;Fi[	@€i5I"}class TestCompilerFailures < Formula
  def function(var)
    @var = SoftwareSpec.new("STRING")
    super("STRING")
  end;Fi[	@|I"'if Array.method_defined?(var) then;Fi[[	@i2I"‹          self.class.delegate_to_scoped_klass(var)
          scoping { @klass.send(var, *var, &var) }
        else
          if Array.method_defined?(var) then
            self.class.delegate(var, "LITERAL" => "LITERAL");Fi[	@ihI"±      if @klass.respond_to?(var) then
        scoping { @klass.send(var, *var, &var) }
      else
        if Array.method_defined?(var) then
          to_a.send(var, *var, &var);Fi[	@|@‡Bi[[	@J
i*I"}      var = (self + var)
      var = Pathname.new(var)
    else
      var = self
      var = (self + File.basename(var));Fi[	@ÿi8I"å            var = Nokogiri::XML::Node.new("STRING", document)
            send(var, var)
          else
            var = self
          end;Fi[	@ﬁ,I"/var.stable.instance_eval { md5("STRING") };Fi[[	@Ú'iI"s  
  def function
    var = TestBall.new
    var.stable.instance_eval { md5("STRING") }
    good_checksum(var);Fi[	@Ú'iI"r  
  def function
    var = TestBall.new
    var.stable.instance_eval { md5("STRING") }
    bad_checksum(var);Fi[	@ﬁ,I"0var.stable.instance_eval { sha1("STRING") };Fi[[	@Ú'iI"t  
  def function
    var = TestBall.new
    var.stable.instance_eval { sha1("STRING") }
    good_checksum(var);Fi[	@Ú'i#I"s  
  def function
    var = TestBall.new
    var.stable.instance_eval { sha1("STRING") }
    bad_checksum(var);Fi[	@ﬁ,I"2var.stable.instance_eval { sha256("STRING") };Fi[[	@Ú'i)I"v  
  def function
    var = TestBall.new
    var.stable.instance_eval { sha256("STRING") }
    good_checksum(var);Fi[	@Ú'i/I"u  
  def function
    var = TestBall.new
    var.stable.instance_eval { sha256("STRING") }
    bad_checksum(var);Fi[	@|I"'if superclass.abstract_class? then;Fi[[	@ i I"ú        if (self == Base) then
          false
        else
          if superclass.abstract_class? then
            superclass.descends_from_active_record?;Fi[	@&irI"Ê        self.table_name = if abstract_class? then
          (superclass == Base) ? (nil) : (superclass.table_name)
        else
          if superclass.abstract_class? then
            (superclass.table_name or compute_table_name);Fi[	@åD@ﬁ,i[[	@Ô'iOI"ﬁ    var = TestBall.new
    var.instance_eval { @var = Version.new("STRING") }
    var.active_spec.instance_eval { @var = Version.new("STRING") }
    var = TestBall.new
    var.instance_eval { @var = Version.new("STRING") };Fi[	@Ô'iRI"ﬁ    var = TestBall.new
    var.instance_eval { @var = Version.new("STRING") }
    var.active_spec.instance_eval { @var = Version.new("STRING") }
    var = TestBall.new
    var.instance_eval { @var = Version.new("STRING") };Fi[	I"var.brew { var.install };F@!li[[	@Ô'iWI"Ø    var.active_spec.instance_eval { @var = Version.new("STRING") }
    nostdout do
      var.brew { var.install }
      var.brew { var.install }
      var.brew { var.install };Fi[	@Ô'iXI"y    nostdout do
      var.brew { var.install }
      var.brew { var.install }
      var.brew { var.install }
    end;Fi[	I"assert(var.installed?);F@(li[[	@Ô'i[I"|      var.brew { var.install }
    end
    assert(var.installed?)
    assert(var.installed?)
    assert(var.installed?);Fi[	@Ô'i\I"á    end
    assert(var.installed?)
    assert(var.installed?)
    assert(var.installed?)
    nostdout { Homebrew.cleanup_formula(var) };Fi[	@|I")ActiveRecord::FixtureSet.reset_cache;Fi[[	@[iòI"≠          var.begin_transaction("LITERAL" => (false))
        end
      else
        ActiveRecord::FixtureSet.reset_cache
        @@already_loaded_fixtures[self.class] = nil;Fi[	@[ißI"u        end
        @fixture_connections.clear
      else
        ActiveRecord::FixtureSet.reset_cache
      end;Fi[	@°jI"%assert_equal("STRING", var.stem);Fi[[	@Ô'iàI"±  def function
    var = (HOMEBREW_CACHE / "STRING")
    assert_equal("STRING", var.extname)
    assert_equal("STRING", var.stem)
    assert_version_equal("STRING", var.version);Fi[	@Ô'iåI"“    assert_version_equal("STRING", var.version)
    var = (HOMEBREW_CACHE / "STRING")
    assert_equal("STRING", var.extname)
    assert_equal("STRING", var.stem)
    assert_version_equal("STRING", var.version);Fi[	@6l@|9i[[	@Ô'iâI"»    var = (HOMEBREW_CACHE / "STRING")
    assert_equal("STRING", var.extname)
    assert_equal("STRING", var.stem)
    assert_version_equal("STRING", var.version)
    var = (HOMEBREW_CACHE / "STRING");Fi[	@Ô'içI"®    var = (HOMEBREW_CACHE / "STRING")
    assert_equal("STRING", var.extname)
    assert_equal("STRING", var.stem)
    assert_version_equal("STRING", var.version)
  end;Fi[	@|9@ú9i[[	@3i}I"Ÿ    var = SpecTestBall.new
    assert_equal(var.devel, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_equal("STRING", var.url)
    assert_equal(CurlDownloadStrategy, var.download_strategy);Fi[	@3iÉI"◊    var = SpecTestBall.new
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy);Fi[	@|@¸Xi[[	@ìiÄI"{          if var.nil? then
            "STRING"
          else
            if (var == "STRING") then
              "STRING";Fi[	@ÏilI"º        yield
        push_silent("STRING", "LITERAL") unless @node.value["LITERAL"]
      else
        if (var == "STRING") then
          if @node.parent.children.last.equal?(@node) then;Fi[	I"cp("STRING", lib);F@Oli[[	I"1projects//homebrew_proj/test/test_cleaner.rb;TiI"u      lib.mkpath
      cp("STRING", bin)
      cp("STRING", lib)
      cp("STRING", lib)
      cp("STRING", lib);Fi[	@RliI"l      cp("STRING", bin)
      cp("STRING", lib)
      cp("STRING", lib)
      cp("STRING", lib)
    end;Fi[	I"<assert_equal("LITERAL", (var.lib / "STRING").stat.mode);F@Wli[[	@RliI"    assert_nothing_raised { Cleaner.new(var) }
    assert_equal("LITERAL", (var.bin / "STRING").stat.mode)
    assert_equal("LITERAL", (var.lib / "STRING").stat.mode)
    assert_equal("LITERAL", (var.lib / "STRING").stat.mode)
    assert_equal("LITERAL", (var.lib / "STRING").stat.mode);Fi[	@RliI"ı    assert_equal("LITERAL", (var.bin / "STRING").stat.mode)
    assert_equal("LITERAL", (var.lib / "STRING").stat.mode)
    assert_equal("LITERAL", (var.lib / "STRING").stat.mode)
    assert_equal("LITERAL", (var.lib / "STRING").stat.mode)
  end;Fi[	@KAI"(assert_equal(@set.count, "LITERAL");Fi[[	@NAiI"î  def function
    (@set << X11Dependency.new)
    (@set << X11Dependency.new)
    assert_equal(@set.count, "LITERAL")
    (@set << Requirement.new);Fi[	@NAiI"ª  def function
    (@set << X11Dependency.new("STRING"))
    (@set << X11Dependency.new)
    assert_equal(@set.count, "LITERAL")
    assert_equal(@set.to_a, [X11Dependency.new("STRING")]);Fi[	@ÍB@∑Di[[	@ÊiI"¿    assert(var.fails_with?("LITERAL").!)
    assert(var.fails_with?("LITERAL"))
    assert(var.fails_with?("LITERAL").!)
    var.select_compiler
    assert_equal(case MacOS.clang_build_version;Fi[	@ÊieI"«    assert(var.fails_with?("LITERAL"))
    assert(var.fails_with?("LITERAL").!)
    assert(var.fails_with?("LITERAL").!)
    var.select_compiler
    assert_equal(MacOS.default_compiler, ENV.compiler);Fi[	@ÍB@ÍBi[[	@Êi,I"≈    var = TestNoCompilerFailures.new
    var = CompilerSelector.new(var)
    assert(var.fails_with?("LITERAL").!)
    assert(var.fails_with?("LITERAL").!)
    assert(case MacOS.gcc_42_build_version;Fi[	@ÊidI"¥    var = CompilerSelector.new(var)
    assert(var.fails_with?("LITERAL"))
    assert(var.fails_with?("LITERAL").!)
    assert(var.fails_with?("LITERAL").!)
    var.select_compiler;Fi[	@|@è8i[[	@ioI"∫          if var.encoding.name =~ "LITERAL" then
            return var.gsub(Regexp.new("STRING".encode(var.encoding.name)), "STRING")
          else
            return var
          end;Fi[	@6i\I"∫            if (@at.is_a?(Time) or (@at.is_a?(Numeric) and (@at > "LITERAL"))) then
              raise(ArgumentError, "STRING")
            else
              return var
            end;Fi[	@|@¨Xi[[	@Ã	iùI"           if var.empty? then
            var = @connection.prepare(var)
          else
            var = @statements[var] ||= { "LITERAL" => (@connection.prepare(var)) }
            var = var["LITERAL"];Fi[	@Xi˝I"Æ            var.close
            var = var
          else
            var = @statements[var] ||= { "LITERAL" => (@connection.prepare(var)) }
            var = var["LITERAL"];Fi[	@|I"&@var = BindSubstitution.new(self);Fi[[	@Ui|I"£        if var.fetch("LITERAL") { true } then
          @var = Arel::Visitors::MySQL.new(self)
        else
          @var = BindSubstitution.new(self)
        end;Fi[	@XiiI"§        if var.fetch("LITERAL") { true } then
          @var = Arel::Visitors::SQLite.new(self)
        else
          @var = BindSubstitution.new(self)
        end;Fi[	@|I"var.to_s;Fi[[	@M"iGI"∞      if var.is_a?(Symbol) then
        I18n.t(:"#{scope}STRING#{var}", "LITERAL" => (scope), "LITERAL" => "STRING", "LITERAL" => ([var]))
      else
        var.to_s
      end;Fi[	@zi≥I"N    when "LITERAL" then
      "LITERAL"
    else
      var.to_s
    end));Fi[	@i@i[[	@ÊiI"ò    assert(var.fails_with?("LITERAL").!)
    var.select_compiler
    assert_equal(case MacOS.clang_build_version
    when "LITERAL" then
      "LITERAL";Fi[	@ÊiXI"}    end)
    var.select_compiler
    assert_equal(case MacOS.clang_build_version
    when "LITERAL" then
      "LITERAL";Fi[	I"+assert(case MacOS.gcc_42_build_version;F@≤=i[[	@Êi.I"Ø    assert(var.fails_with?("LITERAL").!)
    assert(var.fails_with?("LITERAL").!)
    assert(case MacOS.gcc_42_build_version
    when nil then
      var.fails_with?("LITERAL");Fi[	@ÊiQI"´    assert(var.fails_with?("LITERAL"))
    assert(var.fails_with?("LITERAL"))
    assert(case MacOS.gcc_42_build_version
    when nil then
      var.fails_with?("LITERAL");Fi[	@ÇU@|i[[	@Êi0I"â    assert(case MacOS.gcc_42_build_version
    when nil then
      var.fails_with?("LITERAL")
    else
      var.fails_with?("LITERAL").!;Fi[	@ÊiSI"â    assert(case MacOS.gcc_42_build_version
    when nil then
      var.fails_with?("LITERAL")
    else
      var.fails_with?("LITERAL").!;Fi[	@cj@‰(i[[	@Êi2I"r      var.fails_with?("LITERAL")
    else
      var.fails_with?("LITERAL").!
    end)
    var.select_compiler;Fi[	@ÊiUI"r      var.fails_with?("LITERAL")
    else
      var.fails_with?("LITERAL").!
    end)
    var.select_compiler;Fi[	I".(@deps << Dependency.new(var["LITERAL"]));F@§li[[	@ê:iI"Í  def function
    var = { "LITERAL" => "STRING", "LITERAL" => "STRING", "LITERAL" => "STRING" }
    (@deps << Dependency.new(var["LITERAL"]))
    (@deps << Dependency.new(var["LITERAL"]))
    (@deps << Dependency.new(var["LITERAL"]));Fi[	@ê:iI"%    var = { "LITERAL" => "STRING", "LITERAL" => "STRING", "LITERAL" => "STRING" }
    (@deps << Dependency.new(var["LITERAL"]))
    (@deps << Dependency.new(var["LITERAL"]))
    (@deps << Dependency.new(var["LITERAL"]))
    @deps.each_with_index { |var, var| assert_equal(var[var], var.name) };Fi[	I"#var = Dependency.new("STRING");F@´li[[	@ì:i-I"  
  def function
    var = Dependency.new("STRING")
    var = Dependency.new("STRING")
    var = Dependency.new("STRING");Fi[	@ì:i.I"í  def function
    var = Dependency.new("STRING")
    var = Dependency.new("STRING")
    var = Dependency.new("STRING")
    assert_equal(var, var);Fi[	I""var = DependencyCollector.new;FI"2var.each { |var, var| var.add(var => (var)) };Fi[[	@ñ:iTI"«class ExternalDepsTests < Test::Unit::TestCase
  def function(var)
    var = DependencyCollector.new
    var.each { |var, var| var.add(var => (var)) }
    assert((var.requirements.size == "LITERAL"));Fi[	@ñ:i[I"õ  
  def function(var)
    var = DependencyCollector.new
    var.each { |var, var| var.add(var => (var)) }
    assert((var.requirements.size == "LITERAL"));Fi[	@≥lI"1assert((var.requirements.size == "LITERAL"));Fi[[	@ñ:iUI"–  def function(var)
    var = DependencyCollector.new
    var.each { |var, var| var.add(var => (var)) }
    assert((var.requirements.size == "LITERAL"))
    var.requirements { |var| assert(var.satisfied?.!) };Fi[	@ñ:i\I"Œ  def function(var)
    var = DependencyCollector.new
    var.each { |var, var| var.add(var => (var)) }
    assert((var.requirements.size == "LITERAL"))
    var.requirements { |var| assert(var.satisfied?) };Fi[	@|I""var ? ("STRING") : ("STRING");Fi[[	@KiHI"§          if var and (var.type == "LITERAL") then
            var ? ("LITERAL") : ("LITERAL")
          else
            var ? ("STRING") : ("STRING")
          end;Fi[	@—iéI"ä          when false_sql then
            var ? (var) : (false_sql)
          else
            var ? ("STRING") : ("STRING")
          end;Fi[	@|@«=i[[	@‘	i%I"R          var["LITERAL"] = nil
        end
      else
        yield
      end;Fi[	@k
i´I"F          success?
        end
      else
        yield
      end;Fi[	I">assert_equal(CurlDownloadStrategy, var.download_strategy);FI"=assert_instance_of(CurlDownloadStrategy, var.downloader);Fi[[	@3i=I"	    assert_version_equal("STRING", var.version)
    assert_equal(var.stable, var.active_spec)
    assert_equal(CurlDownloadStrategy, var.download_strategy)
    assert_instance_of(CurlDownloadStrategy, var.downloader)
    assert_instance_of(SoftwareSpec, var.stable);Fi[	@3iI"Ë    assert_version_equal("STRING", var.version)
    assert_equal("STRING", var.url)
    assert_equal(CurlDownloadStrategy, var.download_strategy)
    assert_instance_of(CurlDownloadStrategy, var.downloader)
    ARGV.delete("STRING");Fi[	@|@1i[[	@i5I"€      if (var == "LITERAL") then
        synchronize { decode(@redis.lindex(@redis_name, var)) }
      else
        synchronize do
          Array(@redis.lrange(@redis_name, var, ((var + var) - "LITERAL"))).map do |var|;Fi[	@iJI"_          decode(var)
        end
      else
        synchronize do
          until var do;Fi[	I"assert_nil(var.bottle.md5);FI""assert_nil(var.bottle.sha256);Fi[[	@3igI"ü    assert_nil(var.stable.md5)
    assert_nil(var.stable.sha256)
    assert_nil(var.bottle.md5)
    assert_nil(var.bottle.sha256)
    assert_nil(var.devel.md5);Fi[	@3i†I"€      assert(var.bottle.checksum.empty?.!)
      assert_equal("STRING", var.bottle.sha1.hexdigest)
      assert_nil(var.bottle.md5)
      assert_nil(var.bottle.sha256)
      assert(var.bottle.version.detected_from_url?);Fi[	@ÔcI"var = SpecTestBall.new;Fi[[	@3izI"v  
  def function
    ARGV.push("STRING")
    var = SpecTestBall.new
    assert_equal(var.devel, var.active_spec);Fi[	@3iÄI"u  
  def function
    ARGV.push("STRING")
    var = SpecTestBall.new
    assert_equal(var.head, var.active_spec);Fi[	@|@åWi[[	@∏izI"‘        if var.first.is_a?(Hash) and var =~ "LITERAL" then
          replace_named_bind_variables(var, var.first)
        else
          if var.include?("STRING") then
            replace_bind_variables(var, var);Fi[	@	i'I"à      if (var.nil? or var.include?("STRING")) then
        "STRING"
      else
        if var.include?("STRING") then
          "STRING";Fi[	@|@t^i[[	@5)iI"ì      if var.is_a?(Binding) then
        @var = var
      else
        if var.is_a?(Hash) then
          @var = Backup::Binder.new(var).get_binding;Fi[	@ƒi&I"˙              var ||= var.to_s if var.is_a?(Pathname)
              Compass::Configuration::FileData.new_from_string(var.read, var, var)
            else
              if var.is_a?(Hash) then
                Compass::Configuration::Data.new(var, var);Fi[	@|@=i[[	@¨#i2I"ò        if var.respond_to?("LITERAL") then
          var = var.column_types
        else
          ActiveSupport::Deprecation.warn("STRING")
        end;Fi[	@°i$I"è            (var << var) unless var.respond_to?(var)
          end
        else
          ActiveSupport::Deprecation.warn("STRING")
        end;Fi[	@|@;i[[	@“i~I"™    if request.params["LITERAL"].is_a?(String).! then
      var["LITERAL"]
    else
      var = var["LITERAL"]
      var = if (request.content_type.to_s == "STRING") then;Fi[	@ÏiÉI"n        var = {}
        var = false
      else
        var = var["LITERAL"]
        var = var["LITERAL"];Fi[	@|I"if var.include?(var) then;Fi[[	@ÍimI"{      if var and var["LITERAL"] then
        var["LITERAL"].to_s
      else
        if var.include?(var) then
          var;Fi[	@iôI"ú      if var.include?(var) then
        WhitelistMatcher.new(var[var])
      else
        if var.include?(var) then
          BlacklistMatcher.new(var[var]);Fi[	@|@Ä]i[[	@]i&I"µ      if var = var["LITERAL"] then
        var = var.&(Array(var).map(&"LITERAL"))
      else
        if var = var["LITERAL"] then
          var = (var - Array(var).map(&"LITERAL"));Fi[	I",projects//devise_proj/devise/mapping.rb;Ti}I"®      if (var["LITERAL"] == true) then
        @var = @used_routes
      else
        if var = var["LITERAL"] then
          @var = (self.routes - Array(var).map(&var));Fi[	I"send(var, var);F@|i[[	@ i‡I"‡            var = "STRING"
            if respond_to?(var, true) then
              send(var, var)
            else
              define_proxy_call(true, generated_attribute_methods, var, var.method_missing_target, var.to_s);Fi[	@ÿi7I"ñ          if text? then
            var = Nokogiri::XML::Node.new("STRING", document)
            send(var, var)
          else
            var = self;Fi[	@·c@
Ei[[	@3iøI"y  
  def function
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable);Fi[	@3iŒI"y  
  def function
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable);Fi[	@<I"B(var << ("STRING" + var["STRING"])) unless var["STRING"].nil?;Fi[[	@
i:I"Ω      when "STRING" then
        var = (var["STRING"] or var["STRING"])
        var = "STRING"
        (var << ("STRING" + var["STRING"])) unless var["STRING"].nil?
      when "STRING" then;Fi[	@
iOI"™      when "STRING" then
        var = var["STRING"]
        var = "STRING"
        (var << ("STRING" + var["STRING"])) unless var["STRING"].nil?
      when "STRING" then;Fi[	@<@ihi[[	@Ôi˝I"—    # @return [String] The sanitized string
    def function(var)
      var = "STRING"
      var = if (RUBY_VERSION >= "STRING") then
        Regexp.new(var.force_encoding(var.encoding), Regexp::FIXEDENCODING);Fi[	@ÔiI"—    # @return [String] The sanitized string
    def function(var)
      var = "STRING"
      var = if (RUBY_VERSION >= "STRING") then
        Regexp.new(var.force_encoding(var.encoding), Regexp::FIXEDENCODING);Fi[	I"var.dry_run = true;FI",assert_equal("LITERAL", @keg.link(var));Fi[[	@˘'iI"Ö  def function
    var = OpenStruct.new
    var.dry_run = true
    assert_equal("LITERAL", @keg.link(var))
    assert(@keg.linked?.!);Fi[	@˘'i=I"è    var = OpenStruct.new
    var.overwrite = true
    var.dry_run = true
    assert_equal("LITERAL", @keg.link(var))
    assert(@keg.linked?.!);Fi[	@,mI"assert(@keg.linked?.!);Fi[[	@˘'i I"ß    var = OpenStruct.new
    var.dry_run = true
    assert_equal("LITERAL", @keg.link(var))
    assert(@keg.linked?.!)
    ["STRING", "STRING", "STRING"].each do |var|;Fi[	@˘'i>I"°    var.overwrite = true
    var.dry_run = true
    assert_equal("LITERAL", @keg.link(var))
    assert(@keg.linked?.!)
    assert_equal("STRING", $stdout.string);Fi[	@çA@ıii[[	@˘'i3I"z  
  def function
    FileUtils.touch((HOMEBREW_PREFIX / "STRING"))
    var = OpenStruct.new
    var.overwrite = true;Fi[	@˘'i:I"z  
  def function
    FileUtils.touch((HOMEBREW_PREFIX / "STRING"))
    var = OpenStruct.new
    var.overwrite = true;Fi[	@<I"Ovar = (var + "STRING") unless ["STRING", "STRING"].include?(var.port.to_s);Fi[[	@“iΩI"ª    begin
      (var = URI.parse(@attributes["STRING"])
      var = "STRING"
      var = (var + "STRING") unless ["STRING", "STRING"].include?(var.port.to_s)
      var = (var + "STRING"));Fi[	@“i#I"©  def function(var)
    var = URI.parse(var)
    var = "STRING"
    var = (var + "STRING") unless ["STRING", "STRING"].include?(var.port.to_s)
    var = (var + "STRING");Fi[	@<@gAi[[	@f6i#I"{        end
      end
      var = "STRING"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var));Fi[	@f6i<I"ò        Compass.configuration.http_fonts_path
      end
      var = "STRING"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var));Fi[	@<I"0raise(Compass::FilesystemConflict.new(var));Fi[[	@_$iI"∫      unless File.exists?(var) and File.directory?(var) then
        if File.exists?(var) then
          var = "STRING"
          raise(Compass::FilesystemConflict.new(var))
        else;Fi[	@_$i1I"•            log_action("LITERAL", basename(var), var)
          else
            var = "STRING"
            raise(Compass::FilesystemConflict.new(var))
          end;Fi[	@<@Õ7i[[	@iõI"ﬂ        var = var["LITERAL"] ? ("STRING") : ("STRING")
        (var["LITERAL"] == "LITERAL") ? (var = "STRING") : (var = "STRING")
        var = "STRING"
        (var << "STRING") if var["LITERAL"]
        (var << "STRING");Fi[	@i´I"ﬂ        var = var["LITERAL"] ? ("STRING") : ("STRING")
        (var["LITERAL"] == "LITERAL") ? (var = "STRING") : (var = "STRING")
        var = "STRING"
        (var << "STRING") if var["LITERAL"]
        (var << "STRING");Fi[	@-I"assert(var.x86_64?);Fi[[	@u"i)I"à    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?)
    assert(var.ppc7400?.!);Fi[	@u"iaI"à    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?)
    assert(var.ppc7400?.!);Fi[	@<@ûIi[[	@
iEI"∑                when "STRING" then
                  add_item_to_array(var, var, var)
                  var = "STRING"
                  var = false
                when "STRING" then;Fi[	@Ïi~I"€      var = ((var["LITERAL"] and block_given?.!) or (var["LITERAL"] and block_given?))
      if @options["LITERAL"] then
        var = "STRING"
        var = false
        var = var["LITERAL"] ? (nil) : (var["LITERAL"]);Fi[	@<@w,i[[	@
i-I"t          var = false
          var = false
          var = "STRING"
          var = var
          while var do;Fi[	@
iÜI"y        if var.! and var.=~(var) then
          var = true
          var = "STRING"
          var = var
        else;Fi[	@<@;i[[	@ÏiFI"{      (var.map do |var|
        var = "STRING"
        var = "STRING"
        "STRING"
      end.join("STRING") + "STRING");Fi[	@QiI"odef function(var)
  var = File.dirname(serializer.serialized_path(object))
  var = "STRING"
  "STRING"
end;Fi[	@<@<"i[[	@iI"u      
      def function
        var = "STRING"
        var = {}
        var["LITERAL"] = null unless null.nil?;Fi[	@3
i˘I"ù      raise(SyntaxError.new(Error.message("LITERAL"))) if var =~ "LITERAL"
      var = var = var = nil
      var = "STRING"
      var = {}
      while var do;Fi[	@<@M%i[[	@Åi!I"ó      var = var.pop
      var = var.join("STRING") unless var.empty?
      var = "STRING"
      if var then
        var = lookup_ancestors.map do |var|;Fi[	@Èi«I"[        var.id
      end
      var = "STRING"
      if var then
        var = "STRING";Fi[	@<I"#if respond_to?(var, true) then;Fi[[	@ iﬁI"«          var = var.method_name(var)
          unless instance_method_already_implemented?(var) then
            var = "STRING"
            if respond_to?(var, true) then
              send(var, var);Fi[	@≥iÉI"ò      def function(var)
        var = Devise::Mapping.find_scope!(var)
        var = "STRING"
        if respond_to?(var, true) then
          send(var);Fi[	@ô(I"!assert(var.text_executable?);Fi[[	@u"iìI"ó    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?)
    assert_equal([], var.archs);Fi[	@u"i£I"ó    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?)
    assert_equal([], var.archs);Fi[	I"(#     define_attribute_method :name;F@i[[	@ iÕI"∂      #     # attribute_method_prefix, attribute_method_suffix or
      #     # attribute_method_affix declares.
      #     define_attribute_method :name
      #
      #     private;Fi[	@ iI"ì      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_method :name
      #
      #     private;Fi[	I"@#     # attribute_method_prefix, attribute_method_suffix or;FI"-#     # attribute_method_affix declares.;Fi[[	@ iØI"¯      #
      #     # Call to define_attribute_methods must appear after the
      #     # attribute_method_prefix, attribute_method_suffix or
      #     # attribute_method_affix declares.
      #     define_attribute_methods :name, :age, :address;Fi[	@ iÀI"Ê      #
      #     # Call to define_attribute_method must appear after the
      #     # attribute_method_prefix, attribute_method_suffix or
      #     # attribute_method_affix declares.
      #     define_attribute_method :name;Fi[	@*FI"*assert_no_match("LITERAL", file(var));Fi[[	@u"iwI"ª    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?.!)
    assert((var.arch == "LITERAL"))
    assert_no_match("LITERAL", file(var))
    assert_no_match("LITERAL", file(var));Fi[	@u"i∂I"ñ    assert(var.text_executable?.!)
    assert_equal([], var.archs)
    assert((var.arch == "LITERAL"))
    assert_no_match("LITERAL", file(var))
  end;Fi[	I"%# ActiveModel::AttributeMethods.;F@i[[	@ i¢I"Œ      
      # Declares the attributes that should be prefixed and suffixed by
      # ActiveModel::AttributeMethods.
      #
      # To use, pass attribute names (as strings or symbols), be sure to declare;Fi[	@ iæI"Ã      
      # Declares an attribute that should be prefixed and suffixed by
      # ActiveModel::AttributeMethods.
      #
      # To use, pass an attribute name (as string or symbol), be sure to declare;Fi[	@À.I"assert(var.i386?);Fi[[	@u"iI"|  def function
    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?)
    assert(var.x86_64?.!);Fi[	@u"iRI"|  def function
    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?)
    assert(var.x86_64?.!);Fi[	@™m@ç%i[[	@u"iI"à    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!);Fi[	@u"iSI"à    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!);Fi[	@Zm@q"i[[	@u"i*I"Ä    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!);Fi[	@u"ibI"Ä    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!);Fi[	@HI"<assert_valid_keys(var, "LITERAL", "LITERAL", "LITERAL");Fi[[	@iÇI"    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.
    def function(var, var)
      assert_valid_keys(var, "LITERAL", "LITERAL", "LITERAL")
      unless var = var.include?("LITERAL") then;Fi[	@iI"3    # * <tt>:to</tt> - A hash to write the initialized state to instead of
    #   writing to the object.  Default is to write directly to the object.
    def function(var, var)
      assert_valid_keys(var, "LITERAL", "LITERAL", "LITERAL")
      var = { "LITERAL" => (true), "LITERAL" => (true) }.merge(var);Fi[	@HI":var = self.name.gsub("LITERAL", "STRING").constantize;Fi[[	@)1iI"‰    # strings should be a list of content types which will pass and fail
    # validation, respectively.
    def function(var, var)
      var = self.name.gsub("LITERAL", "STRING").constantize
      var = [var["LITERAL"]].flatten;Fi[	@)1i,I"G    # checks that a file is more than a certain size, and :in takes a Range or
    # Array which specifies the lower and upper limits of the file size.
    def function(var, var)
      var = self.name.gsub("LITERAL", "STRING").constantize
      var = (var["LITERAL"] or ((var["LITERAL"] and var["LITERAL"].first) or "LITERAL"));Fi[	@HI"label_field(var, var);Fi[[	@.i%I"i    end
    
    def function(var, var)
      label_field(var, var)
      input_field("STRING", var);Fi[	@.i+I"i    end
    
    def function(var, var)
      label_field(var, var)
      input_field("STRING", var);Fi[	@Üm@)Fi[[	@u"iîI"¢    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?)
    assert_equal([], var.archs)
    assert((var.arch == "LITERAL"));Fi[	@u"i§I"¢    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?)
    assert_equal([], var.archs)
    assert((var.arch == "LITERAL"));Fi[	@HI"check_encoding(var);Fi[[	@˝i-I"ø        # The encoding beings used for this document.
        # Create a new Parser with +doc+ and +encoding+
        def function(var, var)
          check_encoding(var)
          @var = var;Fi[	@˝iAI"}        ###
        # Parse given +io+
        def function(var, var)
          check_encoding(var)
          @var = var;Fi[	@ı>@âVi[[	@¸'i2I"     var = { "LITERAL" => "STRING", "LITERAL" => "STRING" }
    var = Patches.new(var)
    assert_equal("LITERAL", var.patches.length)
    var = Set.new
    var.each { |var| (var << var.patch_filename) };Fi[	@¸'i;I"Ê    var = { "LITERAL" => (["STRING", "STRING"]), "LITERAL" => (["STRING", "STRING"]) }
    var = Patches.new(var)
    assert_equal("LITERAL", var.patches.length)
    var = Set.new
    var.each { |var| (var << var.patch_filename) };Fi[	@HI"$raise(ArgumentError) unless var;Fi[[	@r&iI"º        ###
        # Parse html stored in +data+ using +encoding+
        def function(var, var)
          raise(ArgumentError) unless var
          return unless (var.length > "LITERAL");Fi[	@r&iI"≥        ###
        # Parse a file with +filename+
        def function(var, var)
          raise(ArgumentError) unless var
          raise(Errno::ENOENT) unless File.exists?(var);Fi[	@HI"<var = var.sub("LITERAL", (("STRING" + var) + "STRING"));Fi[[	@Í
iI"'              var = add_code_tags(Pygments.highlight(var, "LITERAL" => (var), "LITERAL" => ({ "LITERAL" => "STRING" })), var)
            end
            def function(var, var)
              var = var.sub("LITERAL", (("STRING" + var) + "STRING"))
              var = var.sub("LITERAL", "STRING");Fi[	@W0i6I"é    end
    
    def function(var, var)
      var = var.sub("LITERAL", (("STRING" + var) + "STRING"))
      var = var.sub("LITERAL", "STRING");Fi[	@øc@ı>i[[	@¸'i"I"è  
  def function
    var = Patches.new("LITERAL" => "STRING")
    assert_equal("LITERAL", var.patches.length)
    var = var.patches["LITERAL"];Fi[	@¸'i)I"è  
  def function
    var = Patches.new("LITERAL" => "STRING")
    assert_equal("LITERAL", var.patches.length)
    var = var.patches["LITERAL"];Fi[	I"var = Patches.new(var);F@ı>i[[	@¸'i1I"¶  def function
    var = { "LITERAL" => "STRING", "LITERAL" => "STRING" }
    var = Patches.new(var)
    assert_equal("LITERAL", var.patches.length)
    var = Set.new;Fi[	@¸'i:I"¬  def function
    var = { "LITERAL" => (["STRING", "STRING"]), "LITERAL" => (["STRING", "STRING"]) }
    var = Patches.new(var)
    assert_equal("LITERAL", var.patches.length)
    var = Set.new;Fi[	@HI"%return if var.options["LITERAL"];Fi[[	@iÃI"É      
      # @see Base#compile
      def function(var, var)
        return if var.options["LITERAL"]
        var.instance_eval do;Fi[	@i˙I"Ñ      end
      
      def function(var, var)
        return if var.options["LITERAL"]
        var.send("LITERAL", precompiled(var));Fi[	@ª,@û<i[[	@æ,i3I"g  
  def function
    with_temp_folder do
      FileUtils.mkdir_p("STRING")
      system("STRING");Fi[	@æ,iPI"g  
  def function
    with_temp_folder do
      FileUtils.mkdir_p("STRING")
      system("STRING");Fi[	I"$TARGET_FOLDER.install("STRING");F@˛6i[[	@æ,iI"¬  def function
    with_temp_folder do
      TARGET_FOLDER.install("STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?.!, "STRING");Fi[	@æ,i6I"“      FileUtils.mkdir_p("STRING")
      system("STRING")
      TARGET_FOLDER.install("STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING");Fi[	@HI"'find_or_create_participation!(var);Fi[[	I":projects//diaspora_proj/models/user/social_actions.rb;TiI"}  end
  
  def function(var, var)
    find_or_create_participation!(var)
    Like::Generator.new(self, var).create!(var);Fi[	@niI"Å  end
  
  def function(var, var)
    find_or_create_participation!(var)
    var = build_post("LITERAL", "LITERAL" => (var.guid));Fi[	@H@gi[[	@Ωi-I"e  end
  
  def function(var, var)
    if self.target.nil? then
      Rails.logger.info("STRING");Fi[	@ÓiSI"e  end
  
  def function(var, var)
    if self.target.nil? then
      Rails.logger.info("STRING");Fi[	@û<@Yi[[	I"2projects//jekyll_proj/jekyll/migrators/csv.rb;TiI"Ñ  module CSV
    def self.process(var)
      FileUtils.mkdir_p("STRING")
      var = "LITERAL"
      FasterCSV.foreach(var) do |var|;Fi[	@˛FiI"¥    def self.process(var)
      raise(ArgumentError, "STRING") unless File.directory?(var)
      FileUtils.mkdir_p("STRING")
      var = "LITERAL"
      Dir["STRING"].each do |var|;Fi[	@û<@Dei[[	@æ,i4I"Ö  def function
    with_temp_folder do
      FileUtils.mkdir_p("STRING")
      system("STRING")
      TARGET_FOLDER.install("STRING");Fi[	@æ,iQI"ë  def function
    with_temp_folder do
      FileUtils.mkdir_p("STRING")
      system("STRING")
      TARGET_FOLDER.install("STRING" => "STRING");Fi[	@û<@ù<i[[	@ø'iI"›    
    def self.process(var, var, var, var)
      FileUtils.mkdir_p("STRING")
      var = Sequel.mysql(var, "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => "STRING")
      var[SQL].each do |var|;Fi[	@piI"√        end
      end
      FileUtils.mkdir_p("STRING")
      var = Sequel.mysql(var, "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => "STRING")
      var = var["LITERAL"];Fi[	@HI" var["LITERAL"] ||= "STRING";Fi[[	@∏iI"V  end
  
  def function(var, var)
    var["LITERAL"] ||= "STRING"
    if var then;Fi[	I"5projects//diaspora_proj/helpers/people_helper.rb;Ti"I"ù  end
  
  def function(var, var)
    var["LITERAL"] ||= "STRING"
    if defined? user_signed_in? and (user_signed_in? and (current_user.person == var)) then;Fi[	@MF@MFi[[	@æ,i@I"Î      TARGET_FOLDER.install("STRING" => "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?.!, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?.!, "STRING")
    end;Fi[	@æ,iJI"Û      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?.!, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?.!, "STRING")
    end;Fi[	@∏cI"ENV.expects("LITERAL");Fi[[	@ô:i0I"Ä  
  def function
    ENV.expects("LITERAL").yields.returns(true)
    ENV.expects("LITERAL")
    var = Class.new(Requirement) do;Fi[	@ô:i:I"Ä  
  def function
    ENV.expects("LITERAL").yields.returns(true)
    ENV.expects("LITERAL")
    var = Class.new(Requirement) do;Fi[	@CnI"$var = Class.new(Requirement) do;Fi[[	@ô:i1I"í  def function
    ENV.expects("LITERAL").yields.returns(true)
    ENV.expects("LITERAL")
    var = Class.new(Requirement) do
      env("LITERAL");Fi[	@ô:i;I"æ  def function
    ENV.expects("LITERAL").yields.returns(true)
    ENV.expects("LITERAL")
    var = Class.new(Requirement) do
      satisfy("LITERAL" => (true), "LITERAL" => (true)) { true };Fi[	@HI"#var = var.map { |var| var.id };Fi[[	@w!i™I"Z  private
  
  def function(var, var)
    var = var.map { |var| var.id }
    var = {};Fi[	@'
i˜I"m  end
  
  def function(var, var)
    var = var.map { |var| var.id }
    var.each { |var| (var << var) };Fi[	@H@—2i[[	@_'iOI"ö  end
  
  def function(var, var)
    Rails.logger.info("STRING")
    var.profile.update_attributes(self.attributes.merge("LITERAL" => (self.tag_string)));Fi[	@ì"iMI"ı  # @note A [Contact] may already exist if the [Request]'s recipient is sharing with the sender
  # @return [Request]
  def function(var, var)
    Rails.logger.info("STRING")
    var = var.contacts.find_or_initialize_by_person_id(self.sender.id);Fi[	@H@˘Gi[[	@ÿiI"É  end
  
  def function(var, var)
    Rails.logger.debug("STRING")
    post_to_facebook("STRING", create_post_params(var).to_param);Fi[	@‡iI"j  end
  
  def function(var, var)
    Rails.logger.debug("STRING")
    var = public_message(var, var);Fi[	@HI"var = lambda do |var|;Fi[[	@æiÎI"º    #   end
    #
    def function(var, var)
      var = lambda do |var|
        var.env["STRING"].authenticate!("LITERAL" => (var)) and (var.nil? or var.call(var.env["STRING"].user(var)));Fi[	@æiI"”    #   root :to => 'landing#show'
    #
    def function(var, var)
      var = lambda do |var|
        var.env["STRING"].authenticate?("LITERAL" => (var)) and (var.nil? or var.call(var.env["STRING"].user(var)));Fi[	@3/I"&var.in_repo_expect("STRING", var);Fi[[	@Ï iII"™      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING", var)
      var.pull!;Fi[	@Ï i]I"™      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING", var)
      var.pull!;Fi[	@±c@¡Ci[[	@Ï iBI"l  
  def function
    var = fixture("STRING")
    HOMEBREW_REPOSITORY.cd do
      var = UpdaterMock.new;Fi[	@Ï iVI"l  
  def function
    var = fixture("STRING")
    HOMEBREW_REPOSITORY.cd do
      var = UpdaterMock.new;Fi[	@kn@ûCi[[	@Ï iJI"û      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING", var)
      var.pull!
      var = Report.new;Fi[	@Ï i^I"û      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING", var)
      var.pull!
      var = Report.new;Fi[	I"1assert(var.select_formula("LITERAL").empty?);F@~ni[[	@Ï iOI"Ÿ      var.merge!(var.report)
      assert(var.expectations_met?)
      assert(var.select_formula("LITERAL").empty?)
      assert(var.select_formula("LITERAL").empty?)
      assert(var.select_formula("LITERAL").empty?);Fi[	@Ï iPI"ƒ      assert(var.expectations_met?)
      assert(var.select_formula("LITERAL").empty?)
      assert(var.select_formula("LITERAL").empty?)
      assert(var.select_formula("LITERAL").empty?)
    end;Fi[	@ˇE@|i[[	@FiI"ˆ    if `sw_vers -productVersion` =~ "LITERAL" and ($1.to_i >= "LITERAL") then
      assert_equal("LITERAL", var.length)
      assert(var.include?("LITERAL"))
    else
      if `sw_vers -productVersion` =~ "LITERAL" and ($1.to_i == "LITERAL") then;Fi[	@FiI"≤        assert_equal("LITERAL", var.length)
        assert(var.include?("LITERAL"))
        assert(var.include?("LITERAL"))
      else
        assert_equal("LITERAL", var.length);Fi[	@HI"var = to_adapter.get(var);Fi[[	@∏i{I"í        end
        
        def function(var, var)
          var = to_adapter.get(var)
          var if var and (var.authenticatable_salt == var);Fi[	@NiSI"⁄        
        # Recreate the user based on the stored cookie
        def function(var, var)
          var = to_adapter.get(var)
          if var and ((var.rememberable_value == var) and var.remember_expired?.!) then;Fi[	I" var = Version.new("STRING");FI"assert(var.devel?);Fi[[	@>i6I"É    var = Version.new("STRING")
    assert(var.alpha?)
    var = Version.new("STRING")
    assert(var.devel?)
    assert(var.beta?);Fi[	@>i9I"|    assert(var.devel?)
    assert(var.beta?)
    var = Version.new("STRING")
    assert(var.devel?)
    assert(var.rc?);Fi[	@H@v1i[[	@Ú@iI"~      end
      
      def function(var, var)
        var = Devise::Mapping.find_scope!(var)
        send("STRING", *var);Fi[	@Ú@iI"~      end
      
      def function(var, var)
        var = Devise::Mapping.find_scope!(var)
        send("STRING", *var);Fi[	I"8# name parameter required for some Formula::factory;F@£i[[	@€iI"ârequire("formula")
class TestBall < Formula
  # name parameter required for some Formula::factory
  def function(var)
    @var = "STRING";Fi[	@€i*I"u  md5("STRING")
  
  # name parameter required for some Formula::factory
  def function(var)
    super("STRING");Fi[	I"devel do;F@nFi[[	@€imI"a  head("STRING", "LITERAL" => "STRING")
  
  devel do
    url("STRING")
    mirror("STRING");Fi[	@€iÅI"K  version("STRING")
  
  devel do
    url("STRING")
    sha1("STRING");Fi[	@H@zAi[[	@4i\I"Ø  
  # Returns the path to the original image file for the sprite with the given name
  def function(var, var)
    var = convert_sprite_name(var)
    verify_map(var, "STRING");Fi[	@4ijI"}  
  # Returns boolean if sprite has a parent
  def function(var, var)
    var = convert_sprite_name(var)
    verify_map(var);Fi[	I"bottle do;F@B/i[[	@€isI"Y  end
  
  bottle do
    sha1("STRING" => "LITERAL")
    sha1("STRING" => "LITERAL");Fi[	@€i˝I"d  sha1("STRING")
  
  bottle do
    sha1("STRING" => "LITERAL")
    sha1("STRING" => "LITERAL");Fi[	@HI"&var, var = *grad_point(var).value;Fi[[	@¶ieI"ä    end
    
    def function(var, var)
      var, var = *grad_point(var).value
      var, var = *grad_point(opposite_position(var)).value;Fi[	@¶imI"ê    end
    
    def function(var, var)
      var, var = *grad_point(var).value
      var = grad_end_position(var, Sass::Script::Bool.new(true));Fi[	@HI"'var ||= configuration.project_path;Fi[[	@ƒi}I"≈      
      # Returns a full path to the relative path to the project directory
      def function(var, var)
        var ||= configuration.project_path
        File.join(var, *var.split("STRING"));Fi[	@ƒi}I"ö      end
      
      def function(var, var)
        var ||= configuration.project_path
        if (var[("LITERAL"..(var.size - "LITERAL"))] == var) then;Fi[	I"/require("multi_json/adapters/json_common");F@`+i[[	@g+iI"yrequire("json") unless defined? ::JSON
require("multi_json/adapters/json_common")
module MultiJson
  module Adapters;Fi[	@j+iI"~require("json/pure") unless defined? ::JSON
require("multi_json/adapters/json_common")
module MultiJson
  module Adapters;Fi[	I"def self.load(var, var);FI"1var = var.read if var.respond_to?("LITERAL");Fi[[	@·iI"¡      ParseError = ::MultiJson::OkJson::Error
      
      def self.load(var, var)
        var = var.read if var.respond_to?("LITERAL")
        var = var.dataUsingEncoding(NSUTF8StringEncoding);Fi[	@>iI"¿      ParseError = ::MultiJson::OkJson::Error
      
      def self.load(var, var)
        var = var.read if var.respond_to?("LITERAL")
        var = ::MultiJson::OkJson.decode("STRING").first;Fi[	@HI"+relevant_rules(var, var).each do |var|;Fi[[	@ãiI"à    end
    
    def function(var, var)
      relevant_rules(var, var).each do |var|
        raise(Error, "STRING") if var.only_raw_sql?;Fi[	@ãiI"Ü    end
    
    def function(var, var)
      relevant_rules(var, var).each do |var|
        raise(Error, "STRING") if var.only_block?;Fi[	I"7raise(Error, "STRING") if (var.length < "LITERAL");FI"#var, var, var = var["LITERAL"];Fi[[	@˝iI"∂    # except that it does not accept atomic values.
    def function(var)
      raise(Error, "STRING") if (var.length < "LITERAL")
      var, var, var = var["LITERAL"]
      case var;Fi[	@˝i-I"∫    # Returns the parsed value and any trailing tokens.
    def function(var)
      raise(Error, "STRING") if (var.length < "LITERAL")
      var, var, var = var["LITERAL"]
      case var;Fi[	@‡n@4i[[	@˝iI"õ    def function(var)
      raise(Error, "STRING") if (var.length < "LITERAL")
      var, var, var = var["LITERAL"]
      case var
      when "STRING" then;Fi[	@˝i.I"õ    def function(var)
      raise(Error, "STRING") if (var.length < "LITERAL")
      var, var, var = var["LITERAL"]
      case var
      when "STRING" then;Fi[	@ÎW@îi[[	@˝i"I"q      case var
      when "STRING" then
        objparse(var)
      when "STRING" then
        arrparse(var);Fi[	@˝i1I"q      case var
      when "STRING" then
        objparse(var)
      when "STRING" then
        arrparse(var);Fi[	@~TI"var, var = valparse(var);Fi[[	@˝iQI"¡      (var, var, var), var = var["LITERAL"], var["LITERAL"]
      raise(Error, "STRING") if var.!=("LITERAL")
      var = eat("STRING", var)
      var, var = valparse(var)
      [var, var, var];Fi[	@˝i`I"≤      return [var, var["LITERAL"]] if (var["LITERAL"]["LITERAL"] == "STRING")
      loop do
        var = eat("STRING", var)
        var, var = valparse(var)
        (var << var);Fi[	@»Q@}Ti[[	@˝iCI"∂      var, var, var = pairparse(var)
      var[var] = var
      return [var, var["LITERAL"]] if (var["LITERAL"]["LITERAL"] == "STRING")
      loop do
        var = eat("STRING", var);Fi[	@˝i^I"Æ      var, var = valparse(var)
      (var << var)
      return [var, var["LITERAL"]] if (var["LITERAL"]["LITERAL"] == "STRING")
      loop do
        var = eat("STRING", var);Fi[	I"#var, var, var = pairparse(var);F@][i[[	@˝iAI"‰      var = {}
      return [var, var["LITERAL"]] if (var["LITERAL"]["LITERAL"] == "STRING")
      var, var, var = pairparse(var)
      var[var] = var
      return [var, var["LITERAL"]] if (var["LITERAL"]["LITERAL"] == "STRING");Fi[	@˝iFI"º      loop do
        var = eat("STRING", var)
        var, var, var = pairparse(var)
        var[var] = var
        return [var, var["LITERAL"]] if (var["LITERAL"]["LITERAL"] == "STRING");Fi[	@Ûn@6i[[	@˝i\I"‹      var = []
      return [var, var["LITERAL"]] if (var["LITERAL"]["LITERAL"] == "STRING")
      var, var = valparse(var)
      (var << var)
      return [var, var["LITERAL"]] if (var["LITERAL"]["LITERAL"] == "STRING");Fi[	@˝iaI"¥      loop do
        var = eat("STRING", var)
        var, var = valparse(var)
        (var << var)
        return [var, var["LITERAL"]] if (var["LITERAL"]["LITERAL"] == "STRING");Fi[	@H@∂`i[[	@‡"iZI"Ÿ      # Net::FTP raises an exception when the directory it's trying to create
      # already exists, so we have rescue it
      def function(var, var)
        var = Array.new
        var.split("STRING").each do |var|;Fi[	@iNI"⁄      # Net::SFTP raises an exception when the directory it's trying to create
      # already exists, so we have rescue it
      def function(var, var)
        var = Array.new
        var.split("STRING").each do |var|;Fi[	@HI"$set_options_for_callbacks!(var);Fi[[	@„	i(I"      # Note that transactional fixtures do not play well with this feature. Please
      # use the +test_after_commit+ gem to have these hooks fired in tests.
      def function(var, var)
        set_options_for_callbacks!(var)
        set_callback("LITERAL", "LITERAL", *var, &var);Fi[	@„	i0I"…      #
      # Please check the documentation of +after_commit+ for options.
      def function(var, var)
        set_options_for_callbacks!(var)
        set_callback("LITERAL", "LITERAL", *var, &var);Fi[	@HI"self[var] ||= "LITERAL";Fi[[	@1iI"    # The increment is performed directly on the underlying attribute, no setter is invoked.
    # Only makes sense for number-based attributes. Returns +self+.
    def function(var, var)
      self[var] ||= "LITERAL"
      self[var] += var;Fi[	@1iI"    # The decrement is performed directly on the underlying attribute, no setter is invoked.
    # Only makes sense for number-based attributes. Returns +self+.
    def function(var, var)
      self[var] ||= "LITERAL"
      self[var] -= var;Fi[	I"8var[(var + "LITERAL")] = Utagx.|(var.&(Umaskx)).chr;F@ói[[	@˝i#I"·      when (var <= Uchar2max) then
        var[(var + "LITERAL")] = Utag2.|((var >> "LITERAL").&("LITERAL")).chr
        var[(var + "LITERAL")] = Utagx.|(var.&(Umaskx)).chr
        "LITERAL"
      when (var <= Uchar3max) then;Fi[	@˝i(I"Ò        var[(var + "LITERAL")] = Utag3.|((var >> "LITERAL").&("LITERAL")).chr
        var[(var + "LITERAL")] = Utagx.|((var >> "LITERAL").&(Umaskx)).chr
        var[(var + "LITERAL")] = Utagx.|(var.&(Umaskx)).chr
        "LITERAL"
      else;Fi[	I"Gvar[(var + "LITERAL")] = Utagx.|((var >> "LITERAL").&(Umaskx)).chr;F@!oi[[	@˝i'I"	      when (var <= Uchar3max) then
        var[(var + "LITERAL")] = Utag3.|((var >> "LITERAL").&("LITERAL")).chr
        var[(var + "LITERAL")] = Utagx.|((var >> "LITERAL").&(Umaskx)).chr
        var[(var + "LITERAL")] = Utagx.|(var.&(Umaskx)).chr
        "LITERAL";Fi[	@˝i-I"3        (var[(var + "LITERAL")] = Utag4.|((var >> "LITERAL").&("LITERAL")).chr
        var[(var + "LITERAL")] = Utagx.|((var >> "LITERAL").&(Umaskx)).chr
        var[(var + "LITERAL")] = Utagx.|((var >> "LITERAL").&(Umaskx)).chr
        var[(var + "LITERAL")] = Utagx.|(var.&(Umaskx)).chr
        "LITERAL");Fi[	I"8when (("STRING" <= var) and (var <= "STRING")) then;FI"+((var.ord - "STRING".ord) + "LITERAL");Fi[[	@˝iGI"˝      when (("STRING" <= var) and (var <= "STRING")) then
        (var.ord - "STRING".ord)
      when (("STRING" <= var) and (var <= "STRING")) then
        ((var.ord - "STRING".ord) + "LITERAL")
      when (("STRING" <= var) and (var <= "STRING")) then;Fi[	@˝iII"‹      when (("STRING" <= var) and (var <= "STRING")) then
        ((var.ord - "STRING".ord) + "LITERAL")
      when (("STRING" <= var) and (var <= "STRING")) then
        ((var.ord - "STRING".ord) + "LITERAL")
      else;Fi[	@ S@˚$i[[	@˝i\I"f      case var
      when Hash then
        objenc(var)
      when Array then
        arrenc(var);Fi[	@˝igI"f      case var
      when Hash then
        objenc(var)
      when Array then
        arrenc(var);Fi[	@HI".var = self.nested_attributes_options[var];Fi[[	@ç
iuI"     # update_only is true, and a <tt>:_destroy</tt> key set to a truthy value,
    # then the existing record will be marked for destruction.
    def function(var, var)
      var = self.nested_attributes_options[var]
      var = var.with_indifferent_access;Fi[	@ç
i¢I"Õ    #     { id: '2', _destroy: true }
    #   ])
    def function(var, var)
      var = self.nested_attributes_options[var]
      raise(ArgumentError, "STRING") unless (var.is_a?(Hash) or var.is_a?(Array));Fi[	@H@ Hi[[	@‘i~I"w  attr_reader("LITERAL", "LITERAL", "LITERAL")
  
  def function(var, var)
    @var = var.to_s
    @var = var.to_s;Fi[	@zi0I"Y  include(Comparable)
  
  def function(var, var)
    @var = var.to_s
    @var = var;Fi[	@HI"exec_query("STRING");Fi[[	@XioI"Y      end
      
      def function(var, var)
        exec_query("STRING")
      end;Fi[	@XiwI"Ç      # Example:
      #   rename_table('octopuses', 'octopi')
      def function(var, var)
        exec_query("STRING")
      end;Fi[	@H@[i[[	@ƒiI"w      end
      
      def function(var, var)
        return if var.nil?
        var = configuration_for(var, var);Fi[	@ˇiéI"ê      private
      
      def function(var, var)
        return if var.nil?
        var = "STRING" if @options["LITERAL"] and (var == "STRING");Fi[	@HI""while (@max <= cache.size) do;Fi[[	@Ã	ifI"â        end
        
        def function(var, var)
          while (@max <= cache.size) do
            cache.shift.last["LITERAL"].close;Fi[	@XiGI"å        end
        
        def function(var, var)
          while (@max <= cache.size) do
            dealloc(cache.shift.last["LITERAL"]);Fi[	@H@w,i[[	@
iI"_        end
        
        def function(var, var)
          var = var
          var = [];Fi[	@H-iTI"f  end
  
  def function(var, var)
    var = var
    var = var.base_class.to_s if var.is_a?(Class);Fi[	@HI"drop_database(var);Fi[[	@UiKI"—      # Drops the database specified on the +name+ attribute
      # and creates it again using the provided +options+.
      def function(var, var)
        drop_database(var)
        create_database(var, var);Fi[	@õiI"€        # Drops the database specified on the +name+ attribute
        # and creates it again using the provided +options+.
        def function(var, var)
          drop_database(var)
          create_database(var, var);Fi[	I"case @config["STRING"];F@îi[[	@Í
iI"p    def function
      return if @setup
      case @config["STRING"]
      when "STRING" then
        begin;Fi[	@Í
i`I"•    def function(var)
      setup
      case @config["STRING"]
      when "STRING" then
        @redcarpet_extensions["LITERAL"] = @redcarpet_extensions["LITERAL"].!;Fi[	@H@3Wi[[	@UiΩI"$      
      # QUOTING ==================================================
      def function(var, var)
        if var.kind_of?(String) and (var and ((var.type == "LITERAL") and var.class.respond_to?("LITERAL"))) then
          var = var.class.string_to_binary(var).unpack("STRING")["LITERAL"];Fi[	@Xi¿I"$      
      # QUOTING ==================================================
      def function(var, var)
        if var.kind_of?(String) and (var and ((var.type == "LITERAL") and var.class.respond_to?("LITERAL"))) then
          var = var.class.string_to_binary(var).unpack("STRING")["LITERAL"];Fi[	I"=MaRuKu::Globals["LITERAL"] = @config["STRING"]["STRING"];F@xoi[[	@Í
iDI".            MaRuKu::Globals["LITERAL"] = "STRING"
            MaRuKu::Globals["LITERAL"] = true
            MaRuKu::Globals["LITERAL"] = @config["STRING"]["STRING"]
            MaRuKu::Globals["LITERAL"] = @config["STRING"]["STRING"]
            MaRuKu::Globals["LITERAL"] = @config["STRING"]["STRING"];Fi[	@Í
iEI"            MaRuKu::Globals["LITERAL"] = true
            MaRuKu::Globals["LITERAL"] = @config["STRING"]["STRING"]
            MaRuKu::Globals["LITERAL"] = @config["STRING"]["STRING"]
            MaRuKu::Globals["LITERAL"] = @config["STRING"]["STRING"]
          end);Fi[	@H@≠Vi[[	@iòI"Ã      
      # @see Base#render_with_options
      def function(var, var)
        var = var["LITERAL"] ? ("STRING") : ("STRING")
        (var["LITERAL"] == "LITERAL") ? (var = "STRING") : (var = "STRING");Fi[	@i®I"Ã      
      # @see Base#render_with_options
      def function(var, var)
        var = var["LITERAL"] ? ("STRING") : ("STRING")
        (var["LITERAL"] == "LITERAL") ? (var = "STRING") : (var = "STRING");Fi[	@HI"2var = Hash[var.map { |var| [var, "STRING"] }];Fi[[	@ÜicI"Ó      
      # Overridden by the mysql adapter for supporting index lengths
      def function(var, var)
        var = Hash[var.map { |var| [var, "STRING"] }]
        var = add_index_sort_order(var, var, var) if supports_index_sort_order?;Fi[	@UiHI"ë      end
      
      def function(var, var)
        var = Hash[var.map { |var| [var, "STRING"] }]
        var = add_index_length(var, var, var);Fi[	@H@)Ui[[	@iaI"£      
      # Return a subquery for the given key using the join information.
      def function(var, var)
        var = var.clone
        var.projections = [var];Fi[	@Ui0I"Ó      # MySQL is too stupid to create a temporary table for use subquery, so we have
      # to give it some prompting in the form of a subsubquery. Ugh!
      def function(var, var)
        var = var.clone
        var.projections = [var];Fi[	@·F@	+i[[	@iI"Õ    # base - The String path to the source.
    # dir  - The String path between the source and the file.
    # name - The String filename of the file.
    def function(var, var, var, var)
      @var = var;Fi[	@ÌiI"Õ    # base - The String path to the <source>.
    # dir  - The String path between <source> and the file.
    # name - The String filename of the file.
    def function(var, var, var, var)
      @var = var;Fi[	@HI" var = var.map do |var, var|;Fi[[	@Ui§I"z      end
      
      def function(var, var)
        var = var.map do |var, var|
          var, var = var.shift, var;Fi[	@iHI"‡      #   #    SET comment_count = COALESCE(comment_count, 0) + 1
      #   #  WHERE id IN (10, 15)
      def function(var, var)
        var = var.map do |var, var|
          var = (var < "LITERAL") ? ("STRING") : ("STRING");Fi[	@H@Yi[[	I"7projects//diaspora_proj/helpers/contacts_helper.rb;TiI"u  end
  
  def function(var, var)
    var = "LITERAL"
    var = { "LITERAL" => "STRING", "LITERAL" => "STRING" };Fi[	@‡iI"É  end
  
  def function(var, var)
    var = "LITERAL"
    URI.extract(var.text("LITERAL" => (true)), ["STRING", "STRING"]) do |var|;Fi[	@H@Ùi[[	@UiÖI"      
      # Returns an array of indexes for the given table.
      def function(var, var)
        var = []
        var = nil;Fi[	@ÅiI"w        end
        
        def function(var, var)
          var = []
          var.each_with_index do |var, var|;Fi[	I")# Returns the HTML formatted String.;F@£i[[	@@iI"õ    # input - The Textile String to convert.
    #
    # Returns the HTML formatted String.
    def function(var)
      var = @context.registers["LITERAL"];Fi[	@@iI"ú    # input - The Markdown String to convert.
    #
    # Returns the HTML formatted String.
    def function(var)
      var = @context.registers["LITERAL"];Fi[	I"!# date - The Time to format.;F@i[[	@@i)I"ã    # Format a date in long format e.g. "27 January 2011".
    #
    # date - The Time to format.
    #
    # Returns the formatted String.;Fi[	@@i2I"d    # Format a date for use in XML.
    #
    # date - The Time to format.
    #
    # Examples;Fi[	@H@YPi[[	@ØixI"~      end
      
      def function(var, var)
        var = var.flatten
        var.each { |var| raise_on_type_mismatch(var) };Fi[	@ªiI"f      end
      
      def function(var, var)
        var = var.flatten
        var.each do |var|;Fi[	@HI"+var, var = nil, var if var.is_a?(Hash);Fi[[	@Øi|I"      # association, it will be used for the query. Otherwise, construct options and pass them with
      # scope to the target class's +count+.
      def function(var, var)
        var, var = nil, var if var.is_a?(Hash)
        if (options["LITERAL"] or options["LITERAL"]) then;Fi[	@∏iI"Œ    #   Person.count(:age, distinct: true)
    #   # => counts the number of different age values
    def function(var, var)
      var, var = nil, var if var.is_a?(Hash)
      calculate("LITERAL", var, var);Fi[	I"$# input - The String to escape.;F@i[[	@@iAI"o    # appropriate HTML entity replacements.
    #
    # input - The String to escape.
    #
    # Examples;Fi[	@@iPI"l    # with appropriate %XX replacements.
    #
    # input - The String to escape.
    #
    # Examples;Fi[	I""# Returns the escaped String.;F@£i[[	@@iHI"Ü    #   # => "foo &quot;bar&quot; &lt;baz&gt;"
    #
    # Returns the escaped String.
    def function(var)
      CGI.escapeHTML(var);Fi[	@@iWI"z    #   # => "foo%2Cbar%3Bbaz%3F"
    #
    # Returns the escaped String.
    def function(var)
      CGI.escape(var);Fi[	@¨*@O+i[[	@$niI""        var = (var + "LITERAL")
        var = (((var["LITERAL"].split("STRING")["LITERAL"] + "STRING") + var["LITERAL"]) + (var["LITERAL"] =~ "LITERAL" ? ("STRING") : ("STRING")))
        File.open("STRING", "STRING") do |var|
          var.puts("STRING")
          var.puts(var["LITERAL"]);Fi[	@Ni-I"æ          var.each do |var|
            FileUtils.mkdir_p(var["LITERAL"])
            File.open("STRING", "STRING") do |var|
              var.puts("STRING")
              var.puts("STRING");Fi[	@H@5.i[[	@J
iJI"c  end
  
  def function(var, var)
    if var.nil? then
      var = (self + File.basename(var));Fi[	@‘iïI"J  end
  
  def function(var, var)
    if var.nil? then
      case var;Fi[	@H@¶Ki[[	@´KiI"Ü    
    module Statements
      def function(var, var)
        raise(ArgumentError, "STRING") if var.empty?
        var.each do |var|;Fi[	@´KiI"|      end
      
      def function(var, var)
        raise(ArgumentError, "STRING") if var.empty?
        var.each do |var|;Fi[	@H@Ei[[	@Ji˛I"w    end
    
    def function(var, var)
      if var.empty? then
        var.project(@klass.arel_table[Arel.star]);Fi[	@›iqI"µ    # override_matching_for_conditions?(subject, conditions) and
    # matches_conditions_hash?(subject, conditions)
    def function(var, var)
      if var.empty? then
        true;Fi[	@H@Qi[[	@qi@I"˜      # @example Return the direct message with the id 1825786345
      #   Twitter.direct_message(1825786345)
      def function(var, var)
        var["LITERAL"] = var
        object_from_response(Twitter::DirectMessage, "LITERAL", "STRING", var);Fi[	@˙iI"¡      # @example Return the top 10 trending topics for San Francisco
      #   Twitter.trends(2487956)
      def function(var, var)
        var["LITERAL"] = var
        var = get("STRING", var);Fi[	@H@∞Ii[[	@—i°I"ô      
      # Takes two hashes and does a deep merge.
      def function(var, var)
        var.each do |var, var|
          if var[var].is_a?(Hash) then;Fi[	@≠
ièI"µ      
      # Parse authentication keys considering if they should be enforced or not.
      def function(var, var)
        var.each do |var, var|
          var = var[var].presence;Fi[	I"fvar = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var) }.delete_if do |var, var|;F@·*i[[	@Ni I"û        var = var.strip.downcase.gsub("LITERAL", "STRING").gsub("LITERAL", "STRING").gsub("LITERAL", "STRING").gsub("LITERAL", "STRING").gsub("LITERAL", "STRING").gsub("LITERAL", "STRING")
        var = ((var.strftime("STRING") + var) + "STRING")
        var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var) }.delete_if do |var, var|
          (var.nil? or (var == "STRING"))
        end.to_yaml;Fi[	@∏*i,I"          var = var["STRING"].!
          var = ("STRING" % [var.year, var.month, var.day, var])
          var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var) }.delete_if do |var, var|
            (var.nil? or (var == "STRING"))
          end.to_yaml;Fi[	@H@±8i[[	@iI"ä      
      # Converts an arel AST to SQL
      def function(var, var)
        if var.respond_to?("LITERAL") then
          var = var.dup;Fi[	@∞i@I"å      end
      
      def function(var, var)
        if var.respond_to?("LITERAL") then
          (var.serialize_to_config(var) + "STRING");Fi[	@·*I"end.to_yaml);Fi[[	@¥'iI"1        File.open("STRING", "STRING") do |var|
          var.puts({ "STRING" => "STRING", "STRING" => (var["LITERAL"].to_s), "STRING" => (var["LITERAL"]), "STRING" => (var["LITERAL"]) }.delete_if do |var, var|
            (var.nil? or (var == "STRING"))
          end.to_yaml)
          var.puts("STRING");Fi[	@ø'iI"        File.open("STRING", "STRING") do |var|
          var.puts({ "STRING" => "STRING", "STRING" => (var["LITERAL"].to_s), "STRING" => (var["LITERAL"]) }.delete_if do |var, var|
            (var.nil? or (var == "STRING"))
          end.to_yaml)
          var.puts("STRING");Fi[	@H@4i[[	@JiÀI"Y    end
    
    def function(var, var)
      case var
      when String, Array then;Fi[	@´iAI"∑      # @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      # @return [Hash]
      def function(var, var)
        case var
        when Integer then;Fi[	@H@x]i[[	@9i˝I"™    #   person.errors.messages
    #   # => {:name=>["can't be empty"]}
    def function(var, var)
      Array(var).each do |var|
        var = @base.send("LITERAL", var);Fi[	@9iI"™    #   person.errors.messages
    #   # => {:name=>["can't be blank"]}
    def function(var, var)
      Array(var).each do |var|
        var = @base.send("LITERAL", var);Fi[	@G@û<i[[	@¥'iI"Â    SQL = "STRING"
    
    def self.process(var, var, var, var)
      FileUtils.mkdir_p("STRING")
      var = Sequel.postgres("LITERAL" => (var), "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => "STRING");Fi[	@ø'iI"”    SQL = "STRING"
    
    def self.process(var, var, var, var)
      FileUtils.mkdir_p("STRING")
      var = Sequel.mysql(var, "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => (var), "LITERAL" => "STRING");Fi[	@H@öi[[	@&i$I"á      # attributes when they are initialized. (e.g. attribute
      # serialization)
      def function(var, var)
        var
      end;Fi[	@”iI"u          defined? ::MongoMapper::Plugins.!
        end
        def function(var, var)
          var
        end;Fi[	@p@O+i[[	@¥'iI"6          var.puts({ "STRING" => "STRING", "STRING" => (var["LITERAL"].to_s), "STRING" => (var["LITERAL"]), "STRING" => (var["LITERAL"]) }.delete_if do |var, var|
            (var.nil? or (var == "STRING"))
          end.to_yaml)
          var.puts("STRING")
          var.puts(var["LITERAL"].delete("STRING"));Fi[	@ø'iI"          var.puts({ "STRING" => "STRING", "STRING" => (var["LITERAL"].to_s), "STRING" => (var["LITERAL"]) }.delete_if do |var, var|
            (var.nil? or (var == "STRING"))
          end.to_yaml)
          var.puts("STRING")
          var.puts(var["LITERAL"].delete("STRING"));Fi[	@H@!6i[[	@î!iI"“    # file in order to add support for new, simple browser functions without
    # waiting for a new compass release.
    def function(var, var)
      var.each do |var|
        unless ASPECTS.include?(var) then;Fi[	@î!i.I"Ë    # file in order to remove support for simple functions that no longer need to
    # a prefix without waiting for a new compass release.
    def function(var, var)
      var.each do |var|
        unless ASPECTS.include?(var) then;Fi[	@m@îi[[	@
i;I"¿        var = (var["STRING"] or var["STRING"])
        var = "STRING"
        (var << ("STRING" + var["STRING"])) unless var["STRING"].nil?
      when "STRING" then
        var = var["STRING"];Fi[	@
iPI"≠        var = var["STRING"]
        var = "STRING"
        (var << ("STRING" + var["STRING"])) unless var["STRING"].nil?
      when "STRING" then
        var = var["STRING"];Fi[	@`f@%i[[	@^iÎI"Ω      def function(var, var, var)
        if (var["LITERAL"] == "STRING") then
          var = ["STRING", "STRING", "STRING", "STRING"]
          var = Node.new("LITERAL", var)
        else;Fi[	@^iÔI"∞        else
          if (var["LITERAL"] == "STRING") then
            var = ["STRING", "STRING", "STRING", "STRING"]
            var = Node.new("LITERAL", var)
          else;Fi[	@KX@JXi[[	@pi*I"œ      var = ("STRING" % [var.year, var.month, var.day, var])
      var = var["LITERAL"].to_s
      var = clean_entities(var) if var["LITERAL"]
      var = var["LITERAL"].to_s
      var = var.index("LITERAL");Fi[	@piSI"¯          var = var["LITERAL"].to_s
          var.force_encoding("STRING") if var.respond_to?("LITERAL")
          var = clean_entities(var) if var["LITERAL"]
          var = var["LITERAL"].to_s
          var = clean_entities(var) if var["LITERAL"];Fi[	I"<if var["LITERAL"] and (var["LITERAL"] == "STRING") then;F@\$i[[	@pi<I"–        var = "STRING"
        var[var].each do |var|
          if var["LITERAL"] and (var["LITERAL"] == "STRING") then
            if var["LITERAL"] then
              (var << clean_entities(var["LITERAL"]));Fi[	@piCI"ø            end
          else
            if var["LITERAL"] and (var["LITERAL"] == "STRING") then
              if var["LITERAL"] then
                (var << clean_entities(var["LITERAL"]));Fi[	@ºV@|i[[	@pi>I"—          if var["LITERAL"] and (var["LITERAL"] == "STRING") then
            if var["LITERAL"] then
              (var << clean_entities(var["LITERAL"]))
            else
              (var << var["LITERAL"]);Fi[	@piEI"€            if var["LITERAL"] and (var["LITERAL"] == "STRING") then
              if var["LITERAL"] then
                (var << clean_entities(var["LITERAL"]))
              else
                (var << var["LITERAL"]);Fi[	@ı:@»:i[[	@ iLI"à      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name
      #;Fi[	@ iÜI"à      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name
      #;Fi[	I"require("time");F@Ö*i[[	@ì*i I"3require("time")
module Resque
  module Failure;Fi [	@]i I"1require("time")
module Resque
  class Worker;Fi [	@écI"var = if permalink then;Fi[[	@iLI"}    # Returns the String url.
    def function
      return @url if @url
      var = if permalink then
        permalink;Fi[	@
iÖI"}    # Returns the String URL.
    def function
      return @url if @url
      var = if permalink then
        permalink;Fi[	@]pI"permalink;Fi[[	@iMI"j    def function
      return @url if @url
      var = if permalink then
        permalink
      else;Fi[	@
iÜI"j    def function
      return @url if @url
      var = if permalink then
        permalink
      else;Fi[	@dp@|i[[	@iNI"∫      return @url if @url
      var = if permalink then
        permalink
      else
        { "STRING" => (self.basename), "STRING" => (self.output_ext) }.inject(template) do |var, var|;Fi[	@
iáI"€      return @url if @url
      var = if permalink then
        permalink
      else
        { "STRING" => (date.strftime("STRING")), "STRING" => (date.strftime("STRING")), "STRING" => (date.strftime("STRING")), "STRING" => (CGI.escape(slug)), "STRING" => (date.strftime("STRING").to_i.to_s), "STRING" => (date.strftime("STRING").to_i.to_s), "STRING" => (categories.map { |var| URI.escape(var) }.join("STRING")), "STRING" => (self.output_ext) }.inject(template) do |var, var|;Fi[	I"P@var = var.split("STRING").reject { |var| var =~ "LITERAL" }.join("STRING");FI"1@var = (@url + "STRING") if var =~ "LITERAL";Fi[[	@iTI"ø        end.gsub("LITERAL", "STRING")
      end
      @var = var.split("STRING").reject { |var| var =~ "LITERAL" }.join("STRING")
      @var = (@url + "STRING") if var =~ "LITERAL"
      @url;Fi[	@
içI"ø        end.gsub("LITERAL", "STRING")
      end
      @var = var.split("STRING").reject { |var| var =~ "LITERAL" }.join("STRING")
      @var = (@url + "STRING") if var =~ "LITERAL"
      @url;Fi[	I"hself.attribute_method_matchers += var.map! { |var| AttributeMethodMatcher.new("LITERAL" => (var)) };FI"undefine_attribute_methods;Fi[[	@ i8I"ÿ      #   person.name          # => nil
      def function(var)
        self.attribute_method_matchers += var.map! { |var| AttributeMethodMatcher.new("LITERAL" => (var)) }
        undefine_attribute_methods
      end;Fi[	@ i[I"Ÿ      #   person.name_short?   # => true
      def function(var)
        self.attribute_method_matchers += var.map! { |var| AttributeMethodMatcher.new("LITERAL" => (var)) }
        undefine_attribute_methods
      end;Fi[	@£I"@attrs.update(var);Fi[[	@oiQI"v    # @param attrs [Hash]
    # @return [Twitter::Base]
    def function(var)
      @attrs.update(var)
      self;Fi[	@ri-I"{    # @param attrs [Hash]
    # @return [Twitter::RateLimit]
    def function(var)
      @attrs.update(var)
      self;Fi[	@èGI")FileUtils.mkdir_p(File.dirname(var));Fi[[	@iÅI"¥    # Returns nothing.
    def function(var)
      var = destination(var)
      FileUtils.mkdir_p(File.dirname(var))
      File.open(var, "STRING") { |var| var.write(self.output) };Fi[	@
i“I"¥    # Returns nothing.
    def function(var)
      var = destination(var)
      FileUtils.mkdir_p(File.dirname(var))
      File.open(var, "STRING") { |var| var.write(self.output) };Fi[	I" rescue Errno::ENOENT => var;F@n
i[[	@Z
i∞I"„        self.categories.values.map { |var| var.sort! { |var, var| (var <=> var) } }
        self.tags.values.map { |var| var.sort! { |var, var| (var <=> var) } })
      rescue Errno::ENOENT => var
        # do nothing
      end;Fi[	@^i)I"ö            (log("STRING")
            FileUtils.rm(var) if File.exist?(var))
          rescue Errno::ENOENT => var
            # do nothing
          end;Fi[	@£I"super.each do |var|;Fi[[	@Ûi∑I"œ      
      # Configures new states with the built-in humanize scheme
      def function(var)
        super.each do |var|
          var.human_name = lambda { |var, var| translate(var, "LITERAL", var.name) };Fi[	@ÛiæI"Œ      
      # Configures new event with the built-in humanize scheme
      def function(var)
        super.each do |var|
          var.human_name = lambda { |var, var| translate(var, "LITERAL", var.name) };Fi[	@£I"@var = [true, false].include?(var.last) ? (var.pop) : (true);Fi[[	@ÌiáI"U    #   
    #   vehicle.fire_events!(:ignite, :disable_alarm) # => StateMachine::InvalidTranstion: Cannot run events in parallel: ignite, disable_alarm
    def function(var)
      var = [true, false].include?(var.last) ? (var.pop) : (true)
      (fire_events(*(var + [var])) or raise(StateMachine::InvalidParallelTransition.new(self, var)));Fi[	@3iΩI"J    #   transition.perform(Time.now)        # => Passes in additional arguments and runs the +save+ action
    #   transition.perform(Time.now, false) # => Passes in additional arguments and only sets the state attribute
    def function(var)
      var = [true, false].include?(var.last) ? (var.pop) : (true)
      self.args = var;Fi[	@£@ƒmi[[	@)1iI"‘    # checking for all the required fields exist after the definition of the
    # attachment.
    def function(var)
      var = self.name.gsub("LITERAL", "STRING").constantize
      var = have_attached_file(var);Fi[	@)1iI"√    
    # Tests for validations on the presence of the attachment.
    def function(var)
      var = self.name.gsub("LITERAL", "STRING").constantize
      var = validate_attachment_presence(var);Fi[	@£I"5var = (options["LITERAL"] or options["LITERAL"]);Fi[[	@EiAI"õ      end
      
      def function(var)
        var = (options["LITERAL"] or options["LITERAL"])
        var = var.call(var) if var.respond_to?("LITERAL");Fi[	@EiHI"õ      end
      
      def function(var)
        var = (options["LITERAL"] or options["LITERAL"])
        var = var.call(var) if var.respond_to?("LITERAL");Fi[	@£I"@var = var.flatten;Fi[[	@JiI"_        end
        
        def function(var)
          @var = var.flatten
          self;Fi[	@Ji!I"_        end
        
        def function(var)
          @var = var.flatten
          self;Fi[	@lGI"xvar.value["LITERAL"] = Node.new("LITERAL", [Node.new("LITERAL", ["STRING"]), Node.new("LITERAL", ["STRING", var])]);Fi[[	@Ùi4I"B            var = var.value["LITERAL"].value.first.gsub("LITERAL", "STRING")
            var = var.value["LITERAL"].value.first
            var.value["LITERAL"].value = ["STRING"]
            var.value["LITERAL"] = Node.new("LITERAL", [Node.new("LITERAL", ["STRING"]), Node.new("LITERAL", ["STRING", var])])
          else;Fi[	@Ùi9I"?            if ("STRING" == var.value["LITERAL"].value.first) then
              var = var.value["LITERAL"].value.first
              var.value["LITERAL"].value = ["STRING"]
              var.value["LITERAL"] = Node.new("LITERAL", [Node.new("LITERAL", ["STRING"]), Node.new("LITERAL", ["STRING", var])])
            end;Fi[	@£I"5while var = var.read(("LITERAL" * "LITERAL")) do;Fi[[	@DiI"}    end
    
    def function(var)
      while var = var.read(("LITERAL" * "LITERAL")) do
        destination.write(var);Fi[	@Ji I"}    end
    
    def function(var)
      while var = var.read(("LITERAL" * "LITERAL")) do
        destination.write(var);Fi[	@£I")var = @options["LITERAL"]["LITERAL"];Fi[[	@iZI"ä    end
    
    def function(var)
      var = @options["LITERAL"]["LITERAL"]
      var = var.call(instance) if var.respond_to?("LITERAL");Fi[	@ibI"ä    end
    
    def function(var)
      var = @options["LITERAL"]["LITERAL"]
      var = var.call(instance) if var.respond_to?("LITERAL");Fi[	@£I"/var = self.class.name.split("STRING").last;Fi[[	@+i	I"ª    module PP
      module CharacterData
        def function(var)
          var = self.class.name.split("STRING").last
          var.group("LITERAL", "STRING", "STRING") { var.pp(text) };Fi[	@«iI"ô        end
        
        def function(var)
          var = self.class.name.split("STRING").last
          var.group("LITERAL", "STRING", "STRING") do;Fi[	@?`@öi[[	@^iñI"ê      
      def function(var, var, var)
        var = Node.new("LITERAL", [[var.first, var.last].compact.join("STRING")])
        var
      end;Fi[	@^i∂I"ê      
      def function(var, var, var)
        var = Node.new("LITERAL", [[var.first, var.last].compact.join("STRING")])
        var
      end;Fi[	@8`@öi[[	@^ißI"†      # reduce 27 omitted
      def function(var, var, var)
        var = Node.new("LITERAL", ([var["LITERAL"]] + (var["LITERAL"] or [])))
        var
      end;Fi[	@^i¨I"ç      
      def function(var, var, var)
        var = Node.new("LITERAL", ([var["LITERAL"]] + (var["LITERAL"] or [])))
        var
      end;Fi[	@£I"each do |var|;Fi[[	@(iöI"π      ###
      # Append the class attribute +name+ to all Node objects in the NodeSet.
      def function(var)
        each do |var|
          var = var["STRING"].to_s.split("LITERAL");Fi[	@(i¶I"ü      # If +name+ is nil, remove the class attribute from all Nodes in the
      # NodeSet.
      def function(var)
        each do |var|
          if var then;Fi[	@£I"#var = document.root.namespaces;Fi[[	@ÿi¡I"Á      ###
      # Search this node's immediate children using CSS selector +selector+
      def function(var)
        var = document.root.namespaces
        xpath(CSS.xpath_for(var, "LITERAL" => "STRING", "LITERAL" => (var)).first);Fi[	@(ivI"Ò      ###
      # Search this NodeSet's nodes' immediate children using CSS selector +selector+
      def function(var)
        var = document.root.namespaces
        xpath(CSS.xpath_for(var, "LITERAL" => "STRING", "LITERAL" => (var)).first);Fi[	@1`@öi[[	@^iFI"m      
      def function(var, var, var)
        var = [var.first, var["LITERAL"]]
        var
      end;Fi[	@^iKI"m      
      def function(var, var, var)
        var = [var.first, var["LITERAL"]]
        var
      end;Fi[	@£@€>i[[	@ÿiıI"á      #
      # Also see related method +<<+.
      def function(var)
        var = coerce(var)
        if var.is_a?(XML::NodeSet) then;Fi[	@ÿiPI"      #
      # Also see related method +inner_html=+
      def function(var)
        var = coerce(var)
        children.unlink;Fi[	@£I"!self.ext = File.extname(var);Fi[[	@‚i(I"b    #
    # Returns nothing.
    def function(var)
      self.ext = File.extname(var)
    end;Fi[	@i^I"ú    #
    # Returns nothing.
    def function(var)
      self.ext = File.extname(var)
      self.basename = var[("LITERAL"..(-self.ext.length - "LITERAL"))];Fi[	I"8return self.send(var, var) if self.respond_to?(var);FI"case var.value.first;Fi[[	@Ki
I"Ÿ      def function(var)
        var = :"visit_function_#{var.value.first.gsub("LITERAL", "STRING")}"
        return self.send(var, var) if self.respond_to?(var)
        case var.value.first
        when "LITERAL" then;Fi[	@KiaI"„        else
          var = :"visit_pseudo_class_#{var.value.first.gsub("LITERAL", "STRING")}"
          return self.send(var, var) if self.respond_to?(var)
          case var.value.first
          when "STRING", "STRING" then;Fi[	@7T@i[[	@KiJI"©        case var.value["LITERAL"]
        when "LITERAL" then
          ((var + "STRING") + "STRING")
        when "LITERAL" then
          ((var + "STRING") + "STRING");Fi[	@KiLI"ö          ((var + "STRING") + "STRING")
        when "LITERAL" then
          ((var + "STRING") + "STRING")
        when "LITERAL" then
          "STRING";Fi[	@`&I"class ElementDescription;Fi[[	@iI"Imodule Nokogiri
  module HTML
    class ElementDescription
      ###;Fi[	@Ï#iI"ˆmodule Nokogiri
  module HTML
    class ElementDescription
      Desc = Struct.new("STRING", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL");Fi[	@£I"(var = @context.registers["LITERAL"];Fi[[	@@iI"©    #
    # Returns the HTML formatted String.
    def function(var)
      var = @context.registers["LITERAL"]
      var = var.getConverterImpl(Jekyll::TextileConverter);Fi[	@@iI"™    #
    # Returns the HTML formatted String.
    def function(var)
      var = @context.registers["LITERAL"]
      var = var.getConverterImpl(Jekyll::MarkdownConverter);Fi[	I"	####;FI";# Create a Nokogiri::XML::DocumentFragment from +tags+;Fi[[	@’iDI"u      end
      
      ####
      # Create a Nokogiri::XML::DocumentFragment from +tags+
      def function(var);Fi[	@iPI"Ä      
      class << self
        ####
        # Create a Nokogiri::XML::DocumentFragment from +tags+
        def function(var);Fi[	I"L# Serialize Node using +options+.  Save options can also be set using a;FI"# block. See SaveOptions.;Fi[[	@’i2I"á      
      ####
      # Serialize Node using +options+.  Save options can also be set using a
      # block. See SaveOptions.
      #;Fi[	@ÿiôI"Ü      
      ###
      # Serialize Node using +options+.  Save options can also be set using a
      # block. See SaveOptions.
      #;Fi[	@&q@i[[	@’i3I"≠      ####
      # Serialize Node using +options+.  Save options can also be set using a
      # block. See SaveOptions.
      #
      # These two statements are equivalent:;Fi[	@ÿiöI"¨      ###
      # Serialize Node using +options+.  Save options can also be set using a
      # block. See SaveOptions.
      #
      # These two statements are equivalent:;Fi[	I"+# These two statements are equivalent:;F@i[[	@’i5I"©      # block. See SaveOptions.
      #
      # These two statements are equivalent:
      #
      #  node.serialize(:encoding => 'UTF-8', :save_with => FORMAT | AS_XML);Fi[	@ÿiúI"©      # block. See SaveOptions.
      #
      # These two statements are equivalent:
      #
      #  node.serialize(:encoding => 'UTF-8', :save_with => FORMAT | AS_XML);Fi[	I"K#  node.serialize(:encoding => 'UTF-8', :save_with => FORMAT | AS_XML);F@i[[	@’i7I"î      # These two statements are equivalent:
      #
      #  node.serialize(:encoding => 'UTF-8', :save_with => FORMAT | AS_XML)
      #
      # or;Fi[	@ÿiûI"î      # These two statements are equivalent:
      #
      #  node.serialize(:encoding => 'UTF-8', :save_with => FORMAT | AS_XML)
      #
      # or;Fi[	I"	# or;F@i[[	@’i9I"¢      #  node.serialize(:encoding => 'UTF-8', :save_with => FORMAT | AS_XML)
      #
      # or
      #
      #   node.serialize(:encoding => 'UTF-8') do |config|;Fi[	@ÿi†I"¢      #  node.serialize(:encoding => 'UTF-8', :save_with => FORMAT | AS_XML)
      #
      # or
      #
      #   node.serialize(:encoding => 'UTF-8') do |config|;Fi[	I"9#   node.serialize(:encoding => 'UTF-8') do |config|;FI"#     config.format.as_xml;Fi[[	@’i;I"|      # or
      #
      #   node.serialize(:encoding => 'UTF-8') do |config|
      #     config.format.as_xml
      #   end;Fi[	@ÿi¢I"|      # or
      #
      #   node.serialize(:encoding => 'UTF-8') do |config|
      #     config.format.as_xml
      #   end;Fi[	@Iq@i[[	@’i<I"~      #
      #   node.serialize(:encoding => 'UTF-8') do |config|
      #     config.format.as_xml
      #   end
      #;Fi[	@ÿi£I"~      #
      #   node.serialize(:encoding => 'UTF-8') do |config|
      #     config.format.as_xml
      #   end
      #;Fi[	@q@£i[[	@’iEI"ô      
      ####
      # Create a Nokogiri::XML::DocumentFragment from +tags+
      def function(var)
        DocumentFragment.new(self, var, self.root);Fi[	@iQI"§      class << self
        ####
        # Create a Nokogiri::XML::DocumentFragment from +tags+
        def function(var)
          self.new(XML::Document.new, var);Fi[	@£I"
setup;Fi[[	@Í
i^I"P    end
    
    def function(var)
      setup
      case @config["STRING"];Fi[	@W
i"I"t    end
    
    def function(var)
      setup
      return RedCloth.new(var).to_html if @config["STRING"].nil?;Fi[	@£I"Ovar = (("STRING" + @config["STRING"].gsub("STRING", "STRING")) + "STRING");Fi[[	@Í
iUI"•    end
    
    def function(var)
      var = (("STRING" + @config["STRING"].gsub("STRING", "STRING")) + "STRING")
      var.=~(Regexp.new(var, Regexp::IGNORECASE));Fi[	@W
iI"•    end
    
    def function(var)
      var = (("STRING" + @config["STRING"].gsub("STRING", "STRING")) + "STRING")
      var.=~(Regexp.new(var, Regexp::IGNORECASE));Fi[	I";(var = var.match("LITERAL") and return var["LITERAL"]);FI"catch("LITERAL") do;Fi[[	@’iìI"2          var = var.match("LITERAL") and return Nokogiri.XML(var["LITERAL"]).encoding
          if Nokogiri.jruby? then
            (var = var.match("LITERAL") and return var["LITERAL"])
            catch("LITERAL") do
              Nokogiri::HTML::SAX::Parser.new(JumpSAXHandler.new("LITERAL")).parse(var);Fi[	@’ißI"*          begin
            ((var = var.match("LITERAL") and return Nokogiri.XML(var["LITERAL"]).encoding)
            (var = var.match("LITERAL") and return var["LITERAL"])
            catch("LITERAL") do
              Nokogiri::HTML::SAX::Parser.new(JumpSAXHandler.new("LITERAL".to_s)).parse(var);Fi[	I",var["LITERAL"] = var["LITERAL"].flatten;F@rqi[[	@Ï#i+I"√        begin
          (var = Desc.new(*var)
          var["LITERAL"] = var["LITERAL"].flatten
          var["LITERAL"] = var["LITERAL"].flatten
          var["LITERAL"] = var["LITERAL"].flatten;Fi[	@Ï#i,I"Ë          (var = Desc.new(*var)
          var["LITERAL"] = var["LITERAL"].flatten
          var["LITERAL"] = var["LITERAL"].flatten
          var["LITERAL"] = var["LITERAL"].flatten
          var["LITERAL"] = var["LITERAL"].flatten);Fi[	@ú?I"class PushParser;Fi[[	@˜iI"lmodule Nokogiri
  module HTML
    module SAX
      class PushParser
        def function(var, var, var);Fi[	@ iI"hmodule Nokogiri
  module XML
    module SAX
      class PushParser
        attr_accessor("LITERAL");Fi[	@ÂmI"2raise(Errno::ENOENT) unless File.exists?(var);Fi[[	@r&iI"ﬁ        # Parse a file with +filename+
        def function(var, var)
          raise(ArgumentError) unless var
          raise(Errno::ENOENT) unless File.exists?(var)
          raise(Errno::EISDIR) if File.directory?(var);Fi[	@˝iLI"Ÿ        # Parse a file with +filename+
        def function(var)
          raise(ArgumentError) unless var
          raise(Errno::ENOENT) unless File.exists?(var)
          raise(Errno::EISDIR) if File.directory?(var);Fi[	@ÄqI"1raise(Errno::EISDIR) if File.directory?(var);Fi[[	@r&iI"‰        def function(var, var)
          raise(ArgumentError) unless var
          raise(Errno::ENOENT) unless File.exists?(var)
          raise(Errno::EISDIR) if File.directory?(var)
          var = ParserContext.file(var, var);Fi[	@˝iMI"⁄        def function(var)
          raise(ArgumentError) unless var
          raise(Errno::ENOENT) unless File.exists?(var)
          raise(Errno::EISDIR) if File.directory?(var)
          var = ParserContext.file(var);Fi[	I"def self.new(var, var);FI"Gif ["LITERAL", "LITERAL"].all? { |var| var.respond_to?(var) } then;Fi[[	@∑"i	I"     module SAX
      class ParserContext < Nokogiri::XML::SAX::ParserContext
        def self.new(var, var)
          if ["LITERAL", "LITERAL"].all? { |var| var.respond_to?(var) } then
            super;Fi[	@◊i	I"¿    module SAX
      class ParserContext
        def self.new(var, var)
          if ["LITERAL", "LITERAL"].all? { |var| var.respond_to?(var) } then
            io(var, Parser::ENCODINGS[var]);Fi[	@ö@•6i[[	@–iI"=module Nokogiri
  module XML
    class << self
      ###;Fi[	@‹iI"=module Nokogiri
  module XML
    class << self
      ###;Fi[	@öI"class Node;Fi[[	@)iI"Hmodule Nokogiri
  module XML
    class Node
      class SaveOptions;Fi[	@ÿiI"|require("nokogiri/xml/node/save_options")
module Nokogiri
  module XML
    class Node
      include(Nokogiri::XML::PP::Node);Fi[	@£@ø"i[[	@˝iºI"}    end
    
    def function(var)
      var = "LITERAL".match(var)
      if var and (var.begin("LITERAL") == "LITERAL") then;Fi[	@˝iÕI"n    end
    
    def function(var)
      var = "LITERAL".match(var)
      raise(Error, "STRING") if var.!;Fi[	@öI"module PP;Fi[[	@+iI"Jmodule Nokogiri
  module XML
    module PP
      module CharacterData;Fi[	@«iI"Amodule Nokogiri
  module XML
    module PP
      module Node;Fi[	@öI"class XPath;Fi[[	@ÂiI"\module Nokogiri
  module XML
    class XPath
      class SyntaxError < XML::SyntaxError;Fi[	@ËiI"{require("nokogiri/xml/xpath/syntax_error")
module Nokogiri
  module XML
    class XPath
      attr_accessor("LITERAL");Fi[	@£@~Ti[[	@˝i=I"Æ    # Parses an "object" in the sense of RFC 4627.
    # Returns the parsed value and any trailing tokens.
    def function(var)
      var = eat("STRING", var)
      var = {};Fi[	@˝iXI"≠    # Parses an "array" in the sense of RFC 4627.
    # Returns the parsed value and any trailing tokens.
    def function(var)
      var = eat("STRING", var)
      var = [];Fi[	I"(# For example, given this document:;F@i[[	@i_I"~      # return them as a hash.
      #
      # For example, given this document:
      #
      #   <root xmlns:foo="bar">;Fi[	@ijI"°      #
      # WARNING: this method will clobber duplicate names in the keys.
      # For example, given this document:
      #
      #   <root xmlns:foo="bar">;Fi[	I"#   </root>;F@i[[	@icI"É      #   <root xmlns:foo="bar">
      #     <bar xmlns:hello="world" />
      #   </root>
      #
      # This method will return:;Fi[	@inI"¶      #   <root xmlns:foo="bar">
      #     <bar xmlns:foo="baz" />
      #   </root>
      #
      # The hash returned will look like this: { 'xmlns:foo' => 'bar' };Fi[	@£@ﬂni[[	@˝iI"ÿ    # Note: this is almost the same as valparse,
    # except that it does not accept atomic values.
    def function(var)
      raise(Error, "STRING") if (var.length < "LITERAL")
      var, var, var = var["LITERAL"];Fi[	@˝i,I"‹    # Parses a "value" in the sense of RFC 4627.
    # Returns the parsed value and any trailing tokens.
    def function(var)
      raise(Error, "STRING") if (var.length < "LITERAL")
      var, var, var = var["LITERAL"];Fi[	@‹>I"+var.each { |var| add_child_node(var) };Fi[[	@ÿi˜I"ó      def function(var)
        var = coerce(var)
        if var.is_a?(XML::NodeSet) then
          var.each { |var| add_child_node(var) }
        else;Fi[	@ÿiSI"ó        var = coerce(var)
        children.unlink
        if var.is_a?(XML::NodeSet) then
          var.each { |var| add_child_node(var) }
        else;Fi[	I"# Entity node type;FI"# PI node type;Fi[[	@ÿi=I"ƒ      # CDATA node type, see Nokogiri::XML::Node#cdata?
      # Entity reference node type
      # Entity node type
      # PI node type
      # Comment node type, see Nokogiri::XML::Node#comment?;Fi[	@Õi;I"Ç      # CDATA node type
      # Entity Reference node type
      # Entity node type
      # PI node type
      # Comment node type;Fi[	I"A# A hash of namespace bindings may be appended. For example:;F@i[[	@ÿivI"π      #   node.xpath('.//title')
      #
      # A hash of namespace bindings may be appended. For example:
      #
      #   node.xpath('.//foo:name', {'foo' => 'http://example.org/'});Fi[	@ÿi°I"ƒ      #   node.css('div + p.green', 'div#one')
      #
      # A hash of namespace bindings may be appended. For example:
      #
      #   node.css('bike|tire', {'bike' => 'http://schwinn.com/'});Fi[	I"$#     def regex node_set, regex;FI"N#       node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ };Fi[[	@ÿiÇI"À      #
      #   node.xpath('.//title[regex(., "\w+")]', Class.new {
      #     def regex node_set, regex
      #       node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }
      #     end;Fi[	@ÿi¨I"¬      #
      #   node.css('title:regex("\w+")', Class.new {
      #     def regex node_set, regex
      #       node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }
      #     end;Fi[	@Ëq@>i[[	@ÿiÉI"‘      #   node.xpath('.//title[regex(., "\w+")]', Class.new {
      #     def regex node_set, regex
      #       node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }
      #     end
      #   }.new);Fi[	@ÿi≠I"À      #   node.css('title:regex("\w+")', Class.new {
      #     def regex node_set, regex
      #       node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }
      #     end
      #   }.new);Fi[	I"#   }.new);F@i[[	@ÿiÖI"ê      #       node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }
      #     end
      #   }.new)
      #
      def function(var);Fi[	@ÿiØI"æ      #       node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }
      #     end
      #   }.new)
      #
      # Note that the CSS query string is case-sensitive with regards;Fi[	@W@-i[[	@ÿiÔI"√      
      ###
      # Add +node_or_tags+ as a child of this Node.
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #;Fi[	@ÿi I"√      
      ###
      # Add +node_or_tags+ as a child of this Node.
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #;Fi[	@£@≤li[[	@ñ:iSI"öend
class ExternalDepsTests < Test::Unit::TestCase
  def function(var)
    var = DependencyCollector.new
    var.each { |var, var| var.add(var => (var)) };Fi[	@ñ:iZI"u  end
  
  def function(var)
    var = DependencyCollector.new
    var.each { |var, var| var.add(var => (var)) };Fi[	@£I"%(@var ||= {}).fetch(var.to_s) do;Fi[[	@·iI"~  end
  
  def function(var)
    (@var ||= {}).fetch(var.to_s) do
      @locate[var.to_s] = if File.executable?("STRING") then;Fi[	@·i>I"l  end
  
  def function(var)
    (@var ||= {}).fetch(var.to_s) do
      @sdk_path[var.to_s] = (var = [];Fi[	@—q@|i[[	@ÿi¯I"ù        var = coerce(var)
        if var.is_a?(XML::NodeSet) then
          var.each { |var| add_child_node(var) }
        else
          add_child_node(var);Fi[	@ÿiTI"õ        children.unlink
        if var.is_a?(XML::NodeSet) then
          var.each { |var| add_child_node(var) }
        else
          add_child_node(var);Fi[	@£@\ji[[	@Êi|I"P  end
  
  def function(var)
    fetch(var, []).map do |var|
      case var;Fi[	@ÊiäI"P  end
  
  def function(var)
    fetch(var, []).map do |var|
      case var;Fi[	@£I"if var.likes.loaded? then;Fi[[	@'
i
I"ñ  # Check whether the user has liked a post.
  # @param [Post] post
  def function(var)
    if var.likes.loaded? then
      if self.like_for(var) then;Fi[	@'
iI"•  # @param [Post] post
  # @return [Like]
  def function(var)
    if var.likes.loaded? then
      return var.likes.detect { |var| (var.author_id == self.person.id) };Fi[	I"if text? then;FI"6var = Nokogiri::XML::Node.new("STRING", document);Fi[[	@ÿicI"∫      # Also see related method +swap+.
      def function(var)
        if text? then
          var = Nokogiri::XML::Node.new("STRING", document)
          add_previous_sibling_node(var);Fi[	@ÿi5I"≤        var = coerce(var)
        if var.is_a?(XML::NodeSet) then
          if text? then
            var = Nokogiri::XML::Node.new("STRING", document)
            send(var, var);Fi[	@Ë?@£i[[	@ÿi«I"æ      #   doc.to_xml(:indent => 5, :encoding => 'UTF-8')
      #
      # See Node#write_to for a list of +options+
      def function(var)
        var["LITERAL"] ||= SaveOptions::DEFAULT_XML;Fi[	@ÿi“I"ø      #   doc.to_xhtml(:indent => 5, :encoding => 'UTF-8')
      #
      # See Node#write_to for a list of +options+
      def function(var)
        to_format(SaveOptions::DEFAULT_XHTML, var);Fi[	@Ë?@Hi[[	@ÿi˚I"≈      # Write Node as HTML to +io+ with +options+
      #
      # See Node#write_to for a list of +options+
      def function(var, var)
        write_format_to(SaveOptions::DEFAULT_HTML, var, var);Fi[	@ÿiI"«      # Write Node as XHTML to +io+ with +options+
      #
      # See Node#write_to for a list of +options+
      def function(var, var)
        write_format_to(SaveOptions::DEFAULT_XHTML, var, var);Fi[	@£I";var = find_or_initialize_with_error_by("LITERAL", var);Fi[[	@0iŒI"ˇ        # If the user is already confirmed, create an error for the user
        # Options must have the confirmation_token
        def function(var)
          var = find_or_initialize_with_error_by("LITERAL", var)
          var.confirm! if var.persisted?;Fi[	@iêI"˘        # If the user is not locked, creates an error for the user
        # Options must have the unlock_token
        def function(var)
          var = find_or_initialize_with_error_by("LITERAL", var)
          var.unlock_access! if var.persisted?;Fi[	@£I"7var = lambda { |var| var.to_s.singularize.to_sym };Fi[[	@miqI"Å    end
    
    def function(var)
      var = lambda { |var| var.to_s.singularize.to_sym }
      if var.has_key?("LITERAL") then;Fi[	@mi~I"Ç    end
    
    def function(var)
      var = lambda { |var| var.to_s.singularize.to_sym }
      if (var["LITERAL"] == true) then;Fi[	@£I"@var = Hash.new;Fi[[	@migI"y    end
    
    def function(var)
      @var = Hash.new
      @constraints.merge!(var["LITERAL"]) if var["LITERAL"];Fi[	@milI"v    end
    
    def function(var)
      @var = Hash.new
      @defaults.merge!(var["LITERAL"]) if var["LITERAL"];Fi[	I"0var.group("LITERAL", "STRING", "STRING") do;FI"var.breakable;Fi[[	@«iI"        def function(var)
          var = self.class.name.split("STRING").last
          var.group("LITERAL", "STRING", "STRING") do
            var.breakable
            var = inspect_attributes.map { |var| [var, send(var)] if respond_to?(var) }.compact.find_all do |var|;Fi[	@«i#I"             var.seplist(var) do |var|
              if ["LITERAL", "LITERAL"].include?(var.first) then
                var.group("LITERAL", "STRING", "STRING") do
                  var.breakable
                  var.seplist(var.last) { |var| var.pp(var) };Fi[	@baI"cvar = (var.map { |var, var| [["STRING", var].compact.join("STRING"), var] } + var.map do |var|;Fi[[	@'i3I"b        # +ns+ is a hash of namespace prefix:urls associated with the element
        def function(var, var, var, var, var)
          var = [var, var].compact.join("STRING")
          var = (var.map { |var, var| [["STRING", var].compact.join("STRING"), var] } + var.map do |var|
            [[var.prefix, var.localname].compact.join("STRING"), var.value];Fi[	@Mi1I"      
      def function(var, var, var, var, var)
        var = [var, var].compact.join("STRING")
        var = (var.map { |var, var| [["STRING", var].compact.join("STRING"), var] } + var.map do |var|
          [[var.prefix, var.localname].compact.join("STRING"), var.value];Fi[	@SrI"D[[var.prefix, var.localname].compact.join("STRING"), var.value];Fi[[	@'i4I"#        def function(var, var, var, var, var)
          var = [var, var].compact.join("STRING")
          var = (var.map { |var, var| [["STRING", var].compact.join("STRING"), var] } + var.map do |var|
            [[var.prefix, var.localname].compact.join("STRING"), var.value]
          end);Fi[	@Mi2I"!      def function(var, var, var, var, var)
        var = [var, var].compact.join("STRING")
        var = (var.map { |var, var| [["STRING", var].compact.join("STRING"), var] } + var.map do |var|
          [[var.prefix, var.localname].compact.join("STRING"), var.value]
        end.flatten);Fi[	@ÿm@Hi[[	@˝i.I"û        # Create a new Parser with +doc+ and +encoding+
        def function(var, var)
          check_encoding(var)
          @var = var
          @var = var;Fi[	@˝iBI"¢        # Parse given +io+
        def function(var, var)
          check_encoding(var)
          @var = var
          var = ParserContext.io(var, ENCODINGS[var]);Fi[	I"require("hashie/mash");F@Ω@i[[	@÷-i I"Krequire("hashie/mash")
module OmniAuth
  class AuthHash < Hashie::Mash;Fi [	@€iI"frequire("omniauth")
require("hashie/mash")
module OmniAuth
  class NoSessionError < StandardError;Fi[	@£I"var.visit(self);Fi[[	I"Oprojects//compass_proj/compass/sass_extensions/monkey_patches/traversal.rb;Ti	I"∏    class Node
      unless method_defined?("LITERAL") then
        def function(var)
          var.visit(self)
          var.down(self) if children.any? and var.respond_to?("LITERAL");Fi[	@ÿiåI"ê      ###
      # Accept a visitor.  This method calls "visit" on +visitor+ with self.
      def function(var)
        var.visit(self)
      end;Fi[	@c@;i[[	@/i!I"\    
    def function
      return "STRING" unless env["STRING"]
      "STRING"
    end;Fi[	@/i&I"\    
    def function
      return "STRING" unless env["STRING"]
      "STRING"
    end;Fi[	@£I"*if var.is_a?(Sass::Script::List) then;Fi[[	@1i0I"˘  # This can be used to unpack a space separated list that got turned
  # into a string by sass before it was passed to a mixin.
  def function(var)
    if var.is_a?(Sass::Script::List) then
      Sass::Script::List.new(var.value.dup, var.separator);Fi[	@1i:I"  # If the argument is a list, it will return a new list that is space delimited
  # Otherwise it returns a new, single element, space-delimited list.
  def function(var)
    if var.is_a?(Sass::Script::List) then
      Sass::Script::List.new(var.value.dup, "LITERAL");Fi[	@ÀmI"input_field("STRING", var);Fi[[	@.i&I"l    
    def function(var, var)
      label_field(var, var)
      input_field("STRING", var)
      self;Fi[	@.i,I"l    
    def function(var, var)
      label_field(var, var)
      input_field("STRING", var)
      self;Fi[	@Ér@g7i[[	@.i'I"o    def function(var, var)
      label_field(var, var)
      input_field("STRING", var)
      self
    end;Fi[	@.i-I"o    def function(var, var)
      label_field(var, var)
      input_field("STRING", var)
      self
    end;Fi[	@£@ïci[[	@Ài7I"¥      (var.value.size == "LITERAL") ? (var.value.first) : (var)
    end
    def function(var)
      if var.is_a?(Sass::Script::String) then
        var = var.value =~ "LITERAL".!.!;Fi[	@1iXI"∫  
  # returns the first value of a space delimited list.
  def function(var)
    if var.is_a?(Sass::Script::String) then
      Sass::Script::String.new(var.value.split("LITERAL").first);Fi[	@:H@i[[	@€i(I"s      #
      #   class MyStrategy
      #     include OmniAuth::Strategy
      #
      #     configure do |c|;Fi[	@€iDI"u      #
      #   class MyStrategy
      #     include OmniAuth::Strategy
      #
      #     option :foo, 'bar';Fi[	@o?I"log("LITERAL", "STRING");Fi[[	@€i•I"µ    # Performs the steps necessary to run the request phase of a strategy.
    def function
      setup_phase
      log("LITERAL", "STRING")
      session["STRING"] = request.params;Fi[	@€iæI"Ω    # Performs the steps necessary to run the callback phase of a strategy.
    def function
      setup_phase
      log("LITERAL", "STRING")
      @env["STRING"] = session.delete("STRING");Fi[	I".@env["STRING"] = session.delete("STRING");FI"8@env["STRING"] = nil if (env["STRING"] == "STRING");Fi[[	@€i¿I"“      setup_phase
      log("LITERAL", "STRING")
      @env["STRING"] = session.delete("STRING")
      @env["STRING"] = nil if (env["STRING"] == "STRING")
      @env["STRING"] = (session.delete("STRING") or {});Fi[	@€iI"÷        @env["STRING"] = var
        @env["STRING"] = (session.delete("STRING") or {})
        @env["STRING"] = session.delete("STRING")
        @env["STRING"] = nil if (env["STRING"] == "STRING")
        call_app!;Fi[	@£@g#i[[	@j#i6I"¬  # returns an IE hex string for a color with an alpha channel
  # suitable for passing to IE filters.
  def function(var)
    assert_type(var, "LITERAL")
    var = (var.alpha * "LITERAL").round;Fi[	@¶i"I"j    end
    
    def function(var)
      assert_type(var, "LITERAL")
      var = normalize_stops(var);Fi[	@1I"module Interpolations;Fi[[	@≈3i I"Cmodule Paperclip
  module Interpolations
    class PluralCache;Fi [	@Íi I">module Paperclip
  module Interpolations
    extend(self);Fi [	@£I"/var, var = var.split("LITERAL", "LITERAL");Fi[[	@
iYI"o    end
    
    def function(var)
      var, var = var.split("LITERAL", "LITERAL")
      var ||= "STRING";Fi[	@
ibI"n    end
    
    def function(var)
      var, var = var.split("LITERAL", "LITERAL")
      var = self[var];Fi[	@£I"self.args = var;Fi[[	@

iI"Z    attr_accessor("LITERAL")
    
    def function(var)
      self.args = var
    end;Fi[	@
iI"{    attr_accessor("LITERAL", "LITERAL", "LITERAL")
    
    def function(var)
      self.args = var
      self.options = {};Fi[	I"# Options include:;F@i[[	@iI"√    # +options+ is the same as the hash passed to +has_attached_file+.
    #
    # Options include:
    #
    # +url+ - a relative URL of the attachment. This is interpolated using +interpolator+;Fi[	@b
iI"≈    # set, the options will be appended to the convert command upon image conversion
    #
    # Options include:
    #
    #   +geometry+ - the desired width and height of the thumbnail (required);Fi[	I"7if @options["LITERAL"].respond_to?("LITERAL") then;F@KHi[[	@i4I"Ä    
    def function
      if @options["LITERAL"].respond_to?("LITERAL") then
        @options["LITERAL"].call(self)
      else;Fi[	@	i}I"è      
      def function(var)
        if @options["LITERAL"].respond_to?("LITERAL") then
          @options["LITERAL"].call(self)
        else;Fi[	@£@Ÿbi[[	@»i I"u        end
        
        def function(var)
          inherited_reader(*var)
          inherited_writer(*var);Fi[	@»iOI"u        end
        
        def function(var)
          inherited_reader(*var)
          inherited_writer(*var);Fi[	@∆pI";var = var.call(instance) if var.respond_to?("LITERAL");Fi[[	@i[I"ß    
    def function(var)
      var = @options["LITERAL"]["LITERAL"]
      var = var.call(instance) if var.respond_to?("LITERAL")
      var = @options["LITERAL"][var];Fi[	@icI"ß    
    def function(var)
      var = @options["LITERAL"]["LITERAL"]
      var = var.call(instance) if var.respond_to?("LITERAL")
      var = @options["LITERAL"][var];Fi[	@⁄rI"#var = @options["LITERAL"][var];Fi[[	@i\I"ﬂ    def function(var)
      var = @options["LITERAL"]["LITERAL"]
      var = var.call(instance) if var.respond_to?("LITERAL")
      var = @options["LITERAL"][var]
      var = var.call(instance) if var.respond_to?("LITERAL");Fi[	@idI"ﬂ    def function(var)
      var = @options["LITERAL"]["LITERAL"]
      var = var.call(instance) if var.respond_to?("LITERAL")
      var = @options["LITERAL"][var]
      var = var.call(instance) if var.respond_to?("LITERAL");Fi[	@·r@⁄ri[[	@i]I"Ò      var = @options["LITERAL"]["LITERAL"]
      var = var.call(instance) if var.respond_to?("LITERAL")
      var = @options["LITERAL"][var]
      var = var.call(instance) if var.respond_to?("LITERAL")
      [var, var].compact.join("STRING");Fi[	@ieI"Ò      var = @options["LITERAL"]["LITERAL"]
      var = var.call(instance) if var.respond_to?("LITERAL")
      var = @options["LITERAL"][var]
      var = var.call(instance) if var.respond_to?("LITERAL")
      [var, var].compact.join("STRING");Fi[	@£I"#var = /^#{Regexp.escape(var)}/;Fi[[	@É$iI"Ñ    end
    
    def function(var)
      var = /^#{Regexp.escape(var)}/
      var = @commands.keys.select { |var| var.to_s.=~(var) };Fi[	@É$i$I"~    end
    
    def function(var)
      var = /^#{Regexp.escape(var)}/
      @commands.keys.detect { |var| var.to_s.=~(var) };Fi[	I" require("paperclip/schema");F@1i[[	@¬-iI"~require("paperclip/callbacks")
require("paperclip/validators")
require("paperclip/schema")
module Paperclip
  module Glue;Fi[	I"2projects//paperclip_proj/paperclip/railtie.rb;TiI"Yrequire("paperclip")
require("paperclip/schema")
module Paperclip
  require("rails");Fi[	@£I"@var ||= Hash.new;Fi[[	@É$i)I"    end
    
    def function(var)
      @var ||= Hash.new
      var and (@commands.has_key?(var.to_sym) or abbreviation?(var));Fi[	@i~I"á      
      # Get the list of decorators given +key+
      def function(var)
        @var ||= Hash.new
        @decorators[var] ||= [];Fi[	@±p@g7i[[	@JiI"_        
        def function(var)
          @var = var.flatten
          self
        end;Fi[	@Ji"I"_        
        def function(var)
          @var = var.flatten
          self
        end;Fi[	I"3# See Paperclip.run for the available options.;F@Hi[[	@iI"»    
    # The convert method runs the convert binary with the provided arguments.
    # See Paperclip.run for the available options.
    def function(var, var)
      Paperclip.run("STRING", var, var);Fi[	@iI"     
    # The identify method runs the identify binary with the provided arguments.
    # See Paperclip.run for the available options.
    def function(var, var)
      Paperclip.run("STRING", var, var);Fi[	@£@`i[[	@ü
iGI"§      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(var)
        var, var = case var
        when "LITERAL" then;Fi[	@¢
iÅI"§      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(var)
        var, var = case var
        when "LITERAL" then;Fi[	@ab@ø	i[[	@^i%I"z      #:nodoc:
      def function
        @queued_for_delete.each do |var|
          begin
            (log("STRING");Fi[	@ci‹I"z      #:nodoc:
      def function
        @queued_for_delete.each do |var|
          begin
            (log("STRING");Fi[	I"m@options["LITERAL"] = @options["LITERAL"].gsub("LITERAL", @options["LITERAL"]).gsub("LITERAL", "STRING");FI"#@options["LITERAL"] = "STRING";Fi[[	@	iI"
        var.instance_eval do
          unless @options["LITERAL"].to_s.match("LITERAL") then
            @options["LITERAL"] = @options["LITERAL"].gsub("LITERAL", @options["LITERAL"]).gsub("LITERAL", "STRING")
            @options["LITERAL"] = "STRING"
          end;Fi[	@ci1I"c          @var = @options["LITERAL"].to_s.upcase if @s3_server_side_encryption
          unless (@options["LITERAL"].to_s.match("LITERAL") or (@options["LITERAL"] == "STRING")) then
            @options["LITERAL"] = @options["LITERAL"].gsub("LITERAL", @options["LITERAL"]).gsub("LITERAL", "STRING")
            @options["LITERAL"] = "STRING"
          end;Fi[	I"
retry;F@Æi[[	@	iCI"p            var = true
            directory.save
            retry
          ensure
            var.rewind;Fi[	@ci—I"â          rescue AWS::S3::Errors::NoSuchBucket => var
            create_bucket
            retry
          ensure
            var.rewind;Fi[	I"/var = find_credentials(var).stringify_keys;FI"Avar = Object.const_defined?("LITERAL") ? (Rails.env) : (nil);Fi[[	@	imI"ø      
      def function(var)
        var = find_credentials(var).stringify_keys
        var = Object.const_defined?("LITERAL") ? (Rails.env) : (nil)
        (var[var] or var).symbolize_keys;Fi[	@ciüI"˚      def function(var)
        var = var.respond_to?("STRING") ? (var.call(self)) : (var)
        var = find_credentials(var).stringify_keys
        var = Object.const_defined?("LITERAL") ? (Rails.env) : (nil)
        (var[var] or var).symbolize_keys;Fi[	@!]I"3YAML.load(ERB.new(File.read(var.path)).result);Fi[[	@	iíI"õ      def function(var)
        case var
        when File then
          YAML.load(ERB.new(File.read(var.path)).result)
        when String, Pathname then;Fi[	@ci¯I"õ      def function(var)
        case var
        when File then
          YAML.load(ERB.new(File.read(var.path)).result)
        when String, Pathname then;Fi[	@4sI"when String, Pathname then;Fi[[	@	iìI"∑        case var
        when File then
          YAML.load(ERB.new(File.read(var.path)).result)
        when String, Pathname then
          YAML.load(ERB.new(File.read(var)).result);Fi[	@ci˘I"∑        case var
        when File then
          YAML.load(ERB.new(File.read(var.path)).result)
        when String, Pathname then
          YAML.load(ERB.new(File.read(var)).result);Fi[	@;sI".YAML.load(ERB.new(File.read(var)).result);Fi[[	@	iîI"Ω        when File then
          YAML.load(ERB.new(File.read(var.path)).result)
        when String, Pathname then
          YAML.load(ERB.new(File.read(var)).result)
        when Hash then;Fi[	@ci˙I"Ω        when File then
          YAML.load(ERB.new(File.read(var.path)).result)
        when String, Pathname then
          YAML.load(ERB.new(File.read(var)).result)
        when Hash then;Fi[	@Bs@∞0i[[	@	iïI"¥          YAML.load(ERB.new(File.read(var.path)).result)
        when String, Pathname then
          YAML.load(ERB.new(File.read(var)).result)
        when Hash then
          var;Fi[	@ci˚I"¥          YAML.load(ERB.new(File.read(var.path)).result)
        when String, Pathname then
          YAML.load(ERB.new(File.read(var)).result)
        when Hash then
          var;Fi[	I"?var = (@s3_permissions[var] or @s3_permissions["LITERAL"]);FI"<var = var.call(self, var) if var.respond_to?("LITERAL");Fi[[	@ci≠I"≠      
      def function(var)
        var = (@s3_permissions[var] or @s3_permissions["LITERAL"])
        var = var.call(self, var) if var.respond_to?("LITERAL")
        var;Fi[	@ci¡I"ˇ          begin
            (log("STRING")
            var = (@s3_permissions[var] or @s3_permissions["LITERAL"])
            var = var.call(self, var) if var.respond_to?("LITERAL")
            var = { "LITERAL" => (var.content_type), "LITERAL" => (var) };Fi[	I"3# if a proc has been supplied, we call it here;F@:i[[	@i'I"     # There is an important change of interface here: a style rule can set its own processors
    # by default we behave as before, though.
    # if a proc has been supplied, we call it here
    def function
      if @processors.respond_to?("LITERAL") then;Fi[	@iKI"®    
    # returns the geometry string for this style
    # if a proc has been supplied, we call it here
    def function
      if @geometry.respond_to?("LITERAL") then;Fi[	I"+rescue Cocaine::ExitStatusError => var;FI"0raise(Paperclip::Error, "STRING") if @whiny;Fi[[	@b
iMI"9        var = var.flatten.compact.join("STRING").strip.squeeze("STRING")
        var = convert(var, "LITERAL" => "STRING", "LITERAL" => (File.expand_path(var.path))))
      rescue Cocaine::ExitStatusError => var
        raise(Paperclip::Error, "STRING") if @whiny
      rescue Cocaine::CommandNotFoundError => var;Fi[	@b
ilI"ˇ      begin
        ANIMATED_FORMATS.include?(identify("STRING", "LITERAL" => "STRING").to_s.downcase.strip)
      rescue Cocaine::ExitStatusError => var
        raise(Paperclip::Error, "STRING") if @whiny
      rescue Cocaine::CommandNotFoundError => var;Fi[	@_sI"0rescue Cocaine::CommandNotFoundError => var;Fi[[	@b
iNI"5        var = convert(var, "LITERAL" => "STRING", "LITERAL" => (File.expand_path(var.path))))
      rescue Cocaine::ExitStatusError => var
        raise(Paperclip::Error, "STRING") if @whiny
      rescue Cocaine::CommandNotFoundError => var
        raise(Paperclip::Errors::CommandNotFoundError.new("STRING"));Fi[	@b
imI"8        ANIMATED_FORMATS.include?(identify("STRING", "LITERAL" => "STRING").to_s.downcase.strip)
      rescue Cocaine::ExitStatusError => var
        raise(Paperclip::Error, "STRING") if @whiny
      rescue Cocaine::CommandNotFoundError => var
        raise(Paperclip::Errors::CommandNotFoundError.new("STRING"));Fi[	I"K# * +if+: A lambda or name of an instance method. Validation will only;FI"6#   be run if this lambda or method returns true.;Fi[[	@–<iI"0      # Places ActiveRecord-style validations on the presence of a file.
      # Options:
      # * +if+: A lambda or name of an instance method. Validation will only
      #   be run if this lambda or method returns true.
      # * +unless+: Same as +if+ but validates if lambda or method returns false.;Fi[	@EiWI"w      # * +greater_than+: equivalent to :in => options[:greater_than]..Infinity
      # * +message+: error message to display, use :min and :max as replacements
      # * +if+: A lambda or name of an instance method. Validation will only
      #   be run if this lambda or method returns true.
      # * +unless+: Same as +if+ but validates if lambda or method returns false.;Fi[	I"P# * +unless+: Same as +if+ but validates if lambda or method returns false.;F@£i[[	@–<iI":      # * +if+: A lambda or name of an instance method. Validation will only
      #   be run if this lambda or method returns true.
      # * +unless+: Same as +if+ but validates if lambda or method returns false.
      def function(var)
        validates_with(AttachmentPresenceValidator, _merge_attributes(var));Fi[	@EiYI"6      # * +if+: A lambda or name of an instance method. Validation will only
      #   be run if this lambda or method returns true.
      # * +unless+: Same as +if+ but validates if lambda or method returns false.
      def function(var)
        validates_with(AttachmentSizeValidator, _merge_attributes(var));Fi[	@ns@usi[[	@–<iI"ˇ      # Options:
      # * +if+: A lambda or name of an instance method. Validation will only
      #   be run if this lambda or method returns true.
      # * +unless+: Same as +if+ but validates if lambda or method returns false.
      def function(var);Fi[	@EiXI"?      # * +message+: error message to display, use :min and :max as replacements
      # * +if+: A lambda or name of an instance method. Validation will only
      #   be run if this lambda or method returns true.
      # * +unless+: Same as +if+ but validates if lambda or method returns false.
      def function(var);Fi[	@™pI"6var = var.call(var) if var.respond_to?("LITERAL");Fi[[	@EiBI"≈      
      def function(var)
        var = (options["LITERAL"] or options["LITERAL"])
        var = var.call(var) if var.respond_to?("LITERAL")
        var = var.min if var.respond_to?("LITERAL");Fi[	@EiII"≈      
      def function(var)
        var = (options["LITERAL"] or options["LITERAL"])
        var = var.call(var) if var.respond_to?("LITERAL")
        var = var.max if var.respond_to?("LITERAL");Fi[	@£I""var = configuration["STRING"];Fi[[	@	?i!I"x      end
      
      def function(var)
        var = configuration["STRING"]
        `sqlite3 #{var}STRING#{var}`;Fi[	@	?i&I"~      end
      
      def function(var)
        var = configuration["STRING"]
        `sqlite3 #{var}STRING#{var}STRING`;Fi[	I")require("resque/failure/thoughtbot");F@Ö*i[[	@â*i
I"^  raise("STRING")
end
require("resque/failure/thoughtbot")
module Resque
  module Failure;Fi[	@é*i
I"^  raise("STRING")
end
require("resque/failure/thoughtbot")
module Resque
  module Failure;Fi[	I"rescue Object => var;F@Zbi[[	@]i£I"É        var.perform
        run_hook("LITERAL", var))
      rescue Object => var
        Resque.logger.info("STRING")
        begin;Fi[	@]ißI"z        begin
          var.fail(var)
        rescue Object => var
          Resque.logger.info("STRING")
        end;Fi[	I"require("redis");FI"require("redis-namespace");Fi[[	@^%i I"Brequire("redis")
require("redis-namespace")
require("thread");Fi [	@i I"Brequire("redis")
require("redis-namespace")
require("thread");Fi [	@üs@Ti[[	@^%iI"Urequire("redis")
require("redis-namespace")
require("thread")
require("mutex_m");Fi[	@iI"Urequire("redis")
require("redis-namespace")
require("thread")
require("mutex_m");Fi[	@T@Ö*i[[	@^%iI"erequire("redis-namespace")
require("thread")
require("mutex_m")
module Resque
  class MultiQueue;Fi[	@iI"xrequire("redis-namespace")
require("thread")
require("mutex_m")
module Resque
  class QueueDestroyed < RuntimeError;Fi[	I"P# Pass +true+ for a non-blocking pop.  If nothing is read on a non-blocking;FI"$# pop, a ThreadError is raised.;Fi[[	@^%iI"‹    # is available. This method returns a tuple of the queue object and job.
    #
    # Pass +true+ for a non-blocking pop.  If nothing is read on a non-blocking
    # pop, a ThreadError is raised.
    def function(var);Fi[	@iAI"†    # available.
    #
    # Pass +true+ for a non-blocking pop.  If nothing is read on a non-blocking
    # pop, a ThreadError is raised.
    def function(var);Fi[	@≥s@£i[[	@^%iI"°    #
    # Pass +true+ for a non-blocking pop.  If nothing is read on a non-blocking
    # pop, a ThreadError is raised.
    def function(var)
      if var then;Fi[	@iBI"°    #
    # Pass +true+ for a non-blocking pop.  If nothing is read on a non-blocking
    # pop, a ThreadError is raised.
    def function(var)
      if var then;Fi[	I"/var = @queues.map { |var| var.redis_name };FI"if var.any? then;Fi[[	@^%i.I"{        end
      else
        var = @queues.map { |var| var.redis_name }
        if var.any? then
          synchronize do;Fi[	@^%iCI"®    # the timeout expires.
    def function(var)
      var = @queues.map { |var| var.redis_name }
      if var.any? then
        var, var = @redis.blpop(*(var + [var]));Fi[	@£I"set_psql_env;Fi[[	@Œi.I"h      end
      
      def function(var)
        set_psql_env
        var = configuration["STRING"];Fi[	@Œi9I"b      end
      
      def function(var)
        set_psql_env
        Kernel.system("STRING");Fi[	I"'alias_method("LITERAL", "LITERAL");F@:i[[	@ˆ
iI"≈    helpers do
      include(Rack::Utils)
      alias_method("LITERAL", "LITERAL")
      def function
        url_path(request.path_info.sub("STRING", "STRING").split("STRING")["LITERAL"].downcase);Fi[	@ˆ
i$I"ü        [path_prefix, var].join("STRING").squeeze("STRING")
      end
      alias_method("LITERAL", "LITERAL")
      def function
        request.env["STRING"];Fi[	I" case Resque.redis.type(var);F@îi[[	@ˆ
i4I"r      end
      def function(var)
        case Resque.redis.type(var)
        when "STRING" then
          [];Fi[	@ˆ
iFI"w      end
      def function(var, var)
        case Resque.redis.type(var)
        when "STRING" then
          [];Fi[	@A*@|i[[	@`iÛI"ê    var = queue(var).slice(var, var)
    if var.nil? then
      []
    else
      var.respond_to?("LITERAL") ? ((var.to_ary or [var])) : ([var]);Fi[	@$iwI"≤    def function
      @var ||= if empty? then
        []
      else
        machine.events.transitions_for(object, "LITERAL" => (to_name), "LITERAL" => (@guard)).select do |var|;Fi[	@A*@îi[[	@ˆ
i6I"á        case Resque.redis.type(var)
        when "STRING" then
          []
        when "STRING" then
          Resque.redis.llen(var);Fi[	@ˆ
iHI"°        case Resque.redis.type(var)
        when "STRING" then
          []
        when "STRING" then
          Resque.redis.lrange(var, var, (var + "LITERAL"));Fi[	I"namespace("LITERAL") do;F@-<i[[	@4<i I"Bnamespace("LITERAL") do
  desc("STRING")
  task("LITERAL") do;Fi [	@7<iI"É  _cset("LITERAL") { "STRING" }
  _cset("LITERAL") { "STRING" }
  namespace("LITERAL") do
    desc("STRING")
    task("LITERAL") do;Fi[	@£@ô\i[[	@`i;I"Å      end
      
      def function(var)
        var = prepare_command_options("STRING")
        var.concat(["STRING", "STRING"]);Fi[	@`iCI"Å      end
      
      def function(var)
        var = prepare_command_options("STRING")
        var.concat(["STRING", "STRING"]);Fi[	@Zb@˜%i[[	@]i&I"e    # current job.
    def function
      Resque.logger.info("STRING")
      @var = true
    end;Fi[	@]i_I"p    # currently running one).
    def function
      Resque.logger.info("STRING")
      @var = true
    end;Fi[	@£I"var, *var = var;Fi[[	@∏ivI"
      # sanitized and interpolated into the SQL statement.
      #   ["name='%s' and group_id='%s'", "foo'bar", 4]  returns  "name='foo''bar' and group_id='4'"
      def function(var)
        var, *var = var
        if var.first.is_a?(Hash) and var =~ "LITERAL" then;Fi[	@¨9iI"?  end
  
  def function(var)
    var, *var = var
    begin;Fi[	@£I"var = var.to_s.downcase;Fi[[	@ziI"a  include(Comparable)
  
  def function(var)
    var = var.to_s.downcase
    @var = case var;Fi[	@ˆ
i+I"°        "STRING" if [current_section, current_subtab].include?(var)
      end
      def function(var)
        var = var.to_s.downcase
        var = url_path(var);Fi[	@£I"var = reflections[var];Fi[[	@8i&I"ƒ      #   Account.reflect_on_aggregation(:balance) # => the balance AggregateReflection
      #
      def function(var)
        var = reflections[var]
        var if var.is_a?(AggregateReflection);Fi[	@8i?I"ø      #   Invoice.reflect_on_association(:line_items).macro  # returns :has_many
      #
      def function(var)
        var = reflections[var]
        var if var.is_a?(AssociationReflection);Fi[	@£@bZi[[	@1i”I"‹    # record, all wrapped in a transaction. If the object is invalid, the saving
    # will fail and false will be returned.
    def function(var)
      with_transaction_returning_status do
        assign_attributes(var);Fi[	@1iﬁI"Û    # Updates its receiver just like +update+ but calls <tt>save!</tt> instead
    # of +save+, so an exception is raised if the record is invalid.
    def function(var)
      with_transaction_returning_status do
        assign_attributes(var);Fi[	I"var.worker = self;FI"working_on(var);Fi[[	@]ioI"´          if var = reserve(var) then
            Resque.logger.info("STRING")
            var.worker = self
            working_on(var)
            if (@var = fork(var) do;Fi[	@]iîI"o          return
        end
        var.worker = self
        working_on(var)
        perform(var, &var));Fi[	I"procline("STRING");FI"reconnect;Fi[[	@]isI"¶            if (@var = fork(var) do
              unregister_signal_handlers
              procline("STRING")
              reconnect
              perform(var, &var);Fi[	@]i{I"©              var.fail(DirtyExit.new($?.to_s)) if $?.signaled?
            else
              procline("STRING")
              reconnect
              perform(var, &var);Fi[	@ tI"perform(var, &var);Fi[[	@]itI"ò              unregister_signal_handlers
              procline("STRING")
              reconnect
              perform(var, &var)
            end) then;Fi[	@]i|I"            else
              procline("STRING")
              reconnect
              perform(var, &var)
            end;Fi[	I""Resque.logger.debug("STRING");FI"#Process.kill("STRING", @child);Fi[[	@]i;I"Œ            Resque.logger.debug("STRING")
          else
            Resque.logger.debug("STRING")
            Process.kill("STRING", @child)
            (term_timeout.to_f * "LITERAL").round.times do |var|;Fi[	@]iAI"¥              return if Process.waitpid(@child, Process::WNOHANG)
            end
            Resque.logger.debug("STRING")
            Process.kill("STRING", @child)
          end;Fi[	@Sb@Sbi[[	@]iÆI"w    # Tell Redis we've processed a job.
    def function
      (Stat << "STRING")
      (Stat << "STRING")
    end;Fi[	@]iπI"u    # Tells Redis we've failed a job.
    def function
      (Stat << "STRING")
      (Stat << "STRING")
    end;Fi[	@£I"var = var.new;Fi[[	@1i©I"    # Note: The new instance will share a link to the same attributes as the original class.
    # So any change to the attributes in either instance will affect the other.
    def function(var)
      var = var.new
      var.instance_variable_set("STRING", @attributes);Fi[	@J
iƒI"T  end
  
  def function(var)
    var = var.new
    self.open("STRING") do |var|;Fi[	@•H@:i[[	@]i˝I"¡    
    # Returns an Array of string pids of all the other workers on this
    # machine. Useful when pruning dead workers on startup.
    def function
      if RUBY_PLATFORM =~ "LITERAL" then;Fi[	@]i	I"Ï    #
    # Returns an Array of string pids of all the other workers on this
    # machine. Useful when pruning dead workers on startup.
    def function
      `tasklist  /FI \"IMAGENAME eq ruby.exe\" /FO list`.split($/).select do |var|;Fi[	@£I"0@var = [] unless defined? @uses_transaction;Fi[[	@[ivI"ô      end
      
      def function(var)
        @var = [] unless defined? @uses_transaction
        @uses_transaction.concat(var.map { |var| var.to_s });Fi[	@[i{I"â      end
      
      def function(var)
        @var = [] unless defined? @uses_transaction
        @uses_transaction.include?(var.to_s);Fi[	@£I"var.map do |var|;Fi[[	@ãiÒI"œ    # This should be called before "matches?" and other checking methods since they
    # rely on the actions to be expanded.
    def function(var)
      var.map do |var|
        if aliased_actions[var] then;Fi[	@îiûI"o      
      # helper functions
      def function(var)
        var.map do |var|
          next unless var;Fi[	I"G# It assumes the class you're passing it is a real Ruby class (not;FI"+# a string or reference) which either:;Fi[[	@`iI"∑  #
  # This method can be used to conveniently add a job to a queue.
  # It assumes the class you're passing it is a real Ruby class (not
  # a string or reference) which either:
  #;Fi[	@`i?I"ª  
  # This method can be used to conveniently remove a job from a queue.
  # It assumes the class you're passing it is a real Ruby class (not
  # a string or reference) which either:
  #;Fi[	@Xt@i[[	@`iI"“  # This method can be used to conveniently add a job to a queue.
  # It assumes the class you're passing it is a real Ruby class (not
  # a string or reference) which either:
  #
  #   a) has a @queue ivar set;Fi[	@`i@I"◊  # This method can be used to conveniently remove a job from a queue.
  # It assumes the class you're passing it is a real Ruby class (not
  # a string or reference) which either:
  #
  #   a) has a @queue ivar set;Fi[	I"!#   a) has a @queue ivar set;FI"#   b) responds to `queue`;Fi[[	@`iI"q  # a string or reference) which either:
  #
  #   a) has a @queue ivar set
  #   b) responds to `queue`
  #;Fi[	@`iBI"q  # a string or reference) which either:
  #
  #   a) has a @queue ivar set
  #   b) responds to `queue`
  #;Fi[	@ft@i[[	@`iI"ç  #
  #   a) has a @queue ivar set
  #   b) responds to `queue`
  #
  # If either of those conditions are met, it will use the value obtained;Fi[	@`iCI"ç  #
  #   a) has a @queue ivar set
  #   b) responds to `queue`
  #
  # If either of those conditions are met, it will use the value obtained;Fi[	I"L# If either of those conditions are met, it will use the value obtained;FI"J# from performing one of the above operations to determine the queue.;Fi[[	@`iI"∂  #   b) responds to `queue`
  #
  # If either of those conditions are met, it will use the value obtained
  # from performing one of the above operations to determine the queue.
  #;Fi[	@`iEI"∂  #   b) responds to `queue`
  #
  # If either of those conditions are met, it will use the value obtained
  # from performing one of the above operations to determine the queue.
  #;Fi[	@tt@i[[	@`i I"È  #
  # If either of those conditions are met, it will use the value obtained
  # from performing one of the above operations to determine the queue.
  #
  # If no queue can be inferred this method will raise a `Resque::NoQueueError`;Fi[	@`iFI"È  #
  # If either of those conditions are met, it will use the value obtained
  # from performing one of the above operations to determine the queue.
  #
  # If no queue can be inferred this method will raise a `Resque::NoQueueError`;Fi[	@£I"var = URI.parse(var);Fi[[	@pi=I"m        end
        
        def function(var)
          var = URI.parse(var)
          var = var.scheme;Fi[	@“i!I"w  # @param person [Person]
  # @param url [String]
  def function(var)
    var = URI.parse(var)
    var = "STRING";Fi[	I"K# Returns true if the job was queued, nil if the job was rejected by a;FI"# before_enqueue hook.;Fi[[	@`i$I"π  # If no queue can be inferred this method will raise a `Resque::NoQueueError`
  #
  # Returns true if the job was queued, nil if the job was rejected by a
  # before_enqueue hook.
  #;Fi[	@`i1I"Æ  # `queue` should be the String name of the queue you're targeting.
  #
  # Returns true if the job was queued, nil if the job was rejected by a
  # before_enqueue hook.
  #;Fi[	@ât@i[[	@`i%I"°  #
  # Returns true if the job was queued, nil if the job was rejected by a
  # before_enqueue hook.
  #
  # This method is considered part of the `stable` API.;Fi[	@`i2I"°  #
  # Returns true if the job was queued, nil if the job was rejected by a
  # before_enqueue hook.
  #
  # This method is considered part of the `stable` API.;Fi[	@$?@Hi[[	@`i'I"û  # before_enqueue hook.
  #
  # This method is considered part of the `stable` API.
  def function(var, var)
    enqueue_to(queue_from_class(var), var, *var);Fi[	@`iXI"Î  #   Resque.dequeue(GitHub::Jobs::UpdateNetworkGraph, 'repo:135325')
  #
  # This method is considered part of the `stable` API.
  def function(var, var)
    var = Plugin.before_dequeue_hooks(var).collect { |var| var.send(var, *var) };Fi[	@£I"var = var.symbolize_keys;Fi[[	@pi1I"õ        end
        
        def function(var)
          var = var.symbolize_keys
          raise(AdapterNotSpecified, "STRING") unless var.key?("LITERAL");Fi[	@Ã	iI"ƒ  module ConnectionHandling
    # Establishes a connection to the database that's used by all Active Record objects.
    def function(var)
      var = var.symbolize_keys
      var = var["LITERAL"];Fi[	@£@GJi[[	@UixI"      end
      
      def function(var)
        return false unless var
        return true if tables(nil, nil, var).any?;Fi[	@ÿiíI"≠      ###
      # Test to see if this Node is equal to +other+
      def function(var)
        return false unless var
        return false unless var.respond_to?("LITERAL");Fi[	@£@ˆKi[[	@S!iI"†        
        # Extracts the value from the node as either a string or symbol
        def function(var)
          case var.type
          when "LITERAL" then;Fi[	@˚
iI"Ø        
        # Extracts the statement requirement from the given node
        def function(var)
          case var.type
          when "LITERAL", "LITERAL", "LITERAL" then;Fi[	@£I"(var = retrieve_connection_pool(var);Fi[[	@giôI"      # opened and set as the active connection for the class it was defined
      # for (not necessarily the current class).
      def function(var)
        var = retrieve_connection_pool(var)
        ((var and var.connection) or raise(ConnectionNotEstablished));Fi[	@gi†I"»      # Returns true if a connection that's accessible to this class has
      # already been opened.
      def function(var)
        var = retrieve_connection_pool(var)
        var and var.connected?;Fi[	I"R# configured for this branch.  In addition to matching the event, from state,;FI"L# and to state, this will also check whether the configured :if/:unless;Fi[[	@i8I"    
    # Determines whether the given object / query matches the requirements
    # configured for this branch.  In addition to matching the event, from state,
    # and to state, this will also check whether the configured :if/:unless
    # conditions pass on the given object.;Fi[	@iSI"    
    # Attempts to match the given object / query against the set of requirements
    # configured for this branch.  In addition to matching the event, from state,
    # and to state, this will also check whether the configured :if/:unless
    # conditions pass on the given object.;Fi[	@∑tI"+# conditions pass on the given object.;Fi[[	@i9I"    # Determines whether the given object / query matches the requirements
    # configured for this branch.  In addition to matching the event, from state,
    # and to state, this will also check whether the configured :if/:unless
    # conditions pass on the given object.
    # ;Fi[	@iTI"     # Attempts to match the given object / query against the set of requirements
    # configured for this branch.  In addition to matching the event, from state,
    # and to state, this will also check whether the configured :if/:unless
    # conditions pass on the given object.
    # ;Fi[	@æt@i[[	@i:I"·    # configured for this branch.  In addition to matching the event, from state,
    # and to state, this will also check whether the configured :if/:unless
    # conditions pass on the given object.
    # 
    # == Examples;Fi[	@iUI"    # configured for this branch.  In addition to matching the event, from state,
    # and to state, this will also check whether the configured :if/:unless
    # conditions pass on the given object.
    # 
    # If a match is found, then the event/state requirements that the query;Fi[	I"N#   branch = StateMachine::Branch.new(:parked => :idling, :on => :ignite);F@i[[	@i>I"Ñ    # == Examples
    # 
    #   branch = StateMachine::Branch.new(:parked => :idling, :on => :ignite)
    #   
    #   # Successful;Fi[	@igI"…    # == Examples
    # 
    #   branch = StateMachine::Branch.new(:parked => :idling, :on => :ignite)
    #   
    #   branch.match(object, :on => :ignite)  # => {:to => ..., :from => ..., :on => ...};Fi[	@£I"var.select do |var|;Fi[[	@¸iFI"·    
    # Filters the primary keys and readonly attributes from the attribute names.
    def function(var)
      var.select do |var|
        column_for_attribute(var) and (pk_attribute?(var).! and readonly_attribute?(var).!);Fi[	@¸iNI"
    # Filters out the primary keys, from the attribute names, when the primary
    # key is to be generated (e.g. the id attribute has no value).
    def function(var)
      var.select do |var|
        column_for_attribute(var) and (pk_attribute?(var) and id.nil?).!;Fi[	@£I"var = read_attribute(var);Fi[[	@¸iŒI"À    #   person.attribute_for_inspect(:created_at)
    #   # => "\"2012-10-22 00:15:07\""
    def function(var)
      var = read_attribute(var)
      if var.is_a?(String) and (var.length > "LITERAL") then;Fi[	@¸iÊI"‰    #   person.attribute_present?(:title)   # => true
    #   person.attribute_present?(:is_done) # => true
    def function(var)
      var = read_attribute(var)
      var.nil?.! and (var.respond_to?("LITERAL") and var.empty?).!;Fi[	I"# transition.;F@i[[	@i{I"∂    # 
    # Each edge will be labeled with the name of the event that would cause the
    # transition.
    # 
    # The collection of edges generated on the graph will be returned.;Fi[	@ıiEI"        # Creates a callback that will be invoked *after* a transition is
        # performed so long as the given configuration options match the
        # transition.
        # 
        # See +before_transition+ for a description of the possible configurations;Fi[	I"*#   person = Person.new('John Smith');F@i[[	@·i"I"ô    #   end
    # 
    #   person = Person.new('John Smith')
    #   
    #   evaluate_method(person, :name)                            # => "John Smith";Fi[	@·i2I"æ    # For example,
    # 
    #   person = Person.new('John Smith')
    #   
    #   evaluate_method(person, lambda {|person| person.name}, 21)                              # => "John Smith";Fi[	@£I";if self.class.serialized_attributes.include?(var) then;Fi[[	@∞isI"î        end
        
        def function(var)
          if self.class.serialized_attributes.include?(var) then
            super.unserialized_value;Fi[	@∞i~I"ù        end
        
        def function(var)
          if self.class.serialized_attributes.include?(var) then
            @attributes[var].serialized_value;Fi[	@hCI"loaded!;Fi[[	@ØioI"f      def function
        delete("LITERAL").tap do
          reset
          loaded!
        end;Fi[	@ØiyI"i      def function
        destroy(load_target).tap do
          reset
          loaded!
        end;Fi[	@‘O@£i[[	@ifI"À    # 
    # See StateMachine::Machine#transition for a description of the possible
    # configurations for defining transitions.
    def function(var)
      raise(ArgumentError, "STRING") if var.empty?;Fi[	@0i+I"Ï    # 
    # See StateMachine::Machine#transition for a description of the possible
    # configurations for defining transitions.
    def function(var)
      assert_valid_keys(var, "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL");Fi[	@£I"%var = var.unpack("STRING").first;Fi[[	@$i6I""        # Making it frozen means that it doesn't get duped when used to
        # key the @attributes_cache in read_attribute.
        def function(var)
          var = var.unpack("STRING").first
          generated_attribute_methods.module_eval("STRING", "STRING", ("LITERAL" + "LITERAL"));Fi[	@ %iI"ˇ        # See define_method_attribute in read.rb for an explanation of
        # this code.
        def function(var)
          var = var.unpack("STRING").first
          generated_attribute_methods.module_eval("STRING", "STRING", ("LITERAL" + "LITERAL"));Fi[	@£I"super.tap do;Fi[[	@Ω%i'I"ß      
      # Attempts to <tt>save!</tt> the record and clears changed attributes if successful.
      def function(var)
        super.tap do
          @var = changes;Fi[	@Ω%i/I"ô      
      # <tt>reload</tt> the record and clears changed attributes.
      def function(var)
        super.tap do
          @previously_changed.clear;Fi[	@$II"M# * <tt>:on</tt> - One or more events that fire the transition.  If none;Fi[[	@ÊiI"L    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:on</tt> - One or more events that fire the transition.  If none
    #   are specified, then this will match any event.;Fi[	@Êi6I"L    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:on</tt> - One or more events that fire the transition.  If none
    #   are specified, then this will match any event.;Fi[	@£I"return if var.blank?;Fi[[	@biI"º    # of this method is +false+ an <tt>ActiveModel::ForbiddenAttributesError</tt>
    # exception is raised.
    def function(var)
      return if var.blank?
      var = var.stringify_keys;Fi[	@;iEI"Ü    # Only works for setting values as strings.
    #
    def function(var)
      return if var.blank?
      var = var.split("STRING");Fi[	@à7I"*#   conditionals defined for each one;Fi[[	@$iI"Ô    # Configuration options:
    # * <tt>:target</tt> - The target state to end the path on
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one
    def function(var, var, var);Fi[	@'iI"    # * <tt>:to</tt> - The target end state
    # * <tt>:deep</tt> - Whether to enable deep searches for the target state.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one
    def function(var, var, var);Fi[	@£I"$var = var.first.kind_of?(Array);Fi[[	@Øi’I"Õ      
      # If using a custom finder_sql, #find scans the entire collection.
      def function(var)
        var = var.first.kind_of?(Array)
        var = var.flatten.compact.map { |var| var.to_i }.uniq;Fi[	@‹	iﬂI"{    end
    
    def function(var)
      var = var.first.kind_of?(Array)
      return var.first if var and var.first.empty?;Fi[	I"2#   node's label that gets drawn on the graph;F@Hi[[	@i∫I"Ù    # Configuration options:
    # * <tt>:human_name</tt> - Whether to use the event's human name for the
    #   node's label that gets drawn on the graph
    def function(var, var)
      var = machine.states.by_priority.map { |var| var.name };Fi[	@*i—I"r    # Configuration options:
    # * <tt>:human_name</tt> - Whether to use the state's human name for the
    #   node's label that gets drawn on the graph
    def function(var, var)
      var = var.add_node((name ? (name.to_s) : ("STRING")), "LITERAL" => (description(var)), "LITERAL" => "STRING", "LITERAL" => "STRING", "LITERAL" => (final? ? ("STRING") : ("STRING")));Fi[	@uI"7#   are specified, then this will match any event.;Fi[[	@ÊiI"Q    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:on</tt> - One or more events that fire the transition.  If none
    #   are specified, then this will match any event.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless;Fi[	@Êi7I"Q    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:on</tt> - One or more events that fire the transition.  If none
    #   are specified, then this will match any event.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless;Fi[	@3u@à7i[[	@ÊiI"@    #   specified, then this will match any to state.
    # * <tt>:on</tt> - One or more events that fire the transition.  If none
    #   are specified, then this will match any event.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.;Fi[	@Êi8I"@    #   specified, then this will match any to state.
    # * <tt>:on</tt> - One or more events that fire the transition.  If none
    #   are specified, then this will match any event.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.;Fi[	@£I"var.map! do |var|;Fi[[	@∏içI"°    #   # => ['0', '27761', '173']
    #
    def function(var)
      var.map! do |var|
        if var.is_a?(Symbol) and self.column_names.include?(var.to_s) then;Fi[	@a"iJI"â      end
      
      def function(var)
        var.map! do |var|
          defined? Pathname and Pathname.===(var) ? (var.to_s) : (var);Fi[	@£@=i[[	@´Ki"I"      end
      
      def function(var)
        ActiveSupport::Deprecation.warn("STRING")
        remove_attachment(*var);Fi[	@´Ki-I"x      end
      
      def function(var)
        ActiveSupport::Deprecation.warn("STRING")
        attachment(*var);Fi[	@£@˜%i[[	@ñiEI"“    # See the load_and_authorize_resource method to automatically add the authorize! behavior
    # to the default RESTful actions.
    def function(var)
      @var = true
      current_ability.authorize!(*var);Fi[	@.i1I"S    end
    
    def function(var)
      @var = true
      (@html << "STRING");Fi[	@£@;i[[	@Èi∏I"À    # The second object, if present, is used as a prefix,
    # just like you can do with `dom_id()` and `dom_class()` in Rails
    def function(var)
      var = var["LITERAL"]
      var = var["LITERAL"];Fi[	@˝iﬁI"Ã    # The rules are different than for Ruby, so we cannot use eval.
    # Unquote will raise an error if q contains control characters.
    def function(var)
      var = var["LITERAL"]
      var = var.dup;Fi[	@—$@˚5i[[	@ÊiI"í    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :park do
    #         transition :idling => :parked;Fi[	@Êi?I"í    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :park do
    #         transition :idling => :parked;Fi[	@£I"var = var.dup;Fi[[	@3
iI"N    end
    
    def function(var)
      var = var.dup
      var = @index;Fi[	@3
i,I"^    end
    
    def function(var)
      var = var.dup
      var = StringScanner.new(var);Fi[	@£@±8i[[	@¶i∑I"†    end
    
    def function(var)
      if var.respond_to?("LITERAL") then
        if var.value.is_a?(Array) and var.value.all? { |var| color_stop?(var) } then;Fi[	@Û
iI"Ñ    end
    
    def function(var)
      if var.respond_to?("LITERAL") then
        var.copy_to_local_file(@style, destination.path);Fi[	@£@I1i[[	@ÔiI"e  module Helpers
    class ErrorReturn
      def function(var)
        @var = "STRING"
      end;Fi[	@€iI"îclass TestBall < Formula
  # name parameter required for some Formula::factory
  def function(var)
    @var = "STRING"
    @var ||= SoftwareSpec.new;Fi[	@£@ypi[[	@ i7I"Í      #   person.clear_name
      #   person.name          # => nil
      def function(var)
        self.attribute_method_matchers += var.map! { |var| AttributeMethodMatcher.new("LITERAL" => (var)) }
        undefine_attribute_methods;Fi[	@ iZI"˘      #   person.name          # => "Bob"
      #   person.name_short?   # => true
      def function(var)
        self.attribute_method_matchers += var.map! { |var| AttributeMethodMatcher.new("LITERAL" => (var)) }
        undefine_attribute_methods;Fi[	@Æ5I"(#   person.name          # => "Bob";Fi[[	@ i3I"â      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name          # => "Bob"
      #   person.clear_name;Fi[	@ iWI"ñ      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name          # => "Bob"
      #   person.name_short?   # => true;Fi[	@ü@¥Wi[[	@`iwI"ˆ      #
      #   json = { name: 'bob', age: 22, awesome:true }.to_json
      #   person = Person.new
      #   person.from_json(json) # => #<Person:0x007fec5e7a0088 @age=22, @awesome=true, @name="bob">
      #   person.name            # => "bob";Fi[	@`i|I"      #
      #   json = { person: { name: 'bob', age: 22, awesome:true } }.to_json
      #   person = Person.new
      #   person.from_json(json) # => #<Person:0x007fec5e7a0088 @age=22, @awesome=true, @name="bob">
      #   person.name            # => "bob";Fi[	I".#   events = Vehicle.state_machine.events;F@i[[	@ÊiJI"∞    #   end
    #   
    #   events = Vehicle.state_machine.events
    #   
    #   vehicle = Vehicle.new                             # => #<Vehicle:0xb7c464b0 @state="parked">;Fi[	@ÊikI"æ    #   
    #   vehicle = Vehicle.new                       # => #<Vehicle id: nil, state: "parked">
    #   events = Vehicle.state_machine.events
    #   
    #   vehicle.state_event = nil;Fi[	@@=Xi[[	@ÅiïI"c      #   result.each(as: :hash) do |r|
      #     return r
      #   end
      # end
      #;Fi[	@ÅiùI"`      #   if first = result.first
      #     first.first
      #   end
      # end
      #;Fi[	I"#       event :enable do;F@”Ii[[	@ÌiLI"Ø    #     
    #     state_machine :alarm_state, :namespace => 'alarm', :initial => :on do
    #       event :enable do
    #         transition all => :active
    #       end;Fi[	@Ìi~I"≥    #     
    #     state_machine :alarm_state, :namespace => 'alarm', :initial => :active do
    #       event :enable do
    #         transition all => :active
    #       end;Fi[	@@òQi[[	@≤iÎI"}      #   person.pets.any? do |pet|
      #     pet.group == 'dogs'
      #   end
      #   # => true
      def function(var);Ti[	@≤iI"~      #   person.pets.many? do |pet|
      #     pet.group == 'cats'
      #   end
      #   # => true
      def function(var);Ti[	@@ÑQi[[	@≤iÊI"s      #   person.pets.any? do |pet|
      #     pet.group == 'cats'
      #   end
      #   # => false
      #;Ti[	@≤iI"t      #   person.pets.many? do |pet|
      #     pet.group == 'dogs'
      #   end
      #   # => false
      #;Ti[	@>@ıqi[[	@ÿiÑI"û      #     def regex node_set, regex
      #       node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }
      #     end
      #   }.new)
      #;Fi[	@ÿiÆI"û      #     def regex node_set, regex
      #       node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }
      #     end
      #   }.new)
      #;Fi[	@s@TQi[[	@òiﬁI"ä    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name, on: :new
    #   end;Fi[	@òiI"ä    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name, on: :new
    #   end;Fi[	@ˆI@i[[	@Ìi\I"    #   vehicle.fire_events(:ignite, :disable_alarm)  # => true
    #   vehicle.state                                 # => "idling"
    #   vehicle.alarm_state                           # => "off"
    #   
    #   # If any event fails, the entire event chain fails;Fi[	@ÌiaI"˙    #   vehicle.fire_events(:ignite, :enable_alarm)   # => false
    #   vehicle.state                                 # => "idling"
    #   vehicle.alarm_state                           # => "off"
    #   
    #   # Exception raised on invalid event;Fi[	@ß@ó_i[[	@0iI"k    # returns +self+.
    #
    #   class Person
    #     include ActiveModel::Conversion
    #   end;Fi[	@0i7I"ü    # ActionPack uses this to find a suitable partial to represent the object.
    #
    #   class Person
    #     include ActiveModel::Conversion
    #   end;Fi[	@â@Æi[[	@ÃiI"amodule StateMachine
  module Integrations
    module ActiveRecord
      version("STRING") do;Fi[	@)iI"àrequire("state_machine/integrations/active_model")
module StateMachine
  module Integrations
    module ActiveRecord
      include(Base);Fi[	@âI"module Mongoid;Fi[[	@ÃiI"\module StateMachine
  module Integrations
    module Mongoid
      version("STRING") do;Fi[	@/iI"Umodule StateMachine
  module Integrations
    module Mongoid
      include(Base);Fi[	@I"s# @param size [String, Symbol] The size of the image. Must be one of: 'mini', 'normal', 'bigger' or 'original';Fi[[	@Ü8iGI"≈    
    # Return the URL to the user's profile image
    #
    # @param size [String, Symbol] The size of the image. Must be one of: 'mini', 'normal', 'bigger' or 'original'
    # @return [String];Fi[	@Ü8iOI"Ã    
    # Return the secure URL to the user's profile image
    #
    # @param size [String, Symbol] The size of the image. Must be one of: 'mini', 'normal', 'bigger' or 'original'
    # @return [String];Fi[	@âI"module MongoMapper;Fi[[	@”iI"`module StateMachine
  module Integrations
    module MongoMapper
      version("STRING") do;Fi[	@,iI"árequire("state_machine/integrations/active_model")
module StateMachine
  module Integrations
    module MongoMapper
      include(Base);Fi[	@âI"module Sequel;Fi[[	@ciI"[module StateMachine
  module Integrations
    module Sequel
      version("STRING") do;Fi[	@JiI"Tmodule StateMachine
  module Integrations
    module Sequel
      include(Base);Fi[	@I"é# @param size [String, Symbol] The size of the image. Must be one of: 'mobile', 'mobile_retina', 'web', 'web_retina', 'ipad', or 'ipad_retina';Fi[[	@Ü8i/I"Ï    
    # Return the URL to the user's profile banner image
    #
    # @param size [String, Symbol] The size of the image. Must be one of: 'mobile', 'mobile_retina', 'web', 'web_retina', 'ipad', or 'ipad_retina'
    # @return [String];Fi[	@Ü8i9I"Û    
    # Return the secure URL to the user's profile banner image
    #
    # @param size [String, Symbol] The size of the image. Must be one of: 'mobile', 'mobile_retina', 'web', 'web_retina', 'ipad', or 'ipad_retina'
    # @return [String];Fi[	@I"?# @see https://dev.twitter.com/docs/api/1.1/get/blocks/ids;Fi[[	@iúI"∫      
      # Returns an array of numeric user ids the authenticating user is blocking
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/blocks/ids
      # @rate_limited Yes;Fi[	@i≠I"≥      
      # Returns true if the authenticating user is blocking a target user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/blocks/ids
      # @rate_limited Yes;Fi[	@I"D# @see https://dev.twitter.com/docs/api/1.1/get/statuses/oembed;Fi[[	@iÃI"ë      
      # Returns oEmbed for a Tweet
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/oembed
      # @rate_limited Yes;Fi[	@i‚I"ë      
      # Returns oEmbeds for Tweets
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/oembed
      # @rate_limited Yes;Fi[	@I"J# @see https://dev.twitter.com/docs/api/1.1/post/statuses/retweet/:id;Fi[[	@iÄI"µ      
      # Retweets the specified Tweets as the authenticating user
      #
      # @see https://dev.twitter.com/docs/api/1.1/post/statuses/retweet/:id
      # @rate_limited Yes;Fi[	@iöI"Î      
      # Retweets the specified Tweets as the authenticating user and raises an error if one has already been retweeted
      #
      # @see https://dev.twitter.com/docs/api/1.1/post/statuses/retweet/:id
      # @rate_limited Yes;Fi[	@I"F# @see https://dev.twitter.com/docs/api/1.1/get/statuses/show/:id;Fi[[	@i6I"à      
      # Returns a Tweet
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/show/:id
      # @rate_limited Yes;Fi[	@iFI"á      
      # Returns Tweets
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/show/:id
      # @rate_limited Yes;Fi[	I"G# Initializes class-level extensions and defaults for this machine;F@:i[[	@ÛiqI"      end
      
      # Initializes class-level extensions and defaults for this machine
      def function
        super;Fi[	@	i1I"Ä      protected
      
      # Initializes class-level extensions and defaults for this machine
      def function
        super;Fi[	I"a(callbacks["LITERAL"] << Callback.new("LITERAL") { |var, var| notify("LITERAL", var, var) });F@	vi[[	@ÛiÑI"k      def function
        if supports_observers? then
          (callbacks["LITERAL"] << Callback.new("LITERAL") { |var, var| notify("LITERAL", var, var) })
          (callbacks["LITERAL"] << Callback.new("LITERAL") { |var, var| notify("LITERAL", var, var) })
          (callbacks["LITERAL"] << Callback.new("LITERAL") { |var, var| notify("LITERAL", var, var) });Fi[	@ÛiÖI"d        if supports_observers? then
          (callbacks["LITERAL"] << Callback.new("LITERAL") { |var, var| notify("LITERAL", var, var) })
          (callbacks["LITERAL"] << Callback.new("LITERAL") { |var, var| notify("LITERAL", var, var) })
          (callbacks["LITERAL"] << Callback.new("LITERAL") { |var, var| notify("LITERAL", var, var) })
        end;Fi[	@I"J# @see https://dev.twitter.com/docs/api/1.1/get/statuses/retweets/:id;Fi[[	@iI"µ      
      # Returns up to 100 of the first retweets of a given tweet
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/retweets/:id
      # @rate_limited Yes;Fi[	@i"I"©      
      # Show up to 100 users who retweeted the Tweet
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/retweets/:id
      # @rate_limited Yes;Fi[	I"=owner_class.validates_each(attribute) do |var, var, var|;FI"'var = var.class.state_machine(var);Fi[[	@ÛiéI"        var = self.name
        if supports_validations? then
          owner_class.validates_each(attribute) do |var, var, var|
            var = var.class.state_machine(var)
            var.invalidate(var, "LITERAL", "LITERAL") unless var.states.match(var);Fi[	@JiPI"È      def function
        var = self.name
        owner_class.validates_each(attribute) do |var, var, var|
          var = var.class.state_machine(var)
          var.invalidate(var, "LITERAL", "LITERAL") unless var.states.match(var);Fi[	@I"K# @see https://dev.twitter.com/docs/api/1.1/get/statuses/home_timeline;Fi[[	@ÎilI"4      
      # Returns the 20 most recent Tweets, including retweets if they exist, posted by the authenticating user and the users they follow
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/home_timeline
      # @note This method can only return up to 800 Tweets, including retweets.;Fi[	@Îi~I"      
      # Returns the 20 most recent retweets posted by users the authenticating user follow.
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/home_timeline
      # @note This method can only return up to 800 Tweets, including retweets.;Fi[	@I"N#   @see https://dev.twitter.com/docs/api/1.1/get/saved_searches/show/:id;Fi[[	@ŸiI"      # @overload saved_search(*ids)
      #   Retrieve the data for saved searches owned by the authenticating user
      #
      #   @see https://dev.twitter.com/docs/api/1.1/get/saved_searches/show/:id
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.;Fi[	@Ÿi!I"       # @overload saved_search(*ids, options)
      #   Retrieve the data for saved searches owned by the authenticating user
      #
      #   @see https://dev.twitter.com/docs/api/1.1/get/saved_searches/show/:id
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.;Fi[	@ªJ@öi[[	@´EiI"{var = "STRING"
var = eval(IO.read(var), binding, var)
var["LITERAL"]["LITERAL"] = var["LITERAL"].delete("LITERAL")
var;Fi[	@ÆEiI"{var = "STRING"
var = eval(IO.read(var), binding, var)
var["LITERAL"]["LITERAL"] = var["LITERAL"].delete("LITERAL")
var;Fi[	@I"H# @see https://dev.twitter.com/docs/api/1.1/post/friendships/create;Fi[[	@ÖiwI"ÿ      
      # Allows the authenticating user to follow the specified users, unless they are already followed
      #
      # @see https://dev.twitter.com/docs/api/1.1/post/friendships/create
      # @rate_limited No;Fi[	@ÖiãI"∂      
      # Allows the authenticating user to follow the specified users
      #
      # @see https://dev.twitter.com/docs/api/1.1/post/friendships/create
      # @rate_limited No;Fi[	@I"F# @see https://dev.twitter.com/docs/api/1.1/post/favorites/create;Fi[[	@~iII"±      
      # Favorites the specified Tweets as the authenticating user
      #
      # @see https://dev.twitter.com/docs/api/1.1/post/favorites/create
      # @rate_limited No;Fi[	@~ijI"Á      
      # Favorites the specified Tweets as the authenticating user and raises an error if one has already been favorited
      #
      # @see https://dev.twitter.com/docs/api/1.1/post/favorites/create
      # @rate_limited No;Fi[	I"7require("state_machine/integrations/active_model");F@ài[[	@)i I"arequire("state_machine/integrations/active_model")
module StateMachine
  module Integrations;Fi [	@,i I"arequire("state_machine/integrations/active_model")
module StateMachine
  module Integrations;Fi [	@I"K#   @see https://dev.twitter.com/docs/api/1.1/get/direct_messages/show;Fi[[	@qiWI"È      # @overload direct_messages(*ids)
      #   Returns direct messages
      #
      #   @see https://dev.twitter.com/docs/api/1.1/get/direct_messages/show
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.;Fi[	@qi^I"Ú      # @overload direct_messages(*ids, options)
      #   Returns direct messages
      #
      #   @see https://dev.twitter.com/docs/api/1.1/get/direct_messages/show
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.;Fi[	@I"Q# Once the callbacks are run, they cannot be run again until this transition;Fi[[	@3i`I"œ    # callbacks that are configured to match the event, from state, and to
    # state will be invoked.
    # 
    # Once the callbacks are run, they cannot be run again until this transition
    # is reset.;Fi[	@3i~I"œ    # callbacks that are configured to match the event, from state, and to
    # state will be invoked.
    # 
    # Once the callbacks are run, they cannot be run again until this transition
    # is reset.;Fi[	@I""#   vehicle.state = 'invalid';Fi[[	@)i6I"Â    #   vehicle.state = 'idling'
    #   states.match(vehicle)         # => #<StateMachine::State name=:idling value="idling" initial=true>
    #   
    #   vehicle.state = 'invalid'
    #   states.match(vehicle)         # => nil;Fi[	@)iNI"E    #   vehicle = Vehicle.new         # => #<Vehicle:0xb7c464b0 @state="parked">
    #   states.match!(vehicle)        # => #<StateMachine::State name=:parked value="parked" initial=true>
    #   
    #   vehicle.state = 'invalid'
    #   states.match!(vehicle)        # => ArgumentError: "invalid" is not a known state value;Fi[	@I"Q#   vehicle = Vehicle.new         # => #<Vehicle:0xb7c464b0 @state="parked">;Fi[[	@)i0I"˚    #   
    #   states = Vehicle.state_machine.states
    #   
    #   vehicle = Vehicle.new         # => #<Vehicle:0xb7c464b0 @state="parked">
    #   states.match(vehicle)         # => #<StateMachine::State name=:parked value="parked" initial=true>;Fi[	@)iKI"˚    #   
    #   states = Vehicle.state_machine.states
    #   
    #   vehicle = Vehicle.new         # => #<Vehicle:0xb7c464b0 @state="parked">
    #   states.match!(vehicle)        # => #<StateMachine::State name=:parked value="parked" initial=true>;Fi[	@I"B#   path.to_states  # => [:parked, :idling, :first_gear, ...];Fi[[	@$i,I"x    # 
    # For example,
    # 
    #   path.to_states  # => [:parked, :idling, :first_gear, ...]
    def function;Fi[	@$i;I"x    # 
    # For example,
    # 
    #   path.to_states  # => [:parked, :idling, :first_gear, ...]
    def function;Fi[	@I"O# The above will look up the "parked" key in a hash indexed by each node's;Fi[[	@jiÉI"ö    # 
    #   collection['parked', :value]
    # 
    # The above will look up the "parked" key in a hash indexed by each node's
    # +value+ attribute.;Fi[	@jiëI"ö    # 
    #   collection['parked', :value]
    # 
    # The above will look up the "parked" key in a hash indexed by each node's
    # +value+ attribute.;Fi[	@I"%#   collection['parked', :value];Fi[[	@jiÅI"û    # key in the first index configured for the collection.  A custom index can
    # be specified like so:
    # 
    #   collection['parked', :value]
    # ;Fi[	@jièI"û    # key in the first index configured for the collection.  A custom index can
    # be specified like so:
    # 
    #   collection['parked', :value]
    # ;Fi[	@I"2#   states = StateMachine::NodeCollection.new;Fi[[	@jiiI"‘    # Calls the block once for each element in self, passing that element as a
    # parameter.
    # 
    #   states = StateMachine::NodeCollection.new
    #   states << StateMachine::State.new(machine, :parked);Fi[	@jixI"°    
    # Gets the node at the given index.
    # 
    #   states = StateMachine::NodeCollection.new
    #   states << StateMachine::State.new(machine, :parked);Fi[	@I"#       event :turn_off do;Fi[[	@iƒI"Ñ    #         transition all => :on
    #       end
    #       
    #       event :turn_off do
    #         transition all => :off;Fi[	@iŒI"à    #         transition all => :active
    #       end
    #       
    #       event :turn_off do
    #         transition all => :off;Fi[	@I"#     observe Vehicle;Fi[[	@ıi$I"à        #   class VehicleObserver
        #     include DataMapper::Observer
        #     
        #     observe Vehicle
        #     ;Fi[	@ıiaI"à        #   class VehicleObserver
        #     include DataMapper::Observer
        #     
        #     observe Vehicle
        #     ;Fi[	@I"x#   vehicle = Vehicle.new                         # => #<Vehicle:0xb7c02850 @state="parked", @alarm_state="active">;Fi[[	@ÌiUI"ﬁ    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                         # => #<Vehicle:0xb7c02850 @state="parked", @alarm_state="active">
    #   vehicle.state                                 # => "parked";Fi[	@ÌiÇI"⁄    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                         # => #<Vehicle:0xb7c02850 @state="parked", @alarm_state="active">
    #   vehicle.fire_events(:ignite, :disable_alarm)  # => true;Fi[	I"L# Generates the fully-qualifed column name for this machine's attribute;F@:i[[	@)iTI"ñ      end
      
      # Generates the fully-qualifed column name for this machine's attribute
      def function
        var = owner_class.connection;Fi[	@JiçI"√      end
      
      # Generates the fully-qualifed column name for this machine's attribute
      def function
        ::Sequel::SQL::QualifiedIdentifier.new(owner_class.table_name, attribute);Fi[	@@‹Ii[[	@ÌiOI"á    #         transition all => :active
    #       end
    #       
    #       event :disable do
    #         transition all => :off;Fi[	@Ìi|I"á    #         transition all => :active
    #       end
    #       
    #       event :disable do
    #         transition all => :off;Fi[	@@Ui[[	@ÊiI"ë    #         transition :idling => :parked
    #       end
    #       
    #       event :ignite do
    #         transition :parked => :idling;Fi[	@ÊiCI"ë    #         transition :idling => :parked
    #       end
    #       
    #       event :ignite do
    #         transition :parked => :idling;Fi[	@@”Oi[[	@idI"ö    #    end
    #  end
    # 
    # See StateMachine::Machine#transition for a description of the possible
    # configurations for defining transitions.;Fi[	@0i)I"ú    #     end
    #   end
    # 
    # See StateMachine::Machine#transition for a description of the possible
    # configurations for defining transitions.;Fi[	@πKI"'#     include DataMapper::Observer;Fi[[	@ıi"I"}        #   end
        #   
        #   class VehicleObserver
        #     include DataMapper::Observer
        #     ;Fi[	@ıi_I"}        #   end
        #   
        #   class VehicleObserver
        #     include DataMapper::Observer
        #     ;Fi[	@Æv@i[[	@ıi#I"Ü        #   
        #   class VehicleObserver
        #     include DataMapper::Observer
        #     
        #     observe Vehicle;Fi[	@ıi`I"Ü        #   
        #   class VehicleObserver
        #     include DataMapper::Observer
        #     
        #     observe Vehicle;Fi[	@áv@i[[	@ıi%I"Ñ        #     include DataMapper::Observer
        #     
        #     observe Vehicle
        #     
        #     before :save do;Fi[	@ıibI"ù        #     include DataMapper::Observer
        #     
        #     observe Vehicle
        #     
        #     around_transition do |transition, block|;Fi[	I"#       # log message;F@>i[[	@ıi(I"p        #     
        #     before :save do
        #       # log message
        #     end
        #     ;Fi[	@ıi7I"Æ        #     # Target all state machines without requirements
        #     before_transition do |transition|
        #       # log message
        #     end
        #   end;Fi[	I"#       # put on seatbelt;F@>i[[	@ıi-I"≤        #     # Target all state machines
        #     before_transition :parked => :idling, :on => :ignite do
        #       # put on seatbelt
        #     end
        #     ;Fi[	@ıi2I"¨        #     # Target a specific state machine
        #     before_transition :state, any => :idling do
        #       # put on seatbelt
        #     end
        #     ;Fi[	@ùKI"# for defining callbacks.;Fi[[	@ıiGI"¥        # transition.
        # 
        # See +before_transition+ for a description of the possible configurations
        # for defining callbacks.
        def function(var, var);Fi[	@ıikI"Æ        #   end
        # 
        # See +before_transition+ for a description of the possible configurations
        # for defining callbacks.
        def function(var, var);Fi[	@œv@Hi[[	@ıiHI"◊        # 
        # See +before_transition+ for a description of the possible configurations
        # for defining callbacks.
        def function(var, var)
          add_transition_callback("LITERAL", *var, &var);Fi[	@ıilI"◊        # 
        # See +before_transition+ for a description of the possible configurations
        # for defining callbacks.
        def function(var, var)
          add_transition_callback("LITERAL", *var, &var);Fi[	I"#       # log failure;F@>i[[	@ıiÄI"ó        #   class VehicleObserver
        #     after_transition_failure do |transition|
        #       # log failure
        #     end
        #     ;Fi[	@ıiÑI"á        #     
        #     after_transition_failure :on => :ignite do
        #       # log failure
        #     end
        #   end;Fi[	I"7# Pluralizes the name using the built-in inflector;F@£i[[	@	iMI"ï      end
      
      # Pluralizes the name using the built-in inflector
      def function(var)
        ::DataMapper::Inflector.pluralize(var.to_s);Fi[	@Ji-I"}      end
      
      # Pluralizes the name using the built-in inflector
      def function(var)
        load_inflector;Fi[	I"9# Uses internal save hooks if using the :save action;F@:i[[	@	iqI"î      end
      
      # Uses internal save hooks if using the :save action
      def function
        (action == "LITERAL") ? ("LITERAL") : (super);Fi[	@JiaI"î      end
      
      # Uses internal save hooks if using the :save action
      def function
        (action == "LITERAL") ? ("LITERAL") : (super);Fi[	I"G# Runs a new database transaction, rolling back any changes if the;FI"0# yielded block fails (i.e. returns false).;Fi[[	@	i}I"£      end
      
      # Runs a new database transaction, rolling back any changes if the
      # yielded block fails (i.e. returns false).
      def function(var);Fi[	@JiíI"£      end
      
      # Runs a new database transaction, rolling back any changes if the
      # yielded block fails (i.e. returns false).
      def function(var);Fi[	@Úv@£i[[	@	i~I"€      
      # Runs a new database transaction, rolling back any changes if the
      # yielded block fails (i.e. returns false).
      def function(var)
        var.class.transaction { |var| var.rollback unless yield };Fi[	@JiìI"Ê      
      # Runs a new database transaction, rolling back any changes if the
      # yielded block fails (i.e. returns false).
      def function(var)
        var.db.transaction { raise(::Sequel::Error::Rollback) unless yield };Fi[	I"I# Creates a new callback in the callback chain, always ensuring that;FI"J# it's configured to bind to the object as this is the convention for;Fi[[	@	iÉI"À      end
      
      # Creates a new callback in the callback chain, always ensuring that
      # it's configured to bind to the object as this is the convention for
      # DataMapper/Extlib callbacks;Fi[	@JiòI"¿      end
      
      # Creates a new callback in the callback chain, always ensuring that
      # it's configured to bind to the object as this is the convention for
      # Sequel callbacks;Fi[	I".# Defines a new scope with the given name;F@Hi[[	@,iMI"•      end
      
      # Defines a new scope with the given name
      def function(var, var)
        lambda { |var, var| var.query.merge(var.query(var.call(var))) };Fi[	@/iQI"ù      end
      
      # Defines a new scope with the given name
      def function(var, var)
        lambda { |var, var| var.criteria.where(var.call(var)) };Fi[	I"L# Forces the change in state to be recognized regardless of whether the;FI"## state value actually changed;Fi[[	@ÃiI"’          ::Mongoid::VERSION =~ "LITERAL"
        end
        # Forces the change in state to be recognized regardless of whether the
        # state value actually changed
        def function(var, var, var, var);Fi[	@JiI"™      end
      
      # Forces the change in state to be recognized regardless of whether the
      # state value actually changed
      def function(var, var, var, var);Fi[	@w@	+i[[	@ÃiI"¡        end
        # Forces the change in state to be recognized regardless of whether the
        # state value actually changed
        def function(var, var, var, var)
          var = super;Fi[	@JiI"¥      
      # Forces the change in state to be recognized regardless of whether the
      # state value actually changed
      def function(var, var, var, var)
        var = super;Fi[	I"#         ...;F@i[[	@i=I"j    #     state_machine do
    #       event :park do
    #         ...
    #       end
    #     end;Fi[	@i)I"â    #       @state = 'idling'
    #       initialize_state_machines(:static => :force) do
    #         ...
    #       end
    #     end;Fi[	I"N# state machine based on the *name* of the machine.  Any existing methods;FI"# will not be overwritten.;Fi[[	@iaI"    # 
    # The following class methods will be automatically generated by the
    # state machine based on the *name* of the machine.  Any existing methods
    # will not be overwritten.
    # * <tt>human_state_name(state)</tt> - Gets the humanized value for the;Fi[	@i{I"    # 
    # The following instance methods will be automatically generated by the
    # state machine based on the *name* of the machine.  Any existing methods
    # will not be overwritten.
    # * <tt>state</tt> - Gets the current value for the attribute;Fi[	@@Áti[[	@·i!I"X    #     end
    #   end
    # 
    #   person = Person.new('John Smith')
    #   ;Fi[	@·i1I"X    # 
    # For example,
    # 
    #   person = Person.new('John Smith')
    #   ;Fi[	@¢-@Ui[[	@imI"ú    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling;Fi[	@iûI"ú    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling;Fi[	I"™#                                             #     [#<StateMachine::Transition attribute=:state event=:park from="idling" from_name=:idling to="parked" to_name=:parked>,;FI"¨#                                             #      #<StateMachine::Transition attribute=:state event=:ignite from="parked" from_name=:parked to="idling" to_name=:idling>];Fi[[	@iƒI"¸    #   # Getting current path availability
    #   vehicle.state_paths                       # => [
    #                                             #     [#<StateMachine::Transition attribute=:state event=:park from="idling" from_name=:idling to="parked" to_name=:parked>,
    #                                             #      #<StateMachine::Transition attribute=:state event=:ignite from="parked" from_name=:parked to="idling" to_name=:idling>]
    #                                             #   ];Fi[	@i»I"    #                                             #   ]
    #   vehicle.state_paths(:guard => false)      # => 
    #                                             #     [#<StateMachine::Transition attribute=:state event=:park from="idling" from_name=:idling to="parked" to_name=:parked>,
    #                                             #      #<StateMachine::Transition attribute=:state event=:ignite from="parked" from_name=:parked to="idling" to_name=:idling>]
    #                                             #   ];Fi[	@8wI"8#                                             #   ];Fi[[	@i≈I"    #   vehicle.state_paths                       # => [
    #                                             #     [#<StateMachine::Transition attribute=:state event=:park from="idling" from_name=:idling to="parked" to_name=:parked>,
    #                                             #      #<StateMachine::Transition attribute=:state event=:ignite from="parked" from_name=:parked to="idling" to_name=:idling>]
    #                                             #   ]
    #   vehicle.state_paths(:guard => false)      # => ;Fi[	@i…I"ÿ    #   vehicle.state_paths(:guard => false)      # => 
    #                                             #     [#<StateMachine::Transition attribute=:state event=:park from="idling" from_name=:idling to="parked" to_name=:parked>,
    #                                             #      #<StateMachine::Transition attribute=:state event=:ignite from="parked" from_name=:parked to="idling" to_name=:idling>]
    #                                             #   ]
    #   ;Fi[	@@Àti[[	@i=I"{    # 
    # == Examples
    # 
    #   branch = StateMachine::Branch.new(:parked => :idling, :on => :ignite)
    #   ;Fi[	@ifI"{    # 
    # == Examples
    # 
    #   branch = StateMachine::Branch.new(:parked => :idling, :on => :ignite)
    #   ;Fi[	@@àti[[	@`i#I"π  #
  # If no queue can be inferred this method will raise a `Resque::NoQueueError`
  #
  # Returns true if the job was queued, nil if the job was rejected by a
  # before_enqueue hook.;Fi[	@`i0I"Æ  #
  # `queue` should be the String name of the queue you're targeting.
  #
  # Returns true if the job was queued, nil if the job was rejected by a
  # before_enqueue hook.;Fi[	@ãK@ÿ!i[[	@i¸I"k    #     end
    #     
    #     def initialize(attributes = {})
    #       ...
    #       super();Fi[	@iI"}    #     end
    #     
    #     def initialize(attributes = {})
    #       ...
    #       initialize_state_machines;Fi[	@Äv@ï5i[[	@i≈I"u    #       end
    #       
    #       event :turn_off do
    #         transition all => :off
    #       end;Fi[	@iœI"u    #       end
    #       
    #       event :turn_off do
    #         transition all => :off
    #       end;Fi[	I"3#   matcher.matches?(:parked)       # => false;FI"2#   matcher.matches?(:first_gear)   # => true;Fi[[	@liI"     # 
    #   matcher = StateMachine::AllMatcher.instance - [:parked, :idling]
    #   matcher.matches?(:parked)       # => false
    #   matcher.matches?(:first_gear)   # => true
    def function(var);Fi[	@liOI"œ    # 
    #   matcher = StateMachine::BlacklistMatcher.new([:parked, :idling])
    #   matcher.matches?(:parked)       # => false
    #   matcher.matches?(:first_gear)   # => true
    def function(var, var);Fi[	I"# for this matcher.;F@i[[	@li7I"ü  class WhitelistMatcher < Matcher
    # Checks whether the given value exists within the whitelist configured
    # for this matcher.
    # 
    # == Examples;Fi[	@liJI"†  class BlacklistMatcher < Matcher
    # Checks whether the given value exists outside the blacklist configured
    # for this matcher.
    # 
    # == Examples;Fi[	I"3# A human-readable description of this matcher;F@:i[[	@liBI"ü    end
    
    # A human-readable description of this matcher
    def function
      (values.length == "LITERAL") ? (values.first.inspect) : (values.inspect);Fi[	@li[I"d    end
    
    # A human-readable description of this matcher
    def function
      "STRING";Fi[	@yvI"<#   states << StateMachine::State.new(machine, :parked);Fi[[	@jijI"¡    # parameter.
    # 
    #   states = StateMachine::NodeCollection.new
    #   states << StateMachine::State.new(machine, :parked)
    #   states << StateMachine::State.new(machine, :idling);Fi[	@jiyI"ÿ    # Gets the node at the given index.
    # 
    #   states = StateMachine::NodeCollection.new
    #   states << StateMachine::State.new(machine, :parked)
    #   states << StateMachine::State.new(machine, :idling);Fi[	@twI"<#   states << StateMachine::State.new(machine, :idling);Fi[[	@jikI"Ê    # 
    #   states = StateMachine::NodeCollection.new
    #   states << StateMachine::State.new(machine, :parked)
    #   states << StateMachine::State.new(machine, :idling)
    #   states.each {|state| puts state.name, ' -- '};Fi[	@jizI"π    # 
    #   states = StateMachine::NodeCollection.new
    #   states << StateMachine::State.new(machine, :parked)
    #   states << StateMachine::State.new(machine, :idling)
    #   ;Fi[	I"Q# Gets the node indexed by the given key.  By default, this will look up the;FI"P# key in the first index configured for the collection.  A custom index can;Fi[[	@ji~I"…    end
    
    # Gets the node indexed by the given key.  By default, this will look up the
    # key in the first index configured for the collection.  A custom index can
    # be specified like so:;Fi[	@jiåI"…    end
    
    # Gets the node indexed by the given key.  By default, this will look up the
    # key in the first index configured for the collection.  A custom index can
    # be specified like so:;Fi[	@ÉwI"# be specified like so:;Fi[[	@jiI"»    
    # Gets the node indexed by the given key.  By default, this will look up the
    # key in the first index configured for the collection.  A custom index can
    # be specified like so:
    # ;Fi[	@jiçI"»    
    # Gets the node indexed by the given key.  By default, this will look up the
    # key in the first index configured for the collection.  A custom index can
    # be specified like so:
    # ;Fi[	@äw@i[[	@jiÄI"Ë    # Gets the node indexed by the given key.  By default, this will look up the
    # key in the first index configured for the collection.  A custom index can
    # be specified like so:
    # 
    #   collection['parked', :value];Fi[	@jiéI"Ë    # Gets the node indexed by the given key.  By default, this will look up the
    # key in the first index configured for the collection.  A custom index can
    # be specified like so:
    # 
    #   collection['parked', :value];Fi[	@rv@i[[	@jiÇI"ù    # be specified like so:
    # 
    #   collection['parked', :value]
    # 
    # The above will look up the "parked" key in a hash indexed by each node's;Fi[	@jiêI"ù    # be specified like so:
    # 
    #   collection['parked', :value]
    # 
    # The above will look up the "parked" key in a hash indexed by each node's;Fi[	@kvI"# +value+ attribute.;Fi[[	@jiÑI"ö    #   collection['parked', :value]
    # 
    # The above will look up the "parked" key in a hash indexed by each node's
    # +value+ attribute.
    # ;Fi[	@jiíI"ö    #   collection['parked', :value]
    # 
    # The above will look up the "parked" key in a hash indexed by each node's
    # +value+ attribute.
    # ;Fi[	@ùw@i[[	@jiÖI"≤    # 
    # The above will look up the "parked" key in a hash indexed by each node's
    # +value+ attribute.
    # 
    # If the key cannot be found, then nil will be returned.;Fi[	@jiìI"ƒ    # 
    # The above will look up the "parked" key in a hash indexed by each node's
    # +value+ attribute.
    # 
    # If the key cannot be found, then an IndexError exception will be raised:;Fi[	I"9# Gets the value for the given attribute on the node;F@Hi[[	@ji•I"y    end
    
    # Gets the value for the given attribute on the node
    def function(var, var)
      var.send(var);Fi[	@)ilI"ú    private
    
    # Gets the value for the given attribute on the node
    def function(var, var)
      (var == "LITERAL") ? (var.value(false)) : (super);Fi[	I"# versions of the index;F@Hi[[	@ji≥I"£    
    # Removes the given key from an index, including the string and symbol
    # versions of the index
    def function(var, var)
      index(var).delete(var);Fi[	@jiªI"£    
    # Updates the node for the given index, including the string and symbol
    # versions of the index
    def function(var, var)
      var = self.index(var);Fi[	@u@Ÿi[[	@$iI"    # * <tt>:target</tt> - The target state to end the path on
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one
    def function(var, var, var)
      assert_valid_keys(var, "LITERAL", "LITERAL");Fi[	@'iI">    # * <tt>:deep</tt> - Whether to enable deep searches for the target state.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one
    def function(var, var, var)
      var = { "LITERAL" => (false), "LITERAL" => (var.states.match!(var).name) }.merge(var);Fi[	@dv@:i[[	@$i-I"ì    # For example,
    # 
    #   path.to_states  # => [:parked, :idling, :first_gear, ...]
    def function
      map { |var| var.from_name }.uniq;Fi[	@$i<I"ë    # For example,
    # 
    #   path.to_states  # => [:parked, :idling, :first_gear, ...]
    def function
      map { |var| var.to_name }.uniq;Fi[	I"# this collection.;F@i[[	@'i+I"Ü    
    # Lists all of the states that can be transitioned from through the paths in
    # this collection.
    # 
    # For example,;Fi[	@'i5I"Ñ    
    # Lists all of the states that can be transitioned to through the paths in
    # this collection.
    # 
    # For example,;Fi[	@@sti[[	@`iI"—  #   a) has a @queue ivar set
  #   b) responds to `queue`
  #
  # If either of those conditions are met, it will use the value obtained
  # from performing one of the above operations to determine the queue.;Fi[	@`iDI"—  #   a) has a @queue ivar set
  #   b) responds to `queue`
  #
  # If either of those conditions are met, it will use the value obtained
  # from performing one of the above operations to determine the queue.;Fi[	@
K@i[[	@)i/I"ú    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   
    #   vehicle = Vehicle.new         # => #<Vehicle:0xb7c464b0 @state="parked">;Fi[	@)iJI"ú    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   
    #   vehicle = Vehicle.new         # => #<Vehicle:0xb7c464b0 @state="parked">;Fi[	@KI"c#   transition = StateMachine::Transition.new(Vehicle.new, machine, :ignite, :parked, :idling);Fi[[	@3i§I";    # == Example
    # 
    #   machine = StateMachine.new(Vehicle)
    #   transition = StateMachine::Transition.new(Vehicle.new, machine, :ignite, :parked, :idling)
    #   transition.attributes   # => {:object => #<Vehicle:0xb7d60ea4>, :attribute => :state, :event => :ignite, :from => 'parked', :to => 'idling'};Fi[	@3iôI"¸    # == Example
    # 
    #   machine = StateMachine.new(Vehicle)
    #   transition = StateMachine::Transition.new(Vehicle.new, machine, :ignite, :parked, :idling)
    #   transition.context    # => {:on => :ignite, :from => :parked, :to => :idling};Fi[	I"K# callbacks that are configured to match the event, from state, and to;FI"# state will be invoked.;Fi[[	@3i^I"∫    
    # Runs the machine's +before+ callbacks for this transition.  Only
    # callbacks that are configured to match the event, from state, and to
    # state will be invoked.
    # ;Fi[	@3i|I"π    
    # Runs the machine's +after+ callbacks for this transition.  Only
    # callbacks that are configured to match the event, from state, and to
    # state will be invoked.
    # ;Fi[	@ﬂw@i[[	@3i_I"    # Runs the machine's +before+ callbacks for this transition.  Only
    # callbacks that are configured to match the event, from state, and to
    # state will be invoked.
    # 
    # Once the callbacks are run, they cannot be run again until this transition;Fi[	@3i}I"    # Runs the machine's +after+ callbacks for this transition.  Only
    # callbacks that are configured to match the event, from state, and to
    # state will be invoked.
    # 
    # Once the callbacks are run, they cannot be run again until this transition;Fi[	@OvI"# is reset.;Fi[[	@3iaI"§    # state will be invoked.
    # 
    # Once the callbacks are run, they cannot be run again until this transition
    # is reset.
    def function(var, var, var);Fi[	@3iI"ã    # state will be invoked.
    # 
    # Once the callbacks are run, they cannot be run again until this transition
    # is reset.
    # ;Fi[	@@eti[[	@`iI"≠  # It assumes the class you're passing it is a real Ruby class (not
  # a string or reference) which either:
  #
  #   a) has a @queue ivar set
  #   b) responds to `queue`;Fi[	@`iAI"≠  # It assumes the class you're passing it is a real Ruby class (not
  # a string or reference) which either:
  #
  #   a) has a @queue ivar set
  #   b) responds to `queue`;Fi[	@Lb@‡Bi[[	@?+iI"ä        
        def function
          if owner.is_a?(StateMachine::Machine) then
            var = self
            var = self.statement;Fi[	@D+iI"ä        
        def function
          if owner.is_a?(StateMachine::Machine) then
            var = self
            var = self.statement;Fi[	@ªZI"4var = extract_node_names(var.parameters(false));Fi[[	@?+iI"∆          if owner.is_a?(StateMachine::Machine) then
            var = self
            var = self.statement
            var = extract_node_names(var.parameters(false))
            var.each do |var|;Fi[	@D+iI"∆          if owner.is_a?(StateMachine::Machine) then
            var = self
            var = self.statement
            var = extract_node_names(var.parameters(false))
            var.each do |var|;Fi[	@ˇw@!6i[[	@?+iI"Ë            var = self
            var = self.statement
            var = extract_node_names(var.parameters(false))
            var.each do |var|
              owner.event(var) { var.parse_block(var.last.last, "LITERAL" => (self)) };Fi[	@D+iI"Ë            var = self
            var = self.statement
            var = extract_node_names(var.parameters(false))
            var.each do |var|
              owner.state(var) { var.parse_block(var.last.last, "LITERAL" => (self)) };Fi[	I"\register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING", "LITERAL")));F@fLi[[	@›iI"˚        def function
          return if inherited_machine
          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING", "LITERAL")))
          var.docstring = ["STRING", "STRING", "STRING"]
          var.parameters = ["STRING"];Fi[	@›i}I"          var.docstring = ["STRING", "STRING", "STRING"]
          var.parameters = ["STRING"]
          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING", "LITERAL")))
          var.docstring = ["STRING", "STRING", "STRING"]
          var.parameters = ["STRING"];Fi[	@@§Hi[[	@]iI"∑    
    # Find Resque worker pids on Windows.
    #
    # Returns an Array of string pids of all the other workers on this
    # machine. Useful when pruning dead workers on startup.;Fi[	@]iI"ª    
    # Find worker pids - platform independent
    #
    # Returns an Array of string pids of all the other workers on this
    # machine. Useful when pruning dead workers on startup.;Fi[	I".namespace.attributes["LITERAL"][var] = {};FI"Lregister((var = ::YARD::CodeObjects::MethodObject.new(namespace, var)));Fi[[	@›iÇI"M          unless (integration or instance_attributes.include?(machine.attribute.to_sym)) then
            var = machine.attribute
            namespace.attributes["LITERAL"][var] = {}
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, var)))
            namespace.attributes["LITERAL"][var]["LITERAL"] = var;Fi[	@›içI"f          if ((integration and (integration.defaults["LITERAL"] and options.include?("LITERAL").!)) or options["LITERAL"]) then
            var = "STRING"
            namespace.attributes["LITERAL"][var] = {}
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, var)))
            namespace.attributes["LITERAL"][var]["LITERAL"] = var;Fi[	@x@≤?i[[	@›iÉI"             var = machine.attribute
            namespace.attributes["LITERAL"][var] = {}
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, var)))
            namespace.attributes["LITERAL"][var]["LITERAL"] = var
            var.docstring = ["STRING", "STRING"];Fi[	@›iéI"            var = "STRING"
            namespace.attributes["LITERAL"][var] = {}
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, var)))
            namespace.attributes["LITERAL"][var]["LITERAL"] = var
            var.docstring = ["STRING", "STRING"];Fi[	@I"E# Can optionally accept a second int parameter. The stat is then;Fi[[	I")projects//rescue_proj/resque/stat.rb;TiI"´    
    # For a string stat name, increments the stat by one.
    #
    # Can optionally accept a second int parameter. The stat is then
    # incremented by that amount.;Fi[	@*xi#I"´    
    # For a string stat name, decrements the stat by one.
    #
    # Can optionally accept a second int parameter. The stat is then
    # decremented by that amount.;Fi[	@≥?@gLi[[	@›iàI"            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")))
            namespace.attributes["LITERAL"][var]["LITERAL"] = var
            var.docstring = ["STRING", "STRING"]
            var.parameters = ["STRING"]
          end;Fi[	@›iìI"            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")))
            namespace.attributes["LITERAL"][var]["LITERAL"] = var
            var.docstring = ["STRING", "STRING"]
            var.parameters = ["STRING"]
          end;Fi[	@@≤si[[	@^%iI"    # Pop an item off one of the queues.  This method will block until an item
    # is available. This method returns a tuple of the queue object and job.
    #
    # Pass +true+ for a non-blocking pop.  If nothing is read on a non-blocking
    # pop, a ThreadError is raised.;Fi[	@i@I"‘    # Pop an item off the queue.  This method will block until an item is
    # available.
    #
    # Pass +true+ for a non-blocking pop.  If nothing is read on a non-blocking
    # pop, a ThreadError is raised.;Fi[	@ÄL@≤?i[[	@›iÜI">            namespace.attributes["LITERAL"][var]["LITERAL"] = var
            var.docstring = ["STRING", "STRING"]
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")))
            namespace.attributes["LITERAL"][var]["LITERAL"] = var
            var.docstring = ["STRING", "STRING"];Fi[	@›iëI">            namespace.attributes["LITERAL"][var]["LITERAL"] = var
            var.docstring = ["STRING", "STRING"]
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")))
            namespace.attributes["LITERAL"][var]["LITERAL"] = var
            var.docstring = ["STRING", "STRING"];Fi[	@ÄL@≥?i[[	@›iõI"ä          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, machine.attribute("LITERAL"))))
          var.docstring = ["STRING", "STRING"]
          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")))
          var.docstring = ["STRING", "STRING"]
          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, machine.attribute("LITERAL"))));Fi[	@›iƒI"∫              next
            end
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")))
            var.docstring = ["STRING", "STRING"]
          end;Fi[	@@∆ri[[	@iI"¥    # +instance+ is the ActiveRecord object instance it's attached to, and
    # +options+ is the same as the hash passed to +has_attached_file+.
    #
    # Options include:
    #;Fi[	@b
iI"ø    # +whiny+ is true (which it is, by default. If +convert_options+ is
    # set, the options will be appended to the convert command upon image conversion
    #
    # Options include:
    #;Fi[	@ÄLI"Qvar.docstring = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING"];Fi[[	@›iØI"Y          machine.events.each do |var|
            next if inherited_machine and inherited_machine.events[var.name]
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")))
            var.docstring = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING"]
            var.parameters = [["STRING", "STRING"]];Fi[	@›i≤I"r            var.docstring = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING"]
            var.parameters = [["STRING", "STRING"]]
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")))
            var.docstring = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING"]
            var.parameters = [["STRING", "STRING"]];Fi[	@ëL@gLi[[	@›ióI"8          end
          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")))
          var.docstring = ["STRING", "STRING", "STRING", "STRING"]
          var.parameters = ["STRING"]
          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, machine.attribute("LITERAL"))));Fi[	@›iπI"˚            var.parameters = ["STRING"]
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")))
            var.docstring = ["STRING", "STRING", "STRING", "STRING"]
            var.parameters = ["STRING"]
          end;Fi[	@@‡qi[[	@ÿiuI"{      #
      #   node.xpath('.//title')
      #
      # A hash of namespace bindings may be appended. For example:
      #;Fi[	@ÿi†I"§      #   node.css('body h1.bold')
      #   node.css('div + p.green', 'div#one')
      #
      # A hash of namespace bindings may be appended. For example:
      #;Fi[	@I"#   <root xmlns:foo="bar">;Fi[[	@i`I"Ç      #
      # For example, given this document:
      #
      #   <root xmlns:foo="bar">
      #     <bar xmlns:hello="world" />;Fi[	@ikI"Ω      # WARNING: this method will clobber duplicate names in the keys.
      # For example, given this document:
      #
      #   <root xmlns:foo="bar">
      #     <bar xmlns:foo="baz" />;Fi[	@ºL@ÄLi[[	@›i•I"ó          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, machine.attribute("LITERAL"))))
          var.docstring = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"]
          var.parameters = [["STRING", "STRING"]]
          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")))
          var.docstring = ["STRING", "STRING", "STRING", "STRING"];Fi[	@›i±I"ó            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")))
            var.docstring = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING"]
            var.parameters = [["STRING", "STRING"]]
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")))
            var.docstring = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING"];Fi[	@ºL@™Li[[	@›iüI"…          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, machine.attribute("LITERAL"))))
          var.docstring = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"]
          var.parameters = [["STRING", "STRING"]]
          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, machine.attribute("LITERAL"))))
          var.docstring = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"];Fi[	@›i¢I"…          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, machine.attribute("LITERAL"))))
          var.docstring = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"]
          var.parameters = [["STRING", "STRING"]]
          register((var = ::YARD::CodeObjects::MethodObject.new(namespace, machine.attribute("LITERAL"))))
          var.docstring = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"];Fi[	@Mx@ºLi[[	@›i∞I"ã            next if inherited_machine and inherited_machine.events[var.name]
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")))
            var.docstring = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING"]
            var.parameters = [["STRING", "STRING"]]
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")));Fi[	@›i≥I"|            var.parameters = [["STRING", "STRING"]]
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")))
            var.docstring = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING"]
            var.parameters = [["STRING", "STRING"]]
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, var.qualified_name)));Fi[	@@Hqi[[	@’i:I"{      #
      # or
      #
      #   node.serialize(:encoding => 'UTF-8') do |config|
      #     config.format.as_xml;Fi[	@ÿi°I"{      #
      # or
      #
      #   node.serialize(:encoding => 'UTF-8') do |config|
      #     config.format.as_xml;Fi[	I",puts("STRING") if var.delete("LITERAL");FI" Rake::Task["STRING"].invoke;Fi[[	@4<iI"µ    var["LITERAL"] = (ENV["STRING"] == "STRING") if ENV["STRING"]
    if defined? Rails then
      puts("STRING") if var.delete("LITERAL")
      Rake::Task["STRING"].invoke
    else;Fi[	@4<iI"é    else
      if defined? Merb then
        puts("STRING") if var.delete("LITERAL")
        Rake::Task["STRING"].invoke
        $0 = "STRING";Fi[	@@Aqi[[	@’i8I"t      #
      #  node.serialize(:encoding => 'UTF-8', :save_with => FORMAT | AS_XML)
      #
      # or
      #;Fi[	@ÿiüI"t      #
      #  node.serialize(:encoding => 'UTF-8', :save_with => FORMAT | AS_XML)
      #
      # or
      #;Fi[	@@:qi[[	@’i6I"ë      #
      # These two statements are equivalent:
      #
      #  node.serialize(:encoding => 'UTF-8', :save_with => FORMAT | AS_XML)
      #;Fi[	@ÿiùI"ë      #
      # These two statements are equivalent:
      #
      #  node.serialize(:encoding => 'UTF-8', :save_with => FORMAT | AS_XML)
      #;Fi[	@@3qi[[	@’i4I"™      # Serialize Node using +options+.  Save options can also be set using a
      # block. See SaveOptions.
      #
      # These two statements are equivalent:
      #;Fi[	@ÿiõI"™      # Serialize Node using +options+.  Save options can also be set using a
      # block. See SaveOptions.
      #
      # These two statements are equivalent:
      #;Fi[	@I"# Returns nothing;Fi[[	@Z
i.I"P    
    # Reset Site details.
    #
    # Returns nothing
    def function;Fi[	@`i—I"Ä  #
  #   Resque.push('archive', 'class' => 'Archive', 'args' => [ 35, 'tar' ])
  #
  # Returns nothing
  def function(var, var);Fi[	@@Œoi[[	@@iGI"í    #   xml_escape('foo "bar" <baz>')
    #   # => "foo &quot;bar&quot; &lt;baz&gt;"
    #
    # Returns the escaped String.
    def function(var);Fi[	@@iVI"Ç    #   cgi_escape('foo,bar;baz?')
    #   # => "foo%2Cbar%3Bbaz%3F"
    #
    # Returns the escaped String.
    def function(var);Fi[	@I"class Geo;Fi[[	@∞iI"Urequire("twitter/geo")
module Twitter
  class Geo
    class Point < Twitter::Geo;Fi[	I"2projects//twitter_proj/twitter/geo/polygon.rb;TiI"Wrequire("twitter/geo")
module Twitter
  class Geo
    class Polygon < Twitter::Geo;Fi[	@I"module Response;Fi[[	@iI"}require("faraday")
require("multi_json")
module Twitter
  module Response
    class ParseJson < Faraday::Response::Middleware;Fi[	@ìiI"©require("twitter/error/unauthorized")
require("twitter/error/unprocessable_entity")
module Twitter
  module Response
    class RaiseError < Faraday::Response::Middleware;Fi[	@@«oi[[	@@i@I"£    # XML escape a string for use. Replaces any special characters with
    # appropriate HTML entity replacements.
    #
    # input - The String to escape.
    #;Fi[	@@iOI"§    # CGI escape a string for use in a URL. Replaces any special characters
    # with appropriate %XX replacements.
    #
    # input - The String to escape.
    #;Fi[	@@≥oi[[	@@i(I"q    
    # Format a date in long format e.g. "27 January 2011".
    #
    # date - The Time to format.
    #;Fi[	@@i1I"Z    
    # Format a date for use in XML.
    #
    # date - The Time to format.
    #;Fi[	@@¨oi[[	@@iI"|    #
    # input - The Textile String to convert.
    #
    # Returns the HTML formatted String.
    def function(var);Fi[	@@iI"}    #
    # input - The Markdown String to convert.
    #
    # Returns the HTML formatted String.
    def function(var);Fi[	@I"# Defaults to `false`.;Fi[[	@x/itI"”    # were present. Use with caution as this may cause whitespace-related
    # formatting errors.
    #
    # Defaults to `false`.
    # Whether or not attribute hashes and Ruby scripts designated by `=` or `~`;Fi[	@x/iyI"œ    # should be evaluated. If this is `true`, said scripts are rendered as empty
    # strings.
    #
    # Defaults to `false`.
    # If set to `true`, Haml makes no attempt to properly indent or format the;Fi[	@@[hi[[	@Ôi˘I"ﬂ    # (as is the default for Rails 3.0+, and optional for version 2.3.5+),
    # this won't escape text declared as "safe".
    #
    # @param text [String] The string to sanitize
    # @return [String] The sanitized string;Fi[	@ÔiI"›    # Escapes HTML entities in `text`, but without escaping an ampersand
    # that is already part of an escaped entity.
    #
    # @param text [String] The string to sanitize
    # @return [String] The sanitized string;Fi[	@I"#     click;Fi[[	@Ôi?I"j    # with no whitespace between.
    # For example:
    #
    #     click
    #     = succeed '.' do;Fi[	@ÔiEI"T    #
    # Produces:
    #
    #     click
    #     <a href='thing'>here</a>.;Fi[	@[>I""require("twitter/exceptable");Fi[[	@…iI"rrequire("forwardable")
require("twitter/creatable")
require("twitter/exceptable")
require("twitter/identity");Fi[	@Ü8iI"lrequire("twitter/basic_user")
require("twitter/creatable")
require("twitter/exceptable")
module Twitter;Fi[	@I"#     <h1>foo</h1>;Fi[[	@ÔiﬁI"N    #
    # Produces:
    #
    #     <h1>foo</h1>
    #       <p>bar</p>;Fi[	@Ôi˝I"P    #
    # Produces:
    #
    #     <h1>foo</h1>
    #         <p>bar</p>;Fi[	@I"#     %h1 foo;Fi[[	@Ôi÷I"f    # to the lines of the template.
    # For example:
    #
    #     %h1 foo
    #     - tab_up;Fi[	@ÔiˆI"y    # but only for the duration of the block.
    # For example:
    #
    #     %h1 foo
    #     - with_tabs(2) do;Fi[	@I"9#   @yield The block within which to escape newlines;Fi[[	@Ôi]I"›    # @overload find_and_preserve(tags = haml_buffer.options[:preserve])
    #   Escapes newlines within a block of Haml code.
    #
    #   @yield The block within which to escape newlines
    def function(var, var, var);Fi[	@ÔirI"®    # @overload perserve
    #   Escapes newlines within a block of Haml code.
    #
    #   @yield The block within which to escape newlines
    def function(var, var);Fi[	@@»gi[[	@ˇiFI"¢      # This is meant to be overridden by subclasses
      # so they can add their own options.
      #
      # @param opts [OptionParser]
      def function(var);Fi[	@ˇi¶I"|      
      # Tells optparse how to parse the arguments.
      #
      # @param opts [OptionParser]
      def function(var);Fi[	@,'I"require("twitter/cursor");Fi[[	@ÖiI"require("twitter/api/arguments")
require("twitter/api/utils")
require("twitter/cursor")
require("twitter/error/forbidden");Fi[	@iI"írequire("twitter/action_factory")
require("twitter/api/arguments")
require("twitter/api/utils")
require("twitter/cursor")
require("twitter/tweet");Fi[	@,'I"+require("twitter/core_ext/enumerable");Fi[[	@´iI"~require("twitter/api/arguments")
require("twitter/api/utils")
require("twitter/core_ext/enumerable")
require("twitter/cursor");Fi[	@iI"árequire("twitter/api/arguments")
require("twitter/api/utils")
require("twitter/core_ext/enumerable")
require("twitter/error/not_found");Fi[	@,'I"require("twitter/place");Fi[[	@Œi I"Irequire("twitter/api/utils")
require("twitter/place")
module Twitter;Fi [	@˙i I"Srequire("twitter/api/utils")
require("twitter/place")
require("twitter/trend");Fi [	@I"3# This is meant to be overridden by subclasses;Fi[[	@ˇiCI"¿      # Tells optparse how to parse the arguments
      # available for all executables.
      #
      # This is meant to be overridden by subclasses
      # so they can add their own options.;Fi[	@ˇi]I"Ÿ      # In particular, sets `@options[:input]` and `@options[:output]`
      # to appropriate IO streams.
      #
      # This is meant to be overridden by subclasses
      # so they can run their respective programs.;Fi[	@I"#     # This doesn't;Fi[[	@iåI"‡    #     Haml::Engine.new("%p= foo").render_proc(Object.new, :foo).call :foo => "Hello!"
    #       #=> "<p>Hello!</p>"
    #
    #     # This doesn't
    #     Haml::Engine.new("%p= foo").render_proc.call :foo => "Hello!";Fi[	@iºI"π    #     Haml::Engine.new("%p= foo").def_method(obj, :render, :foo)
    #     obj.render(:foo => "Hello!") #=> "<p>Hello!</p>"
    #
    #     # This doesn't
    #     obj = Object.new;Fi[	@I"#     # This works;Fi[[	@iàI"Ω    # This is done with the `local_names` argument.
    # For example:
    #
    #     # This works
    #     Haml::Engine.new("%p= foo").render_proc(Object.new, :foo).call :foo => "Hello!";Fi[	@i∑I"~    # This is done with the `local_names` argument.
    # For example:
    #
    #     # This works
    #     obj = Object.new;Fi[	@I"Z# @param scope [Binding, Proc, Object] The context in which the template is evaluated;Fi[[	@i]I"    # but if you're relying on local variables defined in the context of `scope`,
    # they won't work.
    #
    # @param scope [Binding, Proc, Object] The context in which the template is evaluated
    # @param locals [{Symbol => Object}] Local variables that will be made available;Fi[	@iíI"    #
    # The proc doesn't take a block; any yields in the template will fail.
    #
    # @param scope [Binding, Proc, Object] The context in which the template is evaluated
    # @param local_names [Array<Symbol>] The names of the locals that can be passed to the proc;Fi[	@n@å"i[[	@¢i,I"      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [String]
      # @example Return {https://twitter.com/privacy Twitter's Privacy Policy};Fi[	@¢i9I"      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [String]
      # @example Return {https://twitter.com/tos Twitter's Terms of Service};Fi[	@@Ügi[[	@i@I"ˇ    # Haml uses it as the second argument to `Kernel#eval`;
    # otherwise, Haml just uses its `#instance_eval` context.
    #
    # Note that Haml modifies the evaluation context
    # (either the scope object or the `self` object of the scope binding).;Fi[	@i¡I"#    #     Haml::Engine.new("%p= foo").def_method(obj, :render)
    #     obj.render(:foo => "Hello!") #=> NameError: undefined local variable or method `foo'
    #
    # Note that Haml modifies the evaluation context
    # (either the scope object or the `self` object of the scope binding).;Fi[	@@e,i[[	@≥
i4I"m  
  # Determine if we want to skip emailing the recipient.
  #
  # @return [Boolean]
  # @return [void];Fi[	@iKI"±    # as is the default for Rails 3.0+, and optional for version 2.3.5+.
    # Overridden in haml/template.rb if this is the case.
    #
    # @return [Boolean]
    def function;Fi[	@I"@#   * Validating if the model allows params authentication;;Fi[[	@≠
i;I"“      
      # Check if this is strategy is valid for http authentication by:
      #
      #   * Validating if the model allows params authentication;
      #   * If any of the authorization headers were sent;;Fi[	@≠
iEI"ﬂ      
      # Check if this is strategy is valid for params authentication by:
      #
      #   * Validating if the model allows params authentication;
      #   * If the request hits the sessions controller through POST;;Fi[	@nI"<# @return [Array<Twitter::Tweet>] The favorited Tweets.;Fi[[	@~iMI"      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>] The favorited Tweets.
      # @overload favorite(*ids);Fi[	@~ioI"[      # @authentication Requires user context
      # @raise [Twitter::Error::AlreadyFavorited] Error raised when tweet has already been favorited.
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>] The favorited Tweets.
      # @overload favorite(*ids);Fi[	@@tdi[[	@≥iZI"Ç      #
      # Examples:
      #
      #   sign_out :user     # sign_out(scope)
      #   sign_out @user     # sign_out(resource);Fi[	@Qi0I"}    #
    # Examples:
    #
    #   sign_out :user     # sign_out(scope)
    #   sign_out @user     # sign_out(resource);Fi[	@nI":# @return [Array<Twitter::User>] The requested users.;Fi[[	@ÖiGI"      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::User>] The requested users.
      # @overload friendships(*users);Fi[	@iÛI"      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::User>] The requested users.
      # @overload users(*users);Fi[	@nI"9# @return [Array<Twitter::User>] The followed users.;Fi[[	@Öi{I"      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::User>] The followed users.
      # @overload follow(*users);Fi[	@ÖièI"      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::User>] The followed users.
      # @overload follow!(*users);Fi[	@nI"&# @return [Twitter::Relationship];Fi[[	@Öi¿I"7      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Relationship]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.;Fi[	@Öi“I"O      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Relationship]
      # @param source [Integer, String, Twitter::User] The Twitter user ID, screen name, or object of the source user.;Fi[	@I"O# This function can be called one or more times in a compass configuration;Fi[[	@î!iI"-    #   Compass::BrowserSupport.add_support("image", "moz", "webkit")
    #   # => Adds support for moz and webkit to the image() function.
    #
    # This function can be called one or more times in a compass configuration
    # file in order to add support for new, simple browser functions without;Fi[	@î!i*I"/    #   Compass::BrowserSupport.remove_support("image", "o", "ms")
    #   # => Adds support for moz and webkit to the image() function.
    #
    # This function can be called one or more times in a compass configuration
    # file in order to remove support for simple functions that no longer need to;Fi[	@I"$#   can :manage, User, :id => 1;Fi[[	@—i@I"‡      #
      # If there is only one "can" definition, a hash of conditions will be returned matching the one defined.
      #
      #   can :manage, User, :id => 1
      #   query(:manage, User).conditions # => { :id => 1 };Fi[	@—iEI"À      #
      # If there are multiple "can" definitions, a SQL string will be returned to handle complex cases.
      #
      #   can :manage, User, :id => 1
      #   can :manage, User, :manager_id => 1;Fi[	@nI"0# @return [Twitter::List] The created list.;Fi[[	@´iÇI"      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::List] The created list.
      # @overload list_update(list, options={});Fi[	@´i°I"      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::List] The created list.
      # @param name [String] The name for the list.;Fi[	@nI"4# @return [Twitter::Tweet] The requested Tweet.;Fi[[	@i:I"      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Tweet] The requested Tweet.
      # @param id [Integer] A Tweet ID.;Fi[	@iQI"      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Tweet] The requested Tweet.
      # @param id [Integer] A Tweet ID.;Fi[	@nI"<# @return [Array<Twitter::Tweet>] The requested Tweets.;Fi[[	@iJI"      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>] The requested Tweets.
      # @overload statuses(*ids);Fi[	@idI"      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>] The requested Tweets.
      # @overload statuses_activity(*ids);Fi[	@nI"2# @return [Twitter::Tweet] The created Tweet.;Fi[[	@itI"8      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Tweet] The created Tweet.
      # @param status [String] The text of your status update, up to 140 characters.;Fi[	@i∫I"8      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Tweet] The created Tweet.
      # @param status [String] The text of your status update, up to 140 characters.;Fi[	@nI"Y# @return [Array<Twitter::Tweet>] The original tweets with retweet details embedded.;Fi[[	@iÑI"+      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>] The original tweets with retweet details embedded.
      # @overload retweet(*ids);Fi[	@iüI"x      # @authentication Requires user context
      # @raise [Twitter::Error::AlreadyRetweeted] Error raised when tweet has already been retweeted.
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>] The original tweets with retweet details embedded.
      # @overload retweet!(*ids);Fi[	@@bi[[	@ñiøI"%      # only do authorization on certain actions. You can pass :only and :except options to specify which actions to
      # skip the effects on. It will apply to all actions by default.
      #
      #   class ProjectsController < ApplicationController
      #     load_and_authorize_resource;Fi[	@ñiœI"      # only do loading on certain actions. You can pass :only and :except options to specify which actions to
      # skip the effects on. It will apply to all actions by default.
      #
      #   class ProjectsController < ApplicationController
      #     load_and_authorize_resource;Fi[	@@Íai[[	@ñipI"®      #
      #     load_resource :new => :build
      #
      # [:+prepend+]
      #   Passing +true+ will use prepend_before_filter instead of a normal before_filter.;Fi[	@ñi¶I"‚      # [:+through+]
      #   Authorize conditions on this parent resource when instance isn't available.
      #
      # [:+prepend+]
      #   Passing +true+ will use prepend_before_filter instead of a normal before_filter.;Fi[	@Œ+I"À# @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[[	@Öi_I"      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      # @example Return an array of numeric IDs for every user who has a pending request to follow the authenticating user;Fi[	@ÖinI"       # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      # @example Return an array of numeric IDs for every protected user for whom the authenticating user has a pending follow request;Fi[	@I"# [:+instance_name+];Fi[[	@ñi[I"ª      # [:+class+]
      #   The class to use for the model (string or constant).
      #
      # [:+instance_name+]
      #   The name of the instance variable to load the resource into.;Fi[	@ñi†I"N      #   The class to use for the model (string or constant). This passed in when the instance variable is not set.
      #   Pass +false+ if there is no associated class for this resource and it will use a symbol of the resource name.
      #
      # [:+instance_name+]
      #   The name of the instance variable for this resource.;Fi[	@I"# [:+class+];Fi[[	@ñiXI"      #   True or false depending on if the resource is considered a parent resource. This defaults to +true+ if a resource
      #   name is given which does not match the controller.
      #
      # [:+class+]
      #   The class to use for the model (string or constant).;Fi[	@ñiúI"H      #   True or false depending on if the resource is considered a parent resource. This defaults to +true+ if a resource
      #   name is given which does not match the controller.
      #
      # [:+class+]
      #   The class to use for the model (string or constant). This passed in when the instance variable is not set.;Fi[	@@’ai[[	@ñiTI"      # [:+singleton+]
      #   Pass +true+ if this is a singleton resource through a +has_one+ association.
      #
      # [:+parent+]
      #   True or false depending on if the resource is considered a parent resource. This defaults to +true+ if a resource;Fi[	@ñiòI"      # [:+singleton+]
      #   Pass +true+ if this is a singleton resource through a +has_one+ association.
      #
      # [:+parent+]
      #   True or false depending on if the resource is considered a parent resource. This defaults to +true+ if a resource;Fi[	@@«ai[[	@ñiQI"¯      # [:+shallow+]
      #   Pass +true+ to allow this resource to be loaded directly when parent is +nil+. Defaults to +false+.
      #
      # [:+singleton+]
      #   Pass +true+ if this is a singleton resource through a +has_one+ association.;Fi[	@ñiïI"¬      # [:+except+]
      #   Does not apply before filter to given actions.
      #
      # [:+singleton+]
      #   Pass +true+ if this is a singleton resource through a +has_one+ association.;Fi[	@T,I"Q# @option options [Integer] :page Specifies the page of results to retrieve.;Fi[[	@qiI"+      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Integer] :page Specifies the page of results to retrieve.
      # @example Return the 20 most recent direct messages sent to the authenticating user;Fi[	@qi,I"+      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Integer] :page Specifies the page of results to retrieve.
      # @example Return the 20 most recent direct messages sent by the authenticating user;Fi[	@I"# [:+through+];Fi[[	@ñiGI"·      # [:+except+]
      #   Does not apply before filter to given actions.
      #
      # [:+through+]
      #   Load this resource through another one. This should match the name of the parent instance variable or method.;Fi[	@ñi£I"Ã      # [:+instance_name+]
      #   The name of the instance variable for this resource.
      #
      # [:+through+]
      #   Authorize conditions on this parent resource when instance isn't available.;Fi[	I"'# @param id [Integer] A Tweet IDs.;F@Œ+i[[	@qi<I"Q      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::DirectMessage] The requested messages.
      # @param id [Integer] A Tweet IDs.
      # @param options [Hash] A customizable set of options.
      # @example Return the direct message with the id 1825786345;Fi[	@Ÿi5I"u      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::SavedSearch] The saved searches.
      # @param id [Integer] A Tweet IDs.
      # @param options [Hash] A customizable set of options.
      # @example Retrieve the data for a saved search owned by the authenticating user with the ID 16129012;Fi[	@@üai[[	@ñi;I"{      # Here the author resource will be loaded before each action using params[:author_id]. The book resource
      # will then be loaded through the @author instance variable.
      #
      # That first argument is optional and will default to the singular name of the controller.
      # A hash of options (see below) can also be passed to this method to further customize it.;Fi[	@ñiâI"0      #
      # Here it will authorize :+show+, @+author+ on every action before authorizing the book.
      #
      # That first argument is optional and will default to the singular name of the controller.
      # A hash of options (see below) can also be passed to this method to further customize it.;Fi[	@@òai[[	@ñiI"       # the initial attributes based on these conditions. This way these actions will satisfy
      # the ability restrictions.
      #
      # Call this method directly on the controller class.
      #;Fi[	@ñi~I"î      #
      #   authorize!(params[:action].to_sym, @article || Article)
      #
      # Call this method directly on the controller class.
      #;Fi[	@eI"y#   @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 100.;Fi[[	@~iI"ñ      #   Returns the 20 most recent favorite Tweets for the authenticating user
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 100.
      #   @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;Fi[	@~i!I"ß      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 100.
      #   @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;Fi[	@I"7#   alias_action :update, :destroy, :to => :modify;Fi[[	@ãiÄI"ê    
    # Alias one or more actions into another one.
    #
    #   alias_action :update, :destroy, :to => :modify
    #   can :modify, Comment;Fi[	@ãiãI"    # This only works in one direction. Passing the aliased action into the "can?" call
    # will not work because aliases are meant to generate more generic actions.
    #
    #   alias_action :update, :destroy, :to => :modify
    #   can :update, Comment;Fi[	@@ëai[[	@ãi4I"ã    
    # Convenience method which works the same as "can?" but returns the opposite value.
    #
    #   cannot? :destroy, @project
    #;Fi[	@ñiuI"ã    
    # Convenience method which works the same as "can?" but returns the opposite value.
    #
    #   cannot? :destroy, @project
    #;Fi[	@eI"\#   @option options [Boolean] :follow (false) Enable notifications for the target user.;Fi[[	@Öi~I"z      # @overload follow(*users, options)
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean] :follow (false) Enable notifications for the target user.
      def function(var);Fi[	@ÖióI"{      # @overload follow!(*users, options)
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean] :follow (false) Enable notifications for the target user.
      def function(var);Fi[	@@Éai[[	@ãi
I"â    #
    #   can? :destroy, @project
    #
    # You can also pass the class instead of an instance (if you don't have one handy).
    #;Fi[	@ñiaI"â    #
    #   can? :destroy, @project
    #
    # You can also pass the class instead of an instance (if you don't have one handy).
    #;Fi[	@eI"#   @option options [String] :mode ('public') Whether your list is public or private. Values can be 'public' or 'private'.;Fi[[	@´iÜI"ú      # @overload list_update(list, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [String] :mode ('public') Whether your list is public or private. Values can be 'public' or 'private'.
      #   @option options [String] :description The description to give the list.;Fi[	@´ièI"Œ      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [String] :mode ('public') Whether your list is public or private. Values can be 'public' or 'private'.
      #   @option options [String] :description The description to give the list.;Fi[	@@|ai[[	@ãiI"ã  module Ability
    # Check if the user has permission to perform a given action on an object.
    #
    #   can? :destroy, @project
    #;Fi[	@ñi_I"ì    # Use in the controller or view to check the user's permission for a given action
    # and object.
    #
    #   can? :destroy, @project
    #;Fi[	@eI"œ#     @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[[	@i8I"Ñ      #   Returns users following followers of the specified user
      #
      #   @param options [Hash] A customizable set of options.
      #     @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #     @return [Twitter::Cursor];Fi[	@iBI"§      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #     @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #     @return [Twitter::Cursor];Fi[	@@@ai[[	@8iI"        # are set via a super() call to RSync::Base,
        # which in turn will invoke Syncer::Base.
        #
        # Once pre-configured defaults and RSync specific defaults are set,
        # the block from the user's configuration file is evaluated.;Fi[	@Üi!I"        # are set via a super() call to RSync::Base,
        # which in turn will invoke Syncer::Base.
        #
        # Once pre-configured defaults and RSync specific defaults are set,
        # the block from the user's configuration file is evaluated.;Fi[	@ï7I"y#   @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[[	@qiPI"      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      #   @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      #   @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      #   @option options [Integer] :page Specifies the page of results to retrieve.;Fi[	@Îi2I"      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      #   @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      #   @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      #   @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@ï7I"L#   @option options [Integer] :count The number of results to retrieve.;Fi[[	@´i7I"ˆ      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      #   @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      #   @option options [Integer] :count The number of results to retrieve.
      #   @example Show tweet timeline for members of the authenticated user's "presidents" list;Fi[	@´iAI"Á      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      #   @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      #   @option options [Integer] :count The number of results to retrieve.
      #   @example Show tweet timeline for members of @sferik's "presidents" list;Fi[	I" #   Returns direct messages;F@i[[	@qiVI"¬      #     Twitter.direct_messages
      # @overload direct_messages(*ids)
      #   Returns direct messages
      #
      #   @see https://dev.twitter.com/docs/api/1.1/get/direct_messages/show;Fi[	@qi]I"◊      #     Twitter.direct_messages(1825786345)
      # @overload direct_messages(*ids, options)
      #   Returns direct messages
      #
      #   @see https://dev.twitter.com/docs/api/1.1/get/direct_messages/show;Fi[	@Hv@ i[[	@qiXI"      #   Returns direct messages
      #
      #   @see https://dev.twitter.com/docs/api/1.1/get/direct_messages/show
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @example Return the direct message with the id 1825786345;Fi[	@qi_I"       #   Returns direct messages
      #
      #   @see https://dev.twitter.com/docs/api/1.1/get/direct_messages/show
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.;Fi[	@@ai[[	@}i%I"        # are set via a super() call to Cloud::Base,
        # which in turn will invoke Syncer::Base.
        #
        # Once pre-configured defaults and Cloud specific defaults are set,
        # the block from the user's configuration file is evaluated.;Fi[	@ÄiI"        # are set via a super() call to Cloud::Base,
        # which in turn will invoke Syncer::Base.
        #
        # Once pre-configured defaults and Cloud specific defaults are set,
        # the block from the user's configuration file is evaluated.;Fi[	@ I"<#   @example Favorite the Tweet with the ID 25938088801;Fi[[	@~iPI"      # @return [Array<Twitter::Tweet>] The favorited Tweets.
      # @overload favorite(*ids)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @example Favorite the Tweet with the ID 25938088801
      #     Twitter.favorite(25938088801);Fi[	@~irI"      # @return [Array<Twitter::Tweet>] The favorited Tweets.
      # @overload favorite(*ids)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @example Favorite the Tweet with the ID 25938088801
      #     Twitter.favorite(25938088801);Fi[	@ I";#   @example Retweet the Tweet with the ID 28561922516;Fi[[	@iáI"+      # @return [Array<Twitter::Tweet>] The original tweets with retweet details embedded.
      # @overload retweet(*ids)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @example Retweet the Tweet with the ID 28561922516
      #     Twitter.retweet(28561922516);Fi[	@i¢I"-      # @return [Array<Twitter::Tweet>] The original tweets with retweet details embedded.
      # @overload retweet!(*ids)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @example Retweet the Tweet with the ID 28561922516
      #     Twitter.retweet!(28561922516);Fi[	@ÿ@Ei[[	@qicI"–      #   @param options [Hash] A customizable set of options.
      def function(var)
        var = Twitter::API::Arguments.new(var)
        if var.empty? then
          direct_messages_received(var.options);Fi[	@Ÿi&I"¯      #   @param options [Hash] A customizable set of options.
      def function(var)
        var = Twitter::API::Arguments.new(var)
        if var.empty? then
          objects_from_response(Twitter::SavedSearch, "LITERAL", "STRING", var.options);Fi[	@I"# @api private;Fi[[	@ziHI"b      #     notify_by Mail
      #   end
      #
      # @api private
      def function(var);Fi[	@ziXI"«      # Cleanup is also ensured, as temporary files may hold sensitive data.
      # If no options can be built, the packaging process will be aborted.
      #
      # @api private
      def function;Fi[	@I"6#   Backup::Model.new(:my_backup, 'My Backup') do;Fi[[	@zi‹I"      # here is the same as that used in {#keys}. Also, all spaces will be stripped
      # from the identifier when used, so the following would be valid.
      #
      #   Backup::Model.new(:my_backup, 'My Backup') do
      #     encrypt_with GPG do |enc|;Fi[	@ziI"ú      #     enc.passphrase = 'secret phrase'
      #   end
      #
      #   Backup::Model.new(:my_backup, 'My Backup') do
      #     # other directives...;Fi[	@ÿI"Gvar.options["LITERAL"] = true if var.options.delete("LITERAL").!.!;Fi[[	@ÖiÅI"      #   @option options [Boolean] :follow (false) Enable notifications for the target user.
      def function(var)
        var = Twitter::API::Arguments.new(var)
        var.options["LITERAL"] = true if var.options.delete("LITERAL").!.!
        var = Thread.new { friend_ids.ids };Fi[	@ÖiöI"      #   @option options [Boolean] :follow (false) Enable notifications for the target user.
      def function(var)
        var = Twitter::API::Arguments.new(var)
        var.options["LITERAL"] = true if var.options.delete("LITERAL").!.!
        var.flatten.threaded_map do |var|;Fi[	@@◊]i[[	@-*iI"ª      ##
      # Specify the level of compression to use.
      #
      # Values should be a single digit from 1 to 9.
      # Note that setting the level to either extreme may or may not;Fi[	@0*iI"ª      ##
      # Specify the level of compression to use.
      #
      # Values should be a single digit from 1 to 9.
      # Note that setting the level to either extreme may or may not;Fi[	@I"5#    # The following queries will be equivalent:;Fi[[	@JimI"Ö    #
    #    author = Author.find(1)
    #
    #    # The following queries will be equivalent:
    #    Post.where(author: author);Fi[	@JivI"Ï    #    treasure = Treasure.create(name: 'gold coins')
    #    treasure.price_estimates << PriceEstimate.create(price: 125)
    #
    #    # The following queries will be equivalent:
    #    PriceEstimate.where(estimate_of: treasure);Fi[	@I"#   User.group(:name);Fi[[	@JiΩI"Ü    
    # Allows to specify a group attribute:
    #
    #   User.group(:name)
    #   => SELECT "users".* FROM "users" GROUP BY name;Fi[	@Ji≈I"Ù    #   User.select([:id, :name])
    #   => [#<User id: 1, name: "Oscar">, #<User id: 2, name: "Oscar">, #<User id: 3, name: "Foo">
    #
    #   User.group(:name)
    #   => [#<User id: 3, name: "Foo", ...>, #<User id: 2, name: "Oscar", ...>];Fi[	@@[i[[	@JiI"Ã      #    User.where.not(["name = ?", "Jon"])
      #    # SELECT * FROM users WHERE NOT (name = 'Jon')
      #
      #    User.where.not(name: "Jon")
      #    # SELECT * FROM users WHERE name != 'Jon';Fi[	@JiãI"    # If no argument is passed, #where returns a new instance of WhereChain, that
    # can be chained with #not to return a new relation that negates the where clause.
    #
    #    User.where.not(name: "Jon")
    #    # SELECT * FROM users WHERE name != 'Jon';Fi[	@@1Zi[[	@1iTI"î    
    # Saves the model.
    #
    # If the model is new a record gets created in the database, otherwise
    # the existing record gets updated.;Fi[	@1ijI"î    
    # Saves the model.
    #
    # If the model is new a record gets created in the database, otherwise
    # the existing record gets updated.;Fi[	I"'require("twitter/error/forbidden");F@i[[	@i I"Drequire("twitter/error/forbidden")
module Twitter
  class Error;Fi [	@i I"Drequire("twitter/error/forbidden")
module Twitter
  class Error;Fi [	@I"+#   class Invoice < ActiveRecord::Base;Fi[[	@&i I"e      #
      # ==== Examples
      #
      #   class Invoice < ActiveRecord::Base
      #   end;Fi[	@&i&I"‡      #   file                  class               table_name
      #   invoice.rb            Invoice             invoices
      #
      #   class Invoice < ActiveRecord::Base
      #     class Lineitem < ActiveRecord::Base;Fi[	@Ëy@î7i[[	@~iI"û      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 100.
      #   @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      #   @example Return the 20 most recent favorite Tweets for the authenticating user;Fi[	@~i"I"Ë      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 100.
      #   @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      #   @example Return the 20 most recent favorite Tweets for @sferik;Fi[	@I",#   user = User.find_by_name('Phusion');Fi[[	@#iI"÷    # <tt>resources :users</tt> route. Normally, +user_path+ will
    # construct a path with the user object's 'id' in it:
    #
    #   user = User.find_by_name('Phusion')
    #   user_path(user)  # => "/users/1";Fi[	@#i%I"    #     end
    #   end
    #
    #   user = User.find_by_name('Phusion')
    #   user_path(user)  # => "/users/Phusion";Fi[	@I"H# ====== Add a backend specific option to the generated SQL (MySQL);Fi[[	@ÜiI"˚      #   Set to true to drop the table before creating it.
      #   Defaults to false.
      #
      # ====== Add a backend specific option to the generated SQL (MySQL)
      #  create_table(:suppliers, options: 'ENGINE=InnoDB DEFAULT CHARSET=utf8');Fi[	@ÜiæI"	      #   Set to true to drop the table before creating it.
      #   Defaults to false.
      #
      # ====== Add a backend specific option to the generated SQL (MySQL)
      #  create_join_table(:assemblies, :parts, options: 'ENGINE=InnoDB DEFAULT CHARSET=utf8');Fi[	@bMI""merge_user!(var.options, var);Fi[[	@~i(I"ò      def function(var)
        var = Twitter::API::Arguments.new(var)
        if var = var.pop then
          merge_user!(var.options, var)
        end;Fi[	@i I"‹      def function(var)
        var = Twitter::API::Arguments.new(var)
        if var = var.pop then
          merge_user!(var.options, var)
          object_from_response(Twitter::User, "LITERAL", "STRING", var.options);Fi[	@:v@Ói[[	@~iJI"ÿ      # Favorites the specified Tweets as the authenticating user
      #
      # @see https://dev.twitter.com/docs/api/1.1/post/favorites/create
      # @rate_limited No
      # @authentication Requires user context;Fi[	@~ikI"      # Favorites the specified Tweets as the authenticating user and raises an error if one has already been favorited
      #
      # @see https://dev.twitter.com/docs/api/1.1/post/favorites/create
      # @rate_limited No
      # @authentication Requires user context;Fi[	@GyI"# @overload favorite(*ids);Fi[[	@~iNI"@      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>] The favorited Tweets.
      # @overload favorite(*ids)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.;Fi[	@~ipI"x      # @raise [Twitter::Error::AlreadyFavorited] Error raised when tweet has already been favorited.
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>] The favorited Tweets.
      # @overload favorite(*ids)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.;Fi[	@ºz@ i[[	@~iOI"P      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>] The favorited Tweets.
      # @overload favorite(*ids)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @example Favorite the Tweet with the ID 25938088801;Fi[	@~iqI"P      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>] The favorited Tweets.
      # @overload favorite(*ids)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @example Favorite the Tweet with the ID 25938088801;Fi[	@DzI"(#     Twitter.favorite(25938088801);Fi[[	@~iQI"˝      # @overload favorite(*ids)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @example Favorite the Tweet with the ID 25938088801
      #     Twitter.favorite(25938088801)
      # @overload favorite(*ids, options);Fi[	@~isI"˝      # @overload favorite(*ids)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @example Favorite the Tweet with the ID 25938088801
      #     Twitter.favorite(25938088801)
      # @overload favorite(*ids, options);Fi[	@…zI"(# @overload favorite(*ids, options);Fi[[	@~iRI"'      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @example Favorite the Tweet with the ID 25938088801
      #     Twitter.favorite(25938088801)
      # @overload favorite(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.;Fi[	@~itI"'      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @example Favorite the Tweet with the ID 25938088801
      #     Twitter.favorite(25938088801)
      # @overload favorite(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.;Fi[	@–z@ i[[	@~iSI"      #   @example Favorite the Tweet with the ID 25938088801
      #     Twitter.favorite(25938088801)
      # @overload favorite(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.;Fi[	@~iuI"      #   @example Favorite the Tweet with the ID 25938088801
      #     Twitter.favorite(25938088801)
      # @overload favorite(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.;Fi[	@I"9# The +options+ hash can include the following keys:;Fi[[	@ÜipI"æ      #  # Add a column to 'suppliers'.
      #  add_column(:suppliers, :name, :string, {limit: 60})
      #
      # The +options+ hash can include the following keys:
      # [<tt>:id</tt>];Fi[	@Üi‰I"ì      #    # Other column alterations here
      #  end
      #
      # The +options+ hash can include the following keys:
      # [<tt>:bulk</tt>];Fi[	@®^I",rescue Twitter::Error::Forbidden => var;Fi[[	@~iZI",        var.flatten.threaded_map do |var|
          begin
            object_from_response(Twitter::Tweet, "LITERAL", "STRING", var.options.merge("LITERAL" => (var)))
          rescue Twitter::Error::Forbidden => var
            raise unless (var.message == Twitter::Error::AlreadyFavorited::MESSAGE);Fi[	@~i|I""        var.flatten.threaded_map do |var|
          begin
            object_from_response(Twitter::Tweet, "LITERAL", "STRING", var.options.merge("LITERAL" => (var)))
          rescue Twitter::Error::Forbidden => var
            handle_forbidden_error(Twitter::Error::AlreadyFavorited, var);Fi[	@˝x@çzi[[	@ÖiI"örequire("twitter/api/arguments")
require("twitter/api/utils")
require("twitter/cursor")
require("twitter/error/forbidden")
require("twitter/relationship");Fi[	@´iI"£require("twitter/api/utils")
require("twitter/core_ext/enumerable")
require("twitter/cursor")
require("twitter/error/forbidden")
require("twitter/error/not_found");Fi[	@I"%# ====== Creating a simple index;Fi[[	@i+I"“      # Adds a new index to the table. +column_name+ can be a single Symbol, or
      # an Array of Symbols. See SchemaStatements#add_index
      #
      # ====== Creating a simple index
      #  t.index(:name);Fi[	@ÜinI"—      # The index will be named after the table and the column name(s), unless
      # you pass <tt>:name</tt> as an option.
      #
      # ====== Creating a simple index
      #  add_index(:suppliers, :name);Fi[	@c%@Œ+i[[	@Öi^I"«      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@ÖimI"«      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@I"&#   create_table :taggings do |t|;Fi[[	@i∫I";      # options, these will be used when creating the <tt>_type</tt> column. The <tt>:index</tt> option
      # will also create an index, similar to calling <tt>add_index</tt>. So what can be written like this:
      #
      #   create_table :taggings do |t|
      #     t.integer :tag_id, :tagger_id, :taggable_id;Fi[	@iƒI"ª      #
      # Can also be written as follows using references:
      #
      #   create_table :taggings do |t|
      #     t.references :tag, index: { name: 'index_taggings_on_tag_id' };Fi[	@I"&#   create_table :products do |t|;Fi[[	@i°I"™      #
      # What can be written like this with the regular calls to column:
      #
      #   create_table :products do |t|
      #     t.column :shop_id,    :integer;Fi[	@i¨I"†      #
      # can also be written as follows using the short-hand:
      #
      #   create_table :products do |t|
      #     t.integer :shop_id, :creator_id;Fi[	@@≈Si[[	@ÙiI"¥      # Returns the value of the attribute identified by +attr_name+ before
      # typecasting and deserialization.
      #
      #   class Task < ActiveRecord::Base
      #   end;Fi[	@¸i€I"ÿ    # to objects that respond to <tt>empty?</tt>, most notably Strings). Otherwise, +false+.
    # Note that it always returns +true+ with boolean attributes.
    #
    #   class Task < ActiveRecord::Base
    #   end;Fi[	@9@•8i[[	@ÖiI"Ü      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.;Fi[	@Öi#I"Ü      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.;Fi[	@I"R# (+association+ is replaced with the symbol passed as the first argument, so;Fi[[	@ÒiwI"8      #   Does the same as <tt>create_association</tt>, but raises <tt>ActiveRecord::RecordInvalid</tt>
      #   if the record is invalid.
      #
      # (+association+ is replaced with the symbol passed as the first argument, so
      # <tt>has_one :manager</tt> would add among others <tt>manager.nil?</tt>.);Fi[	@Òi›I"9      #   Does the same as <tt>create_association</tt>, but raises <tt>ActiveRecord::RecordInvalid</tt>
      #   if the record is invalid.
      #
      # (+association+ is replaced with the symbol passed as the first argument, so
      # <tt>belongs_to :author</tt> would add among others <tt>author.nil?</tt>.);Fi[	@@aSi[[	@ÒifI"Î      #
      # The following methods for retrieval and query of a single associated object will be added:
      #
      # [association(force_reload = false)]
      #   Returns the associated object. +nil+ is returned if none is found.;Fi[	@ÒiŒI"      # Methods will be added for retrieval and query for a single associated object, for which
      # this object holds an id:
      #
      # [association(force_reload = false)]
      #   Returns the associated object. +nil+ is returned if none is found.;Fi[	@@ﬁ:i[[	@ÒiÏI"ô      #
      # === Options
      #
      # [:class_name]
      #   Specify the class name of the association. Use it only if that name can't be inferred;Fi[	@ÒiïI"ô      #
      # === Options
      #
      # [:class_name]
      #   Specify the class name of the association. Use it only if that name can't be inferred;Fi[	@@±Ri[[	@ÒiºI"      # Specifies a one-to-many association. The following methods for retrieval and query of
      # collections of associated objects will be added:
      #
      # [collection(force_reload = false)]
      #   Returns an array of all the associated objects.;Fi[	@ÒiTI"∞      #
      # Adds the following methods for retrieval and query:
      #
      # [collection(force_reload = false)]
      #   Returns an array of all the associated objects.;Fi[	@Ñ @•8i[[	@ÖiI"Ä      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.;Fi[	@Öi-I"Ä      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.;Fi[	@Ñ I"◊#   @option options [Boolean, String, Integer] :filter_to_owned_lists When set to true, t or 1, will return just lists the authenticating user owns, and the user represented by user_id or screen_name is a member of.;Fi[[	@´iwI"e      # @overload memberships(options={})
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :filter_to_owned_lists When set to true, t or 1, will return just lists the authenticating user owns, and the user represented by user_id or screen_name is a member of.
      #   @example List the lists the authenticated user has been added to;Fi[	@´i~I"ì      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :filter_to_owned_lists When set to true, t or 1, will return just lists the authenticating user owns, and the user represented by user_id or screen_name is a member of.
      #   @example List the lists that @sferik has been added to;Fi[	@I"#   person.pets == other;Ti[[	@≤iJI"l      #
      #   other = person.pets.to_ary
      #
      #   person.pets == other
      #   # => true;Ti[	@≤iOI"{      #
      #   other = [Pet.new(id: 1), Pet.new(id: 2)]
      #
      #   person.pets == other
      #   # => false;Ti[	@i I"G#   @example Return extended information for @sferik and @pengwynn;Fi[[	@ÖiJI"|      # @return [Array<Twitter::User>] The requested users.
      # @overload friendships(*users)
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @example Return extended information for @sferik and @pengwynn
      #     Twitter.friendships('sferik', 'pengwynn');Fi[	@iˆI"©      # @return [Array<Twitter::User>] The requested users.
      # @overload users(*users)
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @example Return extended information for @sferik and @pengwynn
      #     Twitter.users('sferik', 'pengwynn')  # Retrieve users with a POST request using screen_names;Fi[	@i I" #   @example Follow @sferik;Fi[[	@Öi~I">      # @return [Array<Twitter::User>] The followed users.
      # @overload follow(*users)
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @example Follow @sferik
      #     Twitter.follow('sferik');Fi[	@ÖiíI"@      # @return [Array<Twitter::User>] The followed users.
      # @overload follow!(*users)
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @example Follow @sferik
      #     Twitter.follow!('sferik');Fi[	@3v@Ói[[	@ÖixI"ˇ      # Allows the authenticating user to follow the specified users, unless they are already followed
      #
      # @see https://dev.twitter.com/docs/api/1.1/post/friendships/create
      # @rate_limited No
      # @authentication Requires user context;Fi[	@ÖiåI"›      # Allows the authenticating user to follow the specified users
      #
      # @see https://dev.twitter.com/docs/api/1.1/post/friendships/create
      # @rate_limited No
      # @authentication Requires user context;Fi[	@¸y@£i[[	@ÖiI"      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean] :follow (false) Enable notifications for the target user.
      def function(var)
        var = Twitter::API::Arguments.new(var);Fi[	@ÖiòI"      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean] :follow (false) Enable notifications for the target user.
      def function(var)
        var = Twitter::API::Arguments.new(var);Fi[	@by@£i[[	@DiI"|    #
    # @param attrs [Hash]
    # @return [Twitter::Relationship]
    def function(var)
      @var = var["LITERAL"];Fi[	@DiI"ö    #
    # @param attrs [Hash]
    # @return [Twitter::Relationship]
    def function(var)
      @attrs.update(var["LITERAL"]) unless var["LITERAL"].nil?;Fi[	@I"##   person.pets.many? do |pet|;Ti[[	@≤i	I"í      #   #      #<Pet name: "Snoop", group: "dogs">
      #   #    ]
      #
      #   person.pets.many? do |pet|
      #     pet.group == 'dogs';Ti[	@≤iI"t      #   end
      #   # => false
      #
      #   person.pets.many? do |pet|
      #     pet.group == 'cats';Ti[	I"u# @param source [Integer, String, Twitter::User] The Twitter user ID, screen name, or object of the source user.;FI"u# @param target [Integer, String, Twitter::User] The Twitter user ID, screen name, or object of the target user.;Fi[[	@Öi‘I"ª      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Relationship]
      # @param source [Integer, String, Twitter::User] The Twitter user ID, screen name, or object of the source user.
      # @param target [Integer, String, Twitter::User] The Twitter user ID, screen name, or object of the target user.
      # @param options [Hash] A customizable set of options.;Fi[	@ÖiÓI"›      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Boolean] true if user_a follows user_b, otherwise false.
      # @param source [Integer, String, Twitter::User] The Twitter user ID, screen name, or object of the source user.
      # @param target [Integer, String, Twitter::User] The Twitter user ID, screen name, or object of the target user.
      # @param options [Hash] A customizable set of options.;Fi[	@m{@Œ+i[[	@Öi’I"ô      # @return [Twitter::Relationship]
      # @param source [Integer, String, Twitter::User] The Twitter user ID, screen name, or object of the source user.
      # @param target [Integer, String, Twitter::User] The Twitter user ID, screen name, or object of the target user.
      # @param options [Hash] A customizable set of options.
      # @example Return the relationship between @sferik and @pengwynn;Fi[	@ÖiÔI"Æ      # @return [Boolean] true if user_a follows user_b, otherwise false.
      # @param source [Integer, String, Twitter::User] The Twitter user ID, screen name, or object of the source user.
      # @param target [Integer, String, Twitter::User] The Twitter user ID, screen name, or object of the target user.
      # @param options [Hash] A customizable set of options.
      # @example Return true if @sferik follows @pengwynn;Fi[	@I""#   person.pets.any? do |pet|;Ti[[	@≤i„I"ñ      #   person.pets
      #   # => [#<Pet name: "Snoop", group: "dogs">]
      #
      #   person.pets.any? do |pet|
      #     pet.group == 'cats';Ti[	@≤iËI"s      #   end
      #   # => false
      #
      #   person.pets.any? do |pet|
      #     pet.group == 'dogs';Ti[	@@[Qi[[	@≤i:I"ü      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size  # => 0
      #   person.pets       # => [];Ti[	@≤iZI"õ      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   person.pets.size  # => 0
      #   person.pets       # => [];Ti[	@¶8@[Ni[[	@ÖiI"û      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids;Fi[	@Öi%I"û      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids;Fi[	@I"E# You can pass +Fixnum+ or +String+ values, it finds the records;Ti[[	@≤iˇI"È      #   Pet.find(1)
      #   # => ActiveRecord::RecordNotFound: Couldn't find Pet with id=1
      #
      # You can pass +Fixnum+ or +String+ values, it finds the records
      # responding to the +id+ and executes delete on them.;Ti[	@≤i?I"      #
      #   Pet.find(1, 2, 3) # => ActiveRecord::RecordNotFound: Couldn't find all Pets with IDs (1, 2, 3)
      #
      # You can pass +Fixnum+ or +String+ values, it finds the records
      # responding to the +id+ and then deletes them from the database.;Ti[	@I"#   Pet.find(1);Ti[[	@≤iƒI"Ø      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1)
      #   # => #<Pet id: 1, name: "Fancy-Fancy", person_id: nil>;Ti[	@≤i¸I"∑      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1)
      #   # => ActiveRecord::RecordNotFound: Couldn't find Pet with id=1;Ti[	@dI"i#   @param user_to_remove [Integer, String] The user id or screen name of the list member to remove.;Fi[[	@´iYI"u      # @return [Twitter::List] The list.
      # @overload list_remove_member(list, user_to_remove, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param user_to_remove [Integer, String] The user id or screen name of the list member to remove.
      #   @param options [Hash] A customizable set of options.;Fi[	@´ibI"≥      # @overload list_remove_member(user, list, user_to_remove, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param user_to_remove [Integer, String] The user id or screen name of the list member to remove.
      #   @param options [Hash] A customizable set of options.;Fi[	@dI"i#   @param user_to_check [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.;Fi[[	@´iæI"ß      # @return [Boolean] true if user is a subscriber of the specified list, otherwise false.
      # @overload list_subscriber?(list, user_to_check, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param user_to_check [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.;Fi[	@´i«I"∞      # @overload list_subscriber?(user, list, user_to_check, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param user_to_check [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.;Fi[	@dI"^#   @param user_to_check [Integer, String] The user ID or screen name of the list member.;Fi[[	@´iI"î      # @return [Boolean] true if user is a member of the specified list, otherwise false.
      # @overload list_member?(list, user_to_check, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param user_to_check [Integer, String] The user ID or screen name of the list member.
      #   @param options [Hash] A customizable set of options.;Fi[	@´iI"°      # @overload list_member?(user, list, user_to_check, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param user_to_check [Integer, String] The user ID or screen name of the list member.
      #   @param options [Hash] A customizable set of options.;Fi[	@dI"\#   @param user_to_add [Integer, String] The user id or screen name to add to the list.;Fi[[	@´iNI"b      # @return [Twitter::List] The list.
      # @overload list_add_member(list, user_to_add, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param user_to_add [Integer, String] The user id or screen name to add to the list.
      #   @param options [Hash] A customizable set of options.;Fi[	@´iVI"†      # @overload list_add_member(user, list, user_to_add, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param user_to_add [Integer, String] The user id or screen name to add to the list.
      #   @param options [Hash] A customizable set of options.;Fi[	@@GQi[[	@≤i∫I"√      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>];Ti[	@≤iÚI"√      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>];Ti[	@õ{@ei[[	@´iZI"¢      # @overload list_remove_member(list, user_to_remove, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param user_to_remove [Integer, String] The user id or screen name of the list member to remove.
      #   @param options [Hash] A customizable set of options.
      #   @example Remove @BarackObama from the authenticated user's "presidents" list;Fi[	@´icI"Æ      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param user_to_remove [Integer, String] The user id or screen name of the list member to remove.
      #   @param options [Hash] A customizable set of options.
      #   @example Remove @BarackObama from @sferik's "presidents" list;Fi[	@¢{@ei[[	@´iøI"Ø      # @overload list_subscriber?(list, user_to_check, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param user_to_check [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @example Check if @BarackObama is a subscriber of the authenticated user's "presidents" list;Fi[	@´i»I"æ      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param user_to_check [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @example Check if @BarackObama is a subscriber of @sferik's "presidents" list;Fi[	@©{@ei[[	@´iI"ú      # @overload list_member?(list, user_to_check, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param user_to_check [Integer, String] The user ID or screen name of the list member.
      #   @param options [Hash] A customizable set of options.
      #   @example Check if @BarackObama is a member of the authenticated user's "presidents" list;Fi[	@´iI"Ø      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param user_to_check [Integer, String] The user ID or screen name of the list member.
      #   @param options [Hash] A customizable set of options.
      #   @example Check if @BarackObama is a member of @sferik's "presidents" list;Fi[	@∞{@ei[[	@´iOI"ä      # @overload list_add_member(list, user_to_add, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param user_to_add [Integer, String] The user id or screen name to add to the list.
      #   @param options [Hash] A customizable set of options.
      #   @example Add @BarackObama to the authenticated user's "presidents" list;Fi[	@´iWI"ú      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param user_to_add [Integer, String] The user id or screen name to add to the list.
      #   @param options [Hash] A customizable set of options.
      #   @example Add @BarackObama to @sferik's "presidents" list;Fi[	@	zI"P#   @option options [String] :description The description to give the list.;Fi[[	@´iáI"ˆ      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [String] :mode ('public') Whether your list is public or private. Values can be 'public' or 'private'.
      #   @option options [String] :description The description to give the list.
      #   @example Update the authenticated user's "presidents" list to have the description "Presidents of the United States of America";Fi[	@´iêI"Î      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [String] :mode ('public') Whether your list is public or private. Values can be 'public' or 'private'.
      #   @option options [String] :description The description to give the list.
      #   @example Update the @sferik's "presidents" list to have the description "Presidents of the United States of America";Fi[	@@	Qi[[	@≤iI"´      #   person.pets.concat(Pet.new(name: 'Spook'), Pet.new(name: 'Choo-Choo'))
      #   person.pets.size # => 3
      #
      #   person.id # => 1
      #   person.pets;Ti[	@≤iâI"®      #   person.pets << [Pet.new(name: 'Spook'), Pet.new(name: 'Choo-Choo')]
      #   person.pets.size # => 3
      #
      #   person.id # => 1
      #   person.pets;Ti[	@@∏Pi[[	@≤i/I"ç      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.select(:name)
      #   # => [;Ti[	@≤ihI"j      #     has_many :pets
      #   end
      #
      #   person.pets.select(:name)
      #   # => [;Ti[	@@'Pi[[	@Øi≥I"      # query if the collection hasn't been loaded, and calling
      # <tt>collection.size</tt> if it has.
      #
      # If the collection has been already loaded +size+ and +length+ are
      # equivalent. If not and you are going to need the records anyway;Fi[	@≤iàI"I      # Returns the size of the collection. If the collection hasn't been loaded,
      # it executes a <tt>SELECT COUNT(*)</tt> query. Else it calls <tt>collection.size</tt>.
      #
      # If the collection has been already loaded +size+ and +length+ are
      # equivalent. If not and you are going to need the records anyway;Ti[	@I"# Options are:;Fi[[	@iI"3      # Adds reader and writer methods for manipulating a value object:
      # <tt>composed_of :address</tt> adds <tt>address</tt> and <tt>address=(new_address)</tt> methods.
      #
      # Options are:
      # * <tt>:class_name</tt> - Specifies the class name of the association. Use it only if that name;Fi[	@ÒiáI"¢      #
      # The declaration can also include an options hash to specialize the behavior of the association.
      #
      # Options are:
      # [:class_name];Fi[	@Õ,@›Ni[[	@i)I"û      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array]
      def function(var, var, var, var);Fi[	@iEI"û      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array]
      def function(var, var, var, var);Fi[	@ M@.i[[	@´iI"‡        begin
          (var = Twitter::API::Arguments.new(var)
          merge_user!(var.options, var.pop)
          merge_list!(var.options, var.pop)
          unless (var.options["LITERAL"] or var.options["LITERAL"]) then;Fi[	@´i(I"Î      def function(var, var, var)
        var = Twitter::API::Arguments.new(var)
        merge_user!(var.options, var.pop)
        merge_list!(var.options, var.pop)
        unless (var.options["LITERAL"] or var.options["LITERAL"]) then;Fi[	@∂)I"^# @param user [Integer, String, Twitter::User] A Twitter user ID, screen_name, or object.;Fi[[	@i}I"›      # Take a user and merge it into the hash with the correct key
      #
      # @param hash [Hash]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen_name, or object.
      # @return [Hash];Fi[	@iÜI"›      # Take a user and merge it into the hash with the correct key
      #
      # @param hash [Hash]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen_name, or object.
      # @return [Hash];Fi[	@∂)I"ì# @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen_names, or objects.;Fi[[	@iôI"$      # Take a multiple users and merge them into the hash with the correct keys
      #
      # @param hash [Hash]
      # @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen_names, or objects.
      # @return [Hash];Fi[	@i¢I"$      # Take a multiple users and merge them into the hash with the correct keys
      #
      # @param hash [Hash]
      # @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen_names, or objects.
      # @return [Hash];Fi[	@∂)I"# @param key [Symbol];Fi[[	@≈)iI"é    # Return a hash that includes everything but the given keys.
    #
    # @param hash [Hash]
    # @param key [Symbol]
    # @return [Hash];Fi[	@≈)i I"}    # Replaces the hash without the given keys.
    #
    # @param hash [Hash]
    # @param key [Symbol]
    # @return [Hash];Fi[	@@pQi[[	@òi◊I"‹    #   person.name = 'david'
    #   person.valid? # => true
    #
    # Context can optionally be supplied to define which callbacks to test
    # against (the context is defined on the validations using <tt>:on</tt>).;Fi[	@òi˛I"ﬂ    #   person.name = 'david'
    #   person.invalid? # => false
    #
    # Context can optionally be supplied to define which callbacks to test
    # against (the context is defined on the validations using <tt>:on</tt>).;Fi[	I"&# @return [Array<Twitter::Place>];FI"T# @example Return the locations that Twitter has trending topic information for;Fi[[	@˙i*I"F      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @return [Array<Twitter::Place>]
      # @example Return the locations that Twitter has trending topic information for
      #   Twitter.trends_available;Fi[	@˙i<I"ö      # @option options [Float] :lat If provided with a :long option the available trend locations will be sorted by distance, nearest to furthest, to the co-ordinate pair. The valid ranges for latitude are -90.0 to +90.0 (North is positive) inclusive.
      # @option options [Float] :long If provided with a :lat option the available trend locations will be sorted by distance, nearest to furthest, to the co-ordinate pair. The valid ranges for longitude are -180.0 to +180.0 (East is positive) inclusive.
      # @return [Array<Twitter::Place>]
      # @example Return the locations that Twitter has trending topic information for
      #   Twitter.trends_closest;Fi[	I"«# @option options [String] :contained_within This is the place_id which you would like to restrict the search results to. Setting this value means only places within the given place_id will be found.;FI"Ï# @option options [String] :"attribute:street_address" This option searches for places which have this given street address. There are other well-known and application-specific attributes available. Custom attributes are also permitted.;Fi[[	@Œi=I"°      # @option options [String] :accuracy ('0m') A hint on the "region" in which to search. If a number, then this is a radius in meters, but it can also take a string that is suffixed with ft to specify feet. If coming from a device, in practice, this value is whatever accuracy the device has measuring its location (whether it be coming from a GPS, WiFi triangulation, etc.).
      # @option options [Integer] :max_results A hint as to the number of results to return. This does not guarantee that the number of results returned will equal max_results, but instead informs how many "nearby" results to return. Ideally, only pass in the number of places you intend to display to the user here.
      # @option options [String] :contained_within This is the place_id which you would like to restrict the search results to. Setting this value means only places within the given place_id will be found.
      # @option options [String] :"attribute:street_address" This option searches for places which have this given street address. There are other well-known and application-specific attributes available. Custom attributes are also permitted.
      # @return [Array<Twitter::Place>];Fi[	@ŒiSI"V      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :name The name a place is known as.
      # @option options [String] :contained_within This is the place_id which you would like to restrict the search results to. Setting this value means only places within the given place_id will be found.
      # @option options [String] :"attribute:street_address" This option searches for places which have this given street address. There are other well-known and application-specific attributes available. Custom attributes are also permitted.
      # @return [Array<Twitter::Place>];Fi[	@%|@|i[[	@Œi>I"r      # @option options [Integer] :max_results A hint as to the number of results to return. This does not guarantee that the number of results returned will equal max_results, but instead informs how many "nearby" results to return. Ideally, only pass in the number of places you intend to display to the user here.
      # @option options [String] :contained_within This is the place_id which you would like to restrict the search results to. Setting this value means only places within the given place_id will be found.
      # @option options [String] :"attribute:street_address" This option searches for places which have this given street address. There are other well-known and application-specific attributes available. Custom attributes are also permitted.
      # @return [Array<Twitter::Place>]
      # @example Return an array of places near the IP address 74.125.19.104;Fi[	@ŒiTI"n      # @option options [String] :name The name a place is known as.
      # @option options [String] :contained_within This is the place_id which you would like to restrict the search results to. Setting this value means only places within the given place_id will be found.
      # @option options [String] :"attribute:street_address" This option searches for places which have this given street address. There are other well-known and application-specific attributes available. Custom attributes are also permitted.
      # @return [Array<Twitter::Place>]
      # @example Return an array of places similar to Twitter HQ;Fi[	I"C# @option options [String] :name The name a place is known as.;F@$|i[[	@ŒiRI"      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :name The name a place is known as.
      # @option options [String] :contained_within This is the place_id which you would like to restrict the search results to. Setting this value means only places within the given place_id will be found.
      # @option options [String] :"attribute:street_address" This option searches for places which have this given street address. There are other well-known and application-specific attributes available. Custom attributes are also permitted.;Fi[	@ŒieI"2      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [String] :name The name a place is known as.
      # @option options [String] :contained_within This is the place_id which you would like to restrict the search results to. Setting this value means only places within the given place_id will be found.
      # @option options [String] :token The token found in the response from {Twitter::API::PlacesAndGeo#places_similar}.;Fi[	@@˚Qi[[	@òi@I"¬      #
      #     validate :must_be_friends
      #
      #     def must_be_friends
      #       errors.add(:base, 'Must be friends to leave a comment') unless commenter.friend_of?(commentee);Fi[	@òiNI"       #       comment.must_be_friends
      #     end
      #
      #     def must_be_friends
      #       errors.add(:base, 'Must be friends to leave a comment') unless commenter.friend_of?(commentee);Fi[	@›N@Ÿi[[	@ŒiwI"€      # @param path [String]
      # @param params [Hash]
      # @return [Array]
      def function(var, var, var)
        objects_from_array(Twitter::Place, send(var.to_sym, var, var)["LITERAL"]["LITERAL"]["LITERAL"]);Fi[	@Îi´I"û      # @param collection [Array]
      # @param max_id [Integer, NilClass]
      # @return [Array]
      def function(var, var, var)
        var = yield(var);Fi[	@I"##     def instance_validations;Fi[[	@ãinI"~    #
    #     validate :instance_validations
    #
    #     def instance_validations
    #       validates_with MyValidator;Fi[	@ãi}I"ù    #
    #     validate :instance_validations, on: :create
    #
    #     def instance_validations
    #       validates_with MyValidator, MyOtherValidator;Fi[	I"N#   Retrieve the data for saved searches owned by the authenticating user;F@i[[	@ŸiI"Ô      #     Twitter.saved_searches
      # @overload saved_search(*ids)
      #   Retrieve the data for saved searches owned by the authenticating user
      #
      #   @see https://dev.twitter.com/docs/api/1.1/get/saved_searches/show/:id;Fi[	@Ÿi I"       #     Twitter.saved_search(16129012)
      # @overload saved_search(*ids, options)
      #   Retrieve the data for saved searches owned by the authenticating user
      #
      #   @see https://dev.twitter.com/docs/api/1.1/get/saved_searches/show/:id;Fi[	@&v@ i[[	@ŸiI"`      #   Retrieve the data for saved searches owned by the authenticating user
      #
      #   @see https://dev.twitter.com/docs/api/1.1/get/saved_searches/show/:id
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @example Retrieve the data for a saved search owned by the authenticating user with the ID 16129012;Fi[	@Ÿi"I"1      #   Retrieve the data for saved searches owned by the authenticating user
      #
      #   @see https://dev.twitter.com/docs/api/1.1/get/saved_searches/show/:id
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.;Fi[	@I"L# If you pass any additional configuration options, they will be passed;Fi[[	@ãiJI""      # * <tt>:strict</tt> - Specifies whether validation should be strict.
      #   See <tt>ActiveModel::Validation#validates!</tt> for more information.
      #
      # If you pass any additional configuration options, they will be passed
      # to the class and available as +options+:;Fi[	@ãiÇI"    # +validates_with+, should instead be placed on the +validates+ method
    # as these are applied and tested in the callback.
    #
    # If you pass any additional configuration options, they will be passed
    # to the class and available as +options+, please refer to the;Fi[	@ª5I"7# @example Update the authenticating user's status;Fi[[	@i}I"=      # @option options [String] :place_id A place in the world. These IDs can be retrieved from {Twitter::API::PlacesAndGeo#reverse_geocode}.
      # @option options [String] :display_coordinates Whether or not to put a pin on the exact coordinates a tweet has been sent from.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @example Update the authenticating user's status
      #   Twitter.update("I'm tweeting with @gem!");Fi[	@iƒI"i      # @option options [String] :place_id A place in the world. These IDs can be retrieved from {Twitter::API::PlacesAndGeo#reverse_geocode}.
      # @option options [String] :display_coordinates Whether or not to put a pin on the exact coordinates a tweet has been sent from.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @example Update the authenticating user's status
      #   Twitter.update_with_media("I'm tweeting with @gem!", File.new('my_awesome_pic.jpeg'));Fi[	@@Si[[	@ãi2I"l      #       end
      #   end
      #
      # You may also pass it multiple classes, like so:
      #;Fi[	@ãivI"∞    # Please consult the class method documentation for more information on
    # creating your own validator.
    #
    # You may also pass it multiple classes, like so:
    #;Fi[	@@
Si[[	@ãi%I"í      #     validates_with MyValidator
      #   end
      #
      #   class MyValidator < ActiveModel::Validator
      #     def validate(record);Fi[	@ãiRI"¥      #     validates_with MyValidator, my_custom_key: 'my custom value'
      #   end
      #
      #   class MyValidator < ActiveModel::Validator
      #     def validate(record);Fi[	@@ÛSi[[	@iI"˙      # values are +true+ and +false+), you will want to use
      # <tt>validates_inclusion_of :field_name, in: [true, false]</tt>.
      #
      # This is due to the way Object#blank? handles boolean values:
      # <tt>false.blank? # => true</tt>.;Fi[	@ni%I"Ô      # are true and false), you will want to use
      # <tt>validates_inclusion_of :field_name, in: [true, false]</tt>.
      #
      # This is due to the way Object#blank? handles boolean values:
      # <tt>false.blank? # => true</tt>.;Fi[	@@ˇIi[[	@li:I"w        #
        #     attr_accessor :name, :status
        #
        #     validates_presence_of :name
        #;Fi[	@òiçI"ë      #
      #     attr_accessor :name , :age
      #
      #     validates_presence_of :name
      #     validates_inclusion_of :age, in: 0..99;Fi[	@OI"}# @option options [Boolean, String, Integer] :include_entities The tweet entities node will be disincluded when set to false.;Fi[[	@ÎizI"A      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :include_rts Specifies that the timeline should include native retweets in addition to regular tweets. Note: If you're using the trim_user parameter in conjunction with include_rts, the retweets will no longer contain a full user object.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @option options [Boolean, String, Integer] :include_entities The tweet entities node will be disincluded when set to false.
      # @example Return the 20 most recent Tweets, including retweets if they exist, posted by the authenticating user and the users they follow;Fi[	@ÎiãI"≤      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @option options [Boolean, String, Integer] :include_entities The tweet entities node will be disincluded when set to false.
      # @example Return the 20 most recent retweets posted by users followed by the authenticating user;Fi[	@vI"N# @note This method can only return up to 800 Tweets, including retweets.;Fi[[	@ÎimI"G      # Returns the 20 most recent Tweets, including retweets if they exist, posted by the authenticating user and the users they follow
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/home_timeline
      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes;Fi[	@ÎiI"      # Returns the 20 most recent retweets posted by users the authenticating user follow.
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/home_timeline
      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes;Fi[	@Ü|@(	i[[	@ÎinI"Ï      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/home_timeline
      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	@ÎiÄI"Ï      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/home_timeline
      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	@v@(	i[[	@iI"‹      # Returns up to 100 of the first retweets of a given tweet
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/retweets/:id
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	@i#I"–      # Show up to 100 users who retweeted the Tweet
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/retweets/:id
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	I"A# @param id [Integer] The numerical ID of the desired Tweet.;F@Œ+i[[	@iI"â      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param id [Integer] The numerical ID of the desired Tweet.
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 100.;Fi[	@i(I"y      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array]
      # @param id [Integer] The numerical ID of the desired Tweet.
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 100.;Fi[	@*:@M(i[[	@iI"ç      # @return [Array] An array of actions
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 100.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @example Return activity about me;Fi[	@i(I"è      # @return [Array] An array of actions
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 100.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @example Return activity by friends;Fi[	@*:@ª5i[[	@iI"      # @param id [Integer] The numerical ID of the desired Tweet.
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 100.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @example Return up to 100 of the first retweets of the Tweet with the ID 28561922516;Fi[	@i*I"      # @param id [Integer] The numerical ID of the desired Tweet.
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 100.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean] :ids_only ('false') Only return user ids instead of full user objects.;Fi[	@˚u@(	i[[	@i7I"Ø      # Returns a Tweet
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/show/:id
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	@iGI"Æ      # Returns Tweets
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/show/:id
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	@~yI"&# @param id [Integer] A Tweet ID.;Fi[[	@i;I"1      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Tweet] The requested Tweet.
      # @param id [Integer] A Tweet ID.
      # @param options [Hash] A customizable set of options.;Fi[	@iRI"1      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Tweet] The requested Tweet.
      # @param id [Integer] A Tweet ID.
      # @param options [Hash] A customizable set of options.;Fi[	@≤|@Œ+i[[	@i<I"æ      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Tweet] The requested Tweet.
      # @param id [Integer] A Tweet ID.
      # @param options [Hash] A customizable set of options.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@iSI"R      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Tweet] The requested Tweet.
      # @param id [Integer] A Tweet ID.
      # @param options [Hash] A customizable set of options.
      # @example Return activity summary for the Tweet with the ID 25938088801;Fi[	@åyI"S# @param status [String] The text of your status update, up to 140 characters.;Fi[[	@iuI"\      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Tweet] The created Tweet.
      # @param status [String] The text of your status update, up to 140 characters.
      # @param options [Hash] A customizable set of options.;Fi[	@iªI"t      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Tweet] The created Tweet.
      # @param status [String] The text of your status update, up to 140 characters.
      # @param media [File, Hash] A File object with your picture (PNG, JPEG or GIF);Fi[	I"˛# @option options [Float] :lat The latitude of the location this tweet refers to. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.;FI"7# @option options [Float] :long The longitude of the location this tweet refers to. The valid ranges for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.;Fi[[	@iyI"Ñ      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :in_reply_to_status_id The ID of an existing status that the update is in reply to.
      # @option options [Float] :lat The latitude of the location this tweet refers to. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude of the location this tweet refers to. The valid ranges for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :place_id A place in the world. These IDs can be retrieved from {Twitter::API::PlacesAndGeo#reverse_geocode}.;Fi[	@i¿I"É      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :in_reply_to_status_id The ID of an existing Tweet that the update is in reply to.
      # @option options [Float] :lat The latitude of the location this tweet refers to. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude of the location this tweet refers to. The valid ranges for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :place_id A place in the world. These IDs can be retrieved from {Twitter::API::PlacesAndGeo#reverse_geocode}.;Fi[	@«|I"à# @option options [String] :place_id A place in the world. These IDs can be retrieved from {Twitter::API::PlacesAndGeo#reverse_geocode}.;Fi[[	@izI"Œ      # @option options [Integer] :in_reply_to_status_id The ID of an existing status that the update is in reply to.
      # @option options [Float] :lat The latitude of the location this tweet refers to. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude of the location this tweet refers to. The valid ranges for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :place_id A place in the world. These IDs can be retrieved from {Twitter::API::PlacesAndGeo#reverse_geocode}.
      # @option options [String] :display_coordinates Whether or not to put a pin on the exact coordinates a tweet has been sent from.;Fi[	@i¡I"Õ      # @option options [Integer] :in_reply_to_status_id The ID of an existing Tweet that the update is in reply to.
      # @option options [Float] :lat The latitude of the location this tweet refers to. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude of the location this tweet refers to. The valid ranges for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :place_id A place in the world. These IDs can be retrieved from {Twitter::API::PlacesAndGeo#reverse_geocode}.
      # @option options [String] :display_coordinates Whether or not to put a pin on the exact coordinates a tweet has been sent from.;Fi[	@Œ|I"Ä# @option options [String] :display_coordinates Whether or not to put a pin on the exact coordinates a tweet has been sent from.;Fi[[	@i{I"      # @option options [Float] :lat The latitude of the location this tweet refers to. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude of the location this tweet refers to. The valid ranges for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :place_id A place in the world. These IDs can be retrieved from {Twitter::API::PlacesAndGeo#reverse_geocode}.
      # @option options [String] :display_coordinates Whether or not to put a pin on the exact coordinates a tweet has been sent from.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@i¬I"      # @option options [Float] :lat The latitude of the location this tweet refers to. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude of the location this tweet refers to. The valid ranges for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :place_id A place in the world. These IDs can be retrieved from {Twitter::API::PlacesAndGeo#reverse_geocode}.
      # @option options [String] :display_coordinates Whether or not to put a pin on the exact coordinates a tweet has been sent from.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@’|@ª5i[[	@i|I"G      # @option options [Float] :long The longitude of the location this tweet refers to. The valid ranges for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :place_id A place in the world. These IDs can be retrieved from {Twitter::API::PlacesAndGeo#reverse_geocode}.
      # @option options [String] :display_coordinates Whether or not to put a pin on the exact coordinates a tweet has been sent from.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @example Update the authenticating user's status;Fi[	@i√I"G      # @option options [Float] :long The longitude of the location this tweet refers to. The valid ranges for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :place_id A place in the world. These IDs can be retrieved from {Twitter::API::PlacesAndGeo#reverse_geocode}.
      # @option options [String] :display_coordinates Whether or not to put a pin on the exact coordinates a tweet has been sent from.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @example Update the authenticating user's status;Fi[	@Ùu@(	i[[	@iÅI"‹      # Retweets the specified Tweets as the authenticating user
      #
      # @see https://dev.twitter.com/docs/api/1.1/post/statuses/retweet/:id
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	@iõI"      # Retweets the specified Tweets as the authenticating user and raises an error if one has already been retweeted
      #
      # @see https://dev.twitter.com/docs/api/1.1/post/statuses/retweet/:id
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	@õ^@‰zi[[	@iíI"Í        var.flatten.threaded_map do |var|
          begin
            post_retweet(var, var.options)
          rescue Twitter::Error::Forbidden => var
            raise unless (var.message == Twitter::Error::AlreadyRetweeted::MESSAGE);Fi[	@i≠I"‡        var.flatten.threaded_map do |var|
          begin
            post_retweet(var, var.options)
          rescue Twitter::Error::Forbidden => var
            handle_forbidden_error(Twitter::Error::AlreadyRetweeted, var);Fi[	@Ìu@(	i[[	@iÕI"∏      # Returns oEmbed for a Tweet
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/oembed
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	@i„I"∏      # Returns oEmbeds for Tweets
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/oembed
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	@@ Xi[[	@`ijI"â      #
      #     attr_accessor :name, :age, :awesome
      #
      #     def attributes=(hash)
      #       hash.each do |key, value|;Fi[	@ci∆I"â      #
      #     attr_accessor :name, :age, :awesome
      #
      #     def attributes=(hash)
      #       hash.each do |key, value|;Fi[	I"*# @return [Array] An array of actions;F@Œ+i[[	@iI"x      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array] An array of actions
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 100.;Fi[	@i&I"y      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid./
      # @return [Array] An array of actions
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 100.;Fi[	@zI"$#     @return [Twitter::Cursor];Fi[[	@i9I"~      #
      #   @param options [Hash] A customizable set of options.
      #     @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #     @return [Twitter::Cursor]
      #   @example Return users follow followers of @sferik;Fi[	@iCI"ÿ      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #     @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #     @return [Twitter::Cursor]
      #   @example Return users follow followers of @sferik;Fi[	@}I":#   @example Return users follow followers of @sferik;Fi[[	@i:I"°      #   @param options [Hash] A customizable set of options.
      #     @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #     @return [Twitter::Cursor]
      #   @example Return users follow followers of @sferik
      #     Twitter.following_followers_of;Fi[	@iDI"´      #   @param options [Hash] A customizable set of options.
      #     @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #     @return [Twitter::Cursor]
      #   @example Return users follow followers of @sferik
      #     Twitter.following_followers_of('sferik');Fi[	@@ÕXi[[	@`ihI"â      #   class Person
      #     include ActiveModel::Serializers::JSON
      #
      #     attr_accessor :name, :age, :awesome
      #;Fi[	@ciƒI"à      #   class Person
      #     include ActiveModel::Serializers::Xml
      #
      #     attr_accessor :name, :age, :awesome
      #;Fi[	@Êu@(	i[[	@iùI"·      # Returns an array of numeric user ids the authenticating user is blocking
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/blocks/ids
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	@iÆI"⁄      # Returns true if the authenticating user is blocking a target user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/blocks/ids
      # @rate_limited Yes
      # @authentication Requires user context;Fi[	@@yYi[[	@]iEI"É    #   class MyClass
    #     include ActiveModel::Validations
    #
    #     def initialize(data = {})
    #       @data = data;Fi[	@òiI"É    #   class MyClass
    #     include ActiveModel::Validations
    #
    #     def initialize(data = {})
    #       @data = data;Fi[	I"&# @param collection_name [Symbol];F@›0i[[	@iXI"|      end
      
      # @param collection_name [Symbol]
      # @param klass [Class]
      # @param request_method [Symbol];Fi[	@igI"|      end
      
      # @param collection_name [Symbol]
      # @param klass [Class]
      # @param request_method [Symbol];Fi[	I""# @param method_name [Symbol];F@c%i[[	@i]I"Ø      # @param path [String]
      # @param args [Array]
      # @param method_name [Symbol]
      # @return [Twitter::Cursor]
      def function(var, var, var, var, var, var);Fi[	@ilI"±      # @param path [String]
      # @param options [Hash]
      # @param method_name [Symbol]
      # @return [Twitter::Cursor]
      def function(var, var, var, var, var, var);Fi[	I"B# Take a user and merge it into the hash with the correct key;F@i[[	@i{I"|      end
      
      # Take a user and merge it into the hash with the correct key
      #
      # @param hash [Hash];Fi[	@iÑI"|      end
      
      # Take a user and merge it into the hash with the correct key
      #
      # @param hash [Hash];Fi[	@|@E-i[[	@i~I"ª      #
      # @param hash [Hash]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen_name, or object.
      # @return [Hash]
      def function(var, var, var);Fi[	@iáI"ª      #
      # @param hash [Hash]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen_name, or object.
      # @return [Hash]
      def function(var, var, var);Fi[	I"O# Take a multiple users and merge them into the hash with the correct keys;F@i[[	@ióI"Ñ      end
      
      # Take a multiple users and merge them into the hash with the correct keys
      #
      # @param hash [Hash];Fi[	@i†I"Ñ      end
      
      # Take a multiple users and merge them into the hash with the correct keys
      #
      # @param hash [Hash];Fi[	@|@E-i[[	@iöI"      #
      # @param hash [Hash]
      # @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen_names, or objects.
      # @return [Hash]
      def function(var, var);Fi[	@i£I"      #
      # @param hash [Hash]
      # @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen_names, or objects.
      # @return [Hash]
      def function(var, var);Fi[	I"4require("twitter/error/identity_map_key_error");F@i[[	@oi I"Prequire("twitter/error/identity_map_key_error")
module Twitter
  class Base;Fi [	@[iI"|require("twitter/base")
require("twitter/error/identity_map_key_error")
module Twitter
  class Identity < Twitter::Base;Fi[	I"def self.fetch(var);FI"return unless identity_map;Fi[[	@oiI"    end
    
    def self.fetch(var)
      return unless identity_map
      if var = identity_map.fetch(Marshal.dump(var)) then;Fi[	@[i	I"Émodule Twitter
  class Identity < Twitter::Base
    def self.fetch(var)
      return unless identity_map
      var = var["LITERAL"];Fi[	I"def self.store(var);FI"#return var unless identity_map;Fi[[	@oi$I"Ä    end
    
    def self.store(var)
      return var unless identity_map
      identity_map.store(Marshal.dump(var.attrs), var);Fi[	@[iI"t    end
    
    def self.store(var)
      return var unless identity_map
      identity_map.store(var.id, var);Fi[	@@õYi[[	@]iBI"Õ    # the attribute. Override this method in subclasses should you need to
    # retrieve the value for a given attribute differently:
    #
    #   class MyClass
    #     include ActiveModel::Validations;Fi[	@òiI"∞    # method in subclasses should you need to retrieve the value for a given
    # attribute differently:
    #
    #   class MyClass
    #     include ActiveModel::Validations;Fi[	@t*@byi[[	@Di
I"    # Initializes a new object
    #
    # @param attrs [Hash]
    # @return [Twitter::Relationship]
    def function(var);Fi[	@DiI"â    # Update the attributes of a Relationship
    #
    # @param attrs [Hash]
    # @return [Twitter::Relationship]
    def function(var);Fi[	@t*I"# @return [Twitter::Base];Fi[[	@oi8I"w    # Initializes a new object
    #
    # @param attrs [Hash]
    # @return [Twitter::Base]
    def function(var);Fi[	@oiOI"|    # Update the attributes of an object
    #
    # @param attrs [Hash]
    # @return [Twitter::Base]
    def function(var);Fi[	@l}@£i[[	@oi9I"i    #
    # @param attrs [Hash]
    # @return [Twitter::Base]
    def function(var)
      @var = var;Fi[	@oiPI"q    #
    # @param attrs [Hash]
    # @return [Twitter::Base]
    def function(var)
      @attrs.update(var);Fi[	@Åp@g7i[[	@oiRI"d    # @return [Twitter::Base]
    def function(var)
      @attrs.update(var)
      self
    end;Fi[	@ri.I"i    # @return [Twitter::RateLimit]
    def function(var)
      @attrs.update(var)
      self
    end;Fi[	I"## @param other [Twitter::Base];F@e,i[[	@oiYI"z    
    # @param attr [Symbol]
    # @param other [Twitter::Base]
    # @return [Boolean]
    def function(var, var);Fi[	@oi_I"b    end
    
    # @param other [Twitter::Base]
    # @return [Boolean]
    def function(var);Fi[	@I"=# Specify +options+ with additional translating options.;Fi[[	@AiûI"ë    #
    #   BlogPost.model_name.human # => "Blog post"
    #
    # Specify +options+ with additional translating options.
    def function(var);Fi[	@ÅiI"ß    #
    #   Person.human_attribute_name("first_name") # => "First name"
    #
    # Specify +options+ with additional translating options.
    def function(var, var);Fi[	I"require("faraday");FI"require("multi_json");Fi[[	I"-projects//twitter_proj/twitter/client.rb;Ti I"Trequire("faraday")
require("multi_json")
require("twitter/api/direct_messages");Fi [	@i I"<require("faraday")
require("multi_json")
module Twitter;Fi [	@I"#  class Person;Fi[[	@>iI"Å    
    # Indicates if the model is persisted. Default is +false+.
    #
    #  class Person
    #    include ActiveModel::Model;Fi[	@òiúI"°      
      # Returns +true+ if +attribute+ is an attribute method, +false+ otherwise.
      #
      #  class Person
      #    include ActiveModel::Validations;Fi[	@I"U#   person.errors.messages # => {:name=>["can not be nil", "must be specified"]};Fi[[	@9iI"œ    
    # Returns all message values.
    #
    #   person.errors.messages # => {:name=>["can not be nil", "must be specified"]}
    #   person.errors.values   # => [["can not be nil", "must be specified"]];Fi[	@9iÇI"´    
    # Returns all message keys.
    #
    #   person.errors.messages # => {:name=>["can not be nil", "must be specified"]}
    #   person.errors.keys     # => [:name];Fi[	@I"A#   person.errors.full_messages # => ["name can not be nil"];Fi[[	@9i!I"á    
    # Clear the error messages.
    #
    #   person.errors.full_messages # => ["name can not be nil"]
    #   person.errors.clear;Fi[	@9iûI"Ì    # Returns +true+ if no errors are found, +false+ otherwise.
    # If the error message is a string it can be empty.
    #
    #   person.errors.full_messages # => ["name can not be nil"]
    #   person.errors.empty?        # => false;Fi[	@I"#   person = Person.create;Fi[[	@0i I"~    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.create
    #   person.to_key # => [1];Fi[	@0i-I"{    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.create
    #   person.to_param # => "1";Fi[	@I"$#     def clear_attribute(attr);Fi[[	@ i,I"r      #
      #     private
      #
      #     def clear_attribute(attr)
      #       send("#{attr}=", nil);Fi[	@ i¥I"`      #
      #     private
      #
      #     def clear_attribute(attr)
      #       ...;Fi[	I"# @return [Time];F@:i[[	I"0projects//twitter_proj/twitter/creatable.rb;Ti
I"ñ    # Time when the object was created on Twitter
    #
    # @return [Time]
    def function
      @var ||= Time.parse(@attrs["LITERAL"]) if created?;Fi[	@riI"T    end
    
    # @return [Time]
    def function
      var = @attrs["STRING"];Fi[	I"L# Uses +method_missing+ and <tt>respond_to?</tt> to rewrite the method.;F@i[[	@ iI"Â    module ClassMethods
      # Declares a method available for all attributes with the given prefix.
      # Uses +method_missing+ and <tt>respond_to?</tt> to rewrite the method.
      #
      #   #{prefix}#{attr}(*args, &block);Fi[	@ i=I"‘      
      # Declares a method available for all attributes with the given suffix.
      # Uses +method_missing+ and <tt>respond_to?</tt> to rewrite the method.
      #
      #   #{attr}#{suffix}(*args, &block);Fi[	@)@¯i[[	@0iAI"K    end
    
    module ClassMethods
      #:nodoc:
      def function;Fi[	@@iI"K    end
    
    module ClassMethods
      #:nodoc:
      def function;Fi[	@$@ò6i[[	@8i	I"y    extend(ActiveSupport::Concern)
    
    included do
      class_attribute("LITERAL")
      self.reflections = {};Fi[	I";projects//activerecord_proj/active_record/timestamp.rb;Ti	I"|    extend(ActiveSupport::Concern)
    
    included do
      class_attribute("LITERAL")
      self.record_timestamps = true;Fi[	I"A# Return a hash that includes everything but the given keys.;F@i[[	@≈)i	I"w    private
    
    # Return a hash that includes everything but the given keys.
    #
    # @param klass [Class];Fi[	@≈)iI"q    end
    
    # Return a hash that includes everything but the given keys.
    #
    # @param hash [Hash];Fi[	@|@E-i[[	@≈)iI"m    #
    # @param hash [Hash]
    # @param key [Symbol]
    # @return [Hash]
    def function(var, var);Fi[	@≈)i!I"m    #
    # @param hash [Hash]
    # @param key [Symbol]
    # @return [Hash]
    def function(var, var);Fi[	I"require("twitter/geo");F@i[[	@∞i I"6require("twitter/geo")
module Twitter
  class Geo;Fi [	@´xi I"6require("twitter/geo")
module Twitter
  class Geo;Fi [	@RI"module Serializers;Fi[[	@`iI"[require("active_support/json")
module ActiveModel
  module Serializers
    module JSON;Fi[	@ci
I"ñrequire("active_support/core_ext/hash/slice")
require("active_support/core_ext/time/acts_like")
module ActiveModel
  module Serializers
    module Xml;Fi[	I"# @return [Twitter::Geo];F@:i[[	@∑iI"ì    alias "LITERAL" "LITERAL"
    
    # @return [Twitter::Geo]
    def function
      @var ||= Twitter::GeoFactory.fetch_or_new(@attrs["LITERAL"]);Fi[	@…iBI"}    end
    
    # @return [Twitter::Geo]
    def function
      @var ||= Twitter::GeoFactory.fetch_or_new(@attrs["LITERAL"]);Fi[	I"## @return [Twitter::RateLimit];F@£i[[	@riI"q    alias "LITERAL" "LITERAL"
    
    # @return [Twitter::RateLimit]
    def function(var)
      @var = var;Fi[	@ri,I"v    #
    # @param attrs [Hash]
    # @return [Twitter::RateLimit]
    def function(var)
      @attrs.update(var);Fi[	I"# @return [Twitter::Place];F@:i[[	@Ii
I"Ú    attr_reader("LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL", "LITERAL")
    
    # @return [Twitter::Place]
    def function
      @var ||= Twitter::Place.fetch_or_new(Array(@attrs["LITERAL"]).first);Fi[	@…iXI"    end
    
    # @return [Twitter::Place]
    def function
      @var ||= Twitter::Place.fetch_or_new(@attrs["LITERAL"]);Fi[	I"## @param other [Twitter::Size];F@e,i[[	@LiI"x    alias "LITERAL" "LITERAL"
    
    # @param other [Twitter::Size]
    # @return [Boolean]
    def function(var);Fi[	@LiI"h    protected
    
    # @param other [Twitter::Size]
    # @return [Boolean]
    def function(var);Fi[	I""require("twitter/basic_user");F@i[[	I"2projects//twitter_proj/twitter/source_user.rb;Ti I"Yrequire("twitter/basic_user")
module Twitter
  class SourceUser < Twitter::BasicUser;Fi [	I"2projects//twitter_proj/twitter/target_user.rb;Ti I"Yrequire("twitter/basic_user")
module Twitter
  class TargetUser < Twitter::BasicUser;Fi [	I"# @return [Twitter::Tweet];F@:i[[	@…iqI"∑    # If this Tweet is a retweet, the original Tweet is available here.
    #
    # @return [Twitter::Tweet]
    def function
      @var ||= self.class.fetch_or_new(@attrs["LITERAL"]);Fi[	@Ü8i\I"©    alias "LITERAL" "LITERAL"
    
    # @return [Twitter::Tweet]
    def function
      @var ||= fetch_or_new_without_self(Twitter::Tweet, @attrs, "LITERAL", "LITERAL");Fi[	@ﬂu@å"i[[	@Ü8i0I"˝    # Return the URL to the user's profile banner image
    #
    # @param size [String, Symbol] The size of the image. Must be one of: 'mobile', 'mobile_retina', 'web', 'web_retina', 'ipad', or 'ipad_retina'
    # @return [String]
    def function(var);Fi[	@Ü8i:I"    # Return the secure URL to the user's profile banner image
    #
    # @param size [String, Symbol] The size of the image. Must be one of: 'mobile', 'mobile_retina', 'web', 'web_retina', 'ipad', or 'ipad_retina'
    # @return [String]
    def function(var);Fi[	@ u@å"i[[	@Ü8iHI"÷    # Return the URL to the user's profile image
    #
    # @param size [String, Symbol] The size of the image. Must be one of: 'mini', 'normal', 'bigger' or 'original'
    # @return [String]
    def function(var);Fi[	@Ü8iPI"›    # Return the secure URL to the user's profile image
    #
    # @param size [String, Symbol] The size of the image. Must be one of: 'mini', 'normal', 'bigger' or 'original'
    # @return [String]
    def function(var);Fi[	I""_cset("LITERAL") { "STRING" };F@(~i[[	@7<iI"π  _cset("LITERAL") { fetch("LITERAL") }
  _cset("LITERAL") { fetch("LITERAL", "STRING") }
  _cset("LITERAL") { "STRING" }
  _cset("LITERAL") { "STRING" }
  _cset("LITERAL") { "STRING" };Fi[	@7<iI"´  _cset("LITERAL") { fetch("LITERAL", "STRING") }
  _cset("LITERAL") { "STRING" }
  _cset("LITERAL") { "STRING" }
  _cset("LITERAL") { "STRING" }
  namespace("LITERAL") do;Fi[	I"module Whenever;FI"module Output;Fi[[	@6iI"Frequire("chronic")
module Whenever
  module Output
    class Cron;Fi[	@|i I":module Whenever
  module Output
    class Redirection;Fi [	I"var.close!;F@q6i[[	@uiNI"        var = "STRING" if @options["LITERAL"]
        puts("STRING")
        var.close!
        exit("LITERAL")
      else;Fi[	@uiRI"[      else
        warn("STRING")
        var.close!
        exit("LITERAL")
      end;Fi[	@q6@|i[[	@uiOI"h        puts("STRING")
        var.close!
        exit("LITERAL")
      else
        warn("STRING");Fi[	@uiZI"      if read_crontab.=~(Regexp.new("STRING")) and read_crontab.=~(Regexp.new("STRING")).nil? then
        warn("STRING")
        exit("LITERAL")
      else
        if read_crontab.=~(Regexp.new("STRING")).nil? and read_crontab.=~(Regexp.new("STRING")) then;Fi[	I"?var["LITERAL"] = @at.is_a?(Time) ? (@at.min) : ("LITERAL");FI"@var["LITERAL"] = @at.is_a?(Time) ? (@at.hour) : ("LITERAL");Fi[[	@6ixI"G        when ("LITERAL".month.."LITERAL".months) then
          var = ((((@time / "LITERAL") / "LITERAL") / "LITERAL") / "LITERAL").round
          var["LITERAL"] = @at.is_a?(Time) ? (@at.min) : ("LITERAL")
          var["LITERAL"] = @at.is_a?(Time) ? (@at.hour) : ("LITERAL")
          var["LITERAL"] = if @at.is_a?(Time) then;Fi[	@6iÖI"        var = @time.to_s
        var = Array.new("LITERAL", "STRING")
        var["LITERAL"] = @at.is_a?(Time) ? (@at.min) : ("LITERAL")
        var["LITERAL"] = @at.is_a?(Time) ? (@at.hour) : ("LITERAL")
        return ((var << "STRING") * "STRING") if var.downcase.index("STRING");Fi[	@Aj@|i[[	@DjiI"~if Whenever.bundler? then
  job_type("LITERAL", "STRING")
  job_type("LITERAL", "STRING")
else
  job_type("LITERAL", "STRING");Fi[	@DjiI"fend
if Whenever.rails3? then
  job_type("LITERAL", "STRING")
else
  job_type("LITERAL", "STRING");Fi[	@Aj@Aji[[	@Dji
I"|job_type("LITERAL", "STRING")
if Whenever.bundler? then
  job_type("LITERAL", "STRING")
  job_type("LITERAL", "STRING")
else;Fi[	@DjiI"m  job_type("LITERAL", "STRING")
else
  job_type("LITERAL", "STRING")
  job_type("LITERAL", "STRING")
end;Fi
